[{"title":"Smart Contracts ABI v2.0 Specification","type":0,"sectionRef":"#","url":"arch/abi/2.0","content":"","keywords":""},{"title":"New in ABI v2.0​","type":1,"pageTitle":"Smart Contracts ABI v2.0 Specification","url":"arch/abi/2.0#new-in-abi-v20","content":"ABI v2.0 introduces a new header JSON ABI section with additional parameters placed before contract function parameters. These additional parameters are used for security checks or some protection mechanisms implemented in a contract. For example, timestamp introduced in ABI v1.0 and used for replay attack protection is now defined as an additional parameter in the header section. Apart from timestamp, the new expire additional parameter is introduced. It specifies the timespan upon expiration of which a message is not processed by a contract. Some other minor modifications Public key became one of header parameters.Signature is moved to root cell.Get methods are placed in a separate section that helps find them among other public methods.The last cell reference can be used by parameter serialization which needs reference (cell, bytes, map, array types) if all the following parameters can fit into current cell. ABI v1 used last cell reference only for cells chaining. Motivation Given the increase in number of additional parameters, it is necessary to review the way they are defined. The header section is intended to include all additional parameters that contract expects in external inbound message body for all public functions. These parameters are placed into the cell body before function ID in order of appearance in the header section. The public key became an optional parameter in order to decrease message size and therefore to reduce the forward fee. Each contract already has a public key, so there is no need to include it into each message. Signature is moved to the root cell to decrease forward and gas fees. Given that reading a cell from reference consumes gas, reading the signature directly from the root cell is cheaper. Besides that, an additional cell increases forward fee. Specification ABI specifies message bodies layout for client to contract and contract to contract interaction. "},{"title":"Message body​","type":1,"pageTitle":"Smart Contracts ABI v2.0 Specification","url":"arch/abi/2.0#message-body","content":""},{"title":"External Inbound Messages​","type":1,"pageTitle":"Smart Contracts ABI v2.0 Specification","url":"arch/abi/2.0#external-inbound-messages","content":"Message body with encoded function call has the following format: Maybe(Signature) + Enc(Header) +Function ID + Enc(Arguments) First comes an optional signature. It is prefixed by one bit flag that indicates the signature presence. If it is 1, then in the next 512 bit a signature is placed, otherwise the signature is omitted. Then сomes the encoded header parameters set (same for all functions). It is followed by 32 bits of function ID identifying which contract functions are called. The function ID comes within the first 32 bits of the SHA256 hash of the function signature. The highest bit is set to 0 for function ID in external inbound messages, and to 1 for external outbound messages. Function parameters are next. They are encoded in compliance with the present specification and stored either to the root cell or the next one in the chain. note An encoded parameter cannot be split between different cells "},{"title":"External Outbound Messages​","type":1,"pageTitle":"Smart Contracts ABI v2.0 Specification","url":"arch/abi/2.0#external-outbound-messages","content":"External outbound messages are used to return values from functions or to emit events. Return values are encoded and put into the message response: Function ID+Enc(Return values) Function ID's highest bit is set to 1. Events are encoded as follows: Event ID + Enc(event args) Event ID - 32 bits of SHA256 hash of the event function signature with highest bit set to 0. "},{"title":"Internal Messages​","type":1,"pageTitle":"Smart Contracts ABI v2.0 Specification","url":"arch/abi/2.0#internal-messages","content":"Internal messages are used for contract-to-contract interaction; they have the following body format: Function ID + Enc(Arguments) Function ID - 32 bits function id calculated as first 32 bits SHA256 hash of the function signature. The highest bit of function ID is 0. Internal messages contain only function calls and no responses. "},{"title":"Message Body Signing​","type":1,"pageTitle":"Smart Contracts ABI v2.0 Specification","url":"arch/abi/2.0#message-body-signing","content":"The message body can be protected with a cryptographic signature to identify a user outside the blockchain. In this case, an External inbound message that calls the function carries a user private key signature. This requirement applies only to External inbound messages because Internal inbound messages are generated within the blockchain, and src address can be used to identify the caller. If a user does not want to sign a message, bit 0 should be placed to the root cell start and signature omitted. The message body signature is generated from the representation hash of the bag of cells following the signature. "},{"title":"Signing Algorithm​","type":1,"pageTitle":"Smart Contracts ABI v2.0 Specification","url":"arch/abi/2.0#signing-algorithm","content":"ABI serialization generates bag of cells containing header parameters, function ID and function parameters. 513 free bits are reserved in the root cell for signature and signature flagRepresentation hash of the bag is signed using the Ed25519 algorithm.Bit 1 followed by 512 bits of the signature is saved to the start of the root cell before header parameters. "},{"title":"Function Signature (Function ID)​","type":1,"pageTitle":"Smart Contracts ABI v2.0 Specification","url":"arch/abi/2.0#function-signature-function-id","content":"The following syntax is used for defining a signature: function namelist of input parameter types (input list) in parenthesislist of return values types (output list) in parenthesisABI version Single comma is used to divide each input parameter and return value type from one another. Spaces are not used. Parameter and return value names are not included. The function name, input and output lists are not separated and immediately follow each other. If a function has no input parameters or does not return any values, the corresponding input or output lists are empty (empty parenthesis). "},{"title":"Function Signature Syntax​","type":1,"pageTitle":"Smart Contracts ABI v2.0 Specification","url":"arch/abi/2.0#function-signature-syntax","content":"function_name(input_type1,input_type2,...,input_typeN)(output_type1,output_type2,...,output_typeM)v2 "},{"title":"Signature Calculation Syntax​","type":1,"pageTitle":"Smart Contracts ABI v2.0 Specification","url":"arch/abi/2.0#signature-calculation-syntax","content":"SHA256(&quot;function_name(input_type1,input_type2,...,input_typeN)(output_type1,output_type2,...,output_typeM)&quot;)v2 "},{"title":"Sample Implementation​","type":1,"pageTitle":"Smart Contracts ABI v2.0 Specification","url":"arch/abi/2.0#sample-implementation","content":"Function func(int64 param1, bool param2) -&gt; uint32 Function Signature func(int64,bool)(uint32)v2 Function Hash sha256(&quot;func(int64,bool)(uint32)v2&quot;) = 0x1354f2c85b50aa84c2f65ebb8cec69aba0aa3269c21e03e142e014e84ea59649 function ID then is 0x1354f2c8 for function call and 0x9354f2c8 for function response "},{"title":"Event ID​","type":1,"pageTitle":"Smart Contracts ABI v2.0 Specification","url":"arch/abi/2.0#event-id","content":"Event ID is calculated in the same way as the function ID except for cases when the event signature does not contain the list of return values types: event(int64,bool)v2 "},{"title":"Encoding​","type":1,"pageTitle":"Smart Contracts ABI v2.0 Specification","url":"arch/abi/2.0#encoding","content":"The goal of the ABI specification is to design ABI types that are cheap to read to reduce gas consumption and gas costs. Some types are optimized for storing without write access. "},{"title":"Header parameter types​","type":1,"pageTitle":"Smart Contracts ABI v2.0 Specification","url":"arch/abi/2.0#header-parameter-types","content":"time: message creation timestamp. Used for replay attack protection, encoded as 64 bit Unix time in milliseconds. Rule: the contract should store the timestamp of the last accepted message. The initial timestamp is 0. When a new message is received, the contract should do the following check: last_time &lt; new_time &lt; now + interval, where last_time - last accepted message timestamp (loaded from c4 register), new_time - inbound external message timestamp (loaded from message body), now - current block creation time (just as NOW TVM primitive), interval - 30 min. The contract should continue execution if these requirements are met. Otherwise, the inbound message should be rejected. expire: Unix time (in seconds, 32 bit) after that message should not be processed by contract. It is used for indicating lost external inbound messages. Rule: if contract execution time is less then expire time, then execution is continued. Otherwise, the message is expired, and the transaction aborts itself (by ACCEPT primitive). The client waits for message processing until the expire time. If the message wasn't processed during that interval is considered to be expired pubkey: public key from key pair used for signing the message body. This parameter is optional. The client decides if he needs to set the public key or not. It is encoded as bit 1 followed by 256 bit of public key if parameter provided, or by bit 0 if it is not. Header may also contain any of standard ABI types used by custom checks. "},{"title":"Function parameter types:​","type":1,"pageTitle":"Smart Contracts ABI v2.0 Specification","url":"arch/abi/2.0#function-parameter-types","content":"uint&lt;M&gt;: unsigned M bit integer. Big-endian encoded unsigned integer stored in the cell-data. int&lt;M&gt;: two’s complement signed M bit integer. Big-endian encoded signed integer stored in the cell-data. bool: equivalent to uint1. tuple (T1, T2, ..., Tn): tuple that includes T1, ..., Tn, n&gt;=0 types encoded in the following way: Enc(X(1)) Enc(X(2)) . . ., Enc(X(n)); where X(i) is value of T(i) for i in 1..n Tuple elements are encoded as independent values so they can be placed in different cells T[] is a dynamic array of T type elements. It is encoded as a TVM dictionary. uint32 defines the array elements count placed into the cell body. HashmapE (see TL-B schema in TVM spec) struct is then added (one bit as a dictionary root and one reference with data if the dictionary is not empty). The dictionary key is a serialized uint32 index of the array element, and the value is a serialized array element as T type. T[k] is a static size array of T type elements. Encoding is equivalent to T[] without elements count bytes: an array of uint8 type elements. The array is put into a separate cell. In the case of array overflow, the maximum cell-data size it's split into multiple sequential cells. Note: contract stores this type as-is without parsing. For high-speed decoding, cut reference from body slice as LDREF. This type is helpful if some raw data must be stored in the contract without write or random access to elements.Note: analog of bytes in Solidity. In C lang can be used as void*. fixedbytes&lt;M&gt;: a fixed-size array of M uint8 type elements. Encoding is equivalent to bytes map(K,V) is a dictionary of V type values with K type key. K may be any of int&lt;M&gt;/uint&lt;M&gt; types with M from 1 to 1023. Dictionary is encoded as HashmapE type (one bit put into cell data as dictionary root and one reference with data is added if the dictionary is not empty). address is an account address in TON blockchain. Encoded as MsgAddress struct (see TL-B schema in TON blockchain spec). cell: a type for defining a raw tree of cells. Stored as a reference in the current cell. Must be decoded with LDREF command and stored as-is. Note: this type is useful to store payloads as a tree of cells analog to contract code and data in the form of StateInit structure of message structure. "},{"title":"Cell Data Overflow​","type":1,"pageTitle":"Smart Contracts ABI v2.0 Specification","url":"arch/abi/2.0#cell-data-overflow","content":"If parameter data does not fit into the available space of the current cell-data, it moves to a separate new cell. This cell is attached to the current one as a reference. The new cell then becomes the current cell. "},{"title":"Cell Reference Limit Overflow​","type":1,"pageTitle":"Smart Contracts ABI v2.0 Specification","url":"arch/abi/2.0#cell-reference-limit-overflow","content":"For simplicity, this ABI version reserves the last cell-reference spot for cell-data overflow. If the cell-reference limit in the current cell is already reached (save for the reserved spot) and a new cell is required, the current cell is considered complete, and a new one is generated. The reserved spot stores the reference to the new cell, and it continues with the new cell as a current one. The last cell reference can be used by parameter serialization which needs reference (cell, bytes, map, array types) if all the following parameters can fit into current cell. "},{"title":"Contract Interface Specification​","type":1,"pageTitle":"Smart Contracts ABI v2.0 Specification","url":"arch/abi/2.0#contract-interface-specification","content":"The contract interface is stored as a JSON file called contract ABI. It includes all public functions with data described by ABI types. Below is a structure of an ABI file: { &quot;ABI version&quot;: 2, &quot;header&quot;: [ ... ], &quot;functions&quot;: [ ... ], &quot;getters&quot;: [ ... ], &quot;events&quot;: [ ... ], &quot;data&quot;: [ ... ] }  Getters is a list of get methods which might be called on local TVM. "},{"title":"Header section​","type":1,"pageTitle":"Smart Contracts ABI v2.0 Specification","url":"arch/abi/2.0#header-section","content":"This section describes additional parameters of functions within the contract. Header-specific types are specified as strings with the type name. Other types are specified as function parameter type (see Functions section) { &quot;header&quot;: [ &quot;header_type&quot;, { &quot;name&quot;: &quot;param_name&quot;, &quot;type&quot;: &quot;param_type&quot; } ] }  Example { &quot;header&quot;: [ &quot;time&quot;, &quot;expire&quot;, { &quot;name&quot;: &quot;custom&quot;, &quot;type&quot;: &quot;int256&quot; } ] }  "},{"title":"Functions section​","type":1,"pageTitle":"Smart Contracts ABI v2.0 Specification","url":"arch/abi/2.0#functions-section","content":"The Functions section specifies each interface function signature, including its name, input, and output parameters. Functions specified in the contract interface can be called from other contracts or from outside the blockchain via ABI call. Functions section has the following fields: { &quot;functions&quot;: [ { &quot;name&quot;: &quot;method_name&quot;, &quot;inputs&quot;: [ {&quot;name&quot;: &quot;func_name&quot;, &quot;type&quot;: &quot;ABI_type&quot;}, ], &quot;outputs&quot;: [], &quot;id&quot;: &quot;0xXXXXXXXX&quot;, //optional } ] }  name: function name;inputs: an array of objects, each containing: name: parameter name;type: the canonical parameter type.components: used for tuple types, optional. id: an optional uint32 id parameter can be added. This id will be used as a Function ID instead of automatically calculated. PS: the last case can be used for contracts that are not ABI-compatible.outputs: an array of objects similar to inputs. It can be omitted if the function does not return anything; "},{"title":"Events section​","type":1,"pageTitle":"Smart Contracts ABI v2.0 Specification","url":"arch/abi/2.0#events-section","content":"This section specifies the events used in the contract. An event is an external outbound message with ABI-encoded parameters in the body. { &quot;events&quot;: [ { &quot;name&quot;: &quot;event_name&quot;, &quot;inputs&quot;: [], &quot;id&quot;: &quot;0xXXXXXXXX&quot;, //optional }, ] }  inputs have the same format as for functions. "},{"title":"Data section​","type":1,"pageTitle":"Smart Contracts ABI v2.0 Specification","url":"arch/abi/2.0#data-section","content":"This section covers the contract global public variables. { &quot;data&quot;: [ { &quot;name&quot;: &quot;var_name&quot;, &quot;type&quot;: &quot;abi_type&quot;, &quot;key&quot;: &quot;&lt;number&gt;&quot; // index of variable in contract data dictionary }, ] }  "},{"title":"Getters section​","type":1,"pageTitle":"Smart Contracts ABI v2.0 Specification","url":"arch/abi/2.0#getters-section","content":"Getters specification is not yet supported and this section is ignored. Problem of mappings or arrays that contains &quot;big&quot; structures as values. "},{"title":"Introduction​","type":1,"pageTitle":"Smart Contracts ABI v2.0 Specification","url":"arch/abi/2.0#introduction","content":"Several months ago we did breaking change in TVM. Opcode DICTSET had worked in this way: if some_data+len(key)+len(value) doesn't fit in one cell (1023 bits) then value are stored in ref of cell. Now if it doesn't fit in one cell opcode will throw exception. We haven't faced with this problem because solidity compiler doesn't support this feature (mappings or arrays that contain &quot;big&quot; structures as values). We are going to support it but ton-abi throws exception then it generates message. "},{"title":"Solving of the problem​","type":1,"pageTitle":"Smart Contracts ABI v2.0 Specification","url":"arch/abi/2.0#solving-of-the-problem","content":"To set value in dictionaries (arrays or mappings) we will use opcode DICTSET or DICTSETREF. if (12 + len(key) + maxPossibleValueLength &lt;= 1023) then we use DICTSET. else we will use DICTSETREF. 12 = 2 + 10 ≥ 2 + log2(keyLength).  See https://github.com/ton-blockchain/ton/blob/master/crypto/block/block.tlb#L30 Max possible size of value: intN/uintN - N bit.address - 591 bit. See https://github.com/ton-blockchain/ton/blob/master/crypto/block/block.tlb#L107 anycast_info$_ depth:(#&lt;= 30) { depth &gt;= 1 } rewrite_pfx:(bits depth) = Anycast; addr_var$11 anycast:(Maybe Anycast) addr_len:(## 9) workchain_id:int32 address:(bits addr_len) = MsgAddressInt; 2 + // 11 1 + 5 + 30 + // anycast 9 + // addr_len 32 + // workchain_id:int32 512 // address = 591  bool - 1 bitbytes/cell - 0 bitarray - 33 bitmapping - 1 bitstructure = SUM maxPosibleLenght(member) for member in members "},{"title":"Reference​","type":1,"pageTitle":"Smart Contracts ABI v2.0 Specification","url":"arch/abi/2.0#reference","content":"ABI (Application Binary Interface) implementationEverscale Smart Contracts ABI 2.0 Specification "},{"title":"Smart Contracts ABI 2.1 Specification","type":0,"sectionRef":"#","url":"arch/abi/2.1","content":"","keywords":""},{"title":"ABI JSON​","type":1,"pageTitle":"Smart Contracts ABI 2.1 Specification","url":"arch/abi/2.1#abi-json","content":"This section describes schema of the smart contracts ABI represented in JSON format. Full ABI schema in TypeScript notation: type Abi = { version: string, setTime?: boolean, header?: Param[], functions: Function[], events?: Event[], data?: Data[], fields?: Param[], } type Function = { name: string, inputs?: Param[], outputs?: Param[], id?: number, } type Event = { name: string, inputs?: Param[], id?: number, } type Data = Param &amp; { key: number, } type Param = { name: string, type: string, components?: Param[], }  Where: version contains string and uses semver semantics. Current version is &quot;2.1&quot;.functions describes all functions the smart contract can handle.events describes all external outbound messages (events) produces by smart contract.data describes Hashmap with public data of the smart contract.fields describes internal structure of the smart contracts data. "},{"title":"Functions​","type":1,"pageTitle":"Smart Contracts ABI 2.1 Specification","url":"arch/abi/2.1#functions","content":"This section stays the same as in ABI 2.0 "},{"title":"Events​","type":1,"pageTitle":"Smart Contracts ABI 2.1 Specification","url":"arch/abi/2.1#events","content":"This section stays the same as in ABI 2.0 "},{"title":"Data​","type":1,"pageTitle":"Smart Contracts ABI 2.1 Specification","url":"arch/abi/2.1#data","content":"This section stays the same as in ABI 2.0 "},{"title":"Fields​","type":1,"pageTitle":"Smart Contracts ABI 2.1 Specification","url":"arch/abi/2.1#fields","content":"This is a new section introduced in ABI 2.1. It describes internal structure of the smart contracts data. This section helps to decode contract data with TON-SDK function decode_account_data Structure of the smart contract data is described as a list of variables names with corresponding data types. It includes contract state variables and some internal contract specific hidden variables. They are listed in the order in which they are stored in the data field of the contract. Example for a Solidity contract BankClient: Contract state variables: contract BankClient { uint public creditLimit = 0; // allowed credit limit; uint public totalDebt = 0; // contract total debt; uint public balance = 0; // contract balance; uint public value = 0; // inbound message value. }  Fields section of the abi file: { &quot;fields&quot;: [ {&quot;name&quot;:&quot;_pubkey&quot;,&quot;type&quot;:&quot;uint256&quot;}, {&quot;name&quot;:&quot;_timestamp&quot;,&quot;type&quot;:&quot;uint64&quot;}, {&quot;name&quot;:&quot;_constructorFlag&quot;,&quot;type&quot;:&quot;bool&quot;}, {&quot;name&quot;:&quot;creditLimit&quot;,&quot;type&quot;:&quot;uint256&quot;}, {&quot;name&quot;:&quot;totalDebt&quot;,&quot;type&quot;:&quot;uint256&quot;}, {&quot;name&quot;:&quot;balance&quot;,&quot;type&quot;:&quot;uint256&quot;}, {&quot;name&quot;:&quot;value&quot;,&quot;type&quot;:&quot;uint256&quot;} ] }  "},{"title":"Types​","type":1,"pageTitle":"Smart Contracts ABI 2.1 Specification","url":"arch/abi/2.1#types","content":""},{"title":"bool​","type":1,"pageTitle":"Smart Contracts ABI 2.1 Specification","url":"arch/abi/2.1#bool","content":"Boolean type. Usage\tUsage\tExamplesCell\t1 bit, 0 or 1 JSON\ttrue, false JSON (accepts)\ttrue, false, 0, 1, &quot;true&quot;, &quot;false&quot;\t0, true, &quot;false&quot; "},{"title":"tuple​","type":1,"pageTitle":"Smart Contracts ABI 2.1 Specification","url":"arch/abi/2.1#tuple","content":"Struct type, consists of fields of different types. All fields should be specified as an array in the components section of the type. For example, for structure S: struct S { uint32 a; uint128 b; uint64 c; }  parameter s of type S would be described like: { &quot;components&quot;: [ {&quot;name&quot;:&quot;a&quot;,&quot;type&quot;:&quot;uint32&quot;}, {&quot;name&quot;:&quot;b&quot;,&quot;type&quot;:&quot;uint128&quot;}, {&quot;name&quot;:&quot;c&quot;,&quot;type&quot;:&quot;uint64&quot;} ], &quot;name&quot;:&quot;s&quot;, &quot;type&quot;:&quot;tuple&quot; }  Usage\tValue\tExamplesCell\tchain of cells with tuple data types encoded consistently (without splitting value between cells) JSON\tdictionary of struct field names with their values\t{&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3} JSON (accepts)\tmapping of struct field names with their values\t{&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3} "},{"title":"int<N>​","type":1,"pageTitle":"Smart Contracts ABI 2.1 Specification","url":"arch/abi/2.1#intn","content":"Fixed-sized signed integer, where N is a decimal bit length. Examples: int8, int32, int256. Usage\tValue\tExamplesCell\tN bit, big endian JSON\tstring with hex representation\t0x12 JSON (accepts)\tnumber or string with decimal or hexadecimal representation\t12, 0x10, &quot;100&quot; "},{"title":"uint<N>​","type":1,"pageTitle":"Smart Contracts ABI 2.1 Specification","url":"arch/abi/2.1#uintn","content":"Fixed-sized unsigned integer, where N is a decimal bit length e.g., uint8, uint32, uint256. Processed like int&lt;N&gt;. "},{"title":"varint<N>​","type":1,"pageTitle":"Smart Contracts ABI 2.1 Specification","url":"arch/abi/2.1#varintn","content":"New type introduced in 2.1 version. Variable-length signed integer. Bit length is between log2(N) and 8 * (N-1), where N is equal to 16 or 32, e.g. varint16, varint32. Usage\tValue\tExamplesCell\t4 (N=16) of 5 (N=32) bits that encode byte length of the number len followed by len * 8 bit number in big endian JSON\tstring with hex representation\t0x12 JSON (accepts)\tnumber or string with decimal or hexadecimal representation\t12, 0x10, &quot;100&quot; "},{"title":"varuint<N>​","type":1,"pageTitle":"Smart Contracts ABI 2.1 Specification","url":"arch/abi/2.1#varuintn","content":"New type introduced in 2.1 version. Variable-length unsigned integer with bit length equal to 8 * N, where Nis equal to 16 or 32 e.g., varint16, varint32. Processed like varint&lt;N&gt;. "},{"title":"map(<keyType>,<valueType>)​","type":1,"pageTitle":"Smart Contracts ABI 2.1 Specification","url":"arch/abi/2.1#mapkeytypevaluetype","content":"Hashtable mapping keys of keyType to values of the valueType, e.g., map(int32, address). Usage\tValue\tExamplesCell\t1 bit (0 - for empty mapping, otherwise 1) and ref to the cell with dictionary JSON\tdictionary of keys and values\t{&quot;0x1&quot;:&quot;0x2&quot;} JSON (accepts)\tdictionary of keys and values\t{&quot;0x1&quot;:&quot;0x2&quot;}, {&quot;2&quot;:&quot;3&quot;,&quot;3&quot;:&quot;55&quot;} "},{"title":"cell​","type":1,"pageTitle":"Smart Contracts ABI 2.1 Specification","url":"arch/abi/2.1#cell","content":"TVM Cell type. Usage\tValue\tExamplesCell\tstored in a ref JSON\tbinary hex data in base64\t&quot;te6ccgEBAQEAEgAAH/////////////////////g=&quot; JSON (accepts)\tbinary hex data in base64\t&quot;te6ccgEBAQEAAgAAAA==&quot; "},{"title":"address​","type":1,"pageTitle":"Smart Contracts ABI 2.1 Specification","url":"arch/abi/2.1#address","content":"Contract address type address, consists of two parts: workchain id (wid) and address value. Usage\tValue\tExamplesCell\t2 bits of address type, 1 bit of anycast, wid - 8 bit signed integer and address value - 256 bit unsigned integer JSON\tdecimal signed integer and unsigned hexadecimal integer with leading zeros separated by :\t&quot;123:000000000000000000000000000000000000000000000000000000000001e0f3&quot; JSON (accepts)\tdecimal signed integer and unsigned hexadecimal integer with leading zeros separated by :\t&quot;123:000000000000000000000000000000000000000000000000000000000001e0f3&quot; "},{"title":"bytes​","type":1,"pageTitle":"Smart Contracts ABI 2.1 Specification","url":"arch/abi/2.1#bytes","content":"Byte string of data. Usage\tValue\tExamplesCell\tcell with data stored in a ref JSON\tbinary hex data\t&quot;313233&quot; JSON (accepts)\tbinary hex data\t&quot;323334&quot; "},{"title":"fixedbytes<N>​","type":1,"pageTitle":"Smart Contracts ABI 2.1 Specification","url":"arch/abi/2.1#fixedbytesn","content":"Where N is a decimal byte length from 1 to 32. It is denoted in abi as uint&lt;M&gt;, where M is a bit length and M = 8 * N. Processed like int&lt;N&gt;. "},{"title":"string​","type":1,"pageTitle":"Smart Contracts ABI 2.1 Specification","url":"arch/abi/2.1#string","content":"New type introduced in 2.1 version. String data. Usage\tValue\tExamplesCell\tcell with data stored in a ref JSON\tstring data\t&quot;hello&quot; JSON (accepts)\tstring data\t&quot;hello&quot; "},{"title":"optional(innerType)​","type":1,"pageTitle":"Smart Contracts ABI 2.1 Specification","url":"arch/abi/2.1#optionalinnertype","content":"New type introduced in 2.1 version. Value of optional type optional(innerType) can store a value of innerType of be empty. Example: optional(string). Usage\tValue\tExamplesCell\t1 bit flag (1 - value is stored, otherwise 0) and the value itself (according to innerType) if it presents JSON\taccording to innerType or null if it is empty\t&quot;hello&quot; JSON (accepts)\taccording to innerType or null if it is empty\t&quot;hello&quot; "},{"title":"itemType[]​","type":1,"pageTitle":"Smart Contracts ABI 2.1 Specification","url":"arch/abi/2.1#itemtype","content":"Array of the itemType values. Example: uint256[] Usage\tValue\tExamplesCell\t32 unsigned bit length of the array, 1 bit flag (0 if array is empty, otherwise 1) and dictionary of keys and values where key is 32 unsigned bit index and value is itemType JSON\tlist of itemType values in []\t[1, 2, 3], [&quot;hello&quot;, &quot;world&quot;] JSON (accepts)\tlist of itemType values in []\t[1, 2, 3], [&quot;hello&quot;, &quot;world&quot;] "},{"title":"Reference​","type":1,"pageTitle":"Smart Contracts ABI 2.1 Specification","url":"arch/abi/2.1#reference","content":"Everscale Smart Contracts ABI 2.1 Specification "},{"title":"Everscale Smart Contracts ABI 2.3 Specification","type":0,"sectionRef":"#","url":"arch/abi/2.3","content":"","keywords":""},{"title":"Problem​","type":1,"pageTitle":"Everscale Smart Contracts ABI 2.3 Specification","url":"arch/abi/2.3#problem","content":"External messages may have a signature. Signatures are dependent only on message body (without signature flag and signature itself). Signatures aren’t dependent on dest address, and it may cause a problem. Let's consider the following situation: User has 2 contracts that contain the same public key and public function with same signatureUser sends message to the first contractThen hacker can create a message and send it to the second contract, and it may be successful. To solve the problem signature must be dependent on the destination address. "},{"title":"Modified Signing Algorithm​","type":1,"pageTitle":"Everscale Smart Contracts ABI 2.3 Specification","url":"arch/abi/2.3#modified-signing-algorithm","content":"ABI serialization generates bag of cells containing header parameters, function ID and function parameters. 591 free bits are reserved in the root cell for destination address (the maximum size of internal address).The root cell data is prepended with actual destination address data without padding to maximum size.Representation hash of the bag is signed using the Ed25519 algorithm.Address data is removed from the root cell and replaced with bit 1 followed by 512 bits of the signature. This functionality is supported staring with 0.64.0 version of the Solidity compiler. "},{"title":"Smart Contracts ABI v2.2 Specification","type":0,"sectionRef":"#","url":"arch/abi/2.2","content":"","keywords":""},{"title":"Fixed layout concepts​","type":1,"pageTitle":"Smart Contracts ABI v2.2 Specification","url":"arch/abi/2.2#fixed-layout-concepts","content":"Since ABI v2.2 fixed message body layout is used in order to reduce gas consumption while parsing parameters. This document describes fixed layout concepts. "},{"title":"Introduction​","type":1,"pageTitle":"Smart Contracts ABI v2.2 Specification","url":"arch/abi/2.2#introduction","content":"Each type has max bit and max ref size: intN/uintN - N bits, 0 refsvarint16/varuint16 - 124 bits, 0 refsvarint32/varuint32 - 253 bits, 0 refsaddress - 591 bits, 0 refsbool - 1 bit, 0 refsbytes/cell/string - 0 bit, 1 refarray - 33 bit, 1 refmapping - 1 bit, 1 refoptional(T) - (1 bit, 1 ref) if optional is large. Otherwise, (1 bit + maxBitQty(T), maxRefQty(T)) structure (aka tuple) type is considered as a sequence of its types when we encode the function parameters. That's why tuple type doesn't have max bit or max ref size. Nested tuple's also are considered as a sequence of its types. For example: struct A { uint8 a; uint16 b; } struct B { uint24 d; A a; uint32 d; }  structure B is considered as a sequence of uint24, uint8, uint16, uint32 types. "},{"title":"Encoding the message​","type":1,"pageTitle":"Smart Contracts ABI v2.2 Specification","url":"arch/abi/2.2#encoding-the-message","content":"Message X contains the field body. If encoded body fits in the cell, then the body is inserted in the cell (Either X). Otherwise, body is located in the reference (Either ^X). "},{"title":"Encoding the body of the message​","type":1,"pageTitle":"Smart Contracts ABI v2.2 Specification","url":"arch/abi/2.2#encoding-the-body-of-the-message","content":"The body of the message is a tree of cells that contains the function ID and encoded function arguments. External messages body is prefixed with function header parameters. "},{"title":"Encoding header for external messages​","type":1,"pageTitle":"Smart Contracts ABI v2.2 Specification","url":"arch/abi/2.2#encoding-header-for-external-messages","content":"Function header has up to 3 optional parameters and mandatory signature. Function ID and function parameters are put after header parameters. Maximum header size is calculated as follows (no references used). maxHeader = 1 + 512 + // signature (hasPubkey? 1 + 256 : 0) + (hasTime? 64 : 0) + (hasExpire? 32 : 0);  "},{"title":"Encoding of function ID and its arguments​","type":1,"pageTitle":"Smart Contracts ABI v2.2 Specification","url":"arch/abi/2.2#encoding-of-function-id-and-its-arguments","content":"Function ID and the function arguments are located in the chain of cells. The last reference of each cell (except for the last cell in the chain) refers to the next cell. After adding the current parameter in the current cell we must presume an invariant (rule that stays true for the object) for our cell: number of unassigned references in the cell must be not less than 1 because the last cell is used for storing the reference on the next cell. When we add a specific value of some function argument to the cell we assume that it takes the max bit and max ref size. Only if the current parameter (by max bit or max ref size) does not fit into the current cell then we create new cell and insert the parameter in the new cell. But If current argument and all the following arguments fit into the current cell by max size then we push the parameters in the cell. In the end we connect the created cells in the chain of cells. For example: function f(address a, address b) public;  Here we create 2 cells. In the first there is function id and a. There may be not more than 32+591=623 bits. It's not more than 1023. The next parameter b can't fit into the first cell. In the second cell there is only b. function f(mapping(uint=&gt;uint) a, mapping(uint=&gt;uint) b, mapping(uint=&gt;uint) c, mapping(uint=&gt;uint) d)  The first cell: function ID, a, b c, d. function f(string a, string b, string c, string d, uint32 e) public  Function ID, a, b, c are located in the first cell. d and e fit in the first cell by max size. That's why we push all parameter in the fist cell. struct A { string a; string b; string c; string d; } function f(A a, uint32 e) public;  Same as previous example, only one cell. function f(string a, string b, string c, string d, uint e, uint f, uint g, uint h) public  We use 3 cells. In the first cell there are function Id, a, b, c. In the second - d, e, f, g. In the third - h. "},{"title":"Reference​","type":1,"pageTitle":"Smart Contracts ABI v2.2 Specification","url":"arch/abi/2.2#reference","content":"Everscale Smart Contracts ABI 2.2 Specification "},{"title":"Basics of Everscale Blockchain","type":0,"sectionRef":"#","url":"arch/basics","content":"","keywords":""},{"title":"Blockchain structure​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#blockchain-structure","content":"At the moment, blockchain consists of 2 workchains. One of them (-1), a so-called masterchain, is needed for service contracts and validator contracts, another one (0) is for simple users. In the future, it is possible to add more simple workchains (1, 2, etc) to the blockchain. In turn, a workchain is split into shards (so-called shardchains). When the load is low, there are 16 shards. When it increases, shards split and when they decrease they merge. Blockchain is validated by validators. Part of them validate masterchain, others are split into groups and validate shardchains. Periodically, the global set of validators changes with elections. Within one election cycle, shardchain validators rotate as well. "},{"title":"Account (contract)​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#account-contract","content":"An account (contract) is identified by its full address consisting of a workchain and ID. Full information about the Account is stored in its state. An account can have some balance, a place for its code, a place for its data and many other fields. It can have 1 owner, many owners and no owners at all. Account ID is calculated during deploy from its initial code and data. In order to learn what Accounts are in detail, please follow this page. "},{"title":"About deploy​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#about-deploy","content":"Deploy — placing the code of the account onto the blockchain. You can not deploy an account's code if its balance is empty because deploy is paid out of that money. This is why any deploy operation must begin with sponsoring the account with some tokens. Because the account's ID is unequivocally calculated from code and data, this calculation can be done before the actual deploy. "},{"title":"Address​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#address","content":"An Address is calculated from the initial contract's code and data that is attached to the deploy message. When a contract performs SETCODE operation, its address does not change. To calculate the contract address, you need to know its code and its initial data (public key of the owner is also stored in the data). "},{"title":"About digital assets transfers​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#about-digital-assets-transfers","content":"Digital assets can be transferred from one account to another only by execution of the account's code. DO NOT transfer digital assets to the addresses where you can not deploy code because it will stay there forever. About fees There are several types of fees for operations with contracts. For example, commission for storage, execution, and message delivery. Please follow this page for Fee calculation details. "},{"title":"About get methods​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#about-get-methods","content":"Get method is a method of the contract which doesn't change its state, so it can be executed locally on the client's machine for free. What shard my account is in right now? An account shard is defined by the first bits of its address and the current list of shards. Encode the hex shard prefix to binary format, discard the most right 1. You just got the shard mask. Put this mask on top of the account address, if the bits are equal — the account is in this shard. An account can change its shard depending on the load of the network. So, before calculating an account's shard, check the current list of shards. "},{"title":"Message​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#message","content":"All interactions in Everscale are performed via messages. External inbound messages help deploy and call contracts from outside. Internal messages allow contracts to communicate with each other. External outbound messages are the events the contracts produce for the outside world. Use them to implement some off-chain logic — subscribe for these messages and perform some off-chain actions whenever you receive them. For example, a simple value transfer can be initiated with an external inbound message (by developers or a service) or with an internal message from another contract. This message will produce a transaction (read below) and an internal message with value transfer. In order to learn what Messages are in detail, please follow this page. "},{"title":"Transaction​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#transaction","content":"A transaction is the result of a contract execution. In general, a transaction is generated with one incoming message (external or internal) and can generate several outcoming messages (external or internal) as a result. The transaction can be successful or aborted. For example, a simple value transfer consists of 2 transactions — Sender's transaction which generated an internal message with a value transfer, and Recipient's transaction where it received the message with value and updated its balance. "},{"title":"BOC (Bag of cells)​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#boc-bag-of-cells","content":"It is a universal format for data packaging in Everscale. Every object — account, transaction, message, block is stored in the blockchain database as bocs. By the way, the boc of the block includes bocs of all messages and transactions that were executed in this block inside of it. "},{"title":"TVM​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#tvm","content":"Turing-complete virtual machine for contract code execution. It works with data represented in boc format. TVM itself does not calculate any commissions and can be used on the client side for running the get methods of the contracts. TVM is used for debot engine execution on the client side as well. Also, TVM is used by validators together with higher level protocols, such as Transaction Executor, to additionally calculate commissions and perform other necessary checks. In order to learn what TVM is in detail, please follow this link. "},{"title":"Transaction Executor​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#transaction-executor","content":"It takes the results of TVM, calculates fees, checks balances and other things. Used by validators to validate blocks. Can also be used on the client side to debug contract execution. In order to learn what Transaction Executor is in detail, please follow this link. In order to understand how Everscale blockchain works please follow this page. "},{"title":"What is Ever OS","type":0,"sectionRef":"#","url":"arch/ever-os","content":"","keywords":""},{"title":"Why we call it Ever OS?​","type":1,"pageTitle":"What is Ever OS","url":"arch/ever-os#why-we-call-it-ever-os","content":"A modern blockchain like Everscale is not just an immutable ledger. Bitcoin and other earlier blockchains were mostly ledgers, yet even Bitcoin supports a non-Turing complete script that provides some transaction execution instructions. In fact, the Bitcoin script is a Forth-like instruction set, which makes it somewhat similar in origin to TON Virtual Machine assembly language, but more on that later. Most blockchains after Ethereum are, in large part, distributed computing engines that execute and verify Turing-complete programs called smart contracts. In simpler words they are a special breed of network processors working in orchestration (called &quot;consensus&quot;) to perform common operations and in that way verify correctness of their execution. In Everscale this paradigm is taken to the extreme. The immutable ledger is quite a small part of Everscale. Of course it is an immutable ledger and a chain of blocks — that is how the data is written and transmitted from one network processor to another — yet there are at least two aspects which make Everscale uniquely more so a computing engine than a simple ledger. Almost everything in Everscale is smart contracts. Every account in Everscale must be associated with a smart contract code (or initialized) in order for a user to be able to perform any operation with it. Smart contracts are Everscale Assembly programs executed in the Everscale Virtual machine much like any assembly code is executed by hardware or by a virtual processor in a regular computer. Between a regular computer and a user (which may be a developer who would like to write programs for that computer or a regular user who would like to execute and interact with these programs) there is something called an operating system. That is how GNU defines operating system: Linux is an operating system: a series of programs that let you interact with your computer and run other programs. An operating system consists of various fundamental programs which are needed by your computer so that it can communicate and receive instructions from users; read and write data to hard disks, tapes, and printers; control the use of memory; and run other software. It is quite obvious why computers need an operating system. Before operating systems existed, interaction with computers looked something like this:  I still think the &quot;world computer&quot; is a good analogy. The idea that you have a shared computing environment that anybody can build and run stuff on is still a totally legitimate and valuable thing to emphasize. — Vitalik Buterin Any way you look at it, blockchain is quite a good candidate to be called a decentralized computer. At least some of the blockchains are. Everscale most definitely is. And just as with any computer, a blockchain needs an intermediate layer (or layers) that manages its resources and provides services to the programs the user runs or interacts with. Of course blockchain, in terms of architecture, cannot perhaps be compared directly 1:1 with a regular PC. But in logical terms, whenever we think about a software stack needed to enable interaction with a user — to call it an operating system is quite compelling. Let's run some arguments. For reasons of practicality we will not talk only about Free Everscale blockchain, but most of the arguments could be applied to some other modern blockchains as well. A classical operating system is expected to provide: Memory Management Processor Managing Device Managing File handling Security Handling System performance control Job accounting and handling Error detecting and handling Synchronization with other software and users Let's compare with Ever OS and the services it provides: "},{"title":"Memory Management​","type":1,"pageTitle":"What is Ever OS","url":"arch/ever-os#memory-management","content":"Individual blocks containing data are created, validated and finalized under governance by the consensus blockchain software. Nodes participating in processing blocks are chosen dynamically without requiring interference from the blockchain user. "},{"title":"Processor Managing​","type":1,"pageTitle":"What is Ever OS","url":"arch/ever-os#processor-managing","content":"Smart contracts are blockchain programs that are executed by the Everscale Virtual Machine across many network devices and locally (if we consider how a user is accessing the blockchain). A user does not think about how a smart contract is executed. Following some deployment instructions, a developer can deploy and run smart contracts without thinking about which virtual machine it is executed on or how this execution has been synchronized across the network and verified. In this respect it is safe to say that Ever OS provides processor management capabilities. "},{"title":"Device Managing​","type":1,"pageTitle":"What is Ever OS","url":"arch/ever-os#device-managing","content":"Blockchain software, including full node implementation, allows users to control, handle, configure and diagnose individual blockchain nodes. "},{"title":"File handling​","type":1,"pageTitle":"What is Ever OS","url":"arch/ever-os#file-handling","content":"Via a smart contract users can store and access persistent data on the blockchain. "},{"title":"Security Handling​","type":1,"pageTitle":"What is Ever OS","url":"arch/ever-os#security-handling","content":"Access to restricted areas of the system is authorized through extensive use of specialized smart contracts. Cases of unauthorized access attempts are recorded and monitored using security smart contracts. "},{"title":"System performance control​","type":1,"pageTitle":"What is Ever OS","url":"arch/ever-os#system-performance-control","content":"System-wide smart contracts deployed to the blockchain are in charge of monitoring system performance and receiving events which pinpoint various cases of system malfunction. "},{"title":"Job accounting and handling​","type":1,"pageTitle":"What is Ever OS","url":"arch/ever-os#job-accounting-and-handling","content":"Smart contracts execution inside the blockchain is governed by specialized software modules. Details of the execution are available for view and analysis through the blockchain explorer. "},{"title":"Error detecting and handling​","type":1,"pageTitle":"What is Ever OS","url":"arch/ever-os#error-detecting-and-handling","content":"Cases of misbehavior and inconsistency of smart contracts and blockchain software are monitored, collected and stored for subsequent analysis by specialized smart contracts. "},{"title":"Synchronization with other software and users​","type":1,"pageTitle":"What is Ever OS","url":"arch/ever-os#synchronization-with-other-software-and-users","content":"System smart contracts form an interconnected decentralized network by exchanging addresses, interfaces and specifications with each other to provide users and other smart contracts with the information required to properly utilize their functionality. "},{"title":"Accounts","type":0,"sectionRef":"#","url":"arch/accounts","content":"","keywords":""},{"title":"Account Structure Definition​","type":1,"pageTitle":"Accounts","url":"arch/accounts#account-structure-definition","content":"The account structure is defined as follows: struct AccountStuff { addr: MsgAddressInt, storage_stat: StorageInfo, storage: AccountStorage, } type Account = Option&lt;AccountStuff&gt;;  AccountStuff structure fields​ Field\tDescriptionaddr\tAccount address storage_stat\tAccount storage use statistics storage\tAccount smart-contract storage "},{"title":"Account Address​","type":1,"pageTitle":"Accounts","url":"arch/accounts#account-address","content":"The location of an account on Everscale blockchain is represented as a two-value structure: the workchain number and the account identifier. This structure is called an account address. Hereinafter, we just call it address for greater convenience. Addresses are defined as follows: pub enum MsgAddressInt { AddrStd(MsgAddrStd), AddrVar(MsgAddrVar), } pub struct MsgAddrStd { pub anycast: Option&lt;AnycastInfo&gt;, pub workchain_id: i8, pub address: AccountId, } pub type AccountId = SliceData;  The address may be encoded by one of the two structures: MsgAddrStd or MsgAddrVar. The latter is used to locate accounts in huge blockchains, when the standard 8-bit workchain_id is not enough, and not supported currently. Type SliceData denotes a binary blob encoded in a tree data structure.Type i8 is an 8-bit signed integer. MsgAddrStd structure fields​ Field\tDescriptionanycast\tMulti-shard contracts routing information workchain_id\tWorkchain identifier address\tAccount identifier within the workchain caution Anycast-addresses are planned to be removed shortly. "},{"title":"Account Storage​","type":1,"pageTitle":"Accounts","url":"arch/accounts#account-storage","content":"Any account on the Everscale blockchain is being charged for occupying space on a regular basis. The fee depends on the size of data being stored, the current prices and when the last charge took place. In some circumstances, an account may also have a debt, called due payment. Most of this information is stored in the StorageInfo structure. pub struct StorageInfo { used: StorageUsed, last_paid: u32, due_payment: Option&lt;Grams&gt;, } pub struct StorageUsed { cells: VarUInteger7, bits: VarUInteger7, public_cells: VarUInteger7, }  StorageInfo structure fields​ Field\tDescriptionused\tBlockchain storage use statistics last_paid\tTime of the latest payment, in Unix Epoch due_payment\tDebt of the account Type Grams denotes a set of natural numbers {0,...,2256}\\{0, ..., 2^{256}\\}{0,...,2256}, equipped with ⊕\\oplus⊕ and ⊖\\ominus⊖ operators, such that: a⊕b=(a+b) mod 2256a \\oplus b = (a + b) \\,\\, \\boldsymbol{mod} \\,\\, 2^{256}a⊕b=(a+b)mod2256 a⊖b=max(a−b,0)a \\ominus b = \\boldsymbol{max}(a - b, 0)a⊖b=max(a−b,0) Here +++ and −-− operators are standard addition and subtraction operators in a set of integers Z\\mathbb{Z}Z. Amount of storage used by the account is encoded with StorageUsed struct. StorageUsed structure fields​ Field\tDescriptioncells\tNumber of cells occupied by the account bits\tNumber of bits occupied by the account public_cells\tField is not used To store the data in a tree-like form, it is encoded as a series of interlinked cells. This data structure also consumes some space and it is accounted for in the cell field. The bits field refers to data size being encoded in the cells. "},{"title":"Account Data​","type":1,"pageTitle":"Accounts","url":"arch/accounts#account-data","content":"The full account record is represented by several nested data structures: Account storageAccount stateSmart-contract storage called StateInit "},{"title":"Account Storage structure​","type":1,"pageTitle":"Accounts","url":"arch/accounts#account-storage-structure","content":"The most outer record is the account storage. It contains the account balance and the account state. The account state may contain the smart-contract code and data, described by the structure called StateInit. pub struct AccountStorage { last_trans_lt: u64, balance: CurrencyCollection, state: AccountState, }  AccountStorage fields​ Field\tDescriptionlast_trans_lt\tLast transaction logical time balance\tAmount of cryptocurrency tokens available for the account state\tCurrent account state "},{"title":"Account State​","type":1,"pageTitle":"Accounts","url":"arch/accounts#account-state","content":"The account state defines the mode of operation for the account, during the message being executed for that account. The Transaction Executor logic varies greatly depending on what the current account state is. The account state may have additional data fields. See the enumeration below. enum AccountState { AccountUninit, AccountActive{ init_code_hash: Option&lt;UInt256&gt;, state_init: StateInit, }, AccountFrozen{ init_code_hash: Option&lt;UInt256&gt;, state_init_hash: UInt256, }, }  The life cycle of an account is depicted on Fig. Let us clarify the fields of enumeration items. For AccountActive, the value stateinit defines the byte-code and data of the associated smart-contract. The field _init_code_hash defines the hash of the field state_init.code that was used at the moment of the account initialization, or at the moment of the account freeze. In Everscale, it is possible to change the smart-contract's code on the fly using the SetCode action. However, the value init_code_hash stays unaffected. The same holds for AccountFrozen. The value of state_init_hash defines the hash of the smart-contract state_init.code at the moment of a freeze. "},{"title":"Smart-Contract Storage (StateInit)​","type":1,"pageTitle":"Accounts","url":"arch/accounts#smart-contract-storage-stateinit","content":"The byte-code and data of a contract are stored within a structure called StateInit. Its name may seem quite confusing. It could have been named just State. The Init part comes from the fact that this structure is also used for the initialization of an account when it is uninitialized. pub struct StateInit { pub split_depth: Option&lt;Number5&gt;, pub special: Option&lt;TickTock&gt;, pub code: Option&lt;Cell&gt;, pub data: Option&lt;Cell&gt;, pub library: StateInitLib, }  split_depth field was initially devoted to large multi-shard smart-contracts, but currently it is not used. special fields signal the fact that the smart-contract is related to the blockchain system functioning. This is related to the very small amount or contracts residing in the Masterchain, i.e. Elector, Config, Giver, etc. There is a special logic to executing messages destined for those contracts. code and data fields encodes the current byte-code and data of a contract. Here, data denote values of contract's variables. library used to encode the code libraries the contract may refer to from its code. This mechanism is deprecated. "},{"title":"Fee calculation","type":0,"sectionRef":"#","url":"arch/fee-calculation","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Fee calculation","url":"arch/fee-calculation#introduction","content":"Transaction fees consist of a few types of different fees connected to the execution of a single transaction. Transactions itself are complex processes, and fees are paid relative to different stages of executing them. In this document, we explain how the fees are calculated. We shall define transaction_fee as a sum of all fees for a single transaction. transaction_fee = inbound_external_message_fee + storage_fees + gas_fees + total_action_fees + outbound_internal_messages_fee  Where: inbound_external_message_fee — is deducted, if an inbound external message is imported in the transaction. storage_fees — storage costs since the moment of the last transaction. gas_fees — include all gas fees associated with the transaction. You can find more info in the Gas calculation basics section. total_action_fees — fees for performing send message actions. outbound_internal_messages_fee — is calculated as a sum of fees for all outbound internal messages generated by the transaction. Depending on the nature of the transaction, all of these except storage fees may not be applicable. Below we examine these types of fees in detail. Note: Block creation fee is not to be confused with the fees discussed in this document. Block creation fee is the new coins minted by the elector contract and distributed among validators as reward for creating blocks. It is not part of transaction fees. "},{"title":"Storage fees​","type":1,"pageTitle":"Fee calculation","url":"arch/fee-calculation#storage-fees","content":"Every transaction in Everscale has a storage phase that implies a certain storage fee charged on an account balance. This fee is charged for the period between transactions and is calculated according to the following formula: storage_fees = CEIL( ( account.bits * global_bit_price + account.cells * global_cell_price ) * period / 2 ^ 16 )  Where: account.bits and account.cells — stand for a number of bits and cells in the Account structure represented as tree of cells (including code and data). global_bit_price — is a global configuration parameter (p18 for both masterchain and workchains), price for storing one bit. global_cell_price — another global configuration parameter (p18 for both masterchain and workchains), price for storing one cell. period — number of seconds since previous storage fee payment. Note: While account.bits are generally easy to estimate, the account.cells value can vary greatly for different types of data. A cell can contain no more than 1023 bits and 4 references to other cells. Contract code and numerical variables tend to be packed into cells effectively, resulting in mostly full cells, and thus a minimal number of cells needed to store the data. More complex data structures can be packed into cells less efficiently, taking up more cells to store the same amount of data. Example: Let's calculate a minimal fee for storing 1KB of data for the duration of one day on a workchain: global_bit_price = 1 global_cell_price = 500 period = 86400 seconds account.bits = 8192 The minimal account.cells value for 8192 bits of data is 9 (rounding 8192/1023 up to the nearest integer). Thus the minimum storage fee would be calculated as follows: storage_fees = CEIL( ( 8192 * 1 + 9 * 500 ) * 86400 / 65536 ) = 16733 nanotokens = 0.000016733 tokens  Real storage fees for 1KB account can be higher, depending on the specific features of the contract. If the account balance is less than the due storage fee, the account is frozen and its balance is subtracted from storage fee and reduced to zero. Remaining storage fee is stored in account as debt. Note: Current global configuration can be always reviewed on [ever.live]( https:/ /ever.live/) in the master config section of the latest key block details (example) FIXME broken link. It can only be changed by a vote of validators. "},{"title":"Message fees​","type":1,"pageTitle":"Fee calculation","url":"arch/fee-calculation#message-fees","content":"Every message is subject to a forwarding fee, which is calculated according to the following formula: msg_fwd_fee = ( lump_price + CEIL( ( bit_price * msg.bits + cell_price * msg.cells ) / 2 ^ 16 ) )  msg.bits and msg.cells are calculated from message represented as a tree of cells. Root cell is not counted. lump_price, bit_price, cell_price are contained in global config parameters p24 and p25, and can and can only be changed by a vote of validators. Note: Like in storage fees, msg.bits are generally easy to estimate, while the msg.cells value can vary for different types of messages. Example: Let's calculate a minimal forward fee for sending a 1KB message on a workchain: lump_price = 10000000 bit_price = 655360000 cell_price = 65536000000 To calculate msg.bits we subtract the root cell bits from the total message bits. For this example we'll assume that the root cell is filled completely (usually this is not the case, and the subtracted value is smaller, which results in a higher fee): msg.bits = 8192 - 1023 = 7169  To calculate msg.cells we subtract the root cell from the total umber of cells. The minimal number of cells in a 1 KB message is 9 (rounding 8192/1023 up to the nearest integer). Thus msg.cells is calculated as follows: msg.bits = 9 - 1 = 8  The minimum forward fee for a 1KB message would be calculated as follows: msg_fwd_fee = ( 10000000 + CEIL( ( 655360000 * 7169 + 65536000000 * 8 ) / 65536 ) ) = 89690000 nanotokens = 0.08969 tokens  Real forward fees for 1 KB messages may be higher, depending on the type and contents of the message. Note: Current global configuration can be always reviewed on ever.live in the master config section of the latest key block details (example) FIXME broken link. "},{"title":"Outbound messages​","type":1,"pageTitle":"Fee calculation","url":"arch/fee-calculation#outbound-messages","content":"outbound_internal_messages_fee is calculated as a sum of outbound internal message fees for every message generated as result of transaction execution: outbound_internal_messages_fee = SUM( out_int_msg.header.fwd_fee + out_int_msg.header.ihr_fee )  Where out_int_msg.header.fwd_fee is a part of the standard forward fee for the outbound internal message. out_int_msg.header.ihr_fee is currently disabled. Routing​ The forward fee for outbound internal message is split into int_msg_mine_fee and int_msg_remain_fee: msg_forward_fee = int_msg_mine_fee + int_msg_remain_fee  Where: int_msg_mine_fee = msg_forward_fee * first_frac / 2 ^ 16  first_frac — is contained in global config parameters p24 and p25, and determines the fraction of the fee, that the current set of validators receive. Note: Current global configuration can be always reviewed on ever.live in the master config section of the latest key block details (example) FIXME broken link. int_msg_mine_fee then becomes part of transaction action fees (see below). The remaining int_msg_remain_fee is placed in the header of outbound internal message (becoming out_int_msg.header.fwd_fee) and will go to validators who will process the message. If, while being forwarded to the destination address, the message passes through additional validator sets (i.e. if the validator set changes more than once while the message is being forwarded), a part of out_int_msg.header.fwd_fee is payed to the relevant validator set every time and the remaining fee in the message header is reduced by this amount: intermediate_fee = out_int_msg.header.fwd_fee * next_frac / 2 ^ 16  next_frac — is contained in global config parameters p24 and p25, and determines the fraction of the remaining forward fee, that intermediary validators receive. Note: Current global configuration can be always reviewed on ever.live in the master config section of the latest key block details (example) FIXME broken link. Note: Length of route does not affect the initial calculation of the forward fee. The fee is simply split between all involved validators according to global config parameters. Note: If an exception is thrown, and a bounce message is generated, it is subject to fees, just like a single regular outbound message. "},{"title":"Inbound external messages​","type":1,"pageTitle":"Fee calculation","url":"arch/fee-calculation#inbound-external-messages","content":"Whenever an inbound external message needs to be imported for transaction execution, the for this action fee is calculated according to the standard forwarding fee formula, and paid to the current validators. "},{"title":"Action fees​","type":1,"pageTitle":"Fee calculation","url":"arch/fee-calculation#action-fees","content":"Action fees pay for performing 'send message' actions. They consist of all fees for external outbound messages, and the first fraction of internal outbound message fees. They are calculated as follows: total_action_fees = total_out_ext_msg_fwd_fee + total_int_msg_mine_fee  where: total_out_ext_msg_fwd_fee — sum of implicit forward fee for all generated outbound external messages.total_int_msg_mine_fee — sum of 'mine' parts of message forward fees for outbound internal messages.total_fwd_fees — is a separate way to calculate total forwarding fees. total_fwd_fees = total_action_fees + SUM( int_msg_remain_fee + out_int_msg.header.ihr_fee )  out_int_msg.header.ihr_fee — this fee is currently zero. The action fee might be absent if no actions are performed during the transaction. "},{"title":"Gas fees​","type":1,"pageTitle":"Fee calculation","url":"arch/fee-calculation#gas-fees","content":"trans.gas_fees includes all gas fees associated with the transaction. As with Action fees, Gas fees are not always applicable. They can be skipped if the TVM compute phase is not initialized for a transaction. In order to study the calculation of Gas fees in detail please consult this page. "},{"title":"Managing gas","type":0,"sectionRef":"#","url":"arch/managing-gas","content":"","keywords":""},{"title":"Gas calculation basics​","type":1,"pageTitle":"Managing gas","url":"arch/managing-gas#gas-calculation-basics","content":""},{"title":"Specification Overview​","type":1,"pageTitle":"Managing gas","url":"arch/managing-gas#specification-overview","content":"The entire state of TVM consists of the five components: StackControl registersCurrent continuationCurrent codepageGas limits Collectively these are called SCCCG. Check out section 1.4 of the TVM specification. The Gas component limits gas usage and сontains four signed 64-bit integers: the remaining gas: grthe current gas limit: glthe maximal gas limit: gmthe gas credit: gc The following is always true: 0≤gl≤gm,gc≥0,andgr≤gl+gc0 ≤ gl ≤ gm, gc ≥ 0, and gr ≤ gl + gc0≤gl≤gm,gc≥0,andgr≤gl+gc gc is initialized by zero for internal messages, gr is initialized by gl + gc and gradually decreases, as the TVM runs. When gr becomes negative or if contract terminates with gc &gt; 0, an out of gas exception is triggered. "},{"title":"Gas prices​","type":1,"pageTitle":"Managing gas","url":"arch/managing-gas#gas-prices","content":"As stated in A.1 of the TVM specification. According to the original TON, for most primitives gas is calculated according to the following formula: Pb:=10+bPb := 10 + bPb:=10+b where b is the instruction length in bits. The same is true for EverX implementation. For example: the gas required for A0 (ADD) instruction is 10 + 8 = 18 gas, while the gas for A6cc (ADDCONST cc) instruction is 10 + 16 = 26 gas. For some instructions this rule does not apply. TVM specification lists either total gas prices, or prices in addition to the basic Pb for them explicitly. Instruction list with additional information may be obtained in A.2 through A.13 of the TVM specification. Apart from integer constants, the following expressions may appear: The total price of loading cells. Currently it is 100 gas units per cell. Reloading a cell again now costs 25 gas units.The total price of creating new Cells from Builders. Currently it is 500 gas units.Exception throwing. 50 gas units per exception.Exiting the block costs 5 gas units per implicit RET. Jumping to the first link costs 10 gas units - implicit JUMP.Moving to a new continuation with transferring parameters costs gas if there are more then 32 parameters. It costs N-32 gas, where N is the number of parameters.Tuple gas price. 1 gas unit for every tuple element. Note: that the most expensive operations are dictionary read/write operations. Dictionaries are stored in the form of trees of cells, where each cell can only be linked to four others. As result, these trees can grow quite large, depending on the data that needs to be stored. To read data in any cell, all its parent cells need to be read first, at the price of 100 gas per cell, and to write data in a cell, similarly all its parent cells need to be (re)created at the price of 500 gas per cell. "},{"title":"Global gas limits​","type":1,"pageTitle":"Managing gas","url":"arch/managing-gas#global-gas-limits","content":"Global gas limits are values stored in the masterchain configuration contract. Global values are standard and do not change at contract deployment. Only validator consensus can modify them. The values currently used can always be reviewed on ever.live in the latest key block details (example FIXME broken link). p20 config parameter values are used for masterchain and p21 values are used for workchain. "},{"title":"Gas-related TVM primitives​","type":1,"pageTitle":"Managing gas","url":"arch/managing-gas#gas-related-tvm-primitives","content":"These is the list of official TVM primitives used for gas-related operations: F800 — ACCEPT, sets current gas limit gl to its maximal allowed value gm, and resets the gas credit gc to zero, decreasing the value of gr by gc in the process. In other words, the current smart contract agrees to buy some gas to finish the current transaction. This action is required to process external messages, which bring no value (hence no gas) with themselves.F801 — SETGASLIMIT (g – ), sets current gas limit gl to the minimum of g and gm, and resets the gas credit gc to zero. If the gas consumed so far (including the present instruction) exceeds the resulting value of gl, an (unhandled) out of gas exception is thrown before setting new gas limits. Notice that SETGASLIMIT with an argument g ≥ 2 63 − 1 is equivalent to ACCEPT.F802 — BUYGAS (x – ), computes the amount of gas that can be bought for x nanotokens, and sets gl accordingly in the same way as SETGASLIMIT.F804 — GRAMTOGAS (x – g), computes the amount of gas that can be bought for x nanotokens. If x is negative, returns 0. If g exceeds 2 63−1, it is replaced with this value.F805 — GASTOGRAM (g – x), computes the price of g gas in nanotokens.F806–F80F — Reserved for gas-related primitives. These are yet to be released. Note: F802, F804, F805 are not implemented in Telegram TON node. In Evernode, the general gas formula is the same as specified by TON specifications. Overall, Evernode operate in compliance with the specification. For every executed primitive, the amount of gas is added to the virtual machine according to the specification formula. Gas value for every primitive is based on gr. "},{"title":"Gas initialization types​","type":1,"pageTitle":"Managing gas","url":"arch/managing-gas#gas-initialization-types","content":""},{"title":"1. Calling contract from another contract​","type":1,"pageTitle":"Managing gas","url":"arch/managing-gas#1-calling-contract-from-another-contract","content":"An internal message with a balance value is received. In this case, the following formulas are applied to determine limits: gm = MIN(account balance / gas price, global_gas_limit) gl = MIN(message value / gas price, global_gas_limit) gc = 0 gr = gc + gl  By default, gas costs are allocated to the caller contract that triggers the transaction with a message. Accepting is also available for internal contracts. If ACCEPT is not called, gas is taken from the caller contract according to the message value. In other words, the message value defines the current limit. The message value determines the starting TVM gas limit. So, to put it plain, if ACCEPT is not called, the message pays, if ACCEPT is used, additional gas can be bought by the target contract. This approach enables flexible contract design where either total gas is paid by the caller contract (but in this case it has to have enough gas at any moment of time) or the target contract also incurs costs. "},{"title":"2. Offchain contract call​","type":1,"pageTitle":"Managing gas","url":"arch/managing-gas#2-offchain-contract-call","content":"External messages do not carry balance values. In this case, the values are calculated according to the following formulas: gm = MIN(account balance / gas price, global_gas_limit) gl = 0 gc = MIN(gm, global_gas_credit) gr = gc + gl  As external messages have no gas value, gas is credited to execute it. Target contracts have to cover costs by calling Accept to buy gas. If a contract returns an exception before the credit is given, no gas fee applies. As the public code for node has just been released this documentation is likely to be updated. Managing Gas in Solidity Some Theory Anyone can send external message to your contract. When a message arrives, the contract initial gas limit is equal to 10,000 units of credit gas that should be bought later by the ACCEPT TVM primitive. Otherwise when credit gas falls to zero, the TVM throws the out of gas exception. The contract is supposed to spend these 10,000 units of 'free' gas to check the body of an inbound message tp make sure that it is valid and can be processed by contract successfully. The idea of credit gas allowance is that as long as it is beyond zero, any exception thrown by contract prevents all further gas charges. But once the contract accepts a message, all gas consumed by contract is converted to gas fees regardless of whether a transaction is aborted or not. ACCEPT is useful in internal messages too. When another contract sends an internal message to your contract, initial gas limit is equal to an inbound message value divided by the gas_price or global gas limit, if it is smaller. If this value is not enough to finish execution, the contract then can increase its gas limit by calling ACCEPT or SETGASLIMIT primitive. The ACCEPT primitive increases the limit to the value of its balance divided by the gas_price, and the SETGASLIMIT primitive sets the current gas limit to the value popped from the TVM stack (the value cannot be bigger than the gm limit). With the ACCEPT command a contract can choose whether gas for its execution is paid by the caller contract or by the contract itself. Implementation In EverX the ACCEPT primitive is implemented in Solidity as a private function called by public functions. Find below actual usage examples. All can be compiled using EverX Solidity compiler. Accept gas inside function To avoid gas payment when the foo function is called by another contract, we can use the following code: Remember that the caller contract should attach enough tokens to its message to cover all gas that will be spend by foo function. Accept gas inside modifier contract AcceptExample2 { uint _sum = 0; modifier AlwaysAccept() { tvm.accept(); _; } function foo(uint a, uint b) AlwaysAccept() public { _sum = a + b; } }  Important: modifier is called before arguments are deserialized from inbound message body. In the example above AlwaysAccept() will be called before a and b are decoded. "},{"title":"Message","type":0,"sectionRef":"#","url":"arch/message","content":"","keywords":""},{"title":"Message Header​","type":1,"pageTitle":"Message","url":"arch/message#message-header","content":"Any message has a message header: a data-structure defining, among other things, the message type and source and destination addresses. The message header defines its type. It is described by the following enumeration: pub enum CommonMsgInfo { IntMsgInfo(InternalMessageHeader), ExtInMsgInfo(ExternalInboundMessageHeader), ExtOutMsgInfo(ExtOutMessageHeader), }  "},{"title":"Internal Message​","type":1,"pageTitle":"Message","url":"arch/message#internal-message","content":"Within Everscale blockchain, smart-contracts communicate with each other by exchanging messages. Messages sent by smart-contracts are called internal. They are opposed to external messages that are sent by off-chain applications to smart-contracts. The message header of an internal message is defined as follows: pub struct InternalMessageHeader { pub ihr_disabled: bool, pub bounce: bool, pub bounced: bool, pub src: MsgAddressIntOrNone, pub dst: MsgAddressInt, pub value: CurrencyCollection, pub ihr_fee: Grams, pub fwd_fee: Grams, pub created_lt: u64, pub created_at: UnixTime32, }  InternalMessageHeader fields​ Field\tDescriptionihr_disabled\tIHR routing protocol disabled, always true bounce\tShould the answer message be generated in case of an error bounced\tIs this message was auto-generated by error handling src\tMessage source address dst\tMessage destination address value\tAmount of coins attached to the message ihr_fee\tIHR fee amount, always 0 fwd_fee\tMessage delivery fee amount created_lt\tMessage creation logic time created_at\tMessage creation time in Epoch Some clarifications: bounced flag is set when the message itself was auto-generated as a result of an error. If the message with bounced flag leads to an error itself, the next bounced message will not be generated.value is measured in Nano Evers (10−910^{-9}10−9)reated_lt is a monotonically increasing counter, thanks to this field, each new generated message is unique, even if the message payload is the same. The message creation logic time is also used to guarantee order of delivery. We do not dive deep into this question, because it is protocol-level details. "},{"title":"External Message​","type":1,"pageTitle":"Message","url":"arch/message#external-message","content":"External messages are created outside of the blockchain and get sent through specially distinguished validator nodes called DApp Servers2. External message header is defined as follows: pub struct ExternalInboundMessageHeader { pub src: MsgAddressExt, pub dst: MsgAddressInt, pub import_fee: Grams, }  Fields src and dst are source and destination addresses.Field import_fee should have been the value paid to the validator for processing an external message. But in the current node, this field is not used. Hence, the fee is not paid. We reported this issue to the developers.The source address for an external message is always set to AddrNone. pub enum MsgAddressExt { AddrNone, AddrExtern(MsgAddrExt), }  The second variant AddrExtern is not supported currently. "},{"title":"Events​","type":1,"pageTitle":"Message","url":"arch/message#events","content":"Event can be considered as a log record. It is used to signal external observers of reaching some significant state in a smart-contract. Usually, observers are external non-blockchain applications that constantly monitor blockchain state3. Other smart-contracts are not able to catch events. pub struct ExtOutMessageHeader { pub src: MsgAddressIntOrNone, pub dst: MsgAddressExt, pub created_lt: u64, pub created_at: UnixTime32, }  pub enum MsgAddressIntOrNone { None, Some(MsgAddressInt) }  Transaction Executor automatically assigns the source address src to be equal to the smart-contract address emitting the event.The destination address dst may contain any identifier. It is included for easier integration with off-chain applications, i.e. applications can monitor emitted events based on their destination address, and consume only those events destined to their custom identifier.Fields created_lt, created_at defines the logical creation time and epoch creation time. "},{"title":"Reference​","type":1,"pageTitle":"Message","url":"arch/message#reference","content":"In the original TON, message dichotomy is different: they distinguish 4 types of messages: (inbound + outbound) * (internal + external). We find this dichotomy a bit tedious to use in practice↩In the current protocol implementation, not all validator nodes process external messages. This is subject to change in the future protocol versions↩For example, by sending GraphQL requests to the DApp-server↩ "},{"title":"Pseudo-code Semantics","type":0,"sectionRef":"#","url":"arch/pseudo-code","content":"Pseudo-code Semantics A few words about the pseudo-code language we use to define the behavior of the Architecture parts. The language used is Python-like, with nearly intuitive semantics. We would like to highlight the following: For basic values like Ints and Bools, the assignment operator copies the value.For complex data types (objects), the assignment operator copies a reference to the object instead of creating a new instance.The call obj.clone() creates a deep copy of the object obj.The input arguments are passed by reference, so, mutating them within the function would mutate them for the caller also.Sometimes, the default value is irrelevant and not specified explicitly. Default values for structure fields are: 0 for IntsFalse for BoolsNone for OptionFor Enum types, the default value is the first item in the enumeration. In few places, we use idiomatic Python values swap: a, b = b, a This construct exchanges the values of a and b.The object method syntax is used in few places, for example: obj.method(p1, p2,...) = method(obj, p1, p2,...).Types and namespaces begin with uppercase letter, for example: TransactionExecutor.TrExecutorError() denotes the object TrExecutorError residing in the namespace TransactionExecutorWe use is operator to do type test. For example, to test that message is internal, we use the following construct: if in_msg.header is IntMsgInfo: return ExecuteInternalMessage(in_msg, ...) We omit details of some global objects, and just assume they exist. For example, the virtual machine is created using some abstract TVM object. The same goes for system error enumerations. It is done this way not to overload the pseudo-code with easily recoverable details.","keywords":""},{"title":"Smart Contract Security","type":0,"sectionRef":"#","url":"arch/security","content":"","keywords":""},{"title":"Replay Attack Protection​","type":1,"pageTitle":"Smart Contract Security","url":"arch/security#replay-attack-protection","content":"All external messages must be protected against replay attacks. Otherwise, a malicious party can resend an external message obtained from blockchain and repeat a transaction for a smart contract. For example, a hacker can repeat a Token transfer and bring an account balance to zero. For internal messages the risk of replay attacks is irrelevant, as they only can be generated inside blockchain by other contracts. "},{"title":"Implementation Options​","type":1,"pageTitle":"Smart Contract Security","url":"arch/security#implementation-options","content":"Different approaches to implementing replay attack protection exist. None of them is a silver bullet, but there are several indicators applied to compare and evaluate them: Gas consumptionStorage feesRace conditionUsability "},{"title":"Sequence number​","type":1,"pageTitle":"Smart Contract Security","url":"arch/security#sequence-number","content":"This is a very simple protection option. It implies that each protected contract stores a counter (i.e. 32bit integer) that is initially set to zero. An external message is then accepted by the contract only under condition that it contains a number equal to the current contract counter value. Each time a new message is accepted, the contract counter value is incremented by one. Pros: simple implementation in contractslow gas and storage fees Cons: To get the right sequence number off-chain, a client must request the contract state from blockchain before sending an external message. If the state is large, it can cause a network traffic overheadRace condition issue that arises when there are multiple contract owners who can simultaneously call it. One owner can increment the contract counter value before this counter becomes available to the next ownerLess sensitive issue of a potential counter overflow in the future. In this case the TVM will throw an exception causing the owner to lose access to the contract "},{"title":"Timestamp​","type":1,"pageTitle":"Smart Contract Security","url":"arch/security#timestamp","content":"Another simple protection option is adding a timestamp to every external message. It can be a 64-bit value in unixtime format. The contract must store the timestamp of the last accepted external message. When a new external message comes, the contract verifies the message timestamp. It must to be bigger than the previous message timestamp and less then now + interval. The interval value is necessary, because now does not stand for the current time, but indicates creation time of the relevant block. The interval can be equal the block generation period or bigger. Pros: Very simple implementationNo need to request account state before sending external messages Cons: Race condition issues remains unresolved as in case of sequence number implementationClient time must be synchronized with blockchain time "},{"title":"Set of accepted messages​","type":1,"pageTitle":"Smart Contract Security","url":"arch/security#set-of-accepted-messages","content":"Dictionary of randoms This option implies that every external message contains a random value, for example, a 32bit integer. A protected contract, in turn, stores previously used randoms in a dictionary, compares message randoms with it and rejects a message if there is a match detected. Pros: No need to request account state before sending an external messageNo race condition; simultaneous access to contract of multiple parties is supported. Collisions are still possible when multiple clients have the same random, but chances can be minimized. Cons: Consumes a lot of gas for dictionary write/read operations. Note that the gas fee will increase in the futureHigh storage fees for storing dictionary Dictionary of messages with garbage collection This option implies that every external message contains an expire-at integer that defines the time when the message becomes invalid (i.e. expires). The contract, in turn, must store a dictionary with all recently accepted and not expired external messages. The key is a message hash, the value is the relevant expire-at integer. The contract then rejects all messages that are already present in its dictionary. To avoid persistent data increase, a protected contract can delete messages with the expire-at value less than now from its dictionary. Pros: No need to request the account state before sending an external messageNo race condition issues Cons: Harder to implement compared to the above option with a dictionary of randomsHigh gas fees caused by the need to access a dictionaryHigh storage fees, yet these can be reduced by deleting expired messages from the dictionaryGarbage collecting also involves some gas costs "},{"title":"Sessions​","type":1,"pageTitle":"Smart Contract Security","url":"arch/security#sessions","content":"Before sending requests to contract, a user creates a session with a contract by sending a create_session external message. The message contains a new session ID, its expired-at time and a starting sequence number. The contract stores a session dictionary. After a session is created, the user adds the session_id and the next session sequence number to every external message. For every external message (not create_session) the contract checks that: The message session ID exists in dictionary The message sequence number is equal to the stored session number, and The now value is less then the expired-at value for session If all checks are passed successfully, the contract increments the stored sequence number for the session. In case of failure, the message is rejected. Also, expired sessions require some garbage collection. Pros: No need to request the account state before sending an external messageNo race condition issuesNo collisions Cons: Harder to implement compared to all the options covered aboveHigh gas feesHigh storage feesNeed to use garbage collectingUnsuitable for simple single-user contracts "},{"title":"Conclusion​","type":1,"pageTitle":"Smart Contract Security","url":"arch/security#conclusion","content":"In EverX, we selected a lightweight and simple replay protection option, it will be implemented in the compiler by default and based on the timestamp approach. It is supposed to work well for single-user contracts, as well as for contracts without heavy race conditions. It is easy to use given that EverX SDK enables inserting a timestamp automatically on the client side. Also, there will be an option to redefine the default protection method by overloading a special contract function. This is how contract developers will be able to implement any protection option they seem fit. "},{"title":"TVM","type":0,"sectionRef":"#","url":"arch/tvm","content":"","keywords":""},{"title":"About TVM​","type":1,"pageTitle":"TVM","url":"arch/tvm#about-tvm","content":"The TVM, is the virtual machine used to execute smart-contract code in the masterchain and in the basic workchain. Other workchains may use other virtual machines alongside or instead of the TVM. Here we list some of its features. TVM represents all data as a collection of (TVM) cells. Each cell contains up to 128 data bytes and up to 4 references to other cells. As a consequence of the “everything is a bag of cells” philosophy, this enables TVM to work with all data related to the Everscale Blockchain, including blocks and blockchain global state if necessary. TVM can work with values of arbitrary algebraic data types, represented as trees or directed acyclic graphs of TVM cells. However, it is agnostic towards the existence of algebraic data types; it just works with cells. TVM has built-in support for hashmaps.TVM is a stack machine. Its stack keeps either 64-bit integers or cell references. 64-bit, 128-bit and 256-bit arithmetic is supported. All n-bit arithmetic operations come in three flavors: for unsigned integers, for signed integers and for integers modulo 2^n (no automatic overflow checks in the latter case). TVM has unsigned and signed integer conversion from n-bit to m-bit, for all 0 ≤ m, n ≤ 256, with overflow checks. All arithmetic operations perform overflow checks by default, greatly simplifying the development of smart contracts. TVM has “multiply-then-shift” and “shift-then-divide” arithmetic operations with intermediate values computed in a larger integer type; this simplifies implementing fixed-point arithmetic. TVM offers support for bit strings and byte strings. Support for 256-bit Elliptic Curve Cryptography (ECC) for some predefined curves, including Curve25519, is present. Support for Weil pairings on some elliptic curves, useful for fast implementation of zk-SNARKs, is also present. Support for popular hash functions, including sha256, is present. TVM can work with Merkle proofs.TVM offers support for “large” or “global” smart contracts. Such smart contracts must be aware of sharding. Usual (local) smart contracts can be sharding-agnostic. TVM supports closures. A “spineless tagless G-machine” can be easily implemented inside TVM.  Several high-level languages can be designed for TVM, in addition to the “TVM assembly”. All these languages will have static types and will support algebraic data types. We envision the following possibilities: A Java-like imperative language, with each smart contract resembling a separate class. A lazy functional language (think of Haskell). An eager functional language (think of ML).  "},{"title":"Peculiarities of TVM.​","type":1,"pageTitle":"TVM","url":"arch/tvm#peculiarities-of-tvm","content":"The TVM, used to run smart contracts in the masterchain and Workchain Zero, is considerably different from customary designs inspired by the EVM (Ethereum Virtual Machine): it works not just with 256-bit integers, but actually with (almost) arbitrary “records”, “structures”, or “sum-product types”, making it more suitable to execute code written in high-level (especially functional) languages. Essentially, TVM uses tagged data types, not unlike those used in implementations of Prolog or Erlang. \\ One might imagine first that the state of a TVM smart contract is not just a hashmap 2^256 → 2^256, or Hashmap(256, 2^256), but (as a first step) Hashmap(256, X), where X is a type with several constructors, enabling it to store, apart from 256-bit integers, other data structures, including other hashmaps Hashmap(256, X) in particular. This would mean that a cell of TVM (persistent or temporary) storage—or a variable or an element of an array in a TVM smart-contract code—may contain not only an integer, but a whole new hashmap. Of course, this would mean that a cell contains not just 256 bits, but also, say, an 8-bit tag, describing how these 256 bits should be interpreted. In fact, values do not need to be precisely 256-bit. The value format used by TVM consists of a sequence of raw bytes and references to other structures, mixed in arbitrary order, with some descriptor bytes inserted in suitable locations to be able to distinguish pointers from raw data (e.g., strings or integers); This raw value format may be used to implement arbitrary sum-product algebraic types. In this case, the value would contain a raw byte first, describing the “constructor” being used (from the perspective of a high-level language), and then other “fields” or “constructor arguments”, consisting of raw bytes and references to other structures depending on the constructor chosen. However, TVM does not know anything about the correspondence between constructors and their arguments; the mixture of bytes and references is explicitly described by certain descriptor bytes.* The Merkle tree hashing is extended to arbitrary such structures: to compute the hash of such a structure, all references are recursively replaced by hashes of objects referred to, and then the hash of the resulting byte string (descriptor bytes included) is computed. In this way, the Merkle tree hashing for hashmaps, described in 2.3.8, is just a special case of hashing for arbitrary (dependent) algebraic data types, applied to type Hashmap(n, X) with two constructors.** *These two descriptor bytes, present in any TVM cell, describe only the total number of references and the total number of raw bytes; references are kept together either before or after all raw bytes. **Actually, Leaf and Node are constructors of an auxiliary type, HashmapAux(n, X). Type Hashmap(n, X) has constructors Root and EmptyRoot, with Root containing a value of type HashmapAux(n, X). "},{"title":"TVM Cells​","type":1,"pageTitle":"TVM","url":"arch/tvm#tvm-cells","content":"Ultimately, the TVM keeps all data in a collection of (TVM) cells. Each cell contains two descriptor bytes first, indicating how many bytes of raw data are present in this cell (up to 128) and how many references to other cells are present (up to four). Then these raw data bytes and references follow. Each cell is referenced exactly once, so we might have included in each cell a reference to its “parent” (the only cell referencing this one). However, this reference need not be explicit. In this way, the persistent data storage cells of a Everscale smart contract are organized into a tree,* with a reference to the root of this tree kept in the smart-contract description. If necessary, a Merkle tree hash of this entire persistent storage is recursively computed, starting from the leaves and then simply replacing all references in a cell with the recursively computed hashes of the referenced cells, and subsequently computing the hash of the byte string thus obtained. *Logically; the “bag of cells” representation described in 2.5.5 identifies all duplicate cells, transforming this tree into a directed acyclic graph (dag) when serialized. "},{"title":"Additionally​","type":1,"pageTitle":"TVM","url":"arch/tvm#additionally","content":"You can learn more about TVM and how it works from several sources: Legacy TON WhitepaperTVM WhitepaperTVM Extended Instructions "},{"title":"Everscale Network Changelog","type":0,"sectionRef":"#","url":"changelog","content":"","keywords":""},{"title":"block version 24 and before​","type":1,"pageTitle":"Everscale Network Changelog","url":"changelog#block-version-24-and-before","content":""},{"title":"Activated in the mainnet​","type":1,"pageTitle":"Everscale Network Changelog","url":"changelog#activated-in-the-mainnet","content":"New ZEROROTRIF instructionZEROROTRIF (x y – x y or 0 x y), pushes a Zero under the second stack entry from the top, but only if the topmost Integer y is non-zero.New ZEROROTRIF2 instructionZEROROTRIF2 (x y – x y or 0 0 x y), pushes two Zeros under the second stack entry from the top, but only if the topmost Integer y is non-zero. Equivalent to ZEROROTRIF; ZEROROTRIF.New ZEROROTRIFNOT instructionZEROROTRIFNOT (x y – x y or 0 x y), pushes a Zero under the second stack entry from the top, but only if the topmost Integer y is zero.New ZEROROTRIFNOT2 instructionZEROSWAPIFNOT2 (x – x or 0 0 x), pushes two Zeros under the topmost Integer x, but only if x = 0. Equivalent to ZEROSWAPIFNOT; ZEROSWAPIFNOT.New ZEROSWAPIF instructionZEROSWAPIF (x – x or 0 x), pushes a Zero under the topmost Integer x, but only if x &lt;&gt; 0.New ZEROSWAPIF2 instructionZEROSWAPIF2 (x – x or 0 0 x), pushes two Zeros under the topmost Integer x, but only if x &lt;&gt; 0. Equivalent to ZEROSWAPIF; ZEROSWAPIF.New ZEROSWAPIFNOT instructionZEROSWAPIFNOT (x – x or 0 x), pushes a Zero under the topmost Integer x, but only if x = 0.New ZEROSWAPIFNOT2 instructionZEROSWAPIFNOT2 (x – x or 0 0 x), pushes two Zeros under the topmost Integer x, but only if x = 0. Equivalent to ZEROSWAPIFNOT; ZEROSWAPIFNOT.Disabled setlibcode, changelibcode instructionValidator not validating in some cases fixSecurity fix for ADNL packet signatureImproved DB restorationFixed several bugs (storage fee calculation, storing last state of validator) "},{"title":"Config Change 30.05.22​","type":1,"pageTitle":"Everscale Network Changelog","url":"changelog#config-change-300522","content":""},{"title":"Activated in the mainnet​","type":1,"pageTitle":"Everscale Network Changelog","url":"changelog#activated-in-the-mainnet-1","content":"Prohibit to send anycast messagesNew MYCODE instructionMYCODE (- s) — returns the Cell with the current code of the smart-contract. Equivalent to GETPARAM 10. Smart-contract has own code which cell representation can be obtained by this instruction see TIP-1.2. "},{"title":"block version 28​","type":1,"pageTitle":"Everscale Network Changelog","url":"changelog#block-version-28","content":""},{"title":"Activated in the mainnet​","type":1,"pageTitle":"Everscale Network Changelog","url":"changelog#activated-in-the-mainnet-2","content":"Prohibit to send anycast messagesNew MYCODE instructionMYCODE (- s) — returns the Cell with the current code of the smartcontract. Equivalent to GETPARAM 10. Smartcontract has own code which cell representation can be obtained by this instruction see TIP-1.2. In the mainnet, not activated yet (using blockchain capabilities): New INITCODEHASH InstructionINITCODEHASH (- x) — returns the integer represented 256bit hash of code cell with contract was deployed. Equivalent to GETPARAM 11 see TIP-1.2.Changed account formatChanged the TLB scheme for Account data to reflect new functionality (hash value of the initial account code). Accounts updated recently cannot be deserialized with old software for this reason, update is mandatory.Increased storage fee calculation performance for accounts with large data sizeTraffic compression "},{"title":"In devnet not in mainnet​","type":1,"pageTitle":"Everscale Network Changelog","url":"changelog#in-devnet-not-in-mainnet","content":"Optimization and refactoring of operations with cellsAutomated DB versioning and updateFixed a bug with persistent zerostate deletion during GC processFixed security issues found (in data deserialization and states/archives requests)New COPYLEFT instrustionCOPYLEFT (s, n - ) — where s — is slice of 256bit AccountId and n — is type of license. Add license payment to code creator. The license payment calculates from compute_phase_fees taking the appropriate percentage. If summary payment is less than license_payment_threshold, then value saves in unsplit_shard_state of masterblock. If summary payment in unsplit_shard_state is more than license_payment_threshold then node sends internal message to account address in masterchain, specified in slice s see TIP-1.1.New STORAGEFEE instructionSTORAGEFEE ( -- x), returns the Integer~x with collected storage fee from account in this transaction. Equivalent to GETPARAM 12Full bounce: bounced message will contain init_state and full body of original message in first reference of the bodyChanges in currency_collections: Changed calculation of bounced message fee if bounced message consists currency_collectionsChanged some error codes in currency_collections operationsNow you can create account with zero grams and non-zero extra_currenciesChanged error in value with deleted and immediately created account with currency_collections "},{"title":"Bug bounty program","type":0,"sectionRef":"#","url":"contribute/bug-bounty-program","content":"Bug bounty program","keywords":""},{"title":"Community maintainers","type":0,"sectionRef":"#","url":"contribute/community-maintainers","content":"Community maintainers","keywords":""},{"title":"Documentation","type":0,"sectionRef":"#","url":"contribute/hot-streams/documentations","content":"Documentation In order to provide the best quality of our decentralized blockchain solutions and products, Everscale network designed this program aimed at improving the documentation. The program is designed to accommodate all potential contributors who are familiar with the blockchain technology. The scope of the Program: quality and structure improvement of Everscale documentation. The contribution can be in the following forms: writing an article from scratch, improving an existing article, relevant comments or advice, correction of grammatical and spelling errors. In case you are eager to contribute, please proceed via consulting the information below. Create an issue on GitHub, namely, a [Community Task]. The task description should be in the format “what to do?&quot; (Update @pagename/Create new page @pagename) [Self implementation - in case you are going to complete the issue yourself] or [Ever team implementation - in case you just stated the issue and are waiting for the review from the Everscale documentation team]”. Community task example №1: &quot;[Community Task] Add information to Fronted App page in Build section [Selfimplemetation]&quot; Community task example №2: &quot;[Community Task] Update Getting started page in Everdev folder in Build section [Everscale team implementation]&quot;; In the description, please indicate in detail what should be done and briefly explain the reasons why. Also, please indicate your nickname in Telegram; It is necessary to set all the parameters in the issue settings and in “Labels”. In addition to the corresponding tags, it is necessary to set the tag “Community task”, as well as to choose a milestone indicating the week during which you are planning to complete the task. In case, the task is set for Everscale documentation team, the milestone does not need to be set; After creating an issue, you need to join the following chat and write a message in accordance with the pinned message to notify the administrator about the created task; All issues that are assigned to the documentation development team are accumulated and reviewed at the end of each working week; When you complete the issue on your own it is necessary to make a pull request indicating as reviewers @ArtemFMX, @Babowski and @maximgree. Also, in the comments section of the pull request it is needed to indicate the link of the issue; In case you do not want to use GitHub and make corrections on your own, it is necessary to fill in the following Google form. In the form, please indicate your nickname, email address and the wallet address where you want your rewards to be deposited to. Also, please indicate the section and page which you want to correct with all necessary comments or provide the page that you want to add. It is worth mentioning that in case you want to write an article from scratch, then it will be necessary to figure out how GitHub works and how to commit there. For these, please follow this link in order to get familiar with detailed instructions. Remuneration Reward Program: The amount of remuneration is the sum of the base rate and the multiplier, which depends on the complexity of the article and the participation of the author in comments and suggestions regarding documentation improvements. Minimum reward: equivalent to $8 paid in Ever tokens. (1 hour work) Maximum reward: equivalent to $1200 paid in Ever tokens (work week - 5 days, $30 hourly pay rate) Multipliers: Pages with general information that do not require strong knowledge of technical aspects (FAQ, Learn section, Contribute section) - x1, hourly pay rate $8Pages with technical information in the format of guides or references (section Build and Validate) - x2.25, hourly pay rate $18Pages with technical information about the Everscale network functionality (pages from sections Standards, Architecture) -×3,75, hourly pay rate $30 The amount of rewards is set as follows: Pages from the Learn and Contribute sections: In the case of writing an article that does not require much editing: $40 - $50.In case of improvement of an existing article: $20 - $30.In case of a relevant comment or advice: $8 - $10. Pages from the Build and Validate sections: In the case of writing an article that does not require much editing: $90 - $120.In case of improvement of an existing article: $45 - $60.In case of a relevant comment or advice: $18 - $20. Pages from the Standards and Architecture sections: In the case of writing an article that does not require much editing: $150 - $500. In case of improvement of an existing article: $75 - $250. In case of a relevant comment or advice: $30 - $50. P.S. Writing a community-accepted standard is reviewed and paid separately. Also, please be informed that in case of contribution in the form of correction of grammatical errors and spelling mistakes as well as active participation in discussions, the size of rewards is reviewed separately. Payment of remuneration Rewards are paid every month in Ever tokens.Payout notifications are posted on Everscale Documentation Developers Chat. N.B. Below are the pages of the highest priority for us. Please check them out and contact us in the Everscale Documentation Developers Chat in case you wish to contribute to one of them. The rewards for these pages are as well reviewed sepatetely. For any questions that may have arisen, please contact us via the following Telegram chat https://t.me/+C2IpQXWZtCwxYzEy Pages: Frontend App, SMV contacts, Debugging","keywords":""},{"title":"Reward calculations","type":0,"sectionRef":"#","url":"contribute/rewards","content":"Reward calculations","keywords":""},{"title":"GitHub contribution tutorial","type":0,"sectionRef":"#","url":"contribute/tutorial/contributor-guide","content":"","keywords":""},{"title":"Welcome to Everscale GitHub tutorial​","type":1,"pageTitle":"GitHub contribution tutorial","url":"contribute/tutorial/contributor-guide#welcome-to-everscale-github-tutorial","content":"By accessing it, we suppose that you are already familiar with how GitHub works. However, in case you wish to refresh your knowledge, please consult the links below in order to guide yourself on how to contribute to Everscale via Github. Github Tutorial https://lab.github.com/githubtraining/introduction-to-githubDocusaurus tutorial https://docusaurus.io/docsGit tutorial https://desktop.github.com/ Everscale documentation https://docs.everscale.network/ is a collection of pages compiled with the help of Docusaurus, which is a generator of static websites. All pages are in the following repository. You can proceed by making changes to the documentation in different ways. Let's dwell on each of them in detail. "},{"title":"For beginners​","type":1,"pageTitle":"GitHub contribution tutorial","url":"contribute/tutorial/contributor-guide#for-beginners","content":"This method does not require installing any applications. However, it should be noted that due to this, it is less convenient and effective. We recommend using this method only in case of minor changes to the documentation. Let's examine this method in detail. "},{"title":"Making changes​","type":1,"pageTitle":"GitHub contribution tutorial","url":"contribute/tutorial/contributor-guide#making-changes","content":"At the bottom of most https://docs.everscale.network/ pages, you can find a hyperlink with the text &quot;Edit this page&quot;. Clicking on it will take you to that file's page in the documentation repository.  Here you can make all the necessary changes directly to the file and take a look at the visualization of your changes by clicking the Preview button.  After you have made all the necessary changes, click Propose Changes. At this point, a fork2 (copy) of the main repository of everscale/docs will be created and a branch1 with the commit3 with changes that you made.  You can freely make changes to this branch, it being a copy of the main repository. "},{"title":"Create pull request​","type":1,"pageTitle":"GitHub contribution tutorial","url":"contribute/tutorial/contributor-guide#create-pull-request","content":"After making all necessary changes, you can create a Pull Request to the main branch of the repository by clicking Create Pull Request. Please note that you can choose from several types of requests, including creating a Draft. It allows you to finish it at any time and then create a full request.  "},{"title":"Advanced​","type":1,"pageTitle":"GitHub contribution tutorial","url":"contribute/tutorial/contributor-guide#advanced","content":"This method allows you: To effectively work with the repository and all files by using an applicationTo conduct local checks identical to Github's testsTo raise a local assembly (copy) of the website and evaluate the changes made in real time. "},{"title":"Preparation​","type":1,"pageTitle":"GitHub contribution tutorial","url":"contribute/tutorial/contributor-guide#preparation","content":"Required Applications:​ To use this method, you will need to install the following software on your device: GitHub Desktop VSCode or other source code editor GitBash Node.js Useful links​ Check out the information on the pages below if you're having issues understanding how Git, Docusaurus, or Markdown work. https://lab.github.com/githubtraining/introduction-to-github - GitHub Tutorial.https://docusaurus.io/docs — Instructions for working with Docusaurus and designing Markdown pages.https://docs.github.com/en/desktop - GitHub Desktop guides. "},{"title":"Making changes​","type":1,"pageTitle":"GitHub contribution tutorial","url":"contribute/tutorial/contributor-guide#making-changes-1","content":"Creating a Fork​ The first thing you need to do is to create a Fork (copy) of the main repository, which will later be administered by you, and all changes will be sent to the “parent” repository via Pull Requests. Go to the Everscale documentation repository and click Fork in the top right corner. Select the name of the repository, make a description and click Create fork.  Create branch​ Go to your Fork page, click Code and then open it with GitHub Desktop. Choose a local name for this repository and a path to save it. Then click Clone.  After that, go to the Branch section and create a new one by entering its name and pressing Enter. Since we created the Branch locally, you can upload the Branch to GitHub directly if you wish, by clicking Publish Branch at the top of the screen.  Now you can contribute to a local copy of the repository. We recommend creating a new Branch for every update you want to make to the documentation, as any Pull Request will contain the changes we made to that specific Branch. Thus, each Pull Request will have its own copy of the repository behind it. Don't make changes directly to the main Branch of your repository! You can update your Fork with everscale/docs by clicking Fetch Upstream. Don't forget to do this before creating a new Branch. Conducting tests​ When creating a pull request, GitHub will automatically run a series of checks from the Actions tab. These checks allow you to detect build errors, broken links, and so on. Without successfully passing all these tests, you will not be able to upload your changes to the documentation. You have the ability to run all tests locally without having to create a Pull Request, which can save you a lot of time and effort. Select your repository from GitHub Desktop and right click on it. Then select Open in Explorer.Go to the .build folder, right click on the Website folder and select GitBash here. This is the easiest way to open a folder in GitBash.In the window that opens, write $ yarnOnce the process is complete, type $ yarn build, in order to start the testing process.  After the testing is done, you will see either a series of errors and their description, or a notification about a successful build. With the second option, you can safely upload changes to GitHub and, if you wish, create a Pull request. Always check your repository for errors before making a Commit! Start local build​ Select your repository from GitHub Desktop and right click on it. Then select Open in Explorer.Go to the .build folder, right click on the Website folder and select GitBash here. This is the easiest way to open a folder in GitBash.In the window that opens, write $ yarnOnce the process is complete, type $ yarn start to begin the process of building a local copy of the site. This will open a local copy of the site at http://localhost:3000/ in your default browser. Any local changes you make will be displayed here. You don't need to restart the process with every new change. Saving changes​ After making the changes to a local copy of your Branch, you need to upload the respective changes to GitHub. To do this, open GitHub Desktop and select the files you want to commit to GitHub. Commits show the history of your repository. They include a lot of metadata in addition to the content, such as author, timestamp, etc. Choose a name for this Commit and click Commit to commit name.To publish a Commit, click Push Origin.  "},{"title":"Create a Pool Request​","type":1,"pageTitle":"GitHub contribution tutorial","url":"contribute/tutorial/contributor-guide#create-a-pool-request","content":"After you have published all the Commits in our repository, you can create a Pool Request. Navigate to the appropriate section in your repository and select Create Pool Request.If you wish, you can create a Draft Pool Request and complete it later.  After you create a &quot;regular&quot; request for a vote, reviewers are selected that take into account the changes you make. Reviewers may accept your changes in case they don't find any errors. However, if they have comments, then you will need to make the appropriate changes, and then re-request the approval by clicking on the appropriate button. You need to get confirmation from at least one reviewer so that changes can be deployed. "},{"title":"Getting started","type":0,"sectionRef":"#","url":"contribute/tutorial/getting-started","content":"","keywords":""},{"title":"Everscale Grants​","type":1,"pageTitle":"Getting started","url":"contribute/tutorial/getting-started#everscale-grants","content":"Everscale Grants is a campaign that aims to attract promising IT projects that can contribute to the Everscale ecosystem's growth. Approved projects receive not only financial, but also technical and marketing support. The formation and distribution of grants is handled by DeFi Alliance. DeFi Alliance is a business combination that creates the necessary infrastructure to attract teams and projects, raises liquidity from other projects in Everscale, and builds partnerships with large companies with large amounts of liquidity. To apply, use the form on the Everscale Grants page on the network's website or Everscale DeFi Alliancecorresponding page of their official website. "},{"title":"Contests​","type":1,"pageTitle":"Getting started","url":"contribute/tutorial/getting-started#contests","content":"Contests are a way to develop and support Everscale, as well as a way that the network’s meritocratic coin distribution model is put into practice. Contests are held in various areas, such as programming, design, SMM, PR, and so on. Some of them are aimed at technically improving operation, while others are to increase awareness of the blockchain and attract new users. Everscale's management is divided into subgovernances – groups of people, each of which is responsible for a certain type of activity and contests within Everscale. Members of the subgovernances receive a portion of tokens for community development, contests, etc. Prizes for first place sometimes reach 500,000 EVER and average between 10,000 and 100,000 EVER. Check out active and completed contests at EverKit Governance. "},{"title":"EVER DAO​","type":1,"pageTitle":"Getting started","url":"contribute/tutorial/getting-started#ever-dao","content":"EVER DAO is a decentralized governance platform that allows EVER (wEVER) token holders to vote on proposals relating to the Everscale network. Community members can express their will and opinion on significant network events in a transparent and verifiable way. To participate in voting, you must have a certain stake EVER, which will be equivalent to the strength of your vote. "},{"title":"EverStart​","type":1,"pageTitle":"Getting started","url":"contribute/tutorial/getting-started#everstart","content":"EverStart - is a DAO-managed multi-chain launcher for connecting to curated projects. This is the first Everscale blockchain launchpad, thanks to which the community has the opportunity not only to decide which project is worthy of being in the network ecosystem, but also to benefit from its further development through vesting. (DAO mechanism not launched yet). "},{"title":"Octus Bridge DAO​","type":1,"pageTitle":"Getting started","url":"contribute/tutorial/getting-started#octus-bridge-dao","content":"Octus Bridge is a cross-chain solution that allows you to move liquidity between Everscale and many other chains. Octus Bridge also has its native BRIDGE token. BRIDGE token holders can vote on certain operational decisions of the Octus Bridge platform to make the bridge better. The voting protocol is a real smart contract that is allowed to make changes to other smart contracts. There are now more than 23 relays of particular importance in the Bridge DAO structure. Any user with at least 100,000 BRIDGE tokens can become a relay. "},{"title":"Transaction executor","type":0,"sectionRef":"#","url":"arch/executor","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#introduction","content":"Transaction Executor is a crucial part of Everscale blockchain node. It applies incoming messages to accounts, sealing the end result of this operation into a block in the form of a transaction object. The Transaction Executor algorithms determine several critical aspects of smart-contracts behavior, such as: How a balance of an account is affected after the message gets processedWhat outbound messages will be generated as a resultShould the account be frozen or deleted?What fees should be charged from the accounts balance To be able to rigorously reason about a smart-contract behavior, it is important to construct the accurate model of this module, explain the main concepts, define its properties. In other words, make the groundwork for you, the reader, to foster the integration of this logic into the reasoning framework of your choice. In the current work, we made the best-effort attempt to write such specification. "},{"title":"Document Structure​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#document-structure","content":"The document consists of two logical parts, intermixed with each other: the explanation part and the specification part. The explanation part is done by providing extensive comments for data structures used through-out the Transaction Executor. The data structures are presented as Rust code snippets, taken from the original Node code. Sometimes, we intentionally omit details that are not relevant to the Transaction Executor, requiring much wider context to be explained. The specification part is presented in two flavors. When the precision is required, we describe the behavior by providing the pseudo-code implementing some algorithm. For more general properties, we formulate them in a form of semi-formal statements about the system behavior. By comparison to the program implementation, the specification pseudo-code overapproximates the implementation by throwing away non-relevant parts of the logic, for example: sophisticated error handling, non-interesting parts of the state being removed, introducing reasonable assumptions that greatly simplifies the logic, etc. In other words, the pseudo-code shows how the system behaves for its significant parts, putting away everything else. "},{"title":"Everscale Platform Architecture​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#everscale-platform-architecture","content":"The main actors of the EverScale blockchain are smart-contracts. Smart-contracts are programs that operate user valuable assets on their behalf. Valuable assets are usually cryptocurrency tokens or some digital goods, like NFTs. Smart-contract execution is triggered by a message sent from some other party. If the message was delivered from the outside world (i.e. from the user program), it is said to be external. Otherwise, the message is considered internal. Smart-contracts may also generate log records called events. Those records are used as information signals for an external observers. They foster communication between smart-contracts and off-chain programs. The platform overall architecture is depicted​  "},{"title":"Platform Implementation​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#platform-implementation","content":"EverScale blockchain is a database operated by a peer-to-peer network of computing nodes. The database store users code and data in a form of programmable units called smart-contracts. Smart-contacts may communicate with other contracts and outside world by sending messages. The computing node is called blockchain node in our context. Among other things, blockchain nodes are responsible for storing the smart-contract state, delivering messages from users and smart-contracts, executing the smart-contacts code when needed. Transaction Executor module is a part of the blockchain node responsible for proper execution of a smart-contract code upon receiving a message addressed to that smart-contract. The result of this execution is an updated smart-contract state and the transaction record that gets sealed into the block candidate. We now go into details on the internals of this module. "},{"title":"Transaction Executor Module​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#transaction-executor-module","content":"In this section, we go into the technical details of Transaction Executor module. The source code of the module is available here. "},{"title":"Remark​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#remark","content":"In our opinion, the name of this module was chosen quite unfortunate. In its current form, it feels like the object being executed is a transaction. This is not true. Transaction is an outcome of executing a message on a smart-contract state using the Transaction Executor logic. Hence, it is the message that is being executed, not the transaction. Nevertheless, we stick with the original name not to confuse developers too much. "},{"title":"Inputs and Outputs​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#inputs-and-outputs","content":"The principal architecture of the module is depicted​  We now describe each input/output entity in detail, together with the logic of the computation. "},{"title":"Multichain Architecture​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#multichain-architecture","content":"Everscale has a native support for multiple blockchains running in parallel. Each blockchain might be established by introducing a separate chain called workchain. Each workchain has a unique integer identifier in a range -127 ... 127, the values -1 and 0 are already taken. Smart-contracts from different workchains may interact with each other by message passing. At the moment, the system implements only two workchains — Masterchain (id -1) and Workchain (id 0). caution Currently, the creation of new workchains is not supported. "},{"title":"Multicurrency payments​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#multicurrency-payments","content":"The native coin of Everscale blockchain is called EVER. However, Everscale has an ability to work with other types of coins. While system payments like gas and storage fees are made only in Evers, the other value transfers may contain coins of other currencies. This contrasts with most of other blockchains where there is only a single native cryptocurrency, and other currencies may be made only using artificial token smart-contracts. Currently, this feature is not used widely. caution In this document, we limit our specification effort only for the case of a single currency — Evers. This choice significantly simplifies the business logic of the execution handlers. "},{"title":"Hashing Algorithm​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#hashing-algorithm","content":"Transaction Executor uses hashing in several places to compactly store data structures fingerprints. It is done in two steps. First, the data structure gets converted into a tree-like form. Then, a special hashing algorithm is applied to that tree. The basic hash function used is SHA256 from Sha2 Rust package. The exact hashing algorithm, as well as tree-like representation is not interesting for our purposes, so we do not consider it here. For details, check this. "},{"title":"Parameters​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#parameters","content":"Besides, incoming message and account, Transaction Executor has to have some external information regarding the current blockchain and non-blockchain state to support the TVM capabilities. For example, it has to know the current time to provide it for smart-contracts. It has to have some random seed to support the random number generator facility. All of this is passed using the ExecuteParams structure. pub struct ExecuteParams { pub state_libs: HashmapE, pub block_unixtime: u32, pub block_lt: u64, pub last_tr_lt: Arc&lt;AtomicU64&gt;, pub seed_block: UInt256, pub debug: bool }  ExecuteParams fields​ Field\tDescriptionstate_libs\tA set of references to external libraries. This mechanism is not supported currently block_unixtime\tCurrent time in Unix Epoch block_lt\tBlock logical time last_tr_lt\tThe last transaction logical time seed_block\tRandom number generator seed debug\tShould the TVM output debug information during its execution "},{"title":"Transaction​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#transaction","content":"Transaction is an object that describes the successful execution of a message on the account. If a message execution results in an error, such execution does not lead to a transaction creation. After transaction is created, it gets sealed into the block. And after the block is negotiated with fellow validators, it find its way into the Masterchain. From that point, it stays there forever1. Transaction is an output of the Transaction Executor, so we have to examine it more closely. pub struct Transaction { pub account_addr: AccountId, pub lt: u64, pub prev_trans_hash: UInt256, pub prev_trans_lt: u64, pub now: u32, pub outmsg_cnt: i16, pub orig_status: AccountStatus, pub end_status: AccountStatus, pub in_msg: Option&lt;ChildCell&lt;Message&gt;&gt;, pub out_msgs: OutMessages, pub total_fees: CurrencyCollection, pub state_update: ChildCell&lt;HashUpdate&gt;, pub description: ChildCell&lt;TransactionDescr&gt;, }  ExecuteParams fields​ Field\tDescriptionaccount_addr\tAccount identifier lt\tTransaction creation logical time prev_trans_hash\tPrevious transaction hash value prev_trans_lt\tPrevious transaction logical time now\tCurrent time in Unix Epoch outmsg_cnt\tNumber of generated outbound messages orig_status\tAccount state upon receiving the message end_status\tAccount state after executing the message in_msg\tProcessed message out_msgs\tSet of generated outbound messages total_fees\tTotal fee amount for all the processing state_update\tHash footprint of the account state change description\tTransaction Descriptor "},{"title":"Transaction Executor​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#transaction-executor-1","content":"Transaction Executor module is responsible for applying the incoming message to the destination account, using the supplied parameters. In case of success, Transaction Executor outputs the newly created transaction and the updated account. The main entry point is the function execute_with_libs_and_params() within transaction_executor.rs module. Other entry points were either flagged as deprecated, or reduce to calling this function after some minor parameters mangling. The message execution is being done in several phases. A phase is a logical step during the message execution. It may finish successfully or with an error. In case of an error, the next phase may not be executed. Phases are done mostly in a fixed order, but there are some nuances. Let us warn you that the phase is not just an implementation detail of the Transaction Executor internals that may be easily discarded. Message execution phases are a part of EverScale smart-contracts programming architecture. It is assumed that you have a good grasp on it, to be able to do proper troubleshooting in case something is not working as expected. Without this knowledge, it may be challenging to debug the problem. This document aims to support programmers in their strive for this knowledge. Transaction executor message processing general scheme​  Credit — Message coins are put on the balance agent Storage.Storage — Storage fee is deducted from the balance agent Computer.Computer — The contract bytecode gets executed inside TVM with proper parameters. Contract generate Actions.Action — Generated actions get executed by the action handler, producing outbound messages.Bounce — Bounce phase is executed if failure happened on compute phase or action phase. It sends back the reply with coins, mostly.Out messages — Queue get propagated to other validators. "},{"title":"Transaction Executor Types​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#transaction-executor-types","content":"There are several type of messages in EverScale. Besides already mentioned ordinary messages, there are also a special type of messages that is a part of a wider protocol. For example, TickTock messages, SplitMerge messages, etc. For each type of messages, there exists a separate Transaction Executor. In this work, we consider only the OrdinaryTransactionExecutor, that is defined in ordinary_transaction.rs. "},{"title":"Main Entry Point​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#main-entry-point","content":"fn execute_with_libs_and_params( &amp;self, in_msg: Option&lt;&amp;Message&gt;, account_root: &amp;mut Cell, params: ExecuteParams, ) -&gt; Result&lt;Transaction&gt;  ExecuteParams fields​ Field\tDescriptionself\tReference to the object calling the function in_msg\tIncoming message messages account_root\tAccount record serialized in a form of Cells account params\tTransaction Executor parameters parameters As a result, the function returns either Ok(Transaction) object or Err value. Please note that besides returning the Transaction, there is a side-effect of mutating the account_root object. This justifies our generalization that it returns two objects: the transaction and the updated account record. "},{"title":"BlockchainConfig parameters​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#blockchainconfig-parameters","content":"Besides ExecuteParams, the Transaction Executor relies on BlockchainConfig parameters. They are passed implicitly, at the Transaction Executor creation time. BlockchainConfig is a set of globally defined parameters regulating different nuances of blockchain work. For example, prices for smart-contract execution, storage and a set of system contract addresses. The latter is needed to let Transaction Executor apply special logic for them. Those parameters are global to the network, and negotiated between all the validators in advance. They are stored in a special system smart-contract, in the Masterchain. pub struct BlockchainConfig { gas_prices_mc: GasLimitsPrices, gas_prices_wc: GasLimitsPrices, fwd_prices_mc: MsgForwardPrices, fwd_prices_wc: MsgForwardPrices, storage_prices: AccStoragePrices, special_contracts: FundamentalSmcAddresses, capabilities: u64, global_version: u32, raw_config: ConfigParams, }  Field\tDescriptiongas_prices_mc\tFees for Masterchain smart-contract execution gas_prices_wc\tFees for Workchain smart-contract execution fwd_prices_mc\tFees for delivering messages in Masterchain fwd_prices_wc\tFees for delivering messages in Workchain storage_prices\tFees for information storage special_contracts\tSet of system smart-contract addresses capabilities\tSet of operation-mode flags global_version\tMinimum blocks version number allowed to be included in the chain raw_config\tDictionary with blockchain settings "},{"title":"Code Execution Fee​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#code-execution-fee","content":"As in most of blockchain, in Everscale the execution of a smart-contract costs money. Usually, this fee is deduced from the coins attached to the message initiating the call, but there are nuances. The fee amount to be deducted from the balance is calculated based on values found in gas_price_mc, gas_price_wc structures. They are defined as follows: pub struct GasLimitsPrices { pub gas_price: u64, pub gas_limit: u64, pub special_gas_limit: u64, pub gas_credit: u64, pub block_gas_limit: u64, pub freeze_due_limit: u64, pub delete_due_limit: u64, pub flat_gas_limit: u64, pub flat_gas_price: u64, pub max_gas_threshold: u128, }  Field\tDescriptiongas_price\tPrice of 1 unit of gas, expressed in Nano Evers gas_limit\tMaximum gas amount for execution of a single message for an ordinary account special_gas_limit\tMaximum gas amount for execution of a single message for a system account gas_credit\tGas credited for an account to execute the external message block_gas_limit\tMaximum gas amount of the whole block freeze_due_limit\tValue of an account debt leading to account freeze delete_due_limit\tValue of an account debt leading to account removal flat_gas_limit flat_gas_price max_gas_threshold\t "},{"title":"Message Passing Fee​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#message-passing-fee","content":"Validators do the work of message delivery. To compensate their efforts, account pays for the message passing. The message passing fee depends on BlockchainConfig parameters fwd_pricesand the message size. The fwd_prices_mc and fwd_prices_wchave the following definition: pub struct MsgForwardPrices { pub lump_price: u64, pub bit_price: u64, pub cell_price: u64, pub ihr_price_factor: u32, pub first_frac: u16, pub next_frac: u16, }  The fee amount is calculated using the expression: msg_fwd_fees=lump_price+bit_price×msg.bits+cell_price×msg.cellsmsg\\_fwd\\_fees = lump\\_price + bit\\_price \\times msg.bits + cell\\_price \\times msg.cellsmsg_fwd_fees=lump_price+bit_price×msg.bits+cell_price×msg.cells Here, msg.bits — bit-length of the message body, msg.cells is a total amount of cells that this message consists of. "},{"title":"Data Storage Fee​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#data-storage-fee","content":"In Everscale, account is charged a fee for storing the data. The fee amount is calculated using the formula: fee=(cells∗prices.cell_price+bits∗prices.bit_price)∗Δfee = (cells * prices.cell\\_price + bits * prices.bit\\_price) * \\Deltafee=(cells∗prices.cell_price+bits∗prices.bit_price)∗Δ Δ\\DeltaΔ — the time interval between now and the latest payment moment, measured in seconds. Here, we assume that storage prices stay constant during the Δ\\DeltaΔ interval. The storage fee gets charged on each message processing storage_phase. For greater flexibility, the storage prices may be changed depending on the current supply/demand situation. It is done by negotiating new blockchain config parameters prices.cell_priceprices.cell\\_priceprices.cell_priceand prices.bit_priceprices.bit\\_priceprices.bit_price among validators. After validators accept it, new parameters are written in the Masterchain config smart-contract. After the change, previous price parameters do no get lost. The whole history of storage price changes is stored in the config. It is done to provide precise calculation of the storage fee that take into account all the price changes during the interval of calculation. Data Storage Fee Calculation​ Here we describe the storage fee calculation expression in its generality. Lets assume we have the following list of prices equipped with a timestamp of a moment when the price change took place: T={t0,t1,...,tN}T = \\{ t_0, t_1, ..., t_N \\}T={t0​,t1​,...,tN​} Pr=⟨(pr0,t0),(pr1,t1),...,(prN,tN)⟩Pr = \\langle (pr_0, t_0), (pr_1, t_1), ..., (pr_N, t_N) \\ranglePr=⟨(pr0​,t0​),(pr1​,t1​),...,(prN​,tN​)⟩ Here, pr_0 is reserved for the initial prices set in the genesis block of the blockchain, and t0t_0t0​ is a timestamp of those initial prices being set. Let now denote the current timestamp, i.e. the moment of time when we want to calculate the storage fee, measured in Unix Epoch. Its value is always greater or equal than the most recent price change timestamp. Let last_paid denote the timestamp of the latest storage payment. If the payment didn't take place, last_paid=0last\\_paid = 0last_paid=0. To simplify the calculation formula, let us introduce a new listPr′Pr'Pr′, such that: Pr′=⟨(prk,tk),...,(prN,tN)⟩Pr' = \\langle (pr_k, t_k), ..., (pr_N, t_N) \\ranglePr′=⟨(prk​,tk​),...,(prN​,tN​)⟩ where t_k is the least timestamp among values t1...tNt_1 ... t_Nt1​...tN​ that is greater than last_paid. tk=min{ti∣ti∈T∧ti&gt;last_paid}t_k = min \\{ t_i | t_i \\in T \\land t_i &gt; last\\_paid \\}tk​=min{ti​∣ti​∈T∧ti​&gt;last_paid} In other words, the values tk,...,tNt_k, ..., t_Ntk​,...,tN​ form a subset ofT where each value is strictly greater than last_paid. We also add two more elements from the left and the right: Pr′′=⟨(prk,last_paid)⟩⋅Pr′⋅⟨(prN,now)⟩Pr'' = \\langle (pr_k, last\\_paid) \\rangle \\cdot Pr' \\cdot \\langle (pr_N, now) \\ranglePr′′=⟨(prk​,last_paid)⟩⋅Pr′⋅⟨(prN​,now)⟩ Here, dot operator denotes lists concatenation operation. We use the following shortcuts: pri=fst(Pri′′)pr_i = fst(Pr''_i)pri​=fst(Pri′′​) the first element of a two-element tuple, and ti=snd(Pri′′)t_i = snd(Pr''_i)ti​=snd(Pri′′​), the second element. The total storage fee for the time interval is: total_storage_fee=∑i=1..∣Pr′′∣(cells∗pri.cell_price+bits∗pri.bits_price)∗(ti−ti−1)total\\_storage\\_fee = \\sum_{i=1..|Pr''|}{(cells * pr_{i}.cell\\_price + bits * pr_{i}.bits\\_price) * (t_i - t_{i-1})}total_storage_fee=∑i=1..∣Pr′′∣​(cells∗pri​.cell_price+bits∗pri​.bits_price)∗(ti​−ti−1​) Data Storage Fee Calculation Algorithm​ For greater convenience, besides having the formula, we provide the pseudo-code for the algorithm calc_storage_fee, implemented in imperative fashion. Input: config — current blockchain configuration, has type BlockchainConfigstorage_info — the account storage info struct, has type StorageInfo.is_masterchain — is the account inhabits Masterchain or not, has type Boolnow — current time, measured in Unix Epoch, has type UInt Output: fee — the fee amount to be deducted from the account balance, has type UIntstorage_info — updated account storage info, has type StorageInfo def calc_storage_fee(config, storage_info, is_masterchain, now): cells = storage_info.used.cells bits = storage_info.used.bits last_paid = storage_info.last_paid prices = config.storage_prices # see AccStoragePrices assert len(prices) &gt; 0 if now &lt;= last_paid or last_paid == 0 or now &lt;= prices[0].utime_since: return 0 fee = 0 # calculate the fee according to prices that were actual # during the specific period of time for i in len(prices): cur_price = prices[i] if i &lt; len(prices) - 1: end = prices[i + 1].utime_since else: end = now_time if end &gt;= last_paid: delta = end - max(cur_price.utime_since, last_paid) if is_masterchain: fee += (cells * cur_price.mc_cell_prices_ps + \\ bits * cur_price.mc_bit_price_ps) * delta else: fee += (cells * cur_price.cell_price_ps + \\ bits * cur_price.bit_price_ps) * delta storage_info.last_paid = end return (fee, storage_info)  "},{"title":"Special Smart-Contracts​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#special-smart-contracts","content":"In Everscale blockchain, there is a set of smart-contracts that have a distinguished status in the system. For those contracts, validators are obligated to process their execution in a special priveledged manner. Such smart-contracts are called special or system. Accounts storing those contracts are called the same. Special smart-contracts enjoy the following privilege: No fee gets deducted for the code executionNo fee gets deducted for the storage useNo fee gets deducted for message passingIt has a special maximum gas limit, see GasLimitsPrices.special_gas_limitAllowed to process TickTock timer messages Upon executing a message for one of those special contracts, the Transaction Executor has to apply all those conditions. caution In this document, we mainly focus on ordinary accounts, leaving the special accounts processing details aside. "},{"title":"GlobalCapabilities Options​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#globalcapabilities-options","content":"There are several flags defining different aspects of the blockchain node operation mode. They are defined in GlobalCapabilities enumeration. Parameter\tDescriptionCapCreateStatsEnabled\tAllow update block statistics. Not related to Transaction Executor. CapBounceMsgBody\tInclude the first 256 bits of the original message in the bounce message body. CapReportVersion\tInclude the blockchain version info into the block. CapShortDequeue\tSome special mode of managing outbound messages by the Validator. Not related to Transaction Executor CapFastStorageStat\tUse alternative algorithm to update the structs AccountsStat. CapInitCodeHash\tUse the field init_code_hash in the AccountState. CapOffHypercube\tTurn off Hypercube routing algorithm for message delivery CapMycode\tProvide the virtual machine with the code of a smart-contract being executed. CapMbppEnabled\tNot used CapIhrEnabled\tNot used CapSplitMergeTransactions\tNot used "},{"title":"RawConfig options​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#rawconfig-options","content":"Besides already mentioned options, there are yet another set of options residing in the BlockchainConfig.raw_config. This field has the following structure: pub struct ConfigParams { pub config_addr: UInt256, pub config_params: HashmapE // &lt;u32, SliceData&gt; }  config_addr — is the configuration smart-contract account identifier (the workchain identifier equals - 1);config_params — dictionary with parameters, dictionary keys refers to an option number. We will not go deep into those options, because they are not relevant to our work. See ton-labs-block/src/config_params.rs for further investigation. "},{"title":"Error Code Enumeration​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#error-code-enumeration","content":"When Transaction Executor encounters an error during message processing, it returns a special answer to the calling side. The answer contains an error code. Here we list possible error codes and their short description. In our further discussion, we rely on those mnemonic names. "},{"title":"Error Code Enumeration​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#error-code-enumeration-1","content":"When Transaction Executor encounters an error during message processing, it returns a special answer to the calling side. The answer contains an error code. Here we list possible error codes and their short description. In our further discussion, we rely on those mnemonic names. Error Mnemonic Name\tDescriptionInvalidExtMessage\tIncorrect format of an incoming external message TrExecutorError(e)\tWide range of errors during message processing TvmExceptionCode(e)\tTVM produced exception e during byte-code execution NoAcceptError\tThe smart-contract did not accept external message NoFundsToImportMsg\tNot enough funds to process external message ExtMsgComputeSkipped(r)\tDuring the external message processing, the Compute phase was skipped with the reason r "},{"title":"Account State Update​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#account-state-update","content":"In the transaction object, there is a special field reflecting the change of the account state, the state_update field of type HashUpdate. The type is defined as follows: pub struct HashUpdate { pub old_hash: UInt256, pub new_hash: UInt256, }  Here old_hash refers to a hash value taken from the initial account state, before message processing; the new_hash is a hash taken from the updated account state, after successful message processing. "},{"title":"Transaction Description Object​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#transaction-description-object","content":"During the incoming message processing, Transaction Executor constructs the report about the processing. This report has a special name — Transaction Description, and defined by the following structure: pub struct TransactionDescrOrdinary { pub credit_first: bool, pub storage_ph: Option&lt;TrStoragePhase&gt;, pub credit_ph: Option&lt;TrCreditPhase&gt;, pub compute_ph: TrComputePhase, pub action: Option&lt;TrActionPhase&gt;, pub aborted: bool, pub bounce: Option&lt;TrBouncePhase&gt;, pub destroyed: bool }  This description object may be used for fast checkups on the main system invariants, critical for its safety, during runtime. Field\tDescriptionstorage_ph\tStorage phase descriptor credit_ph\tCredit phase descriptor compute_ph\tCompute phase descriptor action\tAction phase descriptor bounce\tBounce phase descriptor credit_first\tCredit phase was executed before Storage phase aborted\tIs Action phase failed destroyed\tIs account deleted after message execution We now describe each descriptor separately. Storage Phase Descriptor​ pub struct TrStoragePhase { pub storage_fees_collected: Grams, pub storage_fees_due: Option&lt;Grams&gt;, pub status_change: AccStatusChange }  storage_fees_collected denotes the amount of tokens deducted from the account balance to cover the storage fee.storage_fees_due denotes the debt value, if there is any. Otherwise, this value equals None.status_change denotes the possible account status change. It may have been the case that the status were frozen or deleted due to having a significant debt value. Possible values are: pub enum AccStatusChange { Unchanged, Frozen, Deleted, }  Credit Phase Descriptor​ The Credit Phase descriptor is defined as follows: pub struct TrCreditPhase { pub due_fees_collected: Option&lt;Grams&gt;, pub credit: CurrencyCollection, }  Field\tDescriptiondue_fees_collected\tAmount of coins deducted from the message balance to cover the debt of the account, if any existed at the beginning of the credit phase. If there were no debt, the value is None . credit\tMessage value after the fees were conducted from it. Compute Phase Descriptor​ Compute Phase descriptor is defined with the following enumeration: pub enum TrComputePhase { Skipped(TrComputePhaseSkipped), Vm(TrComputePhaseVm) }  Choice 1. Skipped​ If the Compute phase was not successfully performed, the descriptor value is Skippedin this case. It should have an argument with following type: pub struct TrComputePhaseSkipped { pub reason: ComputeSkipReason }  reason has to be one of the following: pub enum ComputeSkipReason { NoState, BadState, NoGas, }  Field\tDescriptionNoState\tCaused by the following conditions: 1) The account did not exist by the time of message arrival, and the incoming message did not contain the StateInit part; 2) The account was not initialized and the incoming message did not contain the StateInit part. NoState\tCaused by the following conditions: 1) The account did not exist by the time of message arrival, and the incoming message did not contain the StateInit part; 2) The account was not initialized and the incoming message did not contain the StateInit part. BadState\tCaused by the following conditions: 1) The account was in AccStateUninit state, the message did contain the StateInit part, but an attempt to initialize the account with the given StateInit failed due to being inconsistent with the account; 2) The account was in AccStateFrozen state, the message contained the StateInit part, but an attempt to unfreeze the account with the given state init failed due to being inconsistent with the account. NoGas\tCaused by the following conditions: 1) After Credit and Storage phases, the account balance had no coins: its balance equals zero; 2) Values gas_limit and gas_credit, calculated with the init_gas algorithm, both equals 0. Choice 2. Successful computation​ Successful Compute phase result is defined by the following TrComputePhaseVm structure: pub struct TrComputePhaseVm { pub success: bool, pub msg_state_used: bool, pub account_activated: bool, pub gas_fees: Grams, pub gas_used: VarUInteger7, pub gas_limit: VarUInteger7, pub gas_credit: Option&lt;VarUInteger3&gt;, pub mode: i8, pub exit_code: i32, pub exit_arg: Option&lt;i32&gt;, pub vm_steps: u32, pub vm_init_state_hash: UInt256, pub vm_final_state_hash: UInt256 }  Field\tDescriptionsuccess\tCompute phase completion status. See compute_phase_success gas_fees\tFees for the gas used by a smart-contract execution, see here gas_used\tAn exact amount of gas used by the VM during the execution gas_limit\tA strict upper bound on the amount of gas allowed for this account init_gas gas_credit\tAn amount of gas credited to be used for external messages before being accepted init_gas vm_steps\tNumber of steps performed by the VM exit_code\tComputation exit code, see compute_phase_exitcode exit_arg\tComputation exit argument, see compute_phase_exitcode mode\tAlways equals 0 vm_init_state_hash\tNot used vm_final_state_hash\tNot used msg_stated_used\tNot used account_activated\tNot used Action Phase Descriptor​ Action Phase descriptor is defined as follows: pub struct TrActionPhase { pub success: bool, pub valid: bool, pub no_funds: bool, pub status_change: AccStatusChange, pub total_fwd_fees: Option&lt;Grams&gt;, pub total_action_fees: Option&lt;Grams&gt;, pub result_code: i32, pub result_arg: Option&lt;i32&gt;, pub tot_actions: i16, pub spec_actions: i16, pub skipped_actions: i16, pub msgs_created: i16, pub action_list_hash: UInt256, pub tot_msg_size: StorageUsedShort, }  Field\tDescriptionsuccess\tAction phase completed successfully. The success condition is described here. valid\tAction phase is valid. The validity condition is described here. result_code\tAction phase failed with the result code, see action_result_codes. In case of success, the value equals to 0 result_arg\tIn case of an error, the item number of an action in the action list that caused the error no_funds\tTrue if the error was caused by a balance insufficiency status_change\tEquals AccStatusChange::Deleted in case of the account being deleted after processing actions total_fwd_fees\tTotal fees for the SendMsg actions processing total_action_fees\tTotal fees for the whole action list processing tot_actions\tTotal number of actions in the action list at a beginning of the Action phase spec_actions\tNumber of special actions, i.e. Reserve, SetCode, SetLib msg_created\tNumber of successful SendMsg actions action_list_hash\tHash of action list calculated at a beginning of the Action phase tot_msg_size\tTotal size of all the generated messages skipped_actions\tNot used Action Result Codes​ Result Code\tDescriptionRESULT_CODE_ACTIONLIST_INVALID\tMessage serialization error RESULT_CODE_TOO_MANY_ACTIONS\tContract generated more actions than allowed. Maximum actions count is 255 RESULT_CODE_UNKNOWN_OR_INVALID_ACTION\tBinary serialization error, or invalid flags. See remarks. RESULT_CODE_INCORRECT_SRC_ADDRESS\tWide source address address, or the source address does not equal to the account address RESULT_CODE_INCORRECT_DST_ADDRESS\tIncorrect destination address, or destination workchain is not allowed to receive messages, or destination workchain does not exist RESULT_CODE_ANYCAST\tDestination address of type Anycast. It is no longer supported and considered an error. RESULT_CODE_NOT_ENOUGH_GRAMS\tInsufficient balance. See remarks. RESULT_CODE_NOT_ENOUGH_EXTRA\tExtra-tokens balance is insufficient to execute to action RESULT_CODE_INVALID_BALANCE\tReserve action lead to an error, or outgoing message is too big to process RESULT_CODE_BAD_ACCOUNT_STATE\tActions SetCode or ChangeLib lead to an error RESULT_CODE_UNSUPPORTED\tSendMsg action has incorrect flags set Remarks:​ RESULT_CODE_UNKNOWN_OR_INVALID_ACTION reasons are: Actions serialization errorSendMsg action has invalid flags, that is: The mutually exclusive flags are set: SENDMSG_REMAINING_MSG_BALANCE and SENDMSG_ALL_BALANCEMessage was sent with an unknown flag sendmsg_flags;The flag SENDMSG_DELETE_IF_EMPTY is set, but the flag SENDMSG_ALL_BALANCE isn't; Reserve action has invalid flags Unknown flag is setFlag RESERVE_PLUS_ORIG is set, but RESERVE_REVERSE isn't RESULT_CODE_NOT_ENOUGH_GRAMS reasons are: For SendMsg action, the flag SENDMSG_REMAINING_MSG_BALANCE is set, but SENDMSG_PAY_FEE_SEPARATELY isn'tMessage balance is insufficient to cover message delivery feesAccount balance is insufficient to cover all message delivery fees Bounce Phase Transaction Descriptor​ Bounce Phase descriptor is defined with the following enumeration: pub enum TrBouncePhase { Negfunds, Nofunds(TrBouncePhaseNofunds), Ok(TrBouncePhaseOk), }  Negfunds choice is not used.Nofunds(TrBouncePhaseNofunds) denotes the insufficiency of account balance, details are put into the parameter valueOk(TrBouncePhaseOk) denotes success, i.e. that the bounce message has been formed and put into the Msg queue. Details of the phase are put into the parameter value. Choice 1. Nofunds​ pub struct TrBouncePhaseNofunds { pub msg_size: StorageUsedShort, pub req_fwd_fees: Grams, }  msg_size denotes the size of generated bounce message. This value is not used.req_fwd_fees denotes the fee for the message delivery. Choice 2. Ok(TrBouncePhaseOk)​ pub struct TrBouncePhaseOk { pub msg_size: StorageUsedShort, pub msg_fees: Grams, pub fwd_fees: Grams, }  msg_size not used.fwd_fees is a full forwarding fee for the bounce message.msg_fees is a part of fwd_fees that goes to the validator processing the message. "},{"title":"Actions​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#actions","content":"After successfully executing a smart-contract code, the TVM virtual machine provides the executor with updated contract state and a list of actions to be further processed. In our context, an action refers to an order for the Transaction Executor to perform a distinguished stateful act. It could be sending a message, changing the smart-contract's code or reserving coins on the balance. "},{"title":"Type of Actions​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#type-of-actions","content":"Here we provide a set of possible actions, with the description. We go deep on each of them further. pub enum OutAction { None, // default value SendMsg { mode: u8, out_msg: Message, }, SetCode { new_code: Cell, }, ReserveCurrency { mode: u8, value: CurrencyCollection, }, ChangeLibrary { mode: u8, code: Option&lt;Cell&gt;, hash: Option&lt;UInt256&gt;, } }  Action\tDescriptionSendMsg\tSend the message out_msg to some account using the provided mode ReserveCurrency\tManage the account's balance to guarantee its sufficiency SetCode\tChange the contract byte-code with the given new_code ChangeLibrary\tUpdate code library "},{"title":"Action SendMsg​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#action-sendmsg","content":"SendMsg(mode,outmsg)SendMsg(mode,out_msg)SendMsg(mode,outm​sg) action sends a message to an account. The message out_msgout\\_msgout_msg contains the destination address as well as the payload to be delivered. This action has a lot of modes that can be combined using logicalOR operator. Some mode combinations are prohibited. See rc_remarks. Mode\tValue\tDescriptionSENDMSG_ORDINARY\t0\tSend the message. Without other modes, the forwarding fee for the delivery is paid by the receiver. SENDMSG_PAY_FEE_SEPARATELY\t1\tSend the message. The forwarding fee is paid by the sender. SENDMSG_IGNORE_ERROR\t2\tIf an error occurs during the processing of this action, ignore it. SENDMSG_DELETE_IF_EMPTY\t32\tThe account gets deleted if, after the action processed, the balance becomes zero SENDMSG_REMAINING_MSG_BALANCE\t64\tThe message should carry all the remaining value of the inbound message additionally to the value specified in the field SENDMSG_ALL_BALANCE\t128\tThe message should carry all the remaining balance of the account, instead of the value specified in the value field "},{"title":"Action ReserveCurrency​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#action-reservecurrency","content":"ReserveCurrency(mode,val)ReserveCurrency(mode, val)ReserveCurrency(mode,val) action makes a coin reserve on the balance. This action has several modes of operation. Modes can be combined. Mode\tValue\tDescriptionRESERVE_EXACTLY\t0\tReserve exactly valvalval coins RESERVE_ALL_BUT\t1\tReserve acc_balance−valacc\\_balance - valacc_balance−val coins, where acc_balanceacc\\_balanceacc_balance is a remaining balance of the account RESERVE_IGNORE_ERROR\t2\tSkip the action on failure RESERVE_PLUS_ORIG\t4\tReserve acc_balance+valacc\\_balance + valacc_balance+val coins. It should be used only with RESERVE_REVERSE. RESERVE_REVERSE\t8\tReverse value of valvalval in the calculation of the reserve, i.e. substitute valvalval with −val-val−val "},{"title":"Action SetCode​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#action-setcode","content":"Currently, we skip this action. "},{"title":"Message Processing Algorithm​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#message-processing-algorithm","content":"In this section, we present a pseudo-code for incoming message processing algorithm. The algorithm is divided in two mutually exclusive parts: ExecuteInternalMessage — internal message execution internal_message_processingExecuteExternalMessage — external message execution external_message_processing Both algorithms rely on executing some or all of the phases: Credit phase credit_phaseStorage phase storage_phaseCompute phase compute_phaseAction phase action_phaseBounce phase bounce_phase Please note that we consider only ordinary accounts here. The algorithm for executing messages on special accounts is not considered. Input: in_msg — incoming message, has type Messageaccount — account, has type Accountparams — executor parameters, has type Parametersconfig — blockchain configuration, has type BlockchainConfig Output: On success, returns Ok(acc1, trans), such that: acc1 — updated account, has type Accounttrans — transaction, has type Transaction On error, returns error of the type ExecutorError Modifies: def ExecuteMessage(in_msg, account, params, config): if in_msg.header is ExtOutMsgInfo: return ExecutorError.InvalidExtMessage if in_msg.header.dst == None: return ExecutorError.TrExecutorError() if in_msg.header is ExtInMessageHeader and account.balance == 0: return ExecutorError.NoFundsToImportMsg() acc = account.clone() if in_msg.header is ExtInMsgInfo: return ExecuteExternalMessage(in_msg, acc, params, config) elif in_msg.header is IntMsgInfo: return ExecuteInternalMessage(in_msg, acc, params, config) return ExecutorError.TrExecutorError()  "},{"title":"Internal Message Processing Algorithm​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#internal-message-processing-algorithm","content":"At this point, the message is known to be internal. Execute it with the given account. Input: in_msg — incoming message, has type Messageaccount — account, has type Accountparams — executor parameters, has type Parametersconfig — blockchain configuration, has type BlockchainConfig Output: On success, returns Ok(acc1, trans), such that: acc1 — updated account, has type Accounttrans — transaction, has type Transaction On error, returns error of the type TransactionExecutor.TrExecutorError Modifies: account def ExecuteInternalMessage(in_msg, account, params, config): acc_balance = account.balance msg_balance = in_msg.hdr.value credit_first = not in_msg.hdr.bounce lt = max(account.last_tr_time, max(params.last_tr_lt, in_msg.lt + 1)) tr = Transaction(account.account_id, account.status, lt, now(), in_msg) descr = TransactionDescrOrdinary(credit_first: credit_first) # If the bounce flag is not set, execute the Credit Phase # before Storage phase if credit_first: credit_ph_res = credit_phase(account, tr, msg_balance, acc_balance) if credit_ph_res is Ok: descr.credit_ph = credit_ph_res.credit_ph else: return ExecutorError.TrExecutorError() # Execute Storage Phase storage_ph_res = storage_phase(account, acc_balance, tr, is_masterchain, config) descr.storage_ph = storage_ph_res.storage_ph # Why this is needed? if credit_first and (msg_balance &gt; acc_balance): msg_balance = acc_balance original_acc_balance = account.balance - tr.total_fees if not credit_first: credit_ph_res = credit_phase(account, tr, msg_balance, acc_balance) if credit_ph_res is Ok: descr.credit_ph = credit_ph_res.credit_ph else: return ExecutorError.TrExecutorError() # Both storage and credit phases are completed at this point. # We need to update the last_paid field not to loose this # information in case of some further errors showing up. account.last_paid = params.block_unixtime # Parameters to be passed into TVM smci = build_contract_info(acc_balance, account.address, params.block_lt, lt, params.seed_block) # First element is the bottom of the stack stack = Stack([acc_balance, msg_balance, Cell(in_msg), in_msg.body, False]) # Execute Compute Phase compute_ph_res = compute_phase(in_msg, account, acc_balance, msg_balance, params.state_libs, smci, stack, is_masterchain) if not (compute_ph_res is Ok): return ExecutorError.TrExecutorError() descr.compute_ph = compute_ph_res.compute_ph actions = compute_ph_res.actions new_data = compute_ph_res.new_data # Generated outbound messages to be sent into other accounts out_msgs = [] compute_gas_fees = descr.compute_ph.gas_fees tr.total_fee = tr.total_fee + compute_gas_fees if descr.compute_ph.success: act_phase_res = action_phase(tr, account, original_acc_balance, acc_balance, msg_balance, phase.gas_fees, actions, new_data) if act_phase_res is Ok: descr.action = act_phase_res.action_ph out_msgs = act_phase_res.msgs else: return ExecutorError.TrExecutorError() if descr.action != None: if descr.action.status_change == AccStatusChange.Deleted: account = Account() descr.destroyed = True descr.aborted = not descr.action.success else: descr.aborted = True # If the Action Phase failed, and the incoming message allows # bounce answer, execute the Bounce Phase if (descr.aborted == True) and (in_msg.hdr.bounce = True): if descr.compute_ph is Vm: bounce_ph_res = \\ bounce_phase(msg_balance, acc_balance, compute_gas_fees, tr, my_addr) if bounce_ph_res is Ok: descr.bounce = bounce_ph_res.bounce_ph if (bounce_ph_res.bounce_msg != None): out_msgs = out_msgs + [bounce_ph_res.bounce_msg] else: return ExecutorError.TrExecutorError() if descr.bounce is Ok: acc_balance = original_acc_balance if account.status == AccountStatus.AccStateUninit and \\ acc_balance == 0: account = Account() else: if account.is_none() and acc_balance != 0: account = Account.uninit(is_msg.hdr.dst, 0, last_paid, acc_balance) if account.status() == AccountStatus.AccStateUninit and acc_balance == 0: account = Account() tr.acc_end_status = account.status account.balance = acc_balance params.last_tr_lt = lt upd_lt = add_messages(tr, out_msgs, params.last_tr_lt) account.last_tr_time = upd_lt tr.descr = descr return Ok(tr, account)  The function add_messages assigns the proper logical timestamp for each message from the out_msgs collection, and then include the message into the transaction. def add_messages(tr, out_msgs, lt): lt_next = lt + len(out_msgs) + 1 lt_next += 1 for msg in out_msgs: msg.at = now() msg.lt = lt tr.add_out_message(msg) lt_next += 1 return Ok(lt_next)  "},{"title":"External Message Processing Algorithm​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#external-message-processing-algorithm","content":"The execution of external message on the given account. Input: in_msg — incoming message, has type Messageaccount — account, has type Accountparams — executor parameters, has type Parametersconfig — blockchain configuration, has type BlockchainConfig Output: On success, returns Ok(acc1, trans), such that: acc1 — updated account, has type Accounttrans — transaction, has type Transaction On error, returns error of the type TransactionExecutor.TrExecutorError Modifies: account def ExecuteExternalMessage(in_msg, account, params, config): acc_balance = account.balance msg_balance = in_msg.hdr.value is_masterchain = (in_msg.dst_workchain_id == -1) lt = max(account.last_tr_time, max(params.last_tr_lt, in_msg.lt + 1)) tr = Transaction(account.account_id, account.status, lt, now(), Cell(in_msg)) descr = TransactionDescrOrdinary(credit_first: True) in_fwd_fee = fwd_fee(Cell(in_msg)) if acc_balance &lt; in_fwd_fee: return ExecutorError.NoFundsToImportMsg tr.total_fee = tr.total_fee + in_fwd_fee # Execute Storage Phase storage_ph_res = storage_phase(account, acc_balance, tr, is_masterchain, config) descr.storage_ph = storage_ph_res.storage_ph if account.balance &gt;= tr.total_fees: original_acc_balance = account.balance - tr.total_fees else: original_acc_balance = account_balance # Credit Phase is skipped for external messages # Storage phase is completed at this point # We need to update the last_paid field not to loose this # information in case of some further errors showing up account.last_paid = params.block_unixtime # Parameters to be passed into TVM smci = build_contract_info(acc_balance, account.address, params.block_lt, lt, params.seed_block) # First element is the bottom of the stack stack = Stack([acc_balance, msg_balance, Cell(in_msg), in_msg.body, False]) # Execute Compute Phase compute_ph_res = compute_phase(in_msg, account, acc_balance, msg_balance, params.state_libs, smci, stack, is_masterchain) if compute_ph_res is Ok: descr.compute_ph = compute_ph_res.compute_ph else: return ExecutorError.TrExecutorError() # Generated outbound messages to be sent into other # accounts out_msgs = [] compute_gas_fees = descr.compute_ph.gas_fees tr.total_fee = tr.total_fee + compute_gas_fees if descr.compute_ph.success: act_phase_res = action_phase(tr, account, original_acc_balance, acc_balance, msg_balance, phase.gas_fees, accounts, compute_ph_res.new_data) if act_phase_res is Ok: descr.action = act_phase_res.action_ph out_msgs = act_phase_res.msgs else: return ExecutorError.TrExecutorError() if descr.action != None: if descr.action.status_change == AccStatusChange.Deleted: account = Account() descr.destroyed = True descr.aborted = not descr.action.success else: descr.aborted = True # The Bounce Phase is skipped for external messages if account.status() == AccountStatus.AccStateUninit and acc_balance == 0: account = Account() tr.acc_end_status = account.status account.balance = acc_balance params.last_tr_lt = lt upd_lt = add_messages(tr, out_msgs, params.last_tr_lt) account.last_tr_time = upd_lt tr.descr = descr return Ok(tr, account)  "},{"title":"Credit Phase​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#credit-phase","content":"At this phase, coins from the message balance goes to the account balance. This phase is executed only for internal messages. External messages have no coins attached. Input: account — account that the message is executed on, Accounttr — forming transaction, has type Transactionmsg_balance — message balance, has type Gramsacc_balance — current balance of the account, has type Grams Output: The phase always succeeds. It returns the value of type: /Ok(TrCreditPhase(collected, msg_balance))/, such that: collected — the amount of coins withheld for the account debt, if any.msg_balance — the amount of coins put on the account balance after the debt fee was conducted. Modifies: account — updates the due_payment field with the remaining debt, if anytr — updates the total_fees fieldmsg_balance — the original message balance after the debt conducted, if anyacc_balance — the account balance with message coins def credit_phase(account, tr, msg_balance, acc_balance): due_payment = account.due_payment collected = min(due_payment, msg_balance) msg_balance = msg_balance - collected due_payment_remaining = due_payment - collected account.due_payment = due_payment_remaining tr.total_fees = tr.total_fees + collected # put message coins on the account balance acc_balance = acc_balance + msg_balance return Ok(TrCreditPhase(collected, msg_balance))  "},{"title":"Storage Phase​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#storage-phase","content":"This phase withholds the storage fee from the account balance. The fee amount is calculated using the algorithm calc_storage_fee calc_storage_fee Input: account — account that the message is executed on, has type Accounttr — forming transaction, has type Transactionmsg_balance — message balance, has type Gramsacc_balance — current balance of the account, has type Gramsconfig — main blockchain parameters, has type BlockchainConfig Output: This phase always succeeds. The return values may differ Ok(TrStoragePhase(collected, fee, status_change)), such that: collected — the amount of coins withheld for the storage feedebt — if the balance was insufficient, the remaining debt of the accountstatus_change — should the account be frozen or deleted afterwards Modifies: account — updates due_payment and status fieldsacc_balance — the current balance after the fee got deductedtr — updates the total_fee field def storage_phase(account, tr, msg_balance, acc_balance, config): # It is assumed that the current transaction must have a more # recent timestamp than the latest payment timestamp. # Otherwise, something is terribly wrong. assert (tr.now &gt;= acc.last_paid) # The account does not occupy any space, so do not charge the fee if account == None: return Ok(TrStoragePhase()) fee, account.storage_info = config.calc_storage_fee(account.storage_info, is_masterchain, tr.now) if account.due_payment &gt; 0: fee = fee + account.due_payment account.due_payment = None if acc_balance &gt;= fee: acc_balance = acc_balance - fee tr.total_fee = tr.total_fee + fee return Ok(TrStoragePhase(fee, None, AccStatusChange.Unchanged)) storage_fees_collected = acc_balance acc_balance = 0 tr.total_fee = tr.total_fee + storage_fees_collected fee = fee - storage_fees_collected need_freeze = fee &gt; config.get_gas_config(is_masterchanin).freeze_due_limit need_delete = \\ (account.status == AccountStatus.AccStateUninit or \\ account.status == AccountStatus.AccStateFrozen) and \\ fee &gt; config.get_gas_config(is_masterchain).delete_due_limit if need_delete: tr.total_fee = 0 account = Account() return Ok(TrStoragePhase(storage_fees_collected, fee, AccStatusChange.Deleted)) elif need_freeze: account.due_payment = fee if account.status == AccountStatus.AccStateActive: account.status = AccountStatus.AccStateFrozen return Ok(TrStoragePhase(storage_fees_collected, fee, AccStatusChange.Frozen)) else: return Ok(TrStoragePhase(storage_fees_collected, fee, AccStatusChange.Unchanged)) else: account.due_payment = fee return Ok(TrStoragePhase(storage_fees_collected, fee, AccStatusChange.Unchanged))  "},{"title":"Compute Phase​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#compute-phase","content":"Execute the account smart-contract, update the state, gather generated actions to pass on the next phase. Input: msg — message, has type Messageaccount — account, has type Accountacc_balance — current account balance, has type Gramsmsg_balance — message balance,has type Gramsstate_libs — code libraries, has type Blob (not relevant; omitted)smc_info — extra data for TVM, has type SmartContractInfostack — TVM initial stack valuesis_masterchain — is the account belongs to Masterchain, has type bool Output: On success, returns Ok(TrComputePhase, out_actions, new_data), such that: TrComputePhase — actual Compute Phase Descriptorout_actions — an ordered list of generated actionsnew_data — updated smart-contract state On error, returns Err(ExecutorError) with proper code. Modifies: account — updated account statesmc_info — mycode field set to point to the code of the smart-contractacc_balance — account balance after the gas fee deduction def uninit_account(account): if account.storage.state is AccountState.AccountActive: account.storage.state = AccountState.AccountUninit def compute_phase(msg, account, acc_balance, msg_balance, state_libs, smc_info, stack, is_masterchain): result_acc = account.clone() vm_phase = TrComputePhaseVm() is_external = msg.header is ExtInMsgInfo if result_acc == None: new_acc = account_from_message(msg, msg_balance) if new_acc != None: result_acc = new_acc result_acc.last_paid = smc_info.unix_time account = result_acc account.uninit_account() if acc_balance == 0: return Ok(TrComputePhase:skipped(ComputeSkipReason.NoGas), None, None) gas_config = config.get_gas_config(is_masterchain) gas = init_gas(acc_balance, msg_balance, is_external, gas_config) # Is it possible? if gas.gas_limit == 0 and gas.gas_credit == 0: return Ok(TrComputePhase.skipped(ComputeSkipReason.NoGas), None, None) libs = [] if msg.state_init != None: libs = state_init.libraries (reason, result_acc) = result_acc.compute_new_state(acc_balance, msg) if reason != None: return Ok(TrComputePhase.skipped(reason), None, None) vm_phase.gas_credit = gas.gas_credit vm_phase.gas_limit = gas.gas_limit if result_acc.code == None: if is_external: return ExecutorError.NoAcceptError() vm_phase.success = False vm_phase.gas_fees = gas_config.calc_gas_fee(0) if acc_balance &lt; vm_phase.gas_fees: return ExecutorError.TrExecutorError() acc_balance -= vm_phase.gas_fees account = result_acc return Ok(TrComputePhase.Vm(vm_phase), None, None) code = result_acc.code data = result_acc.data libs.push(result_acc.libraries) # local libraries libs.push(state_libs) # masterchain libraries smc_info.mycode = code # Here, we initialize abstract TVM virtual machine. # The exact behavior of this device is out of scope. vm = TVM(code) vm.smc_info = smc_info vm.config = config vm.stack = stack vm.data = data vm.libraries = libs vm.gas = gas result = vm.execute() vm_phase.success = vm.commited_state.is_committed # vm.gas may have been updated after the execution gas_vm = vm.gas # how much credited gas remains unspent credit = gas_vm.gas_credit used = gas_vm.gas_used vm_phase.gas_used = used if credit != 0: if is_external: # The smart-contract has to explicitly accept the external message, # otherwise it gets rejected. The acceptance of a message manifests # itself in the credit field being equal to 0. return ExecutorError.NoAcceptError() vm_phase.gas_fees = 0 else: gas_fees = gas_config.calc_gas_fee(used) vm_phase.gas_fees = gas_fees vm_phase.mode = 0 vm_phase.vm_steps = vm.steps new_data = vm.commited_state if new_data == None: vm_phase.success = False out_actions = vm.actions if out_actions = None: vm_phase.success = False account = result_acc return Ok(TrComputePhase.Vm(vm_phase), out_actions, new_data)  "},{"title":"Compute Phase Success Conditions​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#compute-phase-success-conditions","content":"We would like to explicitly articulate what it means for theCompute Phase to succeed. To do that,we specify the opposite condition, i.e. when it fails. In all other scenarios the phase is considered successful. The success status is important, because it decides if the action phase has to be executed afterwards. For the phase to fail, one of the following conditions must hold: The smart-contract data is not committed after the execution1The new smart-contract data is ill-formedThe generated actions list is ill-formed caution The compute phase may be considered successful even if the computation thrown an exception. This is quite unintuitive, yet very important fact. "},{"title":"Compute Phase Exit Code​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#compute-phase-exit-code","content":"The exit code value shows if the computation finished normally or was aborted due to some exception. In case of the former, the exit code should have values 0 or 1. In case of the latter, the exception might be of a system or custom type. If the exception is a system one, i.e. not intentionally emitted by the code using a special TVM instruction, the exit code contains one of the standard exit codes. If the exception is custom, then the exit code should also equal to 0 or 1, but there is an extra exit_arg field that provides the user defined code. For standard TVM exception codes, see here. "},{"title":"Calculate Gas Fee Algorithm​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#calculate-gas-fee-algorithm","content":"The algorithm to calculate the amount of coins to be paid for the consumed gas. Input: gas_prices — a structure with actual gas prices, has type GasLimitsPricegas_used — amount of gas units consumed by the computation, has type Uint Output: The amount of coins to be paid for the gas. Modifies: None. def calc_gas_fee(gas_prices, gas_used): if gas_used &lt;= gas_prices.flat_gas_limit: return gas_prices.flat_gas_limit gas_fee = flat_gas_price + (gas_used - gas_prices.flag_gas_limit) * \\ gas_prices.gas_price return gas_fee  "},{"title":"Compute New State Algorithm​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#compute-new-state-algorithm","content":"The algorithm compute_new_state computes the actual account state by given account record, the balance and the message. In particular, this algorithm is used to initialize uninitialized accounts with code and data borrowed from an external message with non-emptystate_init field. Input: account — account structure, has type Accountacc_balace — current account balance, has type Uintin_msg — message being executed, has type Message Output: On success, returns None.On failure, returns one of the ComputeSkipReason codes. Modifies: account def compute_new_state(account, acc_balance, in_msg): if account.status == AccountStatus.AccStateNonexist: if in_msg.state_init == None: return ComputeSkipReason.NoState else: return ComputeSkipReason.BadState elif account.status == AccountStatus.AccStateActive: return None elif account.status == AccountStatus.AccStateUninit: if in_msg.state_init != None: if account.try_activate_by_init_code_hash(in_msg.state_init) != None: return None else: return ComputeSkipReason.BadState else: return ComputeSkipReason.NoState elif account.status == AccountStatus.AccStateFrozen: if acc_balance != 0 and in_msg.state_init != None: if account.try_activate_by_init_code_hash(in_msg.state_init) != None: return None else: return ComputeSkipReason.BadState return ComputeSkipReason.NoState return None  "},{"title":"Activate By Init Algorithm​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#activate-by-init-algorithm","content":"The algorithm try_activate_by_init_code_hash does the initialization or re-initialization of the account, with the given state_init. Input: account — account structure to be initializedstate_init — state_init field from the inbound message Output: On success, returns OkOn failure, returns Err Modifies: account — the field storage.state gets updated by the state_init on success def try_activate_by_init_code_hash(account, state_init): if account == None: return Err new_state = None if account.storage.state == AccountState.AccountUninit: if hash(state_init) == account.addr.address: new_state = AccountState.AccountActive( hash(state_init.code), state_init ) else: return Err elif account.storage.state == \\ AccountState.AccountFrozen(init_code_hash, state_init_hash): if state_init_hash == hash(state_init): new_state = AccountState.AccountActive(init_code_hash, state_init) else: return Err else: new_state = account.storage.state account.storage.state = new_state return Ok  "},{"title":"Initial Gas Algorithm​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#initial-gas-algorithm","content":"The algorithm computes TVM Gas-related initial values. Those values are provided to the virtual machine right before a smart-contract execution. If the execution takes more than allowed gas, it gets stopped. Input acc_balance: current account balancemsg_balance: message balanceis_external: is the message externalgas_info: structure with limits and prices for the workchain Output Returns the structure Gas() containing 4 values: gas_limit: the maximum gas value available for any smart-contract of the workchaingas_credit: the amount of gas to be credited for the execution before the smart-contract accepts the messagegas_max: the maximum allowed gas to be spent on the execution of the current smart-contractgas_prices: a structure with gas prices Modifies: None def init_gas(acc_balance, msg_balance, is_external, gas_info): gas_max = min(gas_info.gas_limit, gas_info.calc_gas(acc_balance)) gas_credit = 0 if is_external: gas_credit = min(gas_info.gas_credit, gas_max) gas_limit = gas_credit else: gas_limit = min(gas_max, gas_info.calc_gas(msg_balance)) return Gas(gas_limit, gas_credit, gas_max, gas_info.get_real_gas_price())  "},{"title":"Account From Message Algorithm​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#account-from-message-algorithm","content":"The algorithm creates new account by using data from the internal message. External messages are rejected. Creation of a new account based on an external message is located elsewhere. Seecompute_new_state algorithm. Input msg: incoming message being processed, has type Messagemsg_remaining_balance: the current amount of coins left on the message balance, has type Uint Output Either returns a new Account object, or None. Both results are considered successful. Modifies: None def account_from_message(msg, msg_remaining_balance): if not (msg.header is IntMsgInfo): return None if msg_remaining_balance == 0: return None header = msg.header init = msg.state_init if init != None and init.code != None and hash(init) == header.dst.address: return Account.active_by_init_code_hash(hdr.dst, msg_remaining_balance, 0, init) if header.bounce: return None else: return Account.uninit(hdr.dst, 0, 0, msg_remaining_balance)  "},{"title":"Action Phase​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#action-phase","content":"By given ordered action list, the Action phase executes each action item in the list by applying proper action handler. Input: tr — transaction being constructed, has type Transactionaccount — account executing the message, has type Accountoriginal_acc_balance — account balance after storage and credit phase, has type Uintacc_balance — the mutable copy of the original_acc_balance, has type Uintmsg_remaining_balance — message balance without debt value if any, has type Uintcompute_phase_fees — gas fees from the compute phase, has type Uintactions — list of actions generated on the Compute Phase, has type list(OutAction)new_data — the smart-contract data after the Compute Phase, some binary blob. Output: On success, returns Ok(phase, messages) such that: phase denotes the Action Phase Descriptormessages denotes a list of messages to be sent, has type list(Message) On error, returns Err(result_code), such that: result_code describes a type of an error, see here. Modifies: traccountacc_balancemsg_remaining_balance MAX_ACTIONS = 255 def action_phase(tr, account, original_acc_balance, acc_balance, msg_remaining_balance, compute_phase_fees, actions, new_data): acc_copy = account.clone() acc_remaining_balance = acc_balance phase = TrActionPhase() total_reserved_value = 0 # Serialization issues are put aside, it is too low-level for # our purpose. # Interesting to note, actions overload leads to OK, not Error? if len(actions) &gt; MAX_ACTIONS: phase.result_code = RESULT_CODE_TOO_MANY_ACTIONS return Ok(phase, []) phase.action_list_hash = hash(actions) phase.tot_actions = len(actions) account_deleted = False out_msgs_tmp = [] address = acc_copy.address for action in actions: if action is OutAction.SendMsg: if action.mode &amp; SENDMSG_ALL_BALANCE: out_msgs_tmp.push((action.mode, action.out_msg)) continue result = outmsg_action_handler(phase, action.mode, action.out_msg, acc_remaining_balance, msg_remaining_balance, compute_phase_fees, config, address, total_reserved_value, account_deleted) if result is Ok: phase.msgs_created += 1 out_msgs_tmp.push((action.mode, action.out_msg)) else: return result elif action is OutAction.ReserveCurrency: result = reserve_action_handler(action.mode, action.value, original_acc_balance, acc_remaining_balance) if result is Ok: phase.spec_actions += 1 total_reserved_value += result.reserved_value else: phase.valid = True phase.result_code = result # phase.no_funds = True return Ok(phase, []) else: return Ok(phase, []) # process messages that have SENDMSG_ALL_BALANCE flag set last # skipping all other already processed messages out_msgs = [] for (mode, out_msg) in out_msgs_tmp: if not (mode &amp; SENDMSG_ALL_BALANCE): out_msgs.push(out_msg) continue result = outmsg_action_handler(phase, mode, out_msg, acc_remaining_balance, msg_remaining_balance, compute_phase_fees, config, address, total_reserved_value, account_deleted) if result == Ok: phase.msgs_created += 1 out_msgs.push(out_msg) else: return Ok(phase, []) acc_remaining_balance += total_reserved_value tr.total_fee += phase.total_action_fees if account_deleted: phase.status_change = AccStatusChange.Deleted phase.valid = True phase.success = True acc_balance = acc_remaining_balance account = acc_copy account.data = new_data return Ok(phase, out_msgs)  "},{"title":"Action Phase Success Condition​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#action-phase-success-condition","content":"All actions formed at the Compute Phase were successfully processed. If an action had a special error-canceling flag set, such error will not result in the whole phase failure. The action will be skipped in this case. "},{"title":"Action Phase Validity Condition​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#action-phase-validity-condition","content":"To specify the validity condition, we will define the opposite, i.e. when the action phase is considered invalid. The number of actions in the action list is greater than MAX_ACTIONSAny SendMsg action processing finished with an errorThe unknown action type was found during the processing In all other cases, the action phase is considered valid. "},{"title":"SendMsg Action Handler​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#sendmsg-action-handler","content":"The SendMsg action handler is responsible for generating messages to be sent. It may fail due to several reasons. In this case, the action phase get stopped, unless the SENDMSG_IGNORE_ERROR flag is set. Input: phase — actual Action Phase Descriptormode — flags for sending the messagemsg — message being sent, has type Messageacc_balance — actual account balance, has type UIntmsg_balance — the message balance after debt being deducted, has type Uintcompute_phase_fees — gas fees from Compute Phaseconfig — blockchain configuration, has type BlockchainConfigmy_addr — account addressreserved_value — the value of coins reserved by the ReserveCoins actionsaccount_deleted — the output value, set to True if account needs to be deleted Output: On success, returns Ok(value), such that: value — the amount of coins to be deducted from the account balance On failure, returns Err(result_code), such that: result_code — describes the error, see here Modifies: phasemodemsgacc_balancemsg_balanceaccount_deleted MAX_MSG_BITS = 2**21 # 2 Mb MAX_MSG_CELLS = 2**13 def get_fwd_prices(config, is_masterchain): if is_masterchain: return config.fwd_prices_mc else: return config.fwd_prices_wc def outmsg_action_handler(phase, mode, msg, acc_balance, msg_balance, compute_phase_fees, config, my_addr, reserved_value, account_deleted): invalid_flags = SENDMSG_REMAINING_MSG_BALANCE or SENDMSG_ALL_BALANCE mode_not_valid = mode and (not SENDMSG_VALID_FLAGS) mode_has_invalid = mode and invalid_flags == invalid_flags mode_delete_not_sab = (mode and SENDMSG_DELETE_IF_EMPTY) and \\ (not (mode and SENDMSG_ALL_BALANCE)) if mode_not_valid or mode_has_invalid or mode_delete_not_sab: return Err(RESULT_CODE_UNSUPPORTED) skip = not (mode and SENDMSG_IGNORE_ERROR) msg.header.src = my_addr fwd_prices = config.get_fwd_prices(msg.is_masterchain()) compute_wd_fee = fwd_prices.fwd_fee(Cell(msg)) # The message should be either internal message or event. # It is impossible to send external message from the smart-contract. if not ((msg.header is IntMsgInfo) or (msg.header is ExtOutMsgInfo)): return Err(-1) if msg.header is IntMsgInfo: # ===================================== # Internal message # ===================================== msg.header.bounced = False result_value = msg.header.value msg.header.ihr_disabled = True msg.header.ihr_fee = 0 fwd_fee = max(msg.header.fwd_fee, compute_wd_fee) fwd_mine_fee = fwd_prices.mine_fee(fwd_fee) total_fwd_fees = fwd_fee + msg.header.ihr_fee fwd_remain_fee = fwd_fee - fwd_mine_fee if (mode and SENDMSG_ALL_BALANCE): result_value = acc_balance msg.header.value = acc_balance mode = (mode and (not SENDMSG_PAY_FEE_SEPARATELY)) if (mode and SENDMSG_REMAINING_MSG_BALANCE): # Send all the remaining balance of the inbound message result_value += msg_balance if not (mode and SENDMSG_PAY_FEE_SEPARATELY): if result_value &lt; compute_phase_fees: return Err() result_value -= compute_phase_fees msg.header.value = result_value if (mode and SENDMSG_PAY_FEE_SEPARATELY): result_value += total_fwd_fees else: if msg.header.value &lt; total_fwd_fees: return Err() else: msg.header.value -= total_fwd_fees msg.header.fwd_fee = fwd_remain_fee else: # ===================================== # Event # ===================================== fwd_mine_fee = compute_fwd_fee total_fwd_fees = compute_fwd_fee result_value = compute_fwd_fee if acc_balance &lt; result_value: return Err(RESULT_CODE_NOT_ENOUGH_GRAMS) if (mode and SENDMSG_DELETE_IF_EMPTY) and \\ (mode and SENDMSG_ALL_BALANCE) and \\ (acc_balance + reserved_value == 0): account_deleted = True if total_fwd_fees != 0: phase.total_fwd_fees += total_fed_fees if fwd_mine_fee != 0: phase.total_action_fees += fwd_mine_fee phase.tot_msg_size.append(Cell(msg)) if phase.tot_msg_size.bits() &gt; MAX_MSG_BITS or \\ phase.tot_msg_size.cells() &gt; MAX_MSG_CELLS: return Err(RESULT_CODE_INVALID_BALANCE) if mode and (SENDMSG_ALL_BALANCE or SENDMSG_REMAINING_MSG_BALANCE): msg_balance = 0 return Ok(result_value)  "},{"title":"ReserveCurrency Action Handler​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#reservecurrency-action-handler","content":"ReserveCurrency action handler is responsible for managing the reserve coins. Input: mode — Reserve flags for the reserve action, has type Uintval — amount of coins to be reserved, has type Uintorig_acc_balance — account balance after the deduction of the storage fee and the debt, if any, has type Uintacc_remaining_balance — amount of coins left on the balance after the reserve, has type Uint Output: On success, returnsOk(reserved) value, such that: reserved denotes the amount of coins being reserved for the account On failure, returns Err(result_code), such that: result_code Modifies: acc_remaining_balance — remaining account balance after the reserve amount being withheld def reserve_action_handler(mode, val, orig_acc_balance, acc_remaining_balance): if mode and (not RESERVE_VALID_MODES): return Err(RESULT_CODE_UNKNOWN_OR_INVALID_ACTION) reserved = 0 if mode and RESERVE_PLUS_ORIG: if mode and RESERVE_REVERSE: reserved = orig_acc_balance if reserved &lt; val: return Err(RESULT_CODE_UNSUPPORTED) reserved -= val else: reserved = val reserved += orig_acc_balance else: if mode and RESERVE_REVERSE: return Err(RESULT_CODE_UNKNOWN_OR_INVALID_ACTION) reserved = val if mode and RESERVE_IGNORE_ERROR: reserved = min(reserved, acc_remaining_balance) remaining = acc_remaining_balance if remaining &lt; reserved: return Err(RESULT_CODE_NOT_ENOUGH_GRAMS) remaining -= reserved remaining, acc_remaining_balance = acc_remaining_balance, remaining if mode and RESERVE_ALL_BUT: reserved, acc_remaining_balance = acc_remaining_balance, reserved return Ok(reserved)  "},{"title":"Bounce Phase​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#bounce-phase","content":"If error happens on the previous phases, the bounce phase takes place. Input: remaining_msg_balance — message balance after all previous phases executed, has type Uintacc_balance — remaining account balance after all previous phases executed, has type Uintcompute_phase_fees — the fees of the compute phase, has type Uintmsg — message being processed, has type Messagetr — transaction object, has type Transaction Output: On success, returns Ok(TrBouncePhase, bounce_message), such that: TrBouncePhase is a Bounce Phase Descriptorbounce_message is a bounce message to be included into the out_msgs queue On error, returns /ExecutorError.TrExecutorError/ Modifies: tr — adds the bounce message delivery fee to the total NOTE: Function get_fwd_prices() was defined here. def bounce_phase(remaining_msg_balance, acc_balance, compute_phase_fees, msg, tr): header = msg.header if not header.bounce: return ExecutorError.TrExecutorError() header2 = header.clone() header2.src, header2.dst = header.dst, header.src storage = StorageUsedShort() fwd_prices = config.get_fwd_prices(msg.is_masterchain) fwd_full_fees = fwd_prices.fwd_fee(Cell()) fwd_mine_fees = fwd_prices.mine_fee(fwd_full_fees) fwd_fees = fwd_full_fees - fwd_mine_fees if remaining_msg_balance &lt; fwd_full_fees + compute_phase_fees: return Ok(TrBouncePhase.no_funds, None) acc_balance -= remaining_msg_balance remaining_msg_balance -= fwd_full_fees remaining_msg_balance -= compute_phase_fees header2.ihr_disabled = True header2.bounce = False header2.bounced = True header2.ihr_fee = 0 header2.fwd_fee = fwd_fees header2.value = remaining_msg_balance bounce_msg = Message.with_header(header2) if config.has_capability(GlobalCapabilities.CapBounceMsgBody): body = msg.body.clone() body.shrink_data(0..256) # leave only 256 bits of the original body bounce_msg.body = body tr.total_fees += fwd_mine_fees return Ok(TrBouncePhase.ok(storage, fwd_mine_fees, fwd_fees), bounce_msg)  "},{"title":"Functional Properties​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#functional-properties","content":"In this section, we define the main risks of malfunction in the module, and define several higher-level properties that should hold for the module to mitigate those risks. "},{"title":"Risks​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#risks","content":"We define a risk as a hazard event causing a significant loss for the end user. We distinguish the following types of risks. Financial Risks​ The Transaction Executor is the only place in the Node that is responsible for changing the account balance. Hence, any errors in related operations lead to tokens loss for the user. We identify the following financial risks for the module: Incorrect storage, delivery or gas fees calculation logicIncorrect message value processing logicIncorrect SendMsg, ReserveCoins actions processing logic Behavioral Risks​ Everscale blockchain praises the distributed programming paradigm in application development. It means that instead of producing huge smart-contract monoliths, it is encouraged to separate the system into many manageable smart-contracts that communicate with each other by means of message passing. The message passing scheme used in a system induces some protocol. If message passing breaks in an unexpected way, the whole protocol may stall, potentially leading to global system deadlocks. It is of utter importance to guarantee that all produced correct messages will be eventually delivered to the destination account. The delivery process is complicated and rely on several node components. Here, we identify risks related to the Transaction Executor part of it: Successful SendMsg action does not lead to creation of a corresponding messageGenerated messages do not occur in the Out Message queueMessage delivery order gets brokenA bounce message does not get generated as expected "},{"title":"Assumptions​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#assumptions","content":"All the properties formulated with the following assumptions in mind: We consider only ordinary accounts, not system (special) accounts. For the latter, the properties might look different. "},{"title":"System Properties​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#system-properties","content":"System properties are high-level general statements on the system behavior that the Transaction Executor should obey to. A subset of those statements related to mitigating the main risks, identified in the previous section. Fees​ FEE1 — Gas fees for the computation equal the amount calculated using the algorithm calc_gas_fee.FEE2 — Storage fees for an account equal the amount calculated using the algorithm calc_storage_fee.FEE3 — Forwarding fees are calculated according to the algorithm message_passing_fees .FEE4 — During the message execution process, all type of fees get deducted only once for an account. Message Processing​ MSG1 — The message coins get credited to the account balance before executing a smart-contract logic.MSG2 — Messages delivery order between the current account a1a_1a1​ and some other account a2a_2a2​does not depend on messages sent from a1a_1a1​ to some other account a3a_3a3​, when a2≠a3a_2 \\neq a_3a2​=a3​. Credit Phase Processing​ CRD1 — If the inbound message is external, the credit phase does not get executed.CRD2 — If the inbound message is internal, the account's balance get credited with the message value minus the account debt, if any. Storage Phase Processing​ STR1 — If there is not enough funds to cover the storage phase fee on the account's balance, and if the account is in the Active status, then the account gets a debt storing in the due_payment field of the account. If the debt value exceeds the freeze_due_limit value, the account is switched into a frozen status. If the debt exceeds the delete_due_limit value, the account gets deleted. Compute Phase Processing​ CMP1 — If the Compute Phase fails, the execution of a message is aborted. The bounce message is not created in this case.CMP2 — After the Compute Phase, the account's balance gets decreased exactly on the amount of consumed gas. Action Phase Processing​ ACT1 — Each successful SendMsg action leads to creation of a message.ACT2 — Successfully created message is added into the out queue exactly once.ACT3 — If the action phase fails and the incoming message has the bounce flag set, then a single bounce message is generated and put into the out queue. Bounce Phase Processing​ BNC1 — The bounce message is generated only if and only if all of the following conditions hold: 1) The incoming message is an internal message 2) The incoming message has the bounce flag set 3) During the message processing, the action phase was executed, but failed 4) After the failed action phase, there is enough funds left on the incoming message balance to cover the bounce message processing2. BNC2 — A bounce message attach all the original message value minus the storage, gas and delivery fees. "},{"title":"Footnotes​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#footnotes","content":"Well, at least, until the part of the chain residing the transaction gets cut-off to reduce the disk space consumption.↩See the definition of COMMIT TVM instruction.↩ "},{"title":"About GraphQL API","type":0,"sectionRef":"#","url":"develop/client-api/gql-api/","content":"","keywords":""},{"title":"GraphQL API Documentation​","type":1,"pageTitle":"About GraphQL API","url":"develop/client-api/gql-api/#graphql-api-documentation","content":"Get quick help in our telegram channel:  "},{"title":"Connect to GraphQL API","type":0,"sectionRef":"#","url":"develop/client-api/gql-api/gql-connect","content":"","keywords":""},{"title":"Evercloud​","type":1,"pageTitle":"Connect to GraphQL API","url":"develop/client-api/gql-api/gql-connect#evercloud","content":"If you don't want to manage your own nodes, Evernode Cloud Platform - or Evercloud - provides you with Everscale Cloud Infrastructure. https://docs.everos.dev/evernode-platform/products/evercloud "},{"title":"Community Dapp Server​","type":1,"pageTitle":"Connect to GraphQL API","url":"develop/client-api/gql-api/gql-connect#community-dapp-server","content":"If you want to run Evernode Platform on your server, Dapp Server is a free community version for that. https://docs.everos.dev/evernode-platform/products/dapp-server-ds "},{"title":"Local Blockchain for testing​","type":1,"pageTitle":"Connect to GraphQL API","url":"develop/client-api/gql-api/gql-connect#local-blockchain-for-testing","content":"Test your basic Dapp functionality locally. Simple emulator is a light-weight Evernode instance with GraphQL API that suits good for DApp and contract testing in 90% cases. https://docs.everos.dev/evernode-platform/products/simple-emulator-se Get quick help in our telegram channel:  "},{"title":"GraphQL Samples","type":0,"sectionRef":"#","url":"develop/client-api/gql-api/gql-samples","content":"","keywords":""},{"title":"GraphQL API Samples​","type":1,"pageTitle":"GraphQL Samples","url":"develop/client-api/gql-api/gql-samples#graphql-api-samples","content":"Get quick help in our telegram channel:  The documentation in Everscale repository is a community effort. Therefore, everyone can contribute with proposals for new topics, suggest new content elements, participate in editing, and provide ideas that will be of great help for network development. Please be informed that our documentation can be edited via GitHub. Also please make sure to consult our rules and rewards policy via this link. Feel free to join Everscale Documentation Development Telegram chat and Everscale Developers Onboarding Telegram chat! "},{"title":"Overview","type":0,"sectionRef":"#","url":"develop/client-api/js-api/ever-sdk-js/","content":"","keywords":""},{"title":"Javascript API Official Documentation​","type":1,"pageTitle":"Overview","url":"develop/client-api/js-api/ever-sdk-js/#javascript-api-official-documentation","content":"Get quick help in our telegram channel:  "},{"title":"Samples","type":0,"sectionRef":"#","url":"develop/client-api/js-api/ever-sdk-js/samples","content":"","keywords":""},{"title":"Javascript API Samples​","type":1,"pageTitle":"Samples","url":"develop/client-api/js-api/ever-sdk-js/samples#javascript-api-samples","content":"Get quick help in our telegram channel:  The documentation in Everscale repository is a community effort. Therefore, everyone can contribute with proposals for new topics, suggest new content elements, participate in editing, and provide ideas that will be of great help for network development. Please be informed that our documentation can be edited via GitHub. Also please make sure to consult our rules and rewards policy via this link. Feel free to join Everscale Documentation Development Telegram chat and Everscale Developers Onboarding Telegram chat! "},{"title":"Everscale Inpage Provider","type":0,"sectionRef":"#","url":"develop/client-api/js-api/inpage-provider","content":"Everscale Inpage Provider Via following this link you will get familiar with Everscale Inpage Provider. It is a Web3-like interface to the Everscale blockchain. You can also find instructions on how to install it. The documentation in Everscale repository is a community effort. Therefore, everyone can contribute with proposals for new topics, suggest new content elements, participate in editing, and provide ideas that will be of great help for network development. Please be informed that our documentation can be edited via GitHub. Also please make sure to consult our rules and rewards policy via this link. Feel free to join Everscale Documentation Development Telegram chat and Everscale Developers Onboarding Telegram chat!","keywords":""},{"title":"Other languages API","type":0,"sectionRef":"#","url":"develop/client-api/other-lang","content":"","keywords":""},{"title":"Community Bindings​","type":1,"pageTitle":"Other languages API","url":"develop/client-api/other-lang#community-bindings","content":"The documentation in Everscale repository is a community effort. Therefore, everyone can contribute with proposals for new topics, suggest new content elements, participate in editing, and provide ideas that will be of great help for network development. Please be informed that our documentation can be edited via GitHub. Also please make sure to consult our rules and rewards policy via this link. Feel free to join Everscale Documentation Development Telegram chat and Everscale Developers Onboarding Telegram chat! "},{"title":"Rust API","type":0,"sectionRef":"#","url":"develop/client-api/rust-api","content":"","keywords":""},{"title":"About Core Rust Library​","type":1,"pageTitle":"Rust API","url":"develop/client-api/rust-api#about-core-rust-library","content":"Core Client Library is written in Rust that can be dynamically linked. It provides all heavy-computation components and functions, such as TON Virtual Machine, TON Transaction Executor, ABI-related functions, boc-related functions, crypto functions. The decision to create the Rust library was made after a period of time using pure JavaScript to implement these use cases. We ended up with very slow work of pure JavaScript and decided to move all this to Rust library and link it to Javascript as a compiled binary including a wasm module for browser applications. Also this approach provided an opportunity to easily create bindings for any programming language and platform, thus, to make it possible to develop distributed applications (DApps) for any possible use-cases, such as: mobile DApps, web DApps, server-side DApps, enterprise DApp etc. Client Library exposes all the functionality through a few of exported functions. All interaction with library is performed using JSON-RPC like protocol. Library works over GraphQL API of Evernode Platform. So, it can be used to interact directly with Evercloud, local blockchain Evernode-SE or Community version Dapp Server. "},{"title":"Library Source Code​","type":1,"pageTitle":"Rust API","url":"develop/client-api/rust-api#library-source-code","content":"Get quick help in our telegram channel:  "},{"title":"Library documentation​","type":1,"pageTitle":"Rust API","url":"develop/client-api/rust-api#library-documentation","content":"Via following this link you can find all necessary information concerning the interaction and configuration with Ton wallet API. "},{"title":"Overview","type":0,"sectionRef":"#","url":"develop/client-api/overview","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Overview","url":"develop/client-api/overview#introduction","content":"Before you start developing or integrating anything into Everscale, we would like to tell you about the tools and environment that you will use in your work. First of all, it is worth noting that Everscale is really a decentralized blockchain, not only from a technical point of view, but also from a management side, so the key tools and approaches to development may differ from different teams, technical contributors on the network. At the moment, there are two active companies of technical contributors in Everscale network: EverX Broxus And it is their solutions and tools that you will use when developing, while you will have every opportunity to write your own solutions as well, if necessary or desired. "},{"title":"APIs and Client Libraries for Everscale Access​","type":1,"pageTitle":"Overview","url":"develop/client-api/overview#apis-and-client-libraries-for-everscale-access","content":"GraphQL API (by EverX) - Mainnet validating node with a GraphQL server that allows you to collect a large amount of data about the network. *Suitable for integration by exchanges and other platforms. ever-sdk-js (by EverX) - EverX Web3 Javascript library that works on top of GraphQL API - is a binding over core Rust ever-sdk library. It allows Everscale developers work with contracts and query data from GraphQL API. everscale-inpage-provider (by Broxus) - Web 3.0 library for Everscale. Typed wrappers over contracts etc. Rust Core Library (by EverX) - provides Everscale developers with services on top of scalable blockchain infrastructure, so that developers can focus on business logic instead of infrastructure maintenance. Other Languages (by EverX) - Community bindings over Rust Core Library. "},{"title":"Hackathons & Grants","type":0,"sectionRef":"#","url":"develop/hackathons-grants","content":"Hackathons &amp; Grants Everscale hackathons are designed to help unleash new skills and competences via bringing talent from all corners of the world. This, in turn, speeds up the development of new and innovative technologies that aim to challenge the rules of the world we currently find ourselves in. At Everscale, we have an excellent track record in providing first-class hackathons that foster a mutually beneficial ecosystem of Everscale developers and entrepreneurs. Before exploring the opportunities for your next Everscale hackathon, you are advised to consult our documentation in GitHub so as to be familiar with our main developer tools, programming languages, SDK and support resources to help you build a winning dapp. There is a wide range of challenges for developers at Everscale hackathons. They vary from bug fixing, developing new features, discovering the latest trends in technologies, and a lot of research into different aspects of blockchain in particular, and decentralization at large. All challenges are organised and structured in such a way, so as to achieve maximum productivity. Therefore, it is of outmost importance for participants to have a ready-made work plan in order for experts to provide their feedback. Developers who are looking to obtain funding for their ideas have the Everscale grant program at their disposal. The program was launched for talented blockchain developers, eager and capable of creating and implementing revolutionary ideas that serve the interests of the Everscale ecosystem. The sum available for funding the best projects and ideas is decided and allocated after analysing the utility of each individual case. Grant payments are allocated in EVER. The decision is taken in accordance with the complexity of technical requirements, specifics and mechanics of a proposal, and, most importantly, the expected value of the project for Everscale network. In order to benefit from the Everscale Grants campaign, please apply via the following page.","keywords":""},{"title":"Comparison with Ethereum","type":0,"sectionRef":"#","url":"develop/from-another-platform/comparison-with-ethereum","content":"","keywords":""},{"title":"Sharding​","type":1,"pageTitle":"Comparison with Ethereum","url":"develop/from-another-platform/comparison-with-ethereum#sharding","content":"From the very beginning, Eth 2.0 planned to develop a genuine sharding, with cross-shared transactions and with hundreds of shards. Later, the number of shards was reduced to 32, and now this idea was completely abandoned (at least for the near future). Instead, the decision was made in favour of rollups. The arguments explaining why rollups are not the right solution due to their centralisation and low security are a topic for a separate article. Generally speaking, they are no more than different networks, that rely on some security measures from L1. They are also extremely inconvenient for users. It is very difficult to implement normal sharding in the Ethereum network due to its inherent synchronous architecture. As well, it is very difficult to make synchronous cross-chain transactions, and absolutely impossible to make it so that there is a large throughput. And if each shard exists independently, then this is not much better than rollups are. In Everscale, the asynchronous architecture was envisioned from the very scratch. All contracts communicate with each other by sending messages. Therefore, all that is needed for sharding to work is to synchronize the message queues between shards. At the same time, since Everscale was developed by blockchain maximalists, they went even further. To be specific, they developed not just sharding itself, but endless sharding. "},{"title":"How it actually works​","type":1,"pageTitle":"Comparison with Ethereum","url":"develop/from-another-platform/comparison-with-ethereum#how-it-actually-works","content":"There are two global shards called workchains: Master-workchain for synchronization and governance, and the main workchain for smart contracts.  The main workchain is partitioned into N shards, at least 16. Each shard has its own group of validators. This sub-group is responsible for executing transactions in its shard. At the same time, it constantly downloads blocks from all other shards of its workchain.  A block in Everscale is not just a list of transactions that need to be completed in order to achieve changes in the state. Instead, a block is: A list of messages for which we executed transactions and subsequently removed them from the incoming queue. New messages that entered the outgoing queue after message processing. Changes in smart contract states that resulted from message processing. That is, in order for the validator from shard X to maintain the current state of shard Y, it does not need to execute all the transactions that were in the block of shard Y. It simply downloads the block and rolls up the changes that have occurred in the message queue and smart contract states. "},{"title":"Sharding in Everscale is not merely data sharding, but computation resources sharding​","type":1,"pageTitle":"Comparison with Ethereum","url":"develop/from-another-platform/comparison-with-ethereum#sharding-in-everscale-is-not-merely-data-sharding-but-computation-resources-sharding","content":"In case there are too many transactions in the last N block of some particular shard, then we simply divide this shard into two. This is done in accordance to the address range of smart contracts, with some transactions going to one shard, and some to the another. The resulting shards, in turn, can also be divided into two more. In order for this to work, Everscale also decided to abandon the idea of ​​​​radical decentralization. The number of validators in the network will be in the number of thousands, not hundreds of thousands like on Ethereum network. These validators are professional players with big stakes and expensive servers. Currently, the validator requirements are: 48 CPUs, 128 RAM and 1TB SDD + 1 GB network bandwidth. Having such sharding capabilities, Everscale achieves a huge network bandwidth. Importantly, this is accomplished without any damages to customer satisfaction. That is to say, the customer does not have to switch between shards himself, or constantly transfer his money from one rollup to another. It is important to mention that there is also a big security issue arising. To be specific, as the number of shards increases, there are fewer instruments to watch over each one of them. Therefore, in the event of a high block mining rate, that may lead to the collusion of the validators of a single shard. This, in turn, could end with someone creating the original message that carries the money not belonging to the originator of the contract. A new consensus mechanism that is currently under development answers this question. The main idea is that due to the fact that in Everscale, validators only share computation among themselves, and everyone always has data for all shards, each issued block can be validated independently. In general terms, it looks like this: (this describes the principle, not the exact algorithm): Each validator comes up with a random number and sends its hash to the other validators. After all shards have created a block, but before the rest of the shards accept it, all validators must take the hash of this block, mix it with a random number, and if the remainder of dividing the resulting number by N is zero, then the validator must check this block, and send validators of -1 governance shard-chain a “yes” or “no”. If there is at least one not, then the check of this block by the rest of the validators starts. In the case of an invalid block, not only the validators who created this block will be terminated, but also those who said “yes” or remained silent. Before creating the next block, everyone reveals their guessed number and guesses a new one. Thus, shard validators never know who and how many other validators will validate their block. It is a very nice and elegant solution. "},{"title":"Large amount of data and its long tail issue​","type":1,"pageTitle":"Comparison with Ethereum","url":"develop/from-another-platform/comparison-with-ethereum#large-amount-of-data-and-its-long-tail-issue","content":"The original idea of ​​the blockchain was that there is a chain of blocks from the very beginning (genesis) to the latest block. And there is always the possibility to synchronize from the genesis block to the latest one, to check that everything runs well.  Already for a long time on the Ethereum network, full-nodes begin to synchronize with some kind of snapshot from the recent past, and not from the genesis block.  Many Ethereum maximalists are still not ready to accept the fact that the idea of storing the entire history of blocks from scratch was wrong. They believe that the history of blocks will be stored forever, and, with this, they will come up with some kind of special protocols so that you can always check some particular piece of information from history. However, it can be argued that even the Ethereum team has abandoned this idea. In the roadmap of Ethereum 2.0, there is the section called “History expiry” stating that full-nodes should not store the history of blocks for more than a year. The history of blocks is critically important for rollups. That is, if a rollup operator disappears, then you need the entire history of its transactions on the blockchain in order to withdraw your money from it, on L1. This is one of the reasons demonstrating why rollups are a questionable solution. Starting with Eth 2.0, we can now only say that the history of the blocks is probably stored at least somewhere.  It is assumed that the history will be stored by blockchain explorers. The team is also thinking about some new techniques for storing history, but so far there are none. There is also an understanding that we can only choose from one of the following two options: high throughput or storage history. To add, there is also a concept called &quot;Log events&quot;. It was created to simplify the development of Web3 applications. However, due to the fact that full-nodes or blockchain providers (infura) are as well required to store an infinitely increasing amount of information, the requests to them are very slow. This, too, has already been de facto recognized as a mistake. “Today, I would probably favour the eventual abolition of the LOG opcode from the EVM. However, due to the large number of applications already delivered by Ethereum, it will be difficult for them to refuse this concept. But that's only half the problem. There is also the issue of blockchain state growth. If someone recorded something on the blockchain, at least once, for example, he bought a memcoin for 0.001. Then, even if the price of the memcoin goes to zero, the validators will still be required to store the information about your purchase forever. That is, you pay for the record once, but it will be stored forever. And here comes the interesting economics - blockchains are forced to limit the rate of recording transactions artificially so that the size of the blockchain state does not grow faster than data storage becomes cheaper. As a result, users are forced to compete with each other for the right to record data on the blockchain via an auction, and subsequently, transaction fees are increasing all the time. This issue has also been de facto acknowledged by the Ethereum team, so that they introduced &quot;State expiry” in the Ethereum 2.0 roadmap. But of course they can't completely solve this problem without breaking backwards compatibility. So far, it is proposed to remove contracts from the state that have not been accessed for N years (for example, 10), with the possibility of recovery. Some other blockchains also explore ways to solve this issue. For example, in Near blockchain, the smart contract must lock N tokens each time it registers new information in the state. The issuer of the smart contract can set the conditions on it, so that the user can delete his information and receive the tokens back. This is definitely only a half-measure. Not all issuers of smart contracts set this condition, and even those who do, do not think about the mechanism of how to return tokens in case the cost of transactions changes in the future. Other blockchains simply remove smart contracts with fewer N tokens on the balance from the state. Everscale, as a leading blockchain developer, never looks for easy and uncostly ways to solve blockchain issues. Therefore, the highlighted problem was resolved with the maximum efficiency and accuracy possible. In the Everscale blockchain, each contract is required to pay rent for storing its data in the state. This rent corresponds to the size of the data. When the money runs out, the contract is deleted with the possibility of recovery, and then deleted completely.  Thanks to this, Everscale achieves absolutely controlled behaviour, when each smart contract decides for itself how long it will exist. Users do not have to compete with each other for the right to record data, and we get a huge throughput in terms of the number of transactions. "},{"title":"Distributed programming​","type":1,"pageTitle":"Comparison with Ethereum","url":"develop/from-another-platform/comparison-with-ethereum#distributed-programming","content":"There is a reasonable question. Let's consider that we have a contract with a token, for example, USDT. Then, a user with a larger account balance is more motivated to pay for storage, than, respectively, the user with a lesser balance. This way, wouldn't there arise situations when some users will be obliged to pay for storage on behalf of others, so that their contract is not deleted? In order to solve this problem, another truly genius idea was invented, called distributing programming.  In Everscale, for each entity, balance or even trading pair, its own small smart contract is deployed. The owner of the respective smart contract decides on his own for how long to store the data and pays only for that.  The mechanism describing how this works in detail is quite difficult and can be read in the following article. "},{"title":"References​","type":1,"pageTitle":"Comparison with Ethereum","url":"develop/from-another-platform/comparison-with-ethereum#references","content":"vitalik.ca/general/2022/03/29/road.html(The de-complexification of sharding)https://mitja.gitbook.io/papers/v/everscale-white-paper/readme/chapter-two-ever-kernel-ek/smft-soft-majority-fault-tolerance-consensushttps://www.youtube.com/watch?v=b1m_PTVxD-s&amp;t=2975shttps://vitalik.ca/general/2021/05/23/scaling.html , &quot;History retrievability&quot;https://vitalik.ca/general/2022/03/29/road.html)https://mnill.github.io/everscale-for-solidity-dev/distributed_programminghttps://aerial-ulna-579.notion.site/7a01d6c8ba644701834b105af87d3863 "},{"title":"Contracts","type":0,"sectionRef":"#","url":"develop/integrate/build-cross-chain/getting-started/contracts","content":"Contracts","keywords":""},{"title":"Everscale → EVM Transactions","type":0,"sectionRef":"#","url":"develop/integrate/build-cross-chain/getting-started/everscale-evm","content":"Everscale → EVM Transactions Everscale - EVM transactions are similar to EVM - Everscale. The difference is that they are in the opposite direction. The exception lies in the fact that we don't have to check how many tokens the Vault is still ready to accept, but how many tokens it has on the balance (how muck can be withdrawn). There is a lot of code needed to explain this transaction type. Therefore, in what follows, only a simplified version is given. Please check the details in the repository via following this link. The transaction pipeline is as follows: Similarly, we take the Vaults list from this file. Select the desired token, and take for it the Vault of the desired network (chain id), and depositType - default. DO NOT use EthereumEventConfiguration.sol. Instead, use EverscaleEventConfiguration.sol. Get the address from Proxy.sol. This is a contract owner TIP 3 Root which knows which configuration can be trusted. Take the proxy address from the following file. const proxyContract = new rpc.Contract(TokenAbi.EvmTokenTransferProxy, new Address(address)); const configurationAddress = (await contract.methods.getDetails({ answerId: 0 }).call()).value0.tonConfiguration; The so-called liquid tokens are the tokens that are issued by the bridge for the tokens locked in Vaults. Accordingly, in order to get the tokens from the Vaults, the issued tokens must be burned. Send tokens for burning, and put the callback from this burning on Proxy.sol, which in turn will send the callback EverscaleEventConfiguration.sol, and it will deposit TokenTransferEverscaleEvent.sol. This is similar to EVM → Everscale transactions, except that in this case, the relayers do not just say Yes/No. They sign the contract for the transaction, with which the funds can be withdrawn from Vault.sol on the EVM side. const data = await rpc.packIntoCell({ data: { addr: evmAddress, chainId: evmChainId, }, structure: [ {name: 'addr', type: 'uint160'}, {name: 'chainId', type: 'uint32'}, ] as const, }); await walletContract.methods .burn({ callbackTo: proxyAddress, payload: data.boc, remainingGasTo: userAddress, amount: amount, }).send({ amount: burnValue, bounce: true, from: userAddress, }); Actually, having sent the token burning transaction, it is needed to wait for the Event. This is a difficult task. The Event contract address cannot be calculated in advance, because it depends on the LT (Logical time). It can be solved in different ways. One of them is to subscribe to the EverscaleEventConfiguration.sol contract and wait for the transaction that will create the contract. const lastConfigurationLt = ( await rpc.getFullContractState({ address: configurationAddress, }) ).state?.lastTransactionId?.lt const subscriber = new rpc.Subscriber(); const oldStream = subscriber.oldTransactions(configurationAddress, { fromLt: fromLT, }); const eventStream = oldStream .merge(subscriber.transactions(address)) .flatMap((item) =&gt; item.transactions) .filterMap(async (tx) =&gt; { const decodedTx = await contract.decodeTransaction({ methods: ['deployEvent'], transaction: tx, }); if (decodedTx?.method === 'deployEvent' &amp;&amp; decodedTx.input) { const {eventData} = decodedTx.input.eventVoteData; const event = await rpc.unpackFromCell({ allowPartial: true, boc: eventData, structure: [ {name: 'wid', type: 'int8'}, {name: 'addr', type: 'uint256'}, {name: 'tokens', type: 'uint128'}, {name: 'eth_addr', type: 'uint160'}, {name: 'chainId', type: 'uint32'}, ] as const, }); const checkAddress = `${event.data.wid}:${new BigNumber(event.data.addr) .toString(16) .padStart(64, '0')}`; const checkEvmAddress = `0x${new BigNumber(event.data.eth_addr) .toString(16) .padStart(40, '0')}`; if ( checkAddress.toLowerCase() === fromAddress.toLowerCase() &amp;&amp; checkEvmAddress.toLowerCase() === toAddress.toLowerCase() ) { const eventAddress = await contract.methods .deriveEventAddress({ answerId: 0, eventVoteData: decodedTx.input.eventVoteData, }) .call(); return eventAddress.eventContract; } return undefined; } return undefined; }); const eventAddress = await eventStream.first(); The address must be saved so that if the user refreshes the page without completing the transaction, to be able to return to it. Unfortunately, there is a time lag between the moment when tokens are sent to when the address is generated. Thus, if the user leaves in this time frame, then the address of the Event will have to be searched on app.octusbridge.io. You can check History to find there all transactions via the Bridge. When the address is generated, TokenTransferEverscaleEvent.sol, we subscribe to it and track its status. Everything is the same as in the case of EVM - Everscale. The statuses are: Initializing, Pending, Confirmed, Rejected. After the Event has been signed by a sufficient number of relayers and the transaction is Confirmed, it is needed to get the data that they signed and the signatures themselves. const eventContract = new rpc.Contract(TokenAbi.TokenTransferTonEvent, new Address(eventAddress)); const eventDetails = await eventContract.methods.getDetails({ answerId: 0 }).call(); const round_number = (await eventContract.methods.round_number({}).call()).round_number; const eventConfigDetails = await eventConfig.methods.getDetails({ answerId: 0 }).call() const eventDataEncoded = mapTonCellIntoEthBytes( Buffer.from(eventConfigDetails._basicConfiguration.eventABI, 'base64').toString(), eventDetails._eventInitData.voteData.eventData, ); const encodedEvent = web3.eth.abi.encodeParameters([{ TONEvent: { eventTransactionLt: 'uint64', eventTimestamp: 'uint32', eventData: 'bytes', configurationWid: 'int8', configurationAddress: 'uint256', eventContractWid: 'int8', eventContractAddress: 'uint256', proxy: 'address', round: 'uint32', }, }], [{ eventTransactionLt: eventDetails._eventInitData.voteData.eventTransactionLt, eventTimestamp: eventDetails._eventInitData.voteData.eventTimestamp, eventData: eventDataEncoded, configurationWid: configurationAddressWid, configurationAddress: `0x${configurationAddressValue}`, eventContractWid: eventContractAddressWid, eventContractAddress: `0x${eventContractAddressValue}`, proxy: `0x${new BigNumber(eventConfigDetails._networkConfiguration.proxy).toString(16).padStart(40, '0')}`, round: round_number }]) const signatures = eventDetails._signatures.map(sign =&gt; { const signature = `0x${Buffer.from(sign, 'base64').toString('hex')}` const address = web3!.eth.accounts.recover( this.evmWallet.web3!.utils.sha3(this.data.encodedEvent!)!, signature, ) return { address, order: new BigNumber(address.slice(2).toUpperCase(), 16), signature, } }) signatures.sort((a, b) =&gt; { if (a.order.eq(b.order)) { return 0 } if (a.order.gt(b.order)) { return 1 } return -1 }); const vaultContract = new web3.eth.Contract(EthAbi.Vault, vaultAddress); const isAlreadyReleased = await vaultContract.methods.withdrawalIds(withdrawId).call(); if (!isAlreadyReleased) { vaultContract.methods .saveWithdraw( encodedEvent, signatures.map(({signature}) =&gt; signature), ).send({ from: fromAddress, type: txType, }); } Please follow this page in order to go through the details of EVM – Everscale transactions using the Credit Processor.","keywords":""},{"title":"EVM → Everscale Transactions Using The Credit Processor Contract","type":0,"sectionRef":"#","url":"develop/integrate/build-cross-chain/getting-started/credit-processor","content":"EVM → Everscale Transactions Using The Credit Processor Contract Credit Process is a special smart contract that exchanges part of the tokens for EVERs to pay for gas, and automatically completes transactions on the Everscale network. It is quite complex, and in order to use it in complex cases, it is advisable to independently study it. This tutorial does not cover all possible cases. The transaction pipeline is as follows: Before proceeding, please be informed that this guide will examine transactions of liquid tokens with the exception of WEVER. For WEVER, the swap will be skipped and there will simply be the uwrap. The beginning is the same as for a regular transaction. Values for deposit type = credit are taken from the list. The Vault in EVM will most likely be the same, but there will be other values for ethereumConfigurationAddress. The credit processor has its own implementation of the configuration contract. It issues tokens to the processor and not to the user, and sends the processor a callback onEventConfirmed. All limits should be checked and the amount determined. It is important to mention that transactions are possible only with tokens for which there is a TOKEN/WEVER pair with sufficient liquidity on FlatQube. Next, it is needed to decide on the scenarios and parameters that will be transferred to the processor. To call the deposit, the following is used depositToFactory function(uint128 amount, int8 wid, uint256 user, uint256 creditor, uint256 recipient, uint128 tokenAmount, uint128 tonAmount, uint8 swapType, uint128 slippageNumerator, uint128 slippageDenominator, bytes memory level3), where: Amount - how many tokens are transferred to Everscale and how much the credit the processor will receive for the exchange\\release. ERC20 decimals! User - is the control address. It can process a stuck transaction if, for example, tokens could not be exchanged for gas, because at the moment the price went beyond the limits of the slippage set. It can also cancel the transaction and unwrap. Pay the debt manually and pick up all the tokens. With correctly selected transaction parameters, it is used extremely rarely. Usually, this is just the user's wallet address, and if the user transfers tokens to himself, then it coincides with the recipient. In case tokens are transferred to a Strategy, it is better to specify the user's wallet address, even if it is not initialized. Creditor - the address of the CreditFactory.sol contract, which will create the CreditProcessor.sol contract itself. By default, you can use Broxus factory. The address of the current Factory and the number of tokens that will need to be returned are to be taken from here. Any account can deploy a contract via the Factory. The admin of the Factory can try to push the stuck CreditProcessor, and change the slippage, but with all parameters set correctly, this should not affect the result. There is no binding to the CreditFactory.sol contract code, so you can create your own Factory, but CreditProcessor.sol cannot be changed, or deploy your own Factory. Recipient - the address that will receive tokens + native EVERs. In a normal scenario, this is just the user's wallet address, but it can also be a smart contract. There are two options depending on the logic: If all tokens on the account balance are exchanged for EVERs, then the Credit Processor will trigger the receiving contract onReceiveTONsFromBridgeCallback(EventData) where all EVERs will be transferred. onbounce: EventData.user != EventData.recipient. That is, if the receiving contract is not the same as the user's, then it must be set up in advance or the tokens will be returned.If we have to swap Tokens + EVERs, then the contract will simply transfer tokens to this address along with EVERs, and the contract/wallet will receive a call to onAcceptTokensTransfer. The data of the transfer will also be in the payload. tonAmount is the minimum amount of EVERs together with the tokens that should be received by the recipient, TIP 3 WEVER decimals = 9. tokenAmount is the minimum amount of tokens that should be received by the recipient. Already in **TIP 3 decimals`!swapType – that's according to what algorithm the contract will try to make the transaction. Generally, by correctly combining swapType / tokenAmount /tonAmount, you can come up with different use cases of the Credit Processor. After receiving the tokens, the Processor asks the DEX how many tokens it will cost to buy WEVER (tonAmount + debt) + Slippage. That is, if the debt is 6, the number of tokens is 4, and the slippage is 10%, then it will be 11. The DEX returns expectedSpentAmount and if it is ≤ amount tokenAmount, then it will continue to try to make an exchange according to swapType, and if expectedSpentAmount is &gt; amount -tokenAmount, the contract will end up in the SwapFailed status and will wait for further actions from the user or lender. 0 - the contract will try to exchange tokens for WEVER for an amount equal to expectedSpentAmount, but no more than amount - tokenAmoun.1 - The contract will change to EVERs the exact amount - tokenAmount. slippageNumerator/slippageDenominator are the parameters of slippage during the exchange. level3 is the payload. It must be a valid TvmCell. If a non-valid cell is passed, then an empty cell te6ccgEBAQEAAgAAAA will come to Everscale. Accordingly, before the transfer, we need to calculate which parameters to transfer to depositToFactory, and these calculations strongly depend on what kind of use case we have. Let's see how to make the calculations when we want to transfer tokens, and change some of them for gas using swapType 0: Upload creditBody + Factory fee, this is dept. creditBody and we take it from the same place as the address of the factory. The fee is taken from the contract. const {fee: factoryFee} = ( await factoryContract.methods .getDetails({ answerId: 0, }) .call() ).value0; The user enters the amount of tokens that is to be transferred, and either enters how much tonAmount he/she wants to receive, or the application displays how much is needed for it to process the transfer. Then, we calculate how many tokens tonAmount + dept will cost. However, please note that the price of Token/Ever pair may change. In the contract below, there will be 1% slippage. However, the count will be like for 10%. Why is this the case? The Credit Processor will not be completed successfully without meeting the requirements for tonAmount and tokenAmount. At the same time, before the exchange, it checks how much it will cost to buy (dept + tonAmount) * slippage, and buys exactly this amount of tokens. If the value of this amount is greater than the amount - tokenAmount, then it will fail and wait for further actions from the user or Factory, because it cannot fulfill the requirements. If we just count tokenAmount = amount - ((dept + tonAmount) * 1.01), and transfer such an amount to the contract, then this transfer will fail if the price of EVER increases by at least a bit during the transfer. Therefore, we transfer tokenAmount = amount - ((dept + tonAmount) * 1.1) to the contract, and show this number to the user as the number of tokens that is guaranteed to be received. The slippage set for the contract is not 10% but 1%. The contract will try to exchange with 1% slippage. It can make several attempts, and the transaction will be completed successfully if the price has diverged by no more than 10%. It is done to minimize the likelihood of manual actions in case of price volatility. In case that everything runs well and the market is calm, then we will get more tokenAmount than indicated in deposit To Factory. Additionally, you can show to the user how many tokens he/she will receive if the price does not change. (dept + tonAmount) * slippage const tonAmount = new BigNumber(0); const dept = new BigNumber(CREDIT_BODY).plus(fee); const defaultNumerator = '1'; const maximumNumerator = '10'; const denumenator = '100'; const minEvers = tonAmount.plus(dept); const minEversWithSlippage = minEvers .times(denumenator) .div(new BigNumber(denumenator).minus(maximumNumerator)) .dp(0, BigNumber.ROUND_UP); const dexRootContract = new rpc.Contract(DexAbi.Root, DexRootAddress); const pairAddress = (await dexRootContract.methods .getExpectedPairAddress({ answerId: 0, left_root: new Address(fromToken), right_root: new Address(WEVERAddress), }) .call({})).value0; const pairContract = new rpc.Contract(DexAbi.Pair, pairAddress); const isActive = (await pairContract.methods .isActive({ answerId: 0, }) .call()).value0; if (!isActive) throw new Error('Pair not active); const expectedAmount = (await pairContract.methods .expectedSpendAmount({ answerId: 0, receive_amount: minEversWithSlippage.toFixed(), receive_token_root: WEVERRootAddress, }) .call() ).expected_amoun In the example above, we saw expectedAmount. This is the maximum amount of tokens that will cost to exchange for dept + tonAmounts. Note that this is in decimals already on Everscale in order to see how many tokens this is in EVM. const minTransferAmount = new BigNumber(expectedAmount) .plus(1) .shiftedBy(evm_decimals - tip3_decimals) .dp(0, BigNumber.ROUND_DOWN); Accordingly, the parameters for depositToFactory: const user = '0:0000000000000000000000000000000000000000000000000000000000000000'; const minTokensToRecieve = amount.shiftedBy(tip3_decimals - evm_decimals) // tip3 decimals .minus(necessaryAmountForSwap); depositToFactory( amount.toFixed(), user.split(':')[0], // wid user.split(':')[1], // address `0x${CreditFactoryAddress.toString().split(':')[1]}`, // creditor user.split(':')[1], //recipient minTokensToRecieve.toFixed(), tonAmount.toFixed(), '0', // swap type defaultNumerator, defaultDenominator, `0x${Buffer.from('te6ccgEBAQEAAgAAAA==', 'base64').toString('hex')}`, ) After a successful deposit, wait for the Credit Processor contract, and monitor its status. To do this, we need to get the transaction recipe from Web3 for transaction data (the address of the Credit Processor contract depends on them). Please see how to do it in the frontend demo via following this link. It can also be accessed on the open-source frontend of the bridge via following this link: It works as follows: const eventABI = ''; const decodedLogs = decodeLogs(txReceipt?.logs || []); const depositLog = txReceipt.logs[ decodedLogs.findIndex( (log: any) =&gt; log !== undefined &amp;&amp; log.name === 'FactoryDeposit', ) ]; const eventData = mapEthBytesIntoTonCell( Buffer.from(pipeline.eventABI, 'base64').toString(), depositLog.data, ); const eventVoteData = { eventBlock: txReceipt.blockHash, eventBlockNumber: txReceipt.blockNumber.toString(), eventTransaction: txReceipt.transactionHash, eventData: eventData, eventIndex: depositLog.logIndex.toString(), } const factoryContract = new rpc.Contract(TokenAbi.CreditFactory, CreditFactoryAddress); const creditProcessorAddress = await factoryContract.methods .getCreditProcessorAddress({ answerId: 0, eventVoteData, configuration: EthereumEventConfigurationAddress, }) .call() const creditProcessorContract = new rpc.Contract(TokenAbi.CreditProcessor, creditProcessorAddress); const currentState = (await creditProcessorContract.methods .getDetails({ answerId: 0, }) .call()).value0.state; If everything runs well, then wait for the Processed status. What you need to pay attention to: In case of more complicated cases than just transferring tokens across the bridge, it is needed to study the Credit Processor contract in detail in order to understand the mechanics of Tokens transferring. It is not recommended exchanging a large amount of tokens for EVER on a credit processor (minTonAmount), sooner or later you will be sandwiched. Please always remember about different decimals for the same tokens in different networks. The approximate scheme of the Credit Processor contract below does not include all possible scenarios where it could fail. It is given only for general understanding. This is the main part of this guide. It doesn't look so scary. But in reality, of course, there is quite a lot of code. Some transactions may end up in a waiting queue. It can happen for several reasons: Firstly, there may not be enough liquidity in the Vault. When your transaction is initiated, someone could have sent a transaction a little earlier than you or with a larger amount of gas and take the liquidity before you.Your withdrawal has exceeded the limit for a single transaction, or the daily limit has been exceeded. In this case, the transaction will not just get into the queue, but will also have to wait until your withdrawal is confirmed by governance or guardian.At the same time, if you withdraw money to the account of a smart contract and not a wallet, and, for example, check at the end of the transaction that your balance has increased by a certain amount, you are not immune from getting into the queue, because any wallet can complete the transfer, not just the one to which it is intended.To get out of the queue, you will need to make another transaction. You can also assign a reward to the one who comes and completes your withdrawal in the form of tokens. If you want to integrate the bridge into your website, then it is already very difficult to get into a queue using the UI, but you can always send the user to the frontend of the bridge tosolve any issues that may have arisen. When withdrawing tokens from Everscale, the Event contract does not automatically send the change. In order to get the remaining gas, you need to call Close method from the wallet that transferred tokens. Carefully, DO NOT call this method in the “Initializing” state. Otherwise, the transaction may fail. The contract EverscaleConfiguration.sol is not permanent, and can be replaced by another. So check the endTimestamp parameter if the bridge is integrated into the frontend, and take the configuration address from Proxy.sol if you transfer from the contract. Also, check that the proxy is not on pause. After going through the technical aspects of transactions please follow this page to see the pros and cons of the Octus Bridge.","keywords":""},{"title":"Overview","type":0,"sectionRef":"#","url":"develop/integrate/build-cross-chain/getting-started/overview","content":"","keywords":""},{"title":"Modus operandi​","type":1,"pageTitle":"Overview","url":"develop/integrate/build-cross-chain/getting-started/overview#modus-operandi","content":"The Octus Bridge for transferring assets between chains locks assets in the source chain and creates an equivalent number of wrapped assets in the destination blockchain. When you initiate an asset transfer from one blockchain to another using a bridge, assets are not actually moved or sent anywhere. Instead, the transfer functionality is used in a two-step process and handled by a smart contract. "},{"title":"DAO​","type":1,"pageTitle":"Overview","url":"develop/integrate/build-cross-chain/getting-started/overview#dao","content":"It provides a level of decentralization unprecedented for bridges due to the ability to make decisions directly by network participants. In order to participate in the decision making of Octus Bridge, native tokens are required. BRIDGE token owners can vote on certain operating decisions to make the bridge better. The voting protocol is a real smart contract that is authorized to make changes to other smart contracts. Any user with at least 100k BRIDGE tokens is eligible to become a Relayer. "},{"title":"Staking​","type":1,"pageTitle":"Overview","url":"develop/integrate/build-cross-chain/getting-started/overview#staking","content":"The Octus Bridge locks tokens from some blockchains and pledges those tokens to issue wrapped tokens on others. Part of the locked liquidity is invested in low-risk protocols. The income from these protocols is the income of the Octus Bridge. "},{"title":"Vault/Multi-vault​","type":1,"pageTitle":"Overview","url":"develop/integrate/build-cross-chain/getting-started/overview#vaultmulti-vault","content":"Octus Bridge is one of the most secure cross-chain services due to Vaulting, and more so, Multi Vaulting, which is a storage solution that provides an additional layer of security to digital wallets. "},{"title":"EVM → Everscale transactions of liquid tokens without the credit processor","type":0,"sectionRef":"#","url":"develop/integrate/build-cross-chain/getting-started/evm-everscale","content":"EVM → Everscale transactions of liquid tokens without the credit processor The simplest integration option are EVM → Everscale transactions of liquid tokens when the user already has an Everscale wallet with some amount of EVERs on the balance, and, therefore, can complete the transaction. The transaction pipeline is as follows: In order to get tokens in Everscale, they, firstly, have to be transferred to the bridge storage (Vault.sol) in the EVM network. Each token has its own Vault. The list of currently available tokens can be viewed via following this link. They can also be taken from the network. To proceed, select the desired token, and choose the Vault for the desired network (chain id), then choose depositType - default. It is downloaded from Vault.sol availableDepositLimit. That's how many tokens the Vault can accept (the limits were described above). Also, it should be checked that depositFee = 0 and the Vault is not turned off. Next, it's needed to call Vault.deposit(int128 recieverWorkchainId, uint256 recieverAddress, uint256 amount). Thanks to the previously installed Approve, it will transfer the required amount from the user's account to its own, and create the Event emit Deposit(amount, recieverWorkchainId, recieverAddress); The address should be taken from the following file. ethereumConfiguration. This is the address of the sample contact. EthereumEventConfiguration.sol, with which we will continue to work. It is needed to wait for N confirmations in EVM (how long to wait can be found in EthereumEventConfiguration.sol _networkConfiguratin.eventBlocksToConfirm), Afterwards, it is needed to create an Event of this transfer in Everscale. The Event is the sample of TokenTransferEthereumEvent.sol, which is created using the contract EthereumEventConfiguration.sol It is the contract that deploys Events and contains the Event settings. It is different for each Vault. The required address is taken from the following file. It can also be taken from the network. For the contract EthereumEventConfiguration.sol we call deployEvent(EthereumEventVoteData eventVoteData) method. EthereumEventVoteData - the structure which describes the emit Deposit event that is received when replenishing the Vault. struct EthereumEventVoteData { uint eventTransaction; uint32 eventIndex; TvmCell eventData; uint32 eventBlockNumber; uint eventBlock; } deployEvent will create a contract TokenTransferEthereumEvent.sol, which in turn will start loading into the constructor, calling the Staking contract. It will approach the current Round. The work of relayers is divided into rounds. With each new round, relayers can be added or subtracted, and then referring to the current Round, it will load the public keys of the relayers. The relayers will check that the deposit was really made. Then, they will sign it. TokenTransferEthereumEvent.sol The relayers sign the translation with external messages. That is, they do not pay for adding their signatures, the contract pays for everything. Thus, there are no extra transaction costs for the relayers. At the same time, due to the uniquely generated address, it is impossible to create a second copy of the contract for the same transaction. That's an Everscale feature. When there are 2/3 + 1 signatures, the Event will call onEventConfirmed, firstly in EthereumEventConfiguration that is in ProxyTokenTransfer, which will actually issue the necessary tokens. What you need to pay attention to: When initiating transactions, the user's wallet address is specified (SetCodeMultisig, BridgeMultisig, etc.), and not the TIP 3 wallet address. The TIP 3 wallet address will be generated automatically, and the remaining EVERs will be transferred to the address that trigerred the deployEvent (This may not be the address to which the tokens are to be transferred). Do not forget that decimals are different for different tokens, and one token may have different prices on different networks. This is important when showing how many converted tokens the user will receive. It is also necessary to check the input after the point, we have min(tip3_decimals, evm_decimals). The number of tokens that can be deposited on the Vault is not equal to Limit - Balance, because some tokens may still be blocked in Strategies. The View method is to be used availableDepositLimit. After the user called the Valut.deposit() method, it is advisable to remember the TX hash so that if the user refreshes the page, to be able to return to the incomplete transaction. In deployEvent it is necessary to transfer more EVERs than the amount set in BasicConfiguration basicConfiguration of the contract. Event sends callbacks about the status change to the contract that should receive tokens, see notifyEventStatusChanged. There are 4 transaction statuses: Initializing, Pending, Confirmed, Rejected. These statuses can also be viewed from the frontend to show users the progress of transactions. Currently, there are no fees for deposits and withdrawals. However, they could be introduced in the near future. Anyway, the fees will not be greater than the set maximum. Please see the schematic image of how this type of transfer works at the contract level. The user only needs to perform actions 1 and 2, and then monitor the status of TokenTransferEthereumEvent.sol Please follow this page in order to go through the details of Everscale – EVM transactions.","keywords":""},{"title":"Samples","type":0,"sectionRef":"#","url":"develop/integrate/build-cross-chain/getting-started/samples","content":"Samples","keywords":""},{"title":"Octus Bridge Tokenomics. Pros and cons of the platform.","type":0,"sectionRef":"#","url":"develop/integrate/build-cross-chain/getting-started/tokenomics","content":"","keywords":""},{"title":"Where does the income come from?​","type":1,"pageTitle":"Octus Bridge Tokenomics. Pros and cons of the platform.","url":"develop/integrate/build-cross-chain/getting-started/tokenomics#where-does-the-income-come-from","content":"Octus Bridge has an interesting monetization model. Currently, there are no commissions for transferring funds across the bridge. Although for some tokens, commissions will probably be introduced in the near future. The bridge plans to earn from the Everscale network. With the growing popularity of the network and the emergence of an increasing number of projects, liquidity from other networks will inevitably come to the network, and the bridge will use this locked liquidity to generate income. For instance, when you transfer USDT from Ethereum to Everscale, these USDT are locked in the Vault contract in Ethereum, and the bridge issues the USDT guaranteed by Octus Bridge itself, on the Everscale network. The bridge takes part of the tokens that are locked in the Vault and invests them in liquid protocols such as Curve or Compound. The investments of part of locked tokens are called Startegies, and are voted by the DAO. When the next round closes, the funds earned in the Strategies are redeemed by the bridge from the market and distributed between the relayers and the stake holders. Also, it is important to mention that not only digital assets can be transferred via the bridge, but also DAO solutions. It is applicable when participants of the Everscale DAO vote for a proposal that has actions in other networks. In case the proposal is accepted, it is signed by relayers and executed on behalf of the DAO in the needed network. Therefore, DAO voting can be conducted on a very cheap network, and the decisions executed on an expensive network (for example, Ethereum). "},{"title":"Vault/MultiVault​","type":1,"pageTitle":"Octus Bridge Tokenomics. Pros and cons of the platform.","url":"develop/integrate/build-cross-chain/getting-started/tokenomics#vaultmultivault","content":"Everscale is home network for the Octus bridge. In non-home networks (currently only EVM), there are two types of storage for tokens - Vault and MultiVault. Vault is a repository for liquid tokens. These are the tokens that have analogues in other networks (For example, USDT, for Ethereum it is the original USDT, for BSC it is BSC-USD, etc.). Such Vaults are configured manually, and now they are the following: DAI, USDT, USDC, WETH, WBTC. Also, there is WEVER, but its Vault implementation is different, since its home network is Everscale. It will not be examined here. For the mentioned tokens, the following cross-chain transfer can be made (EVM→ EVM). These tokens could potentially participate in Strategies for generating income. Vaults have limits on the number of tokens they can accept and these limits are set by DAO. This is a way to manage risks. Different networks have different levels of security. The Fantom network has a low limit on the maximum USDT that the Vault can accept (100k). The limit is higher for BSC, and the highest for Ethereum. The cross-chain transfers are possible for such tokens. (Semi-automatic EVM → ES → EVM). MultiVault is a multi-repository that allows to transfer any tokens to the Everscale network, and withdrawal of the tokens from the network. The Tokens are divided into Native and Alien: Native - is a token whose home network is Everscale. In this case, tokens are issued in the EVM network and guaranteed by the bridgeAlien - is a token whose home network is not Everscale. In this case, TIP 3 tokens are issued in Everscale and as well guaranteed by the bridge. When you transfer native tokens to the EVM network, while withdrawing, if necessary, an ERC 20 wallet for this token will be automatically created. The same thing applies to transferring an alien token, in which case a TIP 3 wallet will be created. Also, if you get the same token from different networks, different alien tokens will be created for it in Everscale and cross-chain transfers for such tokens are not possible by default, but there is a unification mechanism. "},{"title":"Pros and cons of the Octus Bridge​","type":1,"pageTitle":"Octus Bridge Tokenomics. Pros and cons of the platform.","url":"develop/integrate/build-cross-chain/getting-started/tokenomics#pros-and-cons-of-the-octus-bridge","content":"A big competitive advantage of the bridge is the tremendous opportunities for future integrations. The EVM part of the bridge is quite simply designed, which is a big advantage due to the fact that there is less room for errors. The Everscale part of the bridge is much more complicated. All decision-making takes place on-chain. Besides DAO, there are Staking and assignment of relayers. Communication of relayers with users (signatures of transactions) is on-chain. Due to the unique feature of the Everscale blockchain, relayers do not pay for signing transactions, instead, the user pays for them. (You create a transfer contract and deposit EVERs there. The contract loads the list of currently available relayers and they say their Yes or No with the help of External messages). At the moment, the bridge does not charge commissions for the transfer of tokens, although commissions could be introduced in the near future. Probably commissions will first be introduced for NON-liquid tokens (MultiVault). The absence of commissions is both a plus and a minus. The plus is in cheap transactions, the minus is that there is no automatic market mechanism for balancing liquidity between networks. If you want to withdraw liquid tokens (Vault) to the EVM network where there is no liquidity, then, you either need to wait for some time until the liquidity is accumulated (but no more than the TTL of the relay round - now it's 2 weeks), or complete the transaction by adding it to the withdrawal queue. Then, the transaction can be completed later with another transaction. Also, a bounty reward can be set for the one who will bring liquidity and complete the transaction. If the transaction hangs in the queue for a long time and liquidity is not accumulated, the transaction can be cancelled. Despite the fact that technically everything seems to be ready for the bridge to be run by the DAO, now the bridge configuration is controlled by the Broxus multisig. Probably, when all the functionalities of the bridge are finally settled, it will be entirely managed by the DAO. You can think of relayers as hot wallets that sign transactions in real time, and about Broxus multisig as hard-core wallets that are used to update the bridge. Vaults currently have limits on withdrawals from the Everscale. There is a limit on both the maximum amount and the number of withdrawals per day per token. If the limit is exceeded, transfers are placed in a waiting queue and are waiting for confirmation from the DAO or Guardian. This is also a risk management measure. The limits will probably increase over time. At the moment, the bridge has limited possibilities for transmitting useful data along with transactions. It is possible to transmit some data for automatic execution only for EVM → Everscale transactions using the credit processor. The bridge will not transfer it to the sender's address. You will simply receive a callback in the form “You have received N tokens and Data with them.” That is, in this data, for example, you can write down who the owner of these digital assets is, and what should be done next. This option is not available for Everscale -&gt; EVM transactions. The main functionality of the bridge is to transfer events that occur on connected to Everscale networks, and sign events that occurred in Everscale to transfer them to other networks. Vault and MultiVault are only special cases of such integrations. Token lock events are transferred from EVM networks, and token burning events are transferred back (or vice versa). After studying the transaction pipeline, you will understand that any events can be transferred according to the same principle. "},{"title":"Transaction types and their mechanics","type":0,"sectionRef":"#","url":"develop/integrate/build-cross-chain/getting-started/transactions-mechanism","content":"Transaction types and their mechanics Firstly, we will examine what kinds of transactions there are and how they work. There are three kinds of transactions: EVM → EverscaleEverscale → EVMEVM → Everscale using a Credit processor contract EVM → Everscale is available for Vault and MultiVaul. It works very simply, in just two transactions: ERC 20 tokens are transferred to the Vault in the EVM network, specifying the recipient's address in Everscale emit Deposit (amount, recipient.wid, recipient.addr).ERC 20 tokens are transferred to the Vault on the EVM network, specifying the recipient's address in Everscale emit Deposit (amount, recipient.wid, recipient.addr). Thus, a contract on Everscale is created with the metadata of this event. The validators see this contract on the network, and if the transaction is confirmed, they will sign it and the contract will issue TIP 3 tokens in Everscale. Everscale → EVM is possible for Vault and MultiVault, according to the same principle: Tokens are transferred to Everscale to a special contract that will burn them and create a special contract with the metadata of the burning. The relayers sign this contract for transaction metadata. When the required number of signatures is reached, a request is made to the Vault in the EVM network with this metadata + signatures. Afterwards, the tokens will be released. In the event that there is not enough liquidity in the Vault, there are the following scenarios: Waiting for a short time, in case the required amount of liquidity is accumulated. However, it should be noted that the signatures of validators last for a specific period of time. Completing the withdrawal request which gets in the queue, and received in a while with another transaction. Assigning a reward for someone who will bring liquidity which will permit to complete the transaction. Please be informed that situations with a lack of liquidity can happen, due to the fact that liquidity moves easily between networks. Thus, in any specific time-frame, there may not be enough locked tokens in a particular network to immediately complete transactions. EVM → Everscale transactions using CPU credit are currently possible only for liquid tokens (Vault). Credit processor is a special contract that will issue EVERs on credit, in order to automatically complete transactions on the Everscale network. It works as follows: Just like in a regular transaction, funds are deposited into the Vault account. It should be noted that, in this case, not only the recipient's address ought to be specified, but, as well, the address that is to be used in emergency cases. **The emergency cases are twofold:**1. There were not enough funds to pay for the transaction. (in the event of high market volatility) 2. Transfer parameters were not set correctly.The address of the token recipient.How many tokens should be received after the exchange, and how much is still needed to have to exchange to EVER additionally (so that the gas payment comes into the contract).The address that credits you is the address of the contract through which someone's bot offers you a loan. But if this bot gets disused, any other account can supply you with a loan.Payload is the data that will be received by the recipient along with the tokens. Accordingly, when funds are deposited in EVM, a credit transfer contract is automatically generated in Everscale. It is confirmed by the relayers. They issue tokens for THEMSELVES, exchange part of them for gas through AMM, return the loan and then send the tokens to the recipient. Also, they can exchange more tokens than needed for EVERs, and send these EVERs to the recipient so that the user has enough funds to make other transactions. The easiest way to use a Credit Processor is when a user who does not have EVERs, wants to transfer tokens to the network. In this case, the controlling address and the recipient's address are the same, and in case any issues arise, which is a very rare situation, the user will get EVERs in one of the other ways and complete the transfer. A more complicated way is characteristic for EVM → Everscale → EVM transactions. In this case, the recipient is a special contract that will send user's tokens further to the requested network. The address for emergency situations is this user's wallet in Everscale - even if not initialized. In the event of emergency cases, it will receive EVERs by another transaction, and will be able to complete/cancel the transaction. The most difficult way is associated with some kind of non-custodial logic, when tokens are linked to a Strategy and without a controlling account (after all, the user can cancel the transaction and take the tokens back). This option is also probably possible. However, in depth knowledge and understanding of processor logic and its settings is needed. Otherwise, the Payload in the transaction should be set up with another contract in control, which, for example, can only cancel the transaction if necessary and send tokens back through the bridge to the sender. In what follows, it is described in more detail how these transactions work. In order to understand the work of the bridge, it is recommended to go through all the pipelines. Please follow this page in order to go through the details of EVM – Everscale transactions.","keywords":""},{"title":"Glossary","type":0,"sectionRef":"#","url":"develop/integrate/build-cross-chain/glossary","content":"Glossary Below are the definitions of terms you will encounter while exploring the Octus Bridge. Cross chain transfers - A feature that allows you to transfer tokens from one blockchain network to another Stake - Tokens locked in the stacking contracts. BRIDGE- a token used in various Octus Bridge interfaces. Relayer - validator, who monitors and confirms a set of events in EVM and Everscale network Relay round - timespan in which specific relayers are active Election round - timespan in which a stakeholder, who has staked over 100,000 Bridge tokens, can become a relayer Native token - any crypto asset that can be used natively to perform a service to a protocol in exchange for a reward Proposal - suggestion created by any stakeholder related to changes which can be voted in favor or against Staker/stakeholder - anyone willing to invest their assets in order to participate in network development Governance - decision-making power accessible to a global distributed community of stakeholders Vote - decision made for any active proposal. It can be in favor of the proposal or against it Vault - storage solution that provides an additional layer of security to digital wallets Event - action emitted in order to notify another participant in the network. EVM actions - actions that happen on EVM. TON actions - actions that happen on Everscale. Keys - public keys of relayers needed for communication between EVM and Everscale Mint - the process of generating new coins. Burn - permanently removing a number of tokens from circulation.","keywords":""},{"title":"Introduction","type":0,"sectionRef":"#","url":"develop/integrate/build-cross-chain/introduction","content":"","keywords":""},{"title":"What are bridges?​","type":1,"pageTitle":"Introduction","url":"develop/integrate/build-cross-chain/introduction#what-are-bridges","content":"A blockchain bridge is a connection that allows the transfer of tokens between completely different networks, such as Everscale and Ethereum, as well as between one parent blockchain and its child chain, called a side chain. In the same way as a physical bridge connects two physical locations, a blockchain bridge connects two blockchain networks. Bridges provide the means for communication between blockchain networks via the transfer of information and assets. "},{"title":"Why do we need bridges?​","type":1,"pageTitle":"Introduction","url":"develop/integrate/build-cross-chain/introduction#why-do-we-need-bridges","content":"All blockchains have their limitations. For Everscale to achieve a high throughput and keep up with increased demand, it implemented sharding. Namely, computational resources sharding. On the other hand, blockchains like Solana and Ethereum are made up differently in order to enable higher throughput but at the cost of reduced decentralization. Please follow this page in order to get familiar with the features and use cases provided by the Octus Bridge. "},{"title":"Use cases","type":0,"sectionRef":"#","url":"develop/integrate/build-cross-chain/use-cases","content":"","keywords":""},{"title":"Games​","type":1,"pageTitle":"Use cases","url":"develop/integrate/build-cross-chain/use-cases#games","content":"Since the online gaming industry is rapidly expanding, the best way to motivate users to become part of the crypto community is by integrating them with Octus Bridge. That can be done for various different games. A few examples of how to benefit from Octus Bridge and exploit all of its features in gaming are: Users can earn rewards by competing with others, accomplish goals, pass levels and so on. After a user wins a certain amount of reward tokens, thanks to Octus Bridge he/she is able to use them in multiple ways, such as:Return some of the award tokens back to the game’s account by buying gaming tools such as armor or special tokens used in the game. This way, it allows the game to earn more tokens using Octus Bridge by staking some or all of the tokens that are available for distribution among users.Swap earned bridge tokens for some other tokens. Use reward tokens to vote for changes inside the game, making every user part of the community, providing them with chances to make decisions and, at the same time, investing in the game by returning some of their tokens back to the game’s pool. To conclude this page, it should be mentioned that Octus Bridge can be used in various applications that are in widespread usage on a daily basis. Besides gaming, Octus Bridge can be used in all kinds of decentralised applications: online auctions, prediction markets, oracles, NFT marketplaces - to state just a few. Octus Bridge plays a big role in motivating users to earn rewards and, on the other hand, helps the application evolve and provide other users with helpful information. Please follow this page in order to learn the terms that will be of use while navigating through Octus Bridge documentation. "},{"title":"Indacoin","type":0,"sectionRef":"#","url":"develop/integrate/integrated-products/indactoin","content":"Indacoin The documentation in Everscale repository is a community effort. Therefore, everyone can contribute with proposals for new topics, suggest new content elements, participate in editing, and provide ideas that will be of great help for network development. Please be informed that our documentation can be edited via GitHub. Also please make sure to consult our rules and rewards policy via this link. Feel free to join Everscale Documentation Development Telegram chat and Everscale Developers Onboarding Telegram chat!","keywords":""},{"title":"Itez","type":0,"sectionRef":"#","url":"develop/integrate/integrated-products/itez","content":"Itez The documentation in Everscale repository is a community effort. Therefore, everyone can contribute with proposals for new topics, suggest new content elements, participate in editing, and provide ideas that will be of great help for network development. Please be informed that our documentation can be edited via GitHub. Also please make sure to consult our rules and rewards policy via this link. Feel free to join Everscale Documentation Development Telegram chat and Everscale Developers Onboarding Telegram chat!","keywords":""},{"title":"EVER Scan API","type":0,"sectionRef":"#","url":"develop/integrate/products-api/everscan","content":"EVER Scan API At the moment, there is no ready-made documentation for the EVER Scan API, but you can study it yourself using the link below: explorer-api.broxus.com/v1 - This API allows you to get the Everscan info, such as account, blocks, transactions and other data. The documentation in Everscale repository is a community effort. Therefore, everyone can contribute with proposals for new topics, suggest new content elements, participate in editing, and provide ideas that will be of great help for network development. Please be informed that our documentation can be edited via GitHub. Also please make sure to consult our rules and rewards policy via this link. Feel free to join Everscale Documentation Development Telegram chat and Everscale Developers Onboarding Telegram chat!","keywords":""},{"title":"FlatQube API","type":0,"sectionRef":"#","url":"develop/integrate/products-api/flatqube","content":"FlatQube API FlatQube DEX, powered by Broxus, is a decentralized digital asset exchange providing users a convenient means of exchanging their cryptocurrency. The DEX also provides users with a plethora of options for earning a passive income through its farming and staking mechanisms. The APIs below are used by FlatQube itself to facilitate user interfaces. The information below will allow you to familiarize yourself with the various function calls, as well as examples of their use. All of the API call methods below are divided into 2 sections: FlatQube Dex Indexer and FlatQube Farming Indexer. Dex Indexer CMC API - used to view all DEX pools with their information and get information about farming pools.Currencies API - used to get DEX currencys data.Pairs API - used to get DEX pairs data.Transactions API - used to get DEX transactions data. Farming Indexer Farming pools API - used to get farming pools list and their data, such as balances, token addresses, etc.Transactions API - used to get transactions data.Graphics API - used to get graphs data, such as TVL, APR and other.","keywords":""},{"title":"Octus Bridge API","type":0,"sectionRef":"#","url":"develop/integrate/products-api/octus-bridge","content":"Octus Bridge API The DAO-controlled Octus Bridge facilitates cross-chain transfers between Everscale and multiple Ethereum-based networks. At the moment, there is no ready-made documentation for the Octus Bridge API, but you can study them yourself using the links below: api.octusbridge.io/v1 - This API allows you to get the Octus Bridge data about relayers, staking, transfers and other information.dao.octusbridge.io/v1 - This API allows you to get the information of Octus Bridge DAO.","keywords":""},{"title":"Getting started","type":0,"sectionRef":"#","url":"develop/integrate/tutorial/getting-started","content":"","keywords":""},{"title":"Tools​","type":1,"pageTitle":"Getting started","url":"develop/integrate/tutorial/getting-started#tools","content":"Also, you will need to learn the basic development tools for integration. Among them, you will find options to connect to the blockchain, create a deposit account, etc. TONOS-CLI - command line tool for the TON blockchain that allows you to deploy any smart contracts on the blockchain, call all contract methods, sign transactions, and generally manage your account. EVER Cloud - EVER Cloud allows you to work with the Everscale blockchain and development network without having to launch your own node. Ever SDK Wallet API - HTTP Api solution for a wallet running on the Everscale network "},{"title":"APIs​","type":1,"pageTitle":"Getting started","url":"develop/integrate/tutorial/getting-started#apis","content":"We highly recommend reading the APIs of the most popular products at Everscale: FlatQube - Everscale's main DEX. Check out the official documentation pages for DEX Indexer and Farming Indexer. The documentation in Everscale repository is a community effort. Therefore, everyone can contribute with proposals for new topics, suggest new content elements, participate in editing, and provide ideas that will be of great help for network development. Please be informed that our documentation can be edited via GitHub. Also please make sure to consult our rules and rewards policy via this link. Feel free to join Everscale Documentation Development Telegram chat and Everscale Developers Onboarding Telegram chat! "},{"title":"How to read Network details","type":0,"sectionRef":"#","url":"develop/integrate/tutorial/how-to-read-network-details","content":"How to read Network details This article has TO DO status. You can contribute by submitting your own version of this page. More details on the Documentation page of the Hot streams section. The documentation in Everscale repository is a community effort. Therefore, everyone can contribute with proposals for new topics, suggest new content elements, participate in editing, and provide ideas that will be of great help for network development. Please be informed that our documentation can be edited via GitHub. Also please make sure to consult our rules and rewards policy via this link. Feel free to join Everscale Documentation Development Telegram chat and Everscale Developers Onboarding Telegram chat!","keywords":""},{"title":"Interact with Ever wallet","type":0,"sectionRef":"#","url":"develop/integrate/tutorial/interact-ever-wallet","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Interact with Ever wallet","url":"develop/integrate/tutorial/interact-ever-wallet#introduction","content":"Welcome to Ever wallet’s Developer Guide. Ever wallet enables user interaction and experience with Everscale ecosystem's dApps. It is currently available as a browser extension and as a mobile app on both Android and iOS devices. The purpose of this documentation is to illustrate how to integrate Ever wallet, initiate transactions and build dApps with Everscale. "},{"title":"Why Ever wallet​","type":1,"pageTitle":"Interact with Ever wallet","url":"develop/integrate/tutorial/interact-ever-wallet#why-ever-wallet","content":"Ever wallet was created by Broxus developers to supply users with a secure and innovative wallet perfectly suited to navigate through multiple services powered by the Everscale network. It is equipped with the most up-to-date features and easy to comprehend documentation for developers that are looking to build their dApps on the Everscale blockchain. "},{"title":"Getting Started​","type":1,"pageTitle":"Interact with Ever wallet","url":"develop/integrate/tutorial/interact-ever-wallet#getting-started","content":"To develop for Everscale, install Ever wallet in any Chromium and Firefox browser of your choice. After Ever wallet is installed (make sure you back up your Seed Phrase), you should find that new browser tabs have a window.__ever object available in the developer console. This is the way your website will interact with Everscale blockchain. Before proceeding with the documentation, please follow this link in order to get familiar with how to use the Everscale blockchain and Ever wallet for user authorization without creating a transaction on the network. Afterwards, please follow this link in order to get familiar with how to interact with the contract from Ever wallet. After having studied the material above, please proceed with the Ever wallet API, Everscale Inpage Provider, and Everscale standalone client documentation. "},{"title":"Ever wallet API​","type":1,"pageTitle":"Interact with Ever wallet","url":"develop/integrate/tutorial/interact-ever-wallet#ever-wallet-api","content":"Ever Wallet API facilitates automatic interaction with the Everscale Blockchain and simplifies the management and transaction processes for Everscale assets. The API includes a built-in lite EVER node, support for Ever and TIP-3.1 tokens, a variety of different wallet contracts and REST API to make usage as convenient as possible. On the security front, the wallet API also has formidable features, most notably in its support for multi-sig operations. Wallet API GitHub repositorySwagger  "},{"title":"Everscale inpage provider​","type":1,"pageTitle":"Interact with Ever wallet","url":"develop/integrate/tutorial/interact-ever-wallet#everscale-inpage-provider","content":"Web3-like interface to the Everscale blockchain. Provider working with extensions. Used for sending transactions. Used for frontend. Installation guide Inpage provider documentation Also, please follow this link for documentation of an example of Inpage Provider usage as well as wallet connection to DApps. "},{"title":"Everscale standalone client​","type":1,"pageTitle":"Interact with Ever wallet","url":"develop/integrate/tutorial/interact-ever-wallet#everscale-standalone-client","content":"It is advisable to be used in conjunction with Everscale Inpage Provider. -Used to get data from smart contracts, and subscriptions to state changes. -Does not support Send in contracts. Installation guideStandalone client documentation For a deeper dive into the Everscale network, please find below links to instruments and services that will be of use while interacting with the Everscale blockchain via Ever wallet. APIs of Everscale services How to get EVERsTONOS-CLI EVERDEVEver SDKEver OS "},{"title":"Add EVER to your Exchange","type":0,"sectionRef":"#","url":"develop/integrate/tutorial/add-everscale-to-your-exchange","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Add EVER to your Exchange","url":"develop/integrate/tutorial/add-everscale-to-your-exchange#introduction","content":"This document describes the various ways to accomplish the most important tasks of running a crypto exchange that supports EVER. There are a few different ways to accomplish the necessary tasks: Blockchain access may be set up either through the EVER OS cloud or through your own node - the DApp server. Deposit account management can be accomplished either through the TONOS-CLI command line tool or integrated into your backend with TON SDK. Both of these approaches are compatible with either of the blockchain access setups. "},{"title":"Setting up Blockchain Access​","type":1,"pageTitle":"Add EVER to your Exchange","url":"develop/integrate/tutorial/add-everscale-to-your-exchange#setting-up-blockchain-access","content":"There are two ways you can set up access to the Everscale blockchain: you may use EVER OS Cloud, or set up your own DApp server. Using EVER OS Cloud​ EVER OS Cloud allows you to work with Everscale blockchain and the Development Network without having to run your own node. TONOS-CLI and SDK can connect to it, as if it were a regular node. It has the same API as a node, and provides all capabilities required for running an exchange. This page lists the endpoints for both clouds. Whenever you have to specify a network in the examples given below, you may use them. Note: We highly recommend testing out the full setup on the developer network first. Using DApp Server​ If you prefer to run your own node, rather than using EVER OS Cloud, you may set up your own DApp server. It is a full node, that may be set up on your own servers and provide full access to either Everscale or the Developer network. To connect to to it with TONOS-CLI or SDK, it needs to have a domain name and a DNS record. You can specify its URL whenever you have to set the network in the examples given below. Get the setup scripts in this repository: https://github.com/tonlabs/TON-OS-DApp-Server 1. System Requirements CPU (cores) - 24 RAM (GiB) - 192 Storage (GiB) - 2000 Network (Gbit/s) - 1 SSD disks are recommended for storage. 2. Prerequisites 2.1 Set the Environment Set the network in /scripts/env.sh: use main.ton.dev for the main network and net.ton.dev for the developer network. Note: We highly recommend testing out the full setup on the developer network first. $ cd TON-OS-DApp-Server/scripts/ $ . ./env.sh  2.2 Install Dependencies Ubuntu 20.04: $ ./install_deps.sh  Note: Make sure to add your user to the docker group, or run deploy command as superuser: sudo usermod -a -G docker $USER  3. Deploy Node Deploy node: $ ./deploy.sh 2&gt;&amp;1 | tee ./deploy.log  Note: the log generated by this command will be located in the TON-OS-DApp-Server/scripts/ folder and can be useful for troubleshooting. ###Setting up Deposit Account Currently we can recommend the formally verified SafeMultisig contract for use in deposit accounts. It is well tested and secure, supports multiple custodians, and can be set up to require several independent signatures for any transfers. However it has certain limitations, that may prove problematic for exchanges: it is not possible to send tokens transfers in batches to multiple addresses. If this functionality is required, you can develop a contract with the needed capabilities or get one developed by someone in the Everscale community. Using command line tool​ TONOS-CLI, the command line tool for the Everscale blockchain, allows to deploy any smart contracts to the blockchain, call all contract methods, sign transactions, and generally manage an account. TONOS-CLI has versions for Linux, Windows and Mac. It supports the EVER OS cloud and DApp server-based approaches both. 1. Install TONOS-CLI You can use EVERDEV to install the latest version of TONOS-CLI: everdev tonos-cli install  The installer requires NPM to be installed, so it can install packages globally without using sudo. In case of error, manually set the environment variable PATH=$PATH:$HOME./everdev/solidity  2. Set the network Use the following command to set the network: tonos-cli config --url &lt;https://network_url&gt;  You may specify either your DApp Server URL, or one of the cloud endpoints: developer network for testing with test tokens. By default, TONOS-CLI connects to the developer network. We highly recommend testing out the full setup on this network first.main Everscale network. Switch to it for working with EVERS. Refer to this list for network URLs. You need to set the network only once before you start using the utility. Note: You should run the TONOS-CLI utility only from the folder where the tonos-cli.conf.json file is located. 3. Get contract files To use the recommended SafeMultisig, get the contract files: .tvc - Compiled contract code SafeMultisigWallet.abi.json direct link: https://raw.githubusercontent.com/tonlabs/ton-labs-contracts/master/solidity/safemultisig/SafeMultisigWallet.abi.json .abi.json - application binary interface, describing the functions of the contract SafeMultisigWallet.tvc direct link: https://github.com/tonlabs/ton-labs-contracts/raw/master/solidity/safemultisig/SafeMultisigWallet.tvc 4. Create account seed phrase To generate your seed phrase enter the following command: tonos-cli genphrase  Terminal displays the generated seed phrase: $ tonos-cli genphrase Config: default Succeeded. Seed phrase: &quot;spoon doll recipe regular list window cage joke stock clown mass glare&quot;  If the deposit account needs to have multiple custodians, each of them has to generate their own seed phrase. 5. Generate public key To generate your public key enter the following command with your previously generated seed phrase in quotes: tonos-cli genpubkey &quot;&lt;seed_phrase&gt;&quot;  If the deposit account needs to have several custodians, each of them should generate their public key and send it to whomever will be deploying the account. $ tonos-cli genpubkey &quot;spoon doll recipe regular list window cage joke stock clown mass glare&quot; Config: default Succeeded. Public key: 352a248222c18d5c87d0e998d3c44ab324d21578f4068028af9b49005d2c9859  6. Generate deployment key pair file Any custodian who has received the public keys of all other custodians can deploy the contract to the blockchain. To create the key pair file from the seed phrase use the following command: tonos-cli getkeypair &lt;deploy.keys.json&gt; &quot;&lt;seed_phrase&gt;&quot;  deploy.keys.json - the file the key pair will be written to. The utility generates the file that contains the key pair produced from seed phrase. $ tonos-cli getkeypair deploy.keys.json &quot;spoon doll recipe regular list window cage joke stock clown mass glare&quot; Config: default Input arguments: key_file: deploy.keys.json phrase: spoon doll recipe regular list window cage joke stock clown mass glare Succeeded.  7. Generate account address Use deployment key pair file to generate your address: tonos-cli genaddr SafeMultisigWallet.tvc SafeMultisigWallet.abi.json --setkey &lt;deploy.keys.json&gt;  deploy.keys.json - the file the key pair is read from. The utility displays the new deposit account address (Raw address). $ tonos-cli genaddr SafeMultisigWallet.tvc SafeMultisigWallet.abi.json --setkey deploy.keys.json Config: default Input arguments: tvc: SafeMultisigWallet.tvc wc: None keys: deploy.keys.json init_data: None is_update_tvc: None Raw address: 0:703546ac78f2b9d58f1072d131ff9fc23f29aeddcc85fd30bcba64f475b306a2 testnet: Non-bounceable address (for init): 0QBwNUasePK51Y8QctEx_5_CPymu3cyF_TC8umT0dbMGot4F Bounceable address (for later access): kQBwNUasePK51Y8QctEx_5_CPymu3cyF_TC8umT0dbMGooPA mainnet: Non-bounceable address (for init): UQBwNUasePK51Y8QctEx_5_CPymu3cyF_TC8umT0dbMGomWP Bounceable address (for later access): EQBwNUasePK51Y8QctEx_5_CPymu3cyF_TC8umT0dbMGojhK Succeeded  8. Send tokens to the new address from another account Before deployment, an account needs to be sponsored with a small amount of tokens. You may use any convenient method to send tokens to the calculated address. For example, sending tokens from multisig wallets through TONOS-CLI is described here. Note, that if the wallet has multiple custodians, the transaction may require confirmation from the other custodians. 9. Deploy the contract to blockchain Use the following command: tonos-cli deploy SafeMultisigWallet.tvc '{&quot;owners&quot;:[&quot;0x...&quot;, ...],&quot;reqConfirms&quot;:N}' --abi SafeMultisigWallet.abi.json --sign &lt;deploy_seed_or_keyfile&gt;  Configuration parameters: owners - array of custodian public keys generated by all account custodians at step 5 as uint256 numbers. Make sure all public keys are enclosed in quotes and start with 0x.... Example of how to specify custodian keys: &quot;owners&quot;:[&quot;0x8868adbf012ebc349ced852fdcf5b9d55d1873a68250fae1be609286ddb962582&quot;,&quot;0xa0e16ccff0c7bf4f29422b33ec1c9187200e9bd949bb2dd4c7841f5009d50778a&quot;]  reqConfirms - number of signatures needed to confirm a transaction ( 0 &lt; N ≤ custodian count). For accounts with a single custodian set reqConfirms:1 deploy_seed_or_keyfile - can either be the seed phrase used in step 6 to generate the deployment key pair file or the deploy.keys.json file itself. If seed phrase is used, enclose it in double quotes. Example: $ tonos-cli deploy --sign deploy.keys.json --abi SafeMultisigWallet.abi.json SafeMultisigWallet.tvc '{&quot;owners&quot;:[&quot;0x88c541e9a1c173069c89bcbcc21fa2a073158c1bd21ca56b3eb264bba12d9340&quot;],&quot;reqConfirms&quot;:1}' Config: /home/user/tonos-cli.conf.json Input arguments: tvc: SafeMultisigWallet.tvc params: {&quot;owners&quot;:[&quot;0x88c541e9a1c173069c89bcbcc21fa2a073158c1bd21ca56b3eb264bba12d9340&quot;],&quot;reqConfirms&quot;:1} abi: SafeMultisigWallet.abi.json keys: deploy.keys.json wc: 0 Connecting to net.ton.dev Deploying... Transaction succeeded. Contract deployed at address: 0:703546ac78f2b9d58f1072d131ff9fc23f29aeddcc85fd30bcba64f475b306a2  Using SDK​ You may integrate above described process of deposit account deployment into your exchange backend. The functionality is supported in SDK. A sample is available in this repository and an overview is given below. Bindings for a large number of languages have been developed for SDK. Note, that similar to the TONOS-CLI approach described above, you have to sponsor a deposit account before deploying contract code. The sample requires you to input the data for a preexisting multisig account on the developer network to server as a giver. The recommended SafeMultisig contract is used. async function main(client) { // Сonfigures the specified multisig wallet as a wallet to sponsor deploy operation // Read more about deploy and other basic concepts here https://ton.dev/faq/blockchain-basic const giver = await ensureGiver(client); console.log(&quot;Generate new wallet keys&quot;); const walletKeys = await client.crypto.generate_random_sign_keys(); const wallet = await getAccount(client, SafeMultisigContract, signerKeys(walletKeys)); const walletAddress = wallet.address; const startBlockTime = seconds(Date.now()); console.log(`Sending deploy fee from giver wallet ${giver.address} to the new wallet at ${walletAddress}`); await depositAccount(walletAddress, 2000000000, client); console.log(`Deploying new wallet at ${walletAddress}ions await deployAccount(wallet, { owners: [`0x${walletKeys.public}`], // constructor parameters of multisig reqConfirms: 1, }); console.log(&quot;Depositing 2 tokens...&quot;); await depositAccount(walletAddress, 2000000000, client); const giverAddress = await giver.address; console.log(`Withdrawing 2 tokens from ${wallet.walletAddress} to ${giverAddress}...`); await walletWithdraw(wallet, giverAddress, 1000000000); console.log(`Transactions for ${walletAddress} account since ${startBlockTime}`); let result = await queryAccountTransactions(client, walletAddress, { startTime: startBlockTime, // endTime: endBlockTime, // You can set an upper time boundary @endTime to 2 minutes before now – to avoid data eventually consistency. }); const countLimit = 200; let count = 0; while (count &lt; countLimit &amp;&amp; result.transactions.length &gt; 0) { for (const transaction of result.transactions) { printTransfers(transaction); count += 1; } result = await queryAccountTransactions(client, walletAddress, { after: result.last, }); } console.log(`Transactions of all accounts since ${startBlockTime}`); result = await queryAllTransactions(client, { startTime: startBlockTime, endTime: seconds(Date.now()) - 20, // we use 20 so that we catch the transactions generated in this sample. Replace with 120. }); count = 0; while (count &lt; countLimit &amp;&amp; result.transactions.length &gt; 0) { for (const transaction of result.transactions) { printTransfers(transaction); count += 1; } result = await queryAllTransactions(client, { after: result.last, endTime: seconds(Date.now()) - 20 }); } }  ###Monitoring Deposit Account An exchange needs to reliably know when customers deposit funds into its exchange accounts. This functionality has been integrated into SDK. A sample is available in this repository and an overview of the relevant part is given below. In this sample JS SDK is used. Bindings for a large number of languages have been developed for SDK. The script iterates over all blocks since the specified time and looks for transfers according to the set up filters. Transfers may be filtered by one or all accounts. ... console.log(`Transactions of all accounts since ${startBlockTime}`); result = await queryAllTransactions(client, { startTime: startBlockTime, endTime: seconds(Date.now()) - 20, // we use 20 so that we catch the transactions generated in this sample. Replace with 120. }); count = 0; while (count &lt; countLimit &amp;&amp; result.transactions.length &gt; 0) { for (const transaction of result.transactions) { printTransfers(transaction); count += 1; } result = await queryAllTransactions(client, { after: result.last, endTime: seconds(Date.now()) - 20, // we use 20 so that we catch the transactions generated in this sample. Replace with 120. }); } ...  You may test out the demo application running this process on the developer network by cloning the sdk-samples repository, and running the following commands in the /demo/exchange folder: npm i node index  Prerequisites: latest Node.js ###Withdrawing from deposit accounts The specific function that is used to send the funds to the user depends on the contract chosen for the deposit account. Below are provided the examples for the SafeMultisig contract. Using command line tool​ TONOS-CLI tool may be used to implement withdrawals from deposit account. The simplest way that bypasses any verification and places all risks entirely on the user is to send the full requested amount with a single transfer to the specified address. If the user made a mistake in the address, and has no control over it, these funds will be lost. If the account does not exist, and the user makes mistakes deploying it after the funds are transferred, they may end up being lost as well. To perform a simple transfer to any account, whether it already exists or not, use the following TONOS-CLI command: tonos-cli call &lt;deposit_account_address&gt; submitTransaction '{&quot;dest&quot;:&quot;recipient_address&quot;,&quot;value&quot;:&lt;nanotokens&gt;,&quot;bounce&quot;:false,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;}' --abi SafeMultisigWallet.abi.json --sign &lt;seed_or_keyfile&gt;  &quot;recipient_address&quot; - raw address of the recipient smart contract. Example: &quot;0:f22e02a1240dd4b5201f8740c38f2baf5afac3cedf8f97f3bd7cbaf23c7261e3&quot; &quot;value&quot;:nanotokens - amount of tokens to transfer in nanotokens (Example: &quot;value&quot;:10000000000 sets up a transfer of 10 tokens). &quot;bounce&quot; - use false to transfer funds to any account regardless of whether it exists. &quot;payload&quot; - use &quot;&quot; for simple transfer. &quot;allBalance&quot; - used to transfer all funds in the wallet. Use false for a simple transfer. Note: Due to a bug setting allBalance to true currently causes errors. Single-custodian multisig wallets may use sendTransaction method with flag 130 and value 0 instead: tonos-cli call &lt;multisig_address&gt; sendTransaction '{&quot;dest&quot;:&quot;raw_address&quot;,&quot;value&quot;:0,&quot;bounce&quot;:true,&quot;flags&quot;:130,&quot;payload&quot;:&quot;&quot;}' --abi &lt;MultisigWallet.abi.json&gt; --sign &lt;seed_or_keyfile&gt; &lt;seed_or_keyfile&gt; - can either be the custodian seed phrase or the corresponding custodian key pair file. If seed phrase is used, enclose it in double quotes.  Example: --sign &quot;flip uncover dish sense hazard smile gun mom vehicle chapter order enact&quot;  or --sign keyfile.json  Example: $ tonos-cli call 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc submitTransaction '{&quot;dest&quot;:&quot;0:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;,&quot;value&quot;:234000000,&quot;bounce&quot;:false,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;}' --abi SafeMultisigWallet.abi.json --sign k1.keys.json Config: /home/user/tonos-cli.conf.json Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: submitTransaction params: {&quot;dest&quot;:&quot;0:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;,&quot;value&quot;:234000000,&quot;bounce&quot;:false,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;} abi: SafeMultisigWallet.abi.json keys: k1.keys.json lifetime: None output: None Connecting to net.ton.dev Generating external inbound message... MessageId: c6baac843fefe6b9e8dc3609487a63ef21207e4fdde9ec253b9a47f7f5a88d01 Expire at: Sat, 08 May 2021 14:52:23 +0300 Processing... Succeeded. Result: { &quot;transId&quot;: &quot;6959885776551137793&quot; }  Note, that if your deposit account has multiple custodians, the transaction has to be confirmed by the required number of signatures to be executed. In this case transaction ID will be displayed as transaction result, when creating it. This transaction ID should be communicated to other custodians, who should use it to confirm the transaction. (Optional) Confirm transaction​ To confirm a transaction, use the following command: tonos-cli call &lt;deposit_account_address&gt; confirmTransaction '{&quot;transactionId&quot;:&quot;&lt;id&gt;&quot;}' --abi SafeMultisigWallet.abi.json --sign &lt;seed_or_keyfile&gt;  transactionId – the ID of the transaction can be acquired from the custodian who created it. seed_or_keyfile - can either be the custodian seed phrase or the corresponding custodian key pair file. If seed phrase is used, enclose it in double quotes. Example: --sign &quot;flip uncover dish sense hazard smile gun mom vehicle chapter order enact&quot;  or --sign keyfile.json  Basic checks of the address format will be performed by the TONOS-CLI utility automatically, only addresses of a valid Everscale format will be accepted. Mitigating risks of token loss due to user error**​ The are two main cases regarding transfers to user accounts: a user may already have an active account to which they want to withdraw funds, or they may want to withdraw funds to a completely new account, that doesn't exist at the time withdraw is requested. The status of the account provided by the user may be checked with the following TONOS-CLI command: tonos-cli account &lt;accound_address&gt;  Example of existing account: $ tonos-cli account 0:255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f3 Config: default Input arguments: address: 0:255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f3 Connecting to &lt;https://net.ton.dev&gt; Processing... Succeeded. acc_type: Active balance: 542692817630 last_paid: 1622198835 last_trans_lt: 0x50cef81af04 data(boc): b5ee9c720101020100980001df8534c46f7a135058773fa1298cb3a299a5ddd40dafe41cb06c64f274da360bfb00000179b295c60dc29a6237bd09a82c3b9fd094c659d14cd2eeea06d7f20e583632793a6d1b05fd80000000000000000000000000000000000000000000000000000000000000002020000000001018010045a010a6988def426a0b0ee7f4253196745334bbba81b5fc83960d8c9e4e9b46c17f6010 code_hash: 207dc560c5956de1a2c1479356f8f3ee70a59767db2bf4788b1d61ad42cdad82  Example of account that doesn't exist yet: $ tonos-cli account 0:255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f4 Config: default Input arguments: address: 0:255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f4 Connecting to &lt;https://net.ton.dev&gt; Processing... Succeeded. Account not found.  The possible results are the following: Account not found - account does not exist. It needs to be sponsored, then deployed, and only then will it be active. acc_type: Uninit - account already has some funds on it but contract code has not been deployed yet. User needs to deploy it. acc_type: Active - account already exists, and its code is deployed. In the first to cases, the exchange might first transfer a small portion of the requested amount (~1 EVER) and request that the user deploys their contract. Upon the user's confirmation that the account is deployed, its status may be rechecked, and if it became active, the remaining amount of requested funds may be safely transferred. If the account is already active, a small portion of the requested amount may be transferred to the user, and the user may be asked what amount they received (note: a small amount of the transfer, usually less than 0.05 EVER, will be spent on fees, so it's best to ask for the whole number of tokens transferred). If the amounts match, the rest of the requested funds may be transferred as well. PIN code verification​ Additionally, for users that use the Surf app to store their tokens, PIN code verification is possible. The following TONOS-CLI command may be used to send a transaction with an encrypted PIN code, which the user will be able to see in Surf: tonos-cli multisig send --addr &lt;deposit_account_address&gt; --dest &lt;recipient_address&gt; --purpose &lt;&quot;PIN_code&quot;&gt; --sign &lt;path_to_keys_or_seed_phrase&gt; --value *number*  deposit_account_address - address of the deposit account address that tokens are sent from. recipient_address - address of the account tokens are sent to. &quot;PIN_code&quot; - accompanying message containing the PIN code. Only the recipient will be able to decrypt and read it. should be enclosed in double quotes. path_to_keys_or_seed_phrase - path to sender wallet key file of the corresponding seed phrase in quotes. --value number - value to be transferred (in tokens). Example: $ tonos-cli multisig send --addr 0:255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f3 --dest 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc --purpose &quot;339&quot; --sign key.json --value 6 Config: /home/user/tonos-cli.conf.json Connecting to net.ton.dev Generating external inbound message... MessageId: 62b1420ac98e586f29bf79bc2917a0981bb3f15c4757e8dca65370c19146e327 Expire at: Thu, 13 May 2021 13:26:06 +0300 Processing... Succeeded. Result: { &quot;transId&quot;: &quot;0&quot; }.  Using SDK​ You may integrate withdrawals from deposit account into your backend using SDK as well. A sample is available in this repository and an overview of the relevant part is given below. In this sample JS SDK is used. Bindings for a large number of languages have been developed for SDK. This example shows how to generate a withdrawal transaction from a Multisig wallet, using its sendTransaction method. Note, that if Multisig has multiple custodians, the transaction will have to be confirmed with the confirmTransaction method. You may choose from which account (sender or recipient), the forward fees will be charged. In this example tokens are withdrawn from the deposit account to the giver, that initially sponsored it. In a proper implementation, the account given by user should be used instead. // ... console.log(`Withdrawing 2 tokens from ${wallet.walletAddress} to ${giverAddress}...`); await walletWithdraw(wallet, giverAddress, 1000000000); // ... async function walletWithdraw(wallet, address, amount) { const transactions = await runAndWaitForRecipientTransactions(wallet, &quot;submitTransaction&quot;, { dest: address, value: amount, bounce: false, allBalance: false, payload: &quot;&quot;, }); if (transactions.length &gt; 0) { console.log(`Recipient received transfer. The recipient's transaction is: ${transactions[0].id}`); } } async function runAndWaitForRecipientTransactions(account, functionName, input) { const runResult = await account.client.processing.process_message({ message_encode_params: { address: account.address, abi: account.abi, signer: account.signer, call_set: { function_name: functionName, input, }, }, send_events: false, }); const transactions = []; // This step is only required if you want to know when the recipient actually receives their tokens. // In Everscale blockchain, transfer consists of 2 transactions (because the blockchain is asynchronous): // 1. Sender sends tokens - this transaction is returned by `Run` method // 2. Recipient receives tokens - this transaction can be caught with `query_transaction_tree method` // Read more about transactions and messages here // https://ton.dev/faq/blockchain-basic for (const messageId of runResult.transaction.out_msgs) { const tree = await account.client.net.query_transaction_tree({ in_msg: messageId, }); transactions.push(...tree.transactions); } return transactions; }  User account verification with SDK​ Same as described above, users of the Surf app can be offered additional verification with a PIN code. Below is a snippet of the SDK sample demonstrating how to generate a transaction with an encrypted comment. A PIN code can be transmitted to the user in this comment attached to a small amount of tokens, and only after the user provides the PIN code, thus proving they have access to their account, may the rest of the withdrawal amount be transferred. // Prepare body with comment // For that we need to prepare internal message with transferAbi and then extract body from it const body = (await client.abi.encode_message_body({ abi: abiContract(transferAbi), call_set: { function_name: &quot;transfer&quot;, input: { comment: Buffer.from(&quot;My comment&quot;).toString(&quot;hex&quot;), }, }, is_internal: true, signer: signerNone(), })).body; const multisig = new Account(MultisigContract, { signer: signerKeys(keyPair), client, }); // Run 'submitTransaction' method of multisig wallet // Create run message console.log(&quot;Call `submitTransaction` function&quot;); const transactionInfo = (await multisig.run(&quot;submitTransaction&quot;, { dest: recipient, value: 100_000_000, bounce: false, allBalance: false, payload: body, })); console.log(transactionInfo); console.log(&quot;Transaction info:&quot;); console.log(&quot;Id:&quot;); console.log(transactionInfo.transaction.id); console.log(&quot;messages:&quot;); console.log(transactionInfo.out_messages); const messages = transactionInfo.out_messages; const decodedMessage1 = (await tonClient.abi.decode_message({ abi: abiContract(transferAbi), message: messages[0], })); // Decode comment from hex to string decodedMessage1.value.comment = Buffer.from(decodedMessage1.value.comment, &quot;hex&quot;).toString(&quot;utf8&quot;); console.log(&quot;Decoded message 1:&quot;, decodedMessage1.value); const decodedMessage2 = (await tonClient.abi.decode_message({ abi: abiContract(multisigContractPackage.abi), message: messages[1], })); console.log(&quot;Decoded message 2:&quot;, decodedMessage2);  "},{"title":"Evercloud","type":0,"sectionRef":"#","url":"develop/nodes-clients/evercloud","content":"","keywords":""},{"title":"Evercloud documentation​","type":1,"pageTitle":"Evercloud","url":"develop/nodes-clients/evercloud#evercloud-documentation","content":"The documentation in Everscale repository is a community effort. Therefore, everyone can contribute with proposals for new topics, suggest new content elements, participate in editing, and provide ideas that will be of great help for network development. Please be informed that our documentation can be edited via GitHub. Also please make sure to consult our rules and rewards policy via this link. Feel free to join Everscale Documentation Development Telegram chat and Everscale Developers Onboarding Telegram chat! "},{"title":"Evernode DApp Server (DS)","type":0,"sectionRef":"#","url":"develop/nodes-clients/evernode-ds","content":"Evernode DApp Server (DS) Client Node with GraphQL API that allows you to collect a large amount of data about the network. *Suitable for integration by exchanges and other platforms. Evernode DS is a set of services enabling you to work with Everscale blockchain. The core element of Evernode DS is Everscale node written in Rust focused on performance and safety. Evernode DS provides a set of services serving EVER SDK endpoint: scalable multi-model database ArangoDB with the information about all blockchain entities (like accounts, blocks, transactions, etc.) stored over time, distributed high-throughput, low-latency streaming platform Kafka, Everscale GraphQL Server (aka Q-Server) for serving GraphQL queries to the database and Nginx web-server. This repository contains instructions on how to build and configure your own free instance of Evernode Platform to connect your application to Everscale. You can try to run a core network node yourself using the Evernode DS solution.","keywords":""},{"title":"Overview","type":0,"sectionRef":"#","url":"develop/nodes-clients/overview","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Overview","url":"develop/nodes-clients/overview#introduction","content":"Before you start developing or integrating anything into Everscale, we would like to tell you about the tools and environment that you will use in your work. First of all, it is worth noting that Everscale is really a decentralized blockchain, not only from a technical point of view, but also from a management side, so the key tools and approaches to development may differ from different teams, technical contributors on the network. At the moment, there are two active companies of technical contributors in Everscale network: EverX Broxus And it is their solutions and tools that you will use when developing, while you will have every opportunity to write your own solutions as well, if necessary or desired. "},{"title":"Solutions for configuring and running nodes​","type":1,"pageTitle":"Overview","url":"develop/nodes-clients/overview#solutions-for-configuring-and-running-nodes","content":"Evernode DS(by EverX) - Client Node with GraphQL API that allows you to collect a large amount of data about the network. *Suitable for integration by exchanges and other platforms. Ever Cloud (by EverX) - provides Everscale developers with services on top of scalable blockchain infrastructure, so that developers can focus on business logic instead of infrastructure maintenance. TON Wallet API(by Broxus) - a non-validating node with a built-in wallet for convenient integration with exchanges and other projects. TON Kafka Producer(by Broxus) - a non-validating node that writes blockchain data to Kafka. It can be used for further work with data in the required format and location. This node is lighter than Evernote DS. TON Indexer(by Broxus) - the solution is in the form of RUST libraries for building your own variation of the Everscale node. For example, with the help of this solution, nodes TON Wallet API, TON Kafka Producer and a number of other nodes are made. "},{"title":"TON Indexer","type":0,"sectionRef":"#","url":"develop/nodes-clients/ton-inderxer","content":"TON Indexer Via following this link you will get familiar with a simple and reliable indexer node. It is a simplified, refactored and optimized version of ton-labs-node and would not have been implemented without their gigantic work of reverse engineering the original С++ node. The documentation in Everscale repository is a community effort. Therefore, everyone can contribute with proposals for new topics, suggest new content elements, participate in editing, and provide ideas that will be of great help for network development. Please be informed that our documentation can be edited via GitHub. Also please make sure to consult our rules and rewards policy via this link. Feel free to join Everscale Documentation Development Telegram chat and Everscale Developers Onboarding Telegram chat!","keywords":""},{"title":"TON Kafka Producer","type":0,"sectionRef":"#","url":"develop/nodes-clients/ton-kafka","content":"TON Kafka Producer Please follow this link in order to get familiar with the easy to comprehend service that will help you stream Everscale data into Kafka. For maximum ease, a configuration example is as well provided. The documentation in Everscale repository is a community effort. Therefore, everyone can contribute with proposals for new topics, suggest new content elements, participate in editing, and provide ideas that will be of great help for network development. Please be informed that our documentation can be edited via GitHub. Also please make sure to consult our rules and rewards policy via this link. Feel free to join Everscale Documentation Development Telegram chat and Everscale Developers Onboarding Telegram chat!","keywords":""},{"title":"Everscale Wallet API","type":0,"sectionRef":"#","url":"develop/nodes-clients/ton-wallet-api","content":"","keywords":""},{"title":"Using the Everscale Wallet API​","type":1,"pageTitle":"Everscale Wallet API","url":"develop/nodes-clients/ton-wallet-api#using-the-everscale-wallet-api","content":""},{"title":"1. Brief description​","type":1,"pageTitle":"Everscale Wallet API","url":"develop/nodes-clients/ton-wallet-api#1-brief-description","content":"This API guide is intended to explain how to send and track transactions with the help of Ever Wallet. The wallet tracks addresses from the database and indexes all transactions, storing the information about them in the postgres DB. All transactions with native EVERs are tracked, and there is a whitelist of Root Token addresses to be tracked in the settings. There is a Callbacks Table in the database, where you can specify the URL of your backend to which callbacks will come for all transactions. It takes about 40 minutes to synchronize the node. Both the Ton-Wallet-API and callback requests use HMAC signatures in the headers. "},{"title":"2. Setup​","type":1,"pageTitle":"Everscale Wallet API","url":"develop/nodes-clients/ton-wallet-api#2-setup","content":"You need postgres11 + a dedicated server to work CPU: 4 cores, 2 GHz RAM: 8 GB Storage: 200 GB fast SSD Network: 100 MBit/s Follow the instructions from the Readme https://github.com/broxus/ever-wallet-apiCreate yourself a &quot;system address&quot; by calling /address/create with empty parameters. The response will return an EVER address. It is necessary to send EVERs to it, which will be consumed as gas for further work.In the table api_service_callback we enter the address of our backend, which will deal with transaction processing.Configure token whitelist: You can see the Root-Contract addresses at https://raw.githubusercontent.com/broxus/ton-assets/master/manifest.json. By default, the whitelist already includes all the tokens in this list. To add more tokens to the whitelist use the script below:  ./scripts/root_token.sh -t native --database-url ${DATABASE_URL} --name ${TOKEN_NAME} --address ${TOKEN_ADDRESS}  DATABASE_URL - Postgres connection url (example: postgresql://postgres:postgres@127.0.0.1/ton_wallet_api)TOKEN_NAME - Token name (example: WEVER)TOKEN_ADDRESS - Token address (example: 0:0ee39330eddb680ce731cd6a443c71d9069db06d149a9bec9569d1eb8d04eb37) "},{"title":"3. Transfer EVER​","type":1,"pageTitle":"Everscale Wallet API","url":"develop/nodes-clients/ton-wallet-api#3-transfer-ever","content":"{ // To create a transaction you will need a sender's address. For example, your system address. &quot;fromAddress&quot;: &quot;0:0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;bounce&quot;: false, // a random uuid that you generate for yourself and store it on your backend to further track the status of the transaction &quot;ID&quot;: &quot;00000000-0000-0000-0000-000000000000&quot;, &quot;outputs&quot;: [ { // How many EVERs to send. To send 1 EVER this value = 1000000000 &quot;value&quot;: &quot;1000000000&quot; // Set Normal to deduct the number of sent EVERs from the value &quot;outputType&quot;: &quot;Normal&quot;, // Recipient address of EVERs &quot;recipientAddress&quot;: &quot;0:0000000000000000000000000000000000000000000000000000000000000000&quot;, } ] }  Or use the script: # Create transaction API_KEY=${API_KEY} SECRET=${API_SECRET} HOST=${HOST} \\ ./scripts/wallet.sh -m create_transaction \\ --src-addr {sender} --dst-addr {recipient} --amount {amount}  You can track the status of a transaction via the following two ways: The recommended way is via callback AccountTransactionEvent, which has transactionStatus field: Expired - end state for failed transactions, Done - final state for successful transactions.  If your backend was disabled during the callback or responded with an error, the event will have an Error state. In this case you should query all events /events in Error state at backend startup, process them and give each event a Done state by calling /events/mark. The second way is by polling the GET method /transactions/id/&lt;uuid&gt; "},{"title":"4. How to process a transaction from a user on the backend​","type":1,"pageTitle":"Everscale Wallet API","url":"develop/nodes-clients/ton-wallet-api#4-how-to-process-a-transaction-from-a-user-on-the-backend","content":"We generate a deposit address for the user by calling /address/create with empty parameters. After receiving the transaction, the backend receives a callback of the form AccountTransactionEvent (see swagger). You can also get such events in a list, using the /events method. To merge tokens to the system address, you can use the /tokens/transactions/create method in such a callback (see &quot;5. Token Transfer.&quot;)If your backend was not working at the time of the callback or responded with an error, the event will have an Error status. "},{"title":"5. Token transfer​","type":1,"pageTitle":"Everscale Wallet API","url":"develop/nodes-clients/ton-wallet-api#5-token-transfer","content":"First, check the status and balance of the address you want to send tokens from by making a GET request to /address/{string}The address you are sending tokens from must have at least 0.6 EVER (balance &gt;= 600000000), if the balance is not enough, top it up (see &quot;3. Transfer EVER&quot; ) To transfer tokens, use the method /tokens/transactions/create { // Sender &quot;fromAddress&quot;: &quot;string&quot;, // Receiver &quot;recipientAddress&quot;: &quot;string&quot;, // The number of tokens with decimals. For example, for transferring 1 USDT this value = &quot;1000000&quot; &quot;value&quot;: &quot;1000000&quot; // How many EVERs to apply. The default recommended value is 0.5 EVER. The funds will be debited fromAddress. &quot;fee&quot;: &quot;5000000000&quot;, // The address to which to return the remaining EVERs. For example, your system address. &quot;sendGasTo&quot;: &quot;string&quot;, // A random uuid that you generate yourself and store on your backend to further track the status of the transaction &quot;id&quot;: &quot;00000000-0000-0000-0000-000000000000&quot;, // Token Address. (see https://raw.githubusercontent.com/broxus/ton-assets/master/manifest.json) &quot;rootAddress&quot;: &quot;string&quot;, }  Or use the script:  # Create token transaction API_KEY=${API_KEY} SECRET=${API_SECRET} HOST=${HOST} \\ ./scripts/wallet.sh -m create_token_transaction \\ --src-addr {sender} --dst-addr {recipient} \\ --root-addr {root_token_address} --amount {amount}  You can track the status of a transaction with: 1) (Recommended way) via callback AccountTransactionEvent, which has transactionStatus field: expired - end state for failed transactions,done - final state for successful transactions.  If your backend was disabled during the callback or responded with an error, the event will have an Error state. In this case you should query all events /events in Error state at backend startup, process them and give each event a Done state by calling /events/mark. 2) by polling the GET method /transactions/id/&lt;uuid&gt; "},{"title":"C/C++ Compiler","type":0,"sectionRef":"#","url":"develop/smart-contract/cpp-developing/compiler","content":"C/C++ Compiler The code we wrote so far can be found at Hello, world!. Let’s assume that we put the contract interface into HelloWorld.hpp and its implementation into HelloWorld.cpp. Compilation consist of two steps: Generating the ABI clang++ -target tvm --sysroot=$TVM_INCLUDE_PATH -export-json-abi -o HelloWorld.abi HelloWorld.cpp Compiling and linking tvm-build++.py --abi HelloWorld.abi HelloWorld.cpp --include $TVM_INCLUDE_PATH --linkerflags=&quot;--genkey key&quot; The first command produces the ABI file. Note that in case the contract uses an unsupported type, clang will silently generate &quot;unknown&quot; for it in the ABI and the contract will not link. The second command compiles and links the contract. It produces address.tvc file and the file named “key”. Option --genkey produces keys to sign messages and store them to specified files (filename - for the private key and filename.pub for the public one). Currently all external messages have to be signed, otherwise an error number 40 will occur, so we need a key to sign if we plan to test a contract locally.","keywords":""},{"title":"Samples","type":0,"sectionRef":"#","url":"develop/smart-contract/cpp-developing/samples","content":"Samples Testing in the network is somewhat similar to testing locally, but instead of the linker tonos-cli needs to be used and argument passing is a bit different. The deploying workflow is described in README but we will repeat it once again here. First, we need to recompile the contract since we used for linker tests. Then copy newly generated tvc file (and rename it to HelloWorld.tvc for simplicity) and abi file to tonos-cli/target/&lt;debug or release&gt;/ After all the preparations, we can execute the following script cd tonos-cli/target/&lt;debug or release&gt;/ cargo run genaddr HelloWorld.tvc HelloWorld.abi --genkey hw.key The latter command returns the raw address of the contract. Now you can send (test) coins to it using any method described in README. When contract balance is greater than 0, we can deploy the contract: cargo run deploy --abi HelloWorld.abi HelloWorld.tvc '{}' --sign hw.key And finally test hello_world method: cargo run call –abi HelloWorld.abi &quot;&lt;raw address&gt;&quot; hello_world &quot;{}&quot; --sign hw.key The command is supposed to output the message ending with Succeded. Result = {&quot;output&quot;:{&quot;value0&quot;:&quot;0x2a&quot;}} ","keywords":""},{"title":"Getting started","type":0,"sectionRef":"#","url":"develop/smart-contract/cpp-developing/getting-started","content":"","keywords":""},{"title":"You will need:​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/cpp-developing/getting-started#you-will-need","content":"A PC or laptop with a basic set of developer tools(Recommended: Ubuntu 18.04) LinuxWindowsMacOSA Solidity to TVM assembly compiler(Recommended) build from sourcesdownload as a binaryrun in a docker containerContract code in SolidityUse Wallet.sol belowUse your own codeTake one of the samples from the samples repositoryUtilities to link and deploy contract to the blockchainbuild from sourcesdownload as a binaryrun in a docker container "},{"title":"Recommended setup​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/cpp-developing/getting-started#recommended-setup","content":"OS: Ubuntu 18.04 is the easiest to run.tip: running Ubuntu in VM works fine. Check out this install guide.Build Solidity compiler from the source (4-6 minutes)checkout from github (a few seconds);install dependencies as per README (1-2 minutes)build the compiler from source per README (~3-5 minutes)Contract source code:Use Wallet.sol belowCommand line tools, either of:download as a part of a binary packagebuild tvm_linker and tonos-cli from sources "},{"title":"Install the Compiler​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/cpp-developing/getting-started#install-the-compiler","content":"Install EverDev Solidity Compiler from the open source repository. git clone git@github.com:tonlabs/TON-Solidity-Compiler.git cd compiler sh ./scripts/install_deps.sh mkdir build cd build cmake .. -DUSE_CVC4=OFF -DUSE_Z3=OFF -DTESTS=OFF -DCMAKE_BUILD_TYPE=Debug make -j8  Get the contract source code pragma solidity &gt;= 0.6.0; /// @title Simple wallet /// @author Tonlabs contract Wallet { // Modifier that allows function to accept external call only if it was signed // with contract owner's public key. modifier checkOwnerAndAccept { // Check that inbound message was signed with owner's public key. // Runtime function that obtains sender's public key. require(msg.pubkey() == tvm.pubkey(), 100); // Runtime function that allows contract to process inbound messages spending // its own resources (it's necessary if contract should process all inbound messages, // not only those that carry value with them). tvm.accept(); _; } /* * Public functions */ /// @dev Contract constructor. constructor() public checkOwnerAndAccept { } /// @dev Allows to transfer grams to the destination account. /// @param dest Transfer target address. /// @param value Nanograms value to transfer. /// @param bounce Flag that enables bounce message in case of target contract error. function sendTransaction(address payable dest, uint128 value, bool bounce) public view checkOwnerAndAccept { // Runtime function that allows to make a transfer with arbitrary settings. dest.transfer(value, bounce, 3); } // Function to receive plain transfers. receive() external payable { } }  "},{"title":"Compile​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/cpp-developing/getting-started#compile","content":"Compile the contract code to TVM assembler with the Solidity Compiler. &lt;PATH_TO&gt;/TON-Solidity-Compiler/compiler/build/solc/solc Wallet.sol  The compiler produces Wallet.code and Wallet.abi.json to be used in the following steps. Assemble and link with a standard library into TVM bytecode: &lt;PATH_TO&gt;/tvm_linker compile Wallet.code --lib &lt;path-to&gt;/TON-Solidity-Compiler/lib/stdlib_sol.tvm  Binary code of your contract is recorded into&lt;WalletAddress&gt;.tvcfile, where&lt;WalletAddress&gt;is a temporary address of the contract. Deploy Let's deploy the contract to TON Labs development blockchain atnet.ton.dev. 1) Make sure tonos-cli is in $PATH: export PATH=$PATH:&lt;PATH_TO&gt;/tonos-cli tonos-cli config --url net.ton.dev  2) Generate address, keys and seed phrase for your contract: tonos-cli genaddr &lt;WalletAddress&gt;.tvc Wallet.abi.json --genkey Wallet.keys.json  Address of your contract in the blockchain is located after Raw address: IMPORTANT: Save this value - you will need it to deploy your contract and to work with it. We will refer to it as &quot;YourAddress&quot; below. Seed phrase is also printed to stdout. Key pair will be generated and saved to the file Wallet.keys.json. Note that you will need to send some coins to the address before the actual deployment. EVER deploy is fee-based, so your new contract will be charged for this. 3) Get some [test] coins to your account. Options are: ask a friend to sponsor your contract deployment;transfer some currency from your wallet account;ask in developer chats. 4) Check the state of the pre-deployed contract. It should be Uninit: tonos-cli account &lt;YourAddress&gt;  5) Deploy your contract to the selected network (TON Labs devnet in the example) with the following command: tonos-cli deploy --abi Wallet.abi.json --sign Wallet.keys.json &lt;contract&gt;.tvc {&lt;constructor_arguments&gt;}  If either of --abi or --sign options is omitted in parameters, it must be specified in the config file. See below. 6) Check the contract state again. This time, it is should be active. 7) Call the function of your contract: tonos-cli call '&lt;YourAddress&gt;' sendTransaction '{&quot;dest&quot;:&quot;DestAddress&quot;, &quot;value&quot;:1000000000, &quot;bounce&quot;:true}' --abi Wallet.abi.json --sign Wallet.keys.json  "},{"title":"Further Steps​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/cpp-developing/getting-started#further-steps","content":"Now your contract is up and running! You can: Check out Solidity API for EVERCheck out more contract samplesExplore in depth some aspects of smart-contract development for EVERBuild CLI utilities from source in GitHub to make sure you have the latest versionCheck our research papers and EVER docs in readable format "},{"title":"DeBrowser","type":0,"sectionRef":"#","url":"develop/smart-contract/debots/debrowser","content":"","keywords":""},{"title":"Version​","type":1,"pageTitle":"DeBrowser","url":"develop/smart-contract/debots/debrowser#version","content":"This command shows the list of available versions. everdev debrowser version Available Versions: 1.1.0, 1.2.0, 1.2.1, 1.3.1  "},{"title":"Interfaces​","type":1,"pageTitle":"DeBrowser","url":"develop/smart-contract/debots/debrowser#interfaces","content":"This command shows the list of implemented interfaces. everdev debrowser interfaces Realised interfaces: - Address Input - Amount Input - Confirm Input - Menu - Network - Number Input - QR Code - Signing Box Input - Terminal - User Info  "},{"title":"Start​","type":1,"pageTitle":"DeBrowser","url":"develop/smart-contract/debots/debrowser#start","content":"This command downloads image and starts DeBrowser container (Docker must be launched). everdev debrowser start 1.3.1  "},{"title":"Stop​","type":1,"pageTitle":"DeBrowser","url":"develop/smart-contract/debots/debrowser#stop","content":"This command stops DeBrowser container. everdev debrowser stop  "},{"title":"DInterfaces","type":0,"sectionRef":"#","url":"develop/smart-contract/debots/deinterfaces","content":"","keywords":""},{"title":"DeBot-IS-consortium​","type":1,"pageTitle":"DInterfaces","url":"develop/smart-contract/debots/deinterfaces#debot-is-consortium","content":"DeBot Interface Specifications (IS) Consortium. IS a place where community defines interfaces every DeBot browser should support. DeBot-IS-consortium repository "},{"title":"Application Rules:​","type":1,"pageTitle":"DInterfaces","url":"develop/smart-contract/debots/deinterfaces#application-rules","content":"Each new interface must create a folder, which has a readme.md desciption of an interface, example of its implementaion in both Solidity and C++ placed in an &quot;examples&quot; sub folder. "},{"title":"Interface submission proccess:​","type":1,"pageTitle":"DInterfaces","url":"develop/smart-contract/debots/deinterfaces#interface-submission-proccess","content":"You should create a specifications proposal, discuss it.After the discussion is over and proposal is accepted you should submit examples in both Solidity and C++.Only proposals with examples will be published. "},{"title":"Supported browsers:​","type":1,"pageTitle":"DInterfaces","url":"develop/smart-contract/debots/deinterfaces#supported-browsers","content":"If you implemented a DeBot browser we will be happy to list it. Please let us know.Your browser should clearly state interfaces which it supports (by version number as stated in repository). "},{"title":"Getting started","type":0,"sectionRef":"#","url":"develop/smart-contract/debots/getting-started","content":"","keywords":""},{"title":"What is a DeBot?​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/debots/getting-started#what-is-a-debot","content":"DeBot (Decentralized Bot) is an intuitive, no-prior-knowledge-required interface for interacting with smart contracts on Everscale Blockchain. Blockchain technology is complex and can be hard to learn for users without prior experience with it. With DeBots, our goal is twofold: simplify user's experience with the blockchain, and streamline the development process of blockchain-based services. It should be noted that this is achieved by maintaining the highest level of security. At its most basic, a DeBot is a secure chat-based interface that allows a user to interact with a smart contract on the blockchain and access its various functions in the form of a dialogue. "},{"title":"Basic terms​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/debots/getting-started#basic-terms","content":"DeBot — a smart contract facilitating conversation-like communication flow with a target smart contract.Target smart contract — the smart contract for which a DeBot is created. The DeBot is an interface to this smart contract.DeBot browser — a program that executes the DeBot and parses its answer using DeBot protocol.DeBot protocol — a set of rules describing the communication between a browser and the DeBot. Namely, it describes how to call DeBot functions and interpret its answers. Debots are deployed on the Everscale blockchain and the browser is being managed by the user. The code is simply downloaded and runs inside the engine. "},{"title":"DeBot interfaces​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/debots/getting-started#debot-interfaces","content":"To fulfill their functions as a user's interface, DeBots must be able to facilitate a number of interactions between the user, the user's device and the target smart contract on the blockchain: receive input from users;query info about other smart contracts;query transactions and messages;receive data from external subsystems (like file systems) and external devices (like NFC, camera and so on);call external function libraries that allow you to do operations that are not supported by VM. For example, work with json, convert numbers to string and vice versa, encrypt/decrypt/sign data. These needs are covered in various DeBot Interfaces (DInterfaces) which can be used in DeBots and which must be supported in DeBot Browsers. To use an interface, the DeBot should import a source file with the DInterface declaration and call its methods like any other smart contract methods in Everscale — by sending internal messages to an interface address, which is unique and explicitly defined for every interface. Every DInterface must be discussed and accepted by DeBot Interface Specifications (DIS) Consortium before it can be used in DeBots. All accepted interfaces are published by DeBot Interface Specifications Consortium. "},{"title":"Prerequisites​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/debots/getting-started#prerequisites","content":"To build DeBots install everdev: npm install -g everdev  To run and debug DeBots install tonos-cli: note For run DeBots required tonos-cli version &gt;= 0.11.4. Install using everdev: npx everdev tonos-cli install  or npx everdev tonos-cli set --version 0.26.2  Or download binaries from here: LinuxMacOSWindows http://sdkbinaries.tonlabs.io/tonos-cli-0_26_2-linux.zip "},{"title":"DeBots​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/debots/getting-started#debots","content":"Hello — Hello World DeBot. Can be used as a template for new DeBots.Multisig — DeBot for multi-signature wallet (multisig). Uses several basic DeBot interfaces: Terminal, AddressInput, AmountInput, ConfirmInput. It supports all functions of the multisig wallet contract, such as submitting and confirming transactions and viewing wallet information.DEvergence — DeBot for the Ever Surf App which the user employs to connect to a Tezos wallet and transact. DeBots are smart contracts with a chat interface similar to those on Telegram. "},{"title":"How to try DeBot​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/debots/getting-started#how-to-try-debot","content":"You can start by trying out multisig DeBot. It's already deployed to net.ever.live and can be called through any DeBot browser that supports it. To try it out in Ever Surf, go to https://ever.surf/ or in tonos-cli call: "},{"title":"DeBot DEvergence​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/debots/getting-started#debot-devergence","content":"tonos-cli config --url eri01.net.everos.dev tonos-cli debot fetch 0:38a53a8bff83c57b6334f369d5ff678bdaa2b8e229d9b5552dfdda2b4d90cf92  or in Ever Surf 0:38a53a8bff83c57b6334f369d5ff678bdaa2b8e229d9b5552dfdda2b4d90cf92 "},{"title":"DeBot Multisig​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/debots/getting-started#debot-multisig","content":"tonos-cli config --url eri01.net.everos.dev tonos-cli debot fetch 0:c69a0ed4a11b467ec1a981f29139dc3ff6af47eeacd2cd93e67a6cfc6f771cfb  or in Ever Surf 0:c69a0ed4a11b467ec1a981f29139dc3ff6af47eeacd2cd93e67a6cfc6f771cfb If you do not have a multisig wallet to try it out with, you can use the following test wallet address and seed phrase: address: 0:66e01d6df5a8d7677d9ab2daf7f258f1e2a7fe73da5320300395f99e01dc3b5f seed phrase: final axis aware because grace sort giant defy dragon blouse motor virus  Please don't empty out its balance, so others can try it out too. "},{"title":"Debugging","type":0,"sectionRef":"#","url":"develop/smart-contract/debugging","content":"Debugging This article has TO DO status. You can contribute by submitting your own version of this page. More details on the Documentation page of the Hot streams section.","keywords":""},{"title":"Samples","type":0,"sectionRef":"#","url":"develop/smart-contract/debots/samples","content":"","keywords":""},{"title":"Simple DeBot application​","type":1,"pageTitle":"Samples","url":"develop/smart-contract/debots/samples#simple-debot-application","content":"Referenced page: https://github.com/tonlabs/debots/blob/main/simple-todo-app/README.md This is an example of a simple TODO application. The application consists of two contracts: todoDebot.sol, contract of DeBottodo.sol, smart contract containing TODO list "},{"title":"How to try DeBot in the Surf​","type":1,"pageTitle":"Samples","url":"develop/smart-contract/debots/samples#how-to-try-debot-in-the-surf","content":"This DeBot is already deployed on blockchain Devnet​ DeBot address: 0:20c3279225a285dfef71efe97f67e823513068b36e79d5fc669899389f89382f Open the link: https://uri.ever.surf/debot/0:20c3279225a285dfef71efe97f67e823513068b36e79d5fc669899389f89382f?net=devnet  Mainnet​ DeBot address: 0:73a7ba235ac26029574f0e053b3f25ba4d536b8ba2c8dd5d10fb266c9035bc36 Open the link: https://uri.ever.surf/debot/0:73a7ba235ac26029574f0e053b3f25ba4d536b8ba2c8dd5d10fb266c9035bc36  On the first launch DeBot deploys TODO contract with initial balance = 0.2 ever tokens, so you need to have a Surf wallet with positive balance. DeBot will ask for your public key every time you launch it. It's inconvenient, but inevitable for now. "},{"title":"How to build​","type":1,"pageTitle":"Samples","url":"develop/smart-contract/debots/samples#how-to-build","content":"Prerequisites​ npm, node.js ver&gt;=14 Install everdev globally $ npm i everdev -g $ everdev tonos-cli install  Compile​ $ everdev sol compile todo.sol $ everdev sol compile todoDebot.sol  "},{"title":"How to deploy​","type":1,"pageTitle":"Samples","url":"develop/smart-contract/debots/samples#how-to-deploy","content":"if you use Evernode SE: $ everdev se start $ ./deploy_debot.sh todoDebot.tvc  if you use net.everos.dev: set GIVER_ADDRESS variable in deploy_debot.shedit ../giver.keys.json respectively $ ./deploy_debot.sh todoDebot.tvc https://net.ton.dev  "},{"title":"Run DeBot​","type":1,"pageTitle":"Samples","url":"develop/smart-contract/debots/samples#run-debot","content":"Find instructions here: How to try-DeBot "},{"title":"TODO​","type":1,"pageTitle":"Samples","url":"develop/smart-contract/debots/samples#todo","content":"Encrypt data before saving to contract "},{"title":"Hello World DeBot​","type":1,"pageTitle":"Samples","url":"develop/smart-contract/debots/samples#hello-world-debot","content":"Referenced page: https://github.com/tonlabs/debots/blob/main/helloworld/README.md Can be used as a template for new DeBots. "},{"title":"How to build​","type":1,"pageTitle":"Samples","url":"develop/smart-contract/debots/samples#how-to-build-1","content":"everdev sol compile helloDebot.sol  "},{"title":"How to deploy to TON OS SE​","type":1,"pageTitle":"Samples","url":"develop/smart-contract/debots/samples#how-to-deploy-to-ton-os-se","content":"Start TON OS SE everdev se start  Deploy debot ./deploy_debot.sh  "},{"title":"How to run in TON OS SE​","type":1,"pageTitle":"Samples","url":"develop/smart-contract/debots/samples#how-to-run-in-ton-os-se","content":"./tonos-cli --url http://127.0.0.1 debot fetch &lt;address&gt;  "},{"title":"Multisig Debot​","type":1,"pageTitle":"Samples","url":"develop/smart-contract/debots/samples#multisig-debot","content":"Referenced page: https://github.com/tonlabs/debots/tree/main/multisig Allows to manage wallet with multiple custodians. "},{"title":"Supported Wallets​","type":1,"pageTitle":"Samples","url":"develop/smart-contract/debots/samples#supported-wallets","content":"SafeMultisigWalletSetcodeMultisigWallet "},{"title":"How to build​","type":1,"pageTitle":"Samples","url":"develop/smart-contract/debots/samples#how-to-build-2","content":"everdev sol compile msigDebotv1.sol  "},{"title":"How to deploy to TON OS SE​","type":1,"pageTitle":"Samples","url":"develop/smart-contract/debots/samples#how-to-deploy-to-ton-os-se-1","content":"Start TON OS SE everdev se start  Run script ./deploy_debot.sh  "},{"title":"How to run in TON OS SE​","type":1,"pageTitle":"Samples","url":"develop/smart-contract/debots/samples#how-to-run-in-ton-os-se-1","content":"./tonos-cli --url http://127.0.0.1 debot fetch &lt;address&gt;  "},{"title":"Run Multisig DeBot in mainnet​","type":1,"pageTitle":"Samples","url":"develop/smart-contract/debots/samples#run-multisig-debot-in-mainnet","content":"using tonos-cli​ ./tonos-cli --url main.ton.dev debot fetch 0:09403116d2d04f3d86ab2de138b390f6ec1b0bc02363dbf006953946e807051e  How to create invoke message for Msig DeBot​ Run script .invoke_msg.sh with debot arguments. Run script .invoke_msg.sh without arguments for help. Example: ./invoke_msg.sh 0:606545c3b681489f2c217782e2da2399b0aed8640ccbcf9884f75648304dbc77 1000000000 true  "},{"title":"Surf Auth DeBot​","type":1,"pageTitle":"Samples","url":"develop/smart-contract/debots/samples#surf-auth-debot","content":"Referenced page: https://github.com/tonlabs/debots/tree/main/auth This DeBot can be used in &quot;Sign Up&quot; / &quot;Sign In&quot; flows as well as in the case when an already registered user wants to link his Surf account. "},{"title":"Disclaimer​","type":1,"pageTitle":"Samples","url":"develop/smart-contract/debots/samples#disclaimer","content":"This code is still experimental, do not use it in production. "},{"title":"Workflow​","type":1,"pageTitle":"Samples","url":"develop/smart-contract/debots/samples#workflow","content":"Web server generates: one time password (OTP)PIN (optionally)callback_urlwarning_text Web server: generates QR-code with a deeplink to the Surf containing all this data except for the PIN.shows PIN and QR-code to the user The user scans a QR code or click deeplink, and is redirected to the SurfSees warning text, e.g. &quot;Attention! You authorize access to ABC site&quot;Enters OTPSigns OTP + PIN + callback_url + warning_text, and returns his signature and his public key to the server If the signature is correct, the server knows that this user is the real owner of this public key.  "},{"title":"Prerequisites​","type":1,"pageTitle":"Samples","url":"develop/smart-contract/debots/samples#prerequisites-1","content":"npm, node.js ver&gt;=14, everdev  "},{"title":"The quickest start (if you want to use DeBot already deployed in net.ton.dev)​","type":1,"pageTitle":"Samples","url":"develop/smart-contract/debots/samples#the-quickest-start-if-you-want-to-use-debot--already-deployed-in-nettondev","content":"Run local webserver $ cd example-webserver-nodejs/ $ npm i $ npm start  Open http://localhost:8080/surfauth.html?pin=true in a browser Click on the link shown to open Surf on your local computer. Do not scan the QR code with your mobile phone, because the test web server is running on your local computer! "},{"title":"If you want to deploy DeBot by yourself​","type":1,"pageTitle":"Samples","url":"develop/smart-contract/debots/samples#if-you-want-to-deploy-debot-by-yourself","content":"Deploy DeBot Set GIVER_KEYS and GIVER_ADDRESS variables in deploy_debot.sh file, then run: $ ./compile_and_deploy.sh  Remember debot_adress Run local webserver $ cd example-webserver-nodejs/ $ npm i $ node src/main &lt;debot_address&gt;  Open http://localhost:8080/surfauth.html?pin=true in a browser "},{"title":"FAQ","type":0,"sectionRef":"#","url":"develop/smart-contract/faq","content":"FAQ This article has TO DO status. You can contribute by submitting your own version of this page. More details on the Documentation page of the Hot streams section.","keywords":""},{"title":"Frontend App","type":0,"sectionRef":"#","url":"develop/smart-contract/frontend-app","content":"Frontend App This article has TO DO status. You can contribute by submitting your own version of this page. More details on the Documentation page of the Hot streams section.","keywords":""},{"title":"Getting started with smart contracts development","type":0,"sectionRef":"#","url":"develop/smart-contract/getting-started","content":"","keywords":""},{"title":"What you can learn​","type":1,"pageTitle":"Getting started with smart contracts development","url":"develop/smart-contract/getting-started#what-you-can-learn","content":"Experienced developers with advanced knowledge of Solidity programming language and solid understanding of Ethereum blockchain design, are advised to consult our Learn section where all necessary technical information is provided in a comprehensive way. For those with no prior knowledge of smart contracts, as well as for intermediaries and advanced developers who strive to learn new things in the blockchain industry, we recommend you to consult our DeBots page. DeBots, in essence, is an intuitive, no prior knowledge required interface for smart contracts on the Everscale blockchain. Having studied the information provided above, now, let's start our DApp launch. "},{"title":"Prerequisite​","type":1,"pageTitle":"Getting started with smart contracts development","url":"develop/smart-contract/getting-started#prerequisite","content":"Node.js &gt;= 14.x installed Node Version Manager (NVM)NVM-windows Docker &gt;= 19.x installed and running "},{"title":"Generate a new project​","type":1,"pageTitle":"Getting started with smart contracts development","url":"develop/smart-contract/getting-started#generate-a-new-project","content":"mkdir my-project &amp;&amp; cd $_ npm init --force npm install --save everdev  "},{"title":"Setup local environment​","type":1,"pageTitle":"Getting started with smart contracts development","url":"develop/smart-contract/getting-started#setup-local-environment","content":"Set Local Blockchain SE (Startup Edition) as the default network: Startup SE at this step, you may have to wait until the docker image is downloaded: npx everdev se start  A local network explorer is available at localhost check it. Setting SE as default network: npx everdev network default se  "},{"title":"Configure Giver​","type":1,"pageTitle":"Getting started with smart contracts development","url":"develop/smart-contract/getting-started#configure-giver","content":"Configure Giver wallet that will sponsor EVER for deploy operation: npx everdev signer add giver 172af540e43a524763dd53b26a066d472a97c4de37d5498170564510608250c3 npx everdev network giver se 0:b5e9240fc2d2f1ff8cbb1d1dee7fb7cae155e5f6320e585fcc685698994a19a5 --signer giver npx everdev network giver dev 0:b5e9240fc2d2f1ff8cbb1d1dee7fb7cae155e5f6320e585fcc685698994a19a5 --signer giver  "},{"title":"Generate the key pair for contract ownership​","type":1,"pageTitle":"Getting started with smart contracts development","url":"develop/smart-contract/getting-started#generate-the-key-pair-for-contract-ownership","content":"Key pair file — used in contracts with implemented authorization. It is the file containing private and public keys authorized to access the contract. In --sign parameter the corresponding seed phrase may be used instead of it. npx everdev signer generate coder npx everdev signer default coder npx everdev signer list  "},{"title":"Generate a new smart-contract​","type":1,"pageTitle":"Getting started with smart contracts development","url":"develop/smart-contract/getting-started#generate-a-new-smart-contract","content":"npx everdev sol create App  You got App.sol: pragma ton-solidity &gt;= 0.35.0; pragma AbiHeader expire; // This is class that describes you smart contract. contract App { // Contract can have an instance variables. // In this example instance variable `timestamp` // is used to store the time of `constructor` // or `touch` function call. uint32 public timestamp; // Contract can have a `constructor`. // The function that will be called when contract will be deployed to the blockchain. // In this example constructor adds current time to the instance variable. // All contracts need call `tvm.accept()` for succeeded deploy. constructor() public { // Check that contract's public key is set require(tvm.pubkey() != 0, 101); // Check that message has signature (msg.pubkey() is not zero) and // message is signed with the owner's private key require(msg.pubkey() == tvm.pubkey(), 102); // The current smart contract agrees to buy some gas to finish the // current transaction. This actions required to process external // messages, which bring no value (hence no gas) with themselves. tvm.accept(); timestamp = now; } function renderHelloWorld () public pure returns (string) { return 'helloWorld'; } // Updates variable `timestamp` with current blockchain time. function touch() external { // Each function that accepts external message must check that // message is correctly signed. require(msg.pubkey() == tvm.pubkey(), 102); // Tells to the TVM that we accept this message. tvm.accept(); // Update timestamp timestamp = now; } function sendValue(address dest, uint128 amount, bool bounce) public view { require(msg.pubkey() == tvm.pubkey(), 102); tvm.accept(); // It allows to make a transfer with arbitrary settings dest.transfer(amount, bounce, 0); } }  For more about Solidity and specific of Everscale Solidity "},{"title":"Compile smart-contract​","type":1,"pageTitle":"Getting started with smart contracts development","url":"develop/smart-contract/getting-started#compile-smart-contract","content":"npx everdev sol compile App.sol  You are got: App.abi.json — ABI *.abi.json file — a file that describes the contract interface, the methods and parameters used to interact with it, for detail see ABI Specification V2.App.tvc — TVC *.tvc file — the compiled smart contract file. Used only when generating contract address and deploying contract code to the blockchain. "},{"title":"Deploy smart-contract​","type":1,"pageTitle":"Getting started with smart contracts development","url":"develop/smart-contract/getting-started#deploy-smart-contract","content":"The 1 EVER is 1000000000 nano EVER Local network: npx everdev contract deploy --network se --value 1000000000 App  Developer network: npx everdev contract deploy --network dev --value 1000000000 App  "},{"title":"Address smart-contract​","type":1,"pageTitle":"Getting started with smart contracts development","url":"develop/smart-contract/getting-started#address-smart-contract","content":"Address of smart-contract is calculated from TVC and signer (coder) public: npx everdev contract info --network se --signer coder App  Getting only address: appAddress=$(npx everdev contract info --network se --signer coder App | grep Address | cut -d ' ' -f 4) echo $appAddress  "},{"title":"Interact with smart-contract​","type":1,"pageTitle":"Getting started with smart contracts development","url":"develop/smart-contract/getting-started#interact-with-smart-contract","content":"Read: npx everdev contract run-local --network se App renderHelloWorld npx everdev contract run-local --network se App timestamp  Write: npx everdev contract run --network se --signer coder App touch  For more details see: Get started with Development Tools. "},{"title":"How the blockchain works on the block and queue level","type":0,"sectionRef":"#","url":"develop/smart-contract/learn/blockchain","content":"How the blockchain works on the block and queue level This note is just for a general understanding of how the blockchain works, it’s not 100% accurate, we are waiting for a description from the writers of the node. This may change after a new consensus. There is a workchain -1, this is the master chain, it is validated by the validators with the largest stake. Contracts can be deployed in the -1 workchain, but it is more expensive, and it was made mainly for governorship. (Probably in the future there will be no user contracts) There is a workchain 0, where contracts are mostly located. More workchains will be launched in the future. Workchains are further divided into Processing threads. There is a workchain parameter that indicates the minimum number of processing threads, and currently it is 16 for a 0 workchain. Thread processing is an interesting concept. In ES, only computation is shared between the validators of the same workchain, but they all have the same storage. Let’s look at what that means and how it works. For example, we have 160 validators for the 0 workchain. They are randomly divided into 16 groups of 10 validators, and each gets its own Processing thread. All workchain contracts are also divided into 16 groups, simply by address ranges. (0.00 - 0:08, 0:08 - 0.18, etc.). Each group of validators executes transactions only for their group of smart contracts, and releases blocks of their processing thread. But at the same time, they are constantly downloading blocks of other processing threads in order to see their outgoing and incoming message queues. At the same time, blocks are not a list of transactions that need to be rolled up, but a list of incoming messages + a state delta. So, when you download a block of another processing thread, you do not have to do computation in order to update your state. You’re just rolling state changes. How roughly works: The Masterchain generates block 1.All threads download the last master block.Threads create their own block and register it in the master block.The masterchain generates block 2, which contains the hashes of all blocks of threads that have registered in it.All threads download masterblock 2.All threads look at the hashes of the registered blocks of other threads, and download them all.All threads generate a block.This process gets repeated. Message delivery guarantees also work in this way. When you create a message, it is placed on that thread’s outgoing queue: Thread A generates a message for the contract that is in thread B, and creates a block with a new outgoing message in the outgoing queue.Thread A is registered in the master block.The masterchain generates a block.Thread B downloads the master block, and downloads the block of thread A registered there.Thread B sees the message in thread A and imports it into its inbound queue. (When a message is imported, it is immediately executed (transaction starts) If there is not enough gas for a transaction in the current block, then the message is simply not imported, and waits for its turn in another block. At the same time, there is a message import order, so that validators will not be able to ignore it forever).Thread B creates a block with a message in the incoming queue, and registers with the master.Thread A downloads the block in which it sees its message in thread B’s incoming queue and removes the message from its outgoing queue since it was delivered successfully.Generally, thread A generates a block, then registers it in the master block. Then thread B downloads it, sees that thread A has removed it from its outgoing queue, and deletes it from its incoming one. In fact, sharding in this blockchain is the sharding of computational resources. And the data is the same for everyone, with the expectation that all validators have gigabit channels, and we rest only on computation. If some processing thread is heavily loaded with the last N blocks, then it will split into two, and new processing threads can also split in turn. Then when the load drops, they all merge.","keywords":""},{"title":"Carefully working with value when creating messages","type":0,"sectionRef":"#","url":"develop/smart-contract/learn/carefully-working-with-value","content":"Carefully working with value when creating messages In general, whenever you create outgoing messages while processing incoming internal messages, you must be very careful with the value that you attach to messages. The subtlety here is that if you create outgoing messages while processing an incoming message, then value can be deducted from your contract account, even if there is not enough money to pay for this value in the incoming message and you did not call tvm.accept(). Here is an example of a function that can spend money from a contract account. function deployWallet( uint256 _wallet_public_key, uint128 _deploy_evers ) external { TvmCell stateInit = tvm.buildStateInit({ contr: TokenWalletContract, varInit: { root_address: address(this), wallet_code: wallet_code }, pubkey: _wallet_public_key, code: wallet_code }); new TokenWalletContract{ stateInit: stateInit, value: _deploy_evers, wid: address(this).wid, flag: 0 }(); } Everything seems to look good; the function should deploy the wallet and send the specified amount of EVER there. But due to the separation of phases (read above about phases), the creation of the message is paid from the money in the incoming message, and the message is put into the register of outgoing messages, where it will wait for the action phase. And in the action phase, it is created, and value is deducted from the contract account instead of the message account. And if we attach 1 ever to the message and request to deploy the wallet with 3 ever, then the remaining 2 ever will be deducted from the contract account. Working with flags and value can be very tricky and you need to play around with them to understand the logic of TVM. Here is another example: function deployWallet( uint256 _wallet_public_key, uint128 _deploy_evers ) external { require(msg.value - 0.1 ever &gt; _deploy_evers); TvmCell stateInit = tvm.buildStateInit({ contr: TokenWalletContract, varInit: { root_address: address(this), wallet_code: wallet_code }, pubkey: _wallet_public_key, code: wallet_code }); new TokenWalletContract{ stateInit: stateInit, value: _deploy_evers, wid: address(this).wid, flag: 0 }(); msg.sender.transfer({ value: 0, bounce: false, flag: 64 }); } Here we have the example as above, but now we’ve checked that the msg.value is 0.1 ever greater than the _deploy_evers, and we want to return the change back to the sender. But this is also incorrect. For example, we send 1 ever with the message and request to deploy the wallet with 0.5 ever. During the computation phase, TVM will queue the wallet creation request with 0.5 ever, and then the reverse transfer creation intention, with the value of 1 ever - gas (let’s say the price of gas is 0.01 ever), i.e. 0.99 ever. As a result, we will have two outgoing messages with 0.5 and 0.99 ever, and only 1 ever in the incoming message. The correct way to write this function is as follows: function deployWallet( uint256 _wallet_public_key, uint128 _deploy_evers ) external { tvm.rawReserve(address(this).balance - msg.value, 2); TvmCell stateInit = tvm.buildStateInit({ contr: TokenWalletContract, varInit: { root_address: address(this), wallet_code: wallet_code }, pubkey: _wallet_public_key, code: wallet_code }); new TokenWalletContract{ stateInit: stateInit, value: _deploy_evers, wid: address(this).wid, flag: 0 }(); msg.sender.transfer({ value: 0, bounce: false, flag: 128 }); } What we actually have to do first it to call tvm.rawReserve, which is like sending a message to yourself, with a value equal to the initial balance of the contract. Then we deploy the wallet with _deploy_evers, and at the end, all the money that is left on the balance after the first two messages is sent back to the caller. This function is guaranteed not to spend the money on the contract. If, in the action phase it does not have enough money to send a message, it will simply be aborted. The most important thing from the chapter above, when processing internal messages, is this: If you apply a value that is not 0 to a message, always call tvm.rawReserve first.Flag 64 can only be used if your transaction is only sending one outgoing message.","keywords":""},{"title":"Data structures","type":0,"sectionRef":"#","url":"develop/smart-contract/learn/data-structures","content":"","keywords":""},{"title":"TVM — Ton Virtual Machine.​","type":1,"pageTitle":"Data structures","url":"develop/smart-contract/learn/data-structures#tvm--ton-virtual-machine","content":"Realized 1 to 1 just like in Nikolai Durov’s whitepaper: https://ton.org/tvm.pdf What do you need to know about VM? It is just a virtual stacking machine, so when using it we are working with information that is on the stack. (Operations that occur there are of the following sort: Combine the two topmost numbers in the stack, or swap the 2nd position in the stack with the 10th). What is important: "},{"title":"The TVM code is standard data​","type":1,"pageTitle":"Data structures","url":"develop/smart-contract/learn/data-structures#the-tvm-code-is-standard-data","content":"The code is simply stored on the chain and can be shared via messages and rewritten. There is a tvm.setcode(code)operation the will change your contract code for your subsequent transactions and even a tvm.setCurrentCode(code)operation that will apply the new code to the current transaction you are making. There are nuances to consider when updating a contract, for more on that see the &quot;How to upgrade contracts&quot; section of this tutorial. "},{"title":"Messages and funds​","type":1,"pageTitle":"Data structures","url":"develop/smart-contract/learn/data-structures#messages-and-funds","content":"In an asynchronous architecture, all communication between contracts occurs through sending messages. The sequence is something like this (I am not going to delve into the questions of how exactly messages are delivered here, there will be a separate chapter in the appendices that cover this): The contract receives an external message from the outside world, and if the contract agrees to pay for it, a transaction is launched. As a result of the transaction launching, the contract can create any number of outgoing internal messages. The outgoing message contains the address of the destination contract, the function that should be called there and what arguments are attached.The destination contract receives an incoming internal message, and a transaction is started, as a result of which outgoing internal messages can be created. External messages are simple. 10k of gas credit are allocated to external messages and if a contract does not agree to supply the gas to pay for the transaction, then the message will simply be discarded and the transaction will not start. But with internal messages, everything is more complicated. When a contract receives an internal message, a transaction is started. Logically, in most cases the calling contract should pay for the gas for this transaction type, and not the called contract. But at the same time, it is obvious that the calling contract must control exactly how much gas it is willing to pay. What further complicates things is that contracts can find themselves in different shards, and one shard cannot spend the money of another shard. Therefore, in ES, all outgoing messages are appended with value ( ever-s ). When a contract receives a message, the gas is paid out of the money attached to this message, and if the money in the message runs out and the contract does not want to continue paying, then the transaction will run out of gas. If, after the transaction is completed, there is money left in the message, then it will be added to the contract’s account (or the contract can send the change back). All internal messages have to carry some amount of money with them. Even if the contract agrees to pay for the message, the message must have enough coins to pay for the download of the contract and the initial checks (until it gets to tvm.accept()). When you create a message, you have to show a flag which will determine where the money that gets attached to the message will come from and how the creation of the message will be paid for. The money can come from the contract account or be taken from money left over on the incoming message after the gas deduction. From this document https://github.com/tonlabs/TON-Solidity-Compiler : Regular money transfer: value — this is the amount of money you want to transfer. (Essentially, this is just the amount of EVER we attach to an internal message and it doesn’t matter that this is a regular money transfer or a call of some kind of method of a smart contract.) bounce — this is a flag that indicates whether we need to try to create a return message should an error occur during the processing of the message or there is no contract deployed on the destination address. By default, the flag will be true. If it is false, then, if there is an error, the money will just remain on the address. flag — flags indicate how, from where and how much money is sent with a message. Read the description from the document below and I will provide further explanation. "},{"title":"Excerpt from the TON Solidity compiler documentation:​","type":1,"pageTitle":"Data structures","url":"develop/smart-contract/learn/data-structures#excerpt-from-the--ton-solidity-compiler-documentation","content":"Possible values of parameter flag: @ 0 - message carries funds equal to the value parameter. Forward fee is subtracted from the value.128 - message carries all the remaining balance of the current smart contract. Parameter value is ignored. The contract's balance will be equal to zero after the message processing.64 - carries funds equal to the value parameter plus all the remaining value of the inbound message (that initiated the contract execution). Parameter flag can also be modified:flag + 1 - means that the sender wants to pay transfer fees separately from contract's balance.flag + 2 - means that any errors arising while processing this message during the action phase should be ignored. But if the message has wrong format, then the transaction fails and + 2 has no effect.flag + 32 - means that the current account must be destroyed if its resulting balance is zero. For example, flag: 128 + 32 is used to send all balance and destroy the contract. When messages are created, two things occur: payment for the creation of the actual message (payment for validators so that they deliver the message), and payment of the value (funds) which will be attached to the message. In most cases you will use the following flags: 0, 1, and 64. 0 and 1 you will use primarily when you start the transaction sequence yourself: 0 — this flag communicates that the creation of the message will be paid from the value that you attached to the message, meaning that a little less than the total value you attached will be sent. The value itself will be paid from the account of the contract (all of the money remaining with the message will be added to the account). 1 — the same thing as with 0, only the creation of the message will be paid from the contract account separately and the total amount attached to the message will be sent with it. 64 — This flag is used when processing an incoming internal message (when another contract calls you). You will most often use this flag with the value: 0. This indicates that for an outgoing message you have to attach the entire value that came with the incoming message, minus the spent gas. The creation of the outgoing message itself will also be paid for with the incoming money. This is a very important concept, in this paradigm other contracts do not spend money from your contract on calls. Below I will demonstrate a few simple examples. Here are some examples of using flags. Contract A gets an Ext message from its owner and begins a message sequence, calling B and attaching 0.5 EVER to the message. // Contract A function updateOwnerOnChildren( address children, uint256 new_pubkey ) external { require(msg.pubkey() == tvm.pubkey(), AErrors.error_message_sender_is_not_my_owner); tvm.accept(); // On the IB interface we call the setNewOnwer function // By default the flag will be 0, we don't have to change it. // So we send 0.5 ever and pay for the creation of the message // from these 0.5 ever IB(children).setNewOnwer{value : 0.5 ever}(new_pubkey); }  // Contract B function setNewOnwer( uint256 new_pubkey ) external { require(msg.sender == myRoot, BErrors.error_message_sender_is_not_my_root); // Here we won't call tvm.accept() because we don't want // the incoming message to be able to spend money on the smart contract account. tvm.setPubkey(new_pubkey); // We send the rest of the remaining value back to the sender. // value - 0, bounce - false, flag - 64 msg.sender.transfer(0, false, 64); }  This is the basic pattern according to which ES works. Even though the price of gas doesn’t fluctuate, we don’t calculate down to the penny the exact amount you need to send to the contract so that you will have enough to cover the transaction. We just send a a decent amount and then send the remainder back. (We know that what we send will cover the fees because the price of gas won’t rise). Doing this, we can create long chains, by putting the contract address that initiated the whole chain in the call arguments and then returning the change to that address at the end. "},{"title":"BoC. Now for the hard part :-)​","type":1,"pageTitle":"Data structures","url":"develop/smart-contract/learn/data-structures#boc-now-for-the-hard-part--","content":"All data in ES is stored and sent in a structure called the BoC (Bag of cell). This is a confusing structure invented by Nikolai Durov, and it’s not very clear whether it was necessary in order to create the blockchain, or Nikolai over-engineered here. In general, all data stored in the contract (not the code, the code is separate, but also the BoC is stored in the contract :-)) is stored in one BoC, this is a given cell (TVMCell) with links to subcells. The TVMCell is a structure that has 1023 Bits of data and 4 references to its child cells. A cell reference is the HASH of that cell. With ES have have a singly connected graph, where each node can have 4 descendants. And we need to pack all smart contract data or messages into a cell with sub cells. Thank God, by using Ton Solidty and knowing the interfaces of contracts, you don’t have to manually pack and unpack cells. The compiler will do everything for you. However, there are rare cases when you will have to do it yourself. In order to do this, there are special primitives in Solidity. When this is necessary, you simply declare state variables in Solidity and read and write to them as usual. The compiler will pack and unpack everything in the BoC for you. Some BoC properties to understand. BoC is an acyclic graph. The link to a cell c is a hash of its data and its hash links to subcells. So we cannot create a cycle. (Because if we add a link from the parent cell to the child cell, then, by doing so, we recalculate all hashes from the changed cell to the root cell and the link to the parent cell changes). The entire state of the contract is BoC. This is one cell with as many child cells as you like. Ton Solidity takes care of work with states for us, but you need to understand that, because of ES’s tree structure, we normally don’t write contracts with a lot of data. In order to illustrate how it works, consider (schematically) how a dictionary could be implemented in BoC.  Each circle in the picture is a separate cell. To get the value by key 2, TVM needs to load a cell of depth 0, then depth 1 and then depth 2. We have to pay gas for each time a cell is loaded. And if we change the value by key two, we will need to recalculate all references from the cell with the value of the root cell because the cell reference is a hash (cell.data + cell.refs). So, links to all cells along the way will change and we will need to change them from bottom to top. So, the more elements our dictionary has, the deeper the cell will be and the more expensive it will be to work with. For a dictionary, the cost of gas will increase to O(log n) in a worst case scenario. (In reality, everything would be more complicated but O (log n) can be useful to look at as a worst case scenario). Now, if we are creating an ERC20 token, then the more owners this token has, the more expensive the gas will be to use this contract (the size of the owner-number map will grow). And although O(Log n) doesn’t sound scary at all, and the cost of working with the map will increase very, very slowly after the first hundred elements, and then even slower after that, in ES there we have a storage fee that grows linearly. If you have accounts in your ERC-20 token that contain pennies, then the fees for holding these accounts will greatly exceed the value of these accounts over the years. Therefore, in ES it is customary to make separate contracts for separate accounts, which themselves pay for their storage. We will look at how the TIP-3 standard (a distributed replacement for ERC-20) works in the next chapter. Fun fact: this entire overcomplicated data storage scheme helps to scale the network, so that the validator can quickly execute smart contracts. Validators do not need to store the entire current state of the blockchain in Ram, because loading the smart contract state from the disk will be fast, since all smart contracts are small. Additionally, since all contracts are small, they are evenly distributed across all shards. "},{"title":"Gas limits and external message size","type":0,"sectionRef":"#","url":"develop/smart-contract/learn/gas-and-messages-limits","content":"Gas limits and external message size There are size restrictions for external messages (now it is about 16 kilobytes). So you will not be able to send more than 16 kb to a data contract in one message, and you will also not be able to deploy a contract with an external call larger than 16 kb. Of course, there are workarounds. You can make a contract where you first fill in the data bit by bit, and then the contract will glue this data together and send it in one big internal message. But it is better to keep contract sizes relatively small. These restrictions apply only to the size of external messages, not to the sizes of contracts and internal messages. There is also a limit on the amount of gas that one transaction can spend, and it is quite small. The absolute limit is about a million gas, but this will not tell you anything :-) You have to test it to see. For example, if you have a mapping with more than 1000 elements, you can write no more than 200 new keys in one transaction. Gas limits can be bypassed recursively by calling yourself (by sending an internal message to yourself). More about​ Managing gasFee calculationBlockchainConfig parameters","keywords":""},{"title":"How to upgrade contracts","type":0,"sectionRef":"#","url":"develop/smart-contract/learn/how-to-upgrade-contracts","content":"How to upgrade contracts There are two complications with upgrading contracts. The first complication with upgrading: We have tvm.setCode() and we can change the contract code at any time. But the problem is in contract storage. We have all the variables in one BoC, and Solidity simply uses the mapping to these cells, which is created at compiling time. If your state variables do not change, then you can simply do tvm.setCode() and complete the transaction as in this example. But we want to be able to change the storage structure. Let’s say that prior to the upgrade we had the following state variables: TvmCell proxyCode; mapping (address =&gt; uint128) balances; uint32 version; address root; uint256[] lastHashes; The Solidity compiler somehow distributes them into cells (you can see how storage is arranged in the chapter on BoC). For example, like this (this is just an example, in reality it is more complicated). And after tvm.setCode we will have more variables: TvmCell proxyCode; mapping (address =&gt; uint128) balances; mapping (address =&gt; uint128) approvedAddresses; uint32 version; address root; uint256[] lastHashes; And the compiler will map them to contract storage in a different way, for example, like this: Solidity expects a different mapping of state variables to storage, but we have the old storage mapping. Unfortunately, there is currently no way to automatically migrate from the old representation to the new one. After changing the code, you need to do tvm.resetStorage() and manually migrate the old data to the new storage. Below I will describe an example of how to do this in practice. We have contract A version 1 and we want to be able to upgrade it to version 2 in the future. In the version 1 contract, we implement the codeUpgrade function: function codeUpgrade(TvmCell _code, uint32 _newVersion) override public onlyRoot { // If a new version if (version != _newVersion) { TvmBuilder data; // We pack old the data from the old version into TvmCell data.store(_newVersion); TvmBuilder prevStateData; prevStateData.store(proxyCode); prevStateData.store(balances); prevStateData.store(lastHashes); data.storeRef(stateData); // Import the new code. // For the following transactions tvm.setcode(_code); // Establish the new code with the CURRENT code // Already in the framework of the current code (shock) tvm.setCurrentCode(_code); // Transfer to the onCodeUpgrade function the new code // With all the data we want to keep from the old contract onCodeUpgrade(data.toCell()); } } In the new version 2 contract, we implement the onCodeUpgrade function (this utility function can only be called after onCodeUpgrade). function onCodeUpgrade(TvmCell _data) private { // We erase contract storage to 0, because we have changed // the storage strcuture. This call will not affect // _pubkey, _constructorFlag or _replayTs variables. tvm.resetStorage(); //We decode TvmCell and rewrite it in the new storage structure TvmSlice s = _data.toSlice(); version = s.decode(uint32); TvmSlice params = s.loadRefAsSlice(); (proxyCode, balances, lastHashes) = params.decodeFunctionParams(prevVersionParams); } function prevVersionParams( TvmCell _proxyCode, mapping (address =&gt; uint128) _balances, uint256[] _lastHashes ) public {} By doing that we have essentially upgraded the contract. But then we run into complication number 2: As you already understand from the chapter on distributed programming, in many use cases in ES it is very important to have a computed contract address. The address is hash(code + static variables), tvm.setCode() does not change the contract address, the contract address is calculated at the time of deployment. What should we do if we have a Root contract that first deployed the v1 contract, and then we told it to deploy the updated contracts, and the old ones were updated? Contract addresses v1 and v2 will be calculated differently. To do this, we use a Proxy contract. The whole point of this contract is to be the starting point of the address. With it, we untie the contract address from the real code, and use the Proxy.sol code to calculate the address. In the constructor of this contract, we pass the Real code, and the data of the constructor, and it will immediately upgrade to the new code and call onCodeUpgrade(). pragma ton-solidity &gt;= 0.52.0; contract Proxy { address static root; // Root contract TvmCell static initialData; modifier onlyRoot { require(msg.sender == root, 100); _; } constructor(TvmCell _code, TvmCell _params) public onlyRoot { TvmBuilder builder; builder.store(uint32(0)); // Upgraded from version 0 builder.store(root); // Root address. Address depends on this data builder.store(initialData); // Static data. Address depends on this data builder.store(_params); // Dynamic params. Address does not depend on these params. //Set code for next transactions. tvm.setcode(_code); //Set new code right now for current transaction tvm.setCurrentCode(_code); // call onCodeUpgrade from new code onCodeUpgrade(builder.toCell()); } function onCodeUpgrade(TvmCell _data) private {} } We always deploy Proxy.sol from Root.sol, and immediately call for the migration to a new version of the code. And if the code changes, then we will still deploy Proxy.sol just with a different version, and the addresses will be considered the same for v1 and v2 (because they are calculated from the Proxy.sol code) You can find a fully-functional example here.","keywords":""},{"title":"Introduction","type":0,"sectionRef":"#","url":"develop/smart-contract/learn/introduction","content":"","keywords":""},{"title":"Smart contracts use cases.​","type":1,"pageTitle":"Introduction","url":"develop/smart-contract/learn/introduction#smart-contracts-use-cases","content":"Smart contracts are the building blocks necessary to ensure the functioning of decentralized projects (DeFi, DApps, etc.), due to the fact that they eliminate the need for intermediaries. They are used to ensure that the stipulated set of conditions is followed in the correct algorithmic sequence. The algorithm itself is written inside the blockchain, so the rules for transactions are mandatory for all participants and manipulations are not possible. "},{"title":"How smart contracts actually work.​","type":1,"pageTitle":"Introduction","url":"develop/smart-contract/learn/introduction#how-smart-contracts-actually-work","content":"Smart contracts are programmed in blockchains (in our case Everscale) and, respectively, work within the network. They perform the same functions as traditional contracts written on paper. The difference is that they are not written on paper, but with the use of mathematical algorithms and programming languages. This makes them secure, efficient, cheaper, and much faster, considering the fact that the intermediary is no longer needed. As in a paper contract, the conditions that were set in the contract are subject to mandatory implementation. Therefore, only in this case will the transaction mentioned above (digital asset swap) be completed and participants in this transaction will receive what they were supposed to. It should be noted that after the correct execution of the transaction, the respective smart contract becomes part of the registry, getting into the blockchain. To add, it can be viewed by anyone with access to the internet. The basic principle of a smart contract is the complete execution of conditions set in the contract. In order to start developing your own dApps please consult Getting started page which provides a complete step-by-step guide. "},{"title":"Distributed programming","type":0,"sectionRef":"#","url":"develop/smart-contract/learn/distributed-programming","content":"","keywords":""},{"title":"Important concept​","type":1,"pageTitle":"Distributed programming","url":"develop/smart-contract/learn/distributed-programming#important-concept","content":"In ES, each contract address is a uniquely computed value. A contract address is a hash of the contract code and initial data (initial data is a value of static variables, and not what you pass to the constructor, since in ES the constructor is a function that you call after the deployment of the contract in one transaction). This is a very important pattern of distributed programming (as it is understood in ES). Knowing the code of a contract, and it initials data you can make sure that you are being called by a contract with the same parents as your own. Or, knowing the contract code and its initial data, you can compute the address of a contract on the fly and send messages to it. "},{"title":"How contracts are deployed​","type":1,"pageTitle":"Distributed programming","url":"develop/smart-contract/learn/distributed-programming#how-contracts-are-deployed","content":"The concept described above is also tied to how contracts are deployed in ES. The contract can naturally be deployed by another contract. But what should we do if we want to deploy a contract from outside? To do this, we have to take the contract code and its initial data, and compute its future address. After that, we simply send money there, with a bounce flag = false. And the money just stays on the address, which has no initialized code. Then we send a special external message to this address with the code and initial data, and we say “Look, here we have the code and initial data, the hash of which gives us this address, initialize it please” and the network initializes the contract. Now let’s look at a really simplified realization of a TIP-3 token. Our token consists of 2 contracts: Root.sol is controlled by whoever released the token, this allows them to print tokens and deploy the wallets of individual users.Wallet.sol is a wallet contract for individual users. Yes, each user has their own small contract that stores their token balance. By creating contract-wallets we solve a number of different problems: All wallets end up in different shards which distributes the load evenly throughout the network.Wallet contracts are very small with small states. Validators can load them very quickly from a disk.Storage fee. If we had one contract with a huge hash map, then it would have to pay a large fee for its storage, and it is not clear who would pay and how for this storage. If there are many accounts with small balances that their owners no longer need, then naturally they will not pay for its storage, and the rest of the holders of this token will have to pay for all of the “remainders.” So that smart contract programmers do not have to think about how to force users to pay for storage (so that the entire contract is not frozen) or clean up old data inside the contract, ES has allowed each user to deploy their own contract. Each user determines how long they will pay for storage and can always adjust these parameters. Below we are going to look at the code underlying this to understand how it works and why it is safe. A few thoughts to keep in mind while looking at the code: The contract address is the hash (contract code + static variables).If we know the wallet contract code and its initial variables (what the root address of the contract is and what pubkey controls it), then we can calculate what address this contract will have.When one wallet receives a message from another wallet, it can determine from the sender's address whether the sending wallet has exactly the same code, to see if it really has the tokens it is sending you. "},{"title":"Root.sol​","type":1,"pageTitle":"Distributed programming","url":"develop/smart-contract/learn/distributed-programming#root","content":"pragma ton-solidity &gt;= 0.53.0; pragma AbiHeader expire; pragma AbiHeader pubkey; import &quot;TokenWallet.sol&quot;; interface ITokenRootContract { function deployEmptyWallet( uint256 _wallet_public_key, uint128 _deploy_evers ) external responsible returns(address); function mint( address to, uint128 tokens ) external; function deployWalletWithBalance( uint256 _wallet_public_key, uint128 _deploy_evers, uint128 _tokens ) external returns ( address ); } library TokenRootContractErrors { uint8 constant error_tvm_pubkey_not_set = 100; uint8 constant error_message_sender_is_not_my_owner = 101; uint8 constant error_deploy_ever_to_small = 102; uint8 constant error_insufficient_evers_on_contract_balance = 103; uint8 constant error_deploy_wallet_pubkey_not_set = 104; } contract TokenRootContract is ITokenRootContract { uint128 public start_gas_balance; uint128 public total_supply; // The code of the wallet contract is needed to deploy the wallet contract. // In the tvm the code is also stored in the TvmCell and it can be sent via messages. TvmCell static wallet_code; constructor() public { require(tvm.pubkey() != 0, TokenRootContractErrors.error_tvm_pubkey_not_set); tvm.accept(); start_gas_balance = address(this).balance; } modifier onlyOwner() { require(tvm.pubkey() != 0 &amp;&amp; tvm.pubkey() == msg.pubkey(), TokenRootContractErrors.error_message_sender_is_not_my_owner); _; } function deployWallet( uint256 _wallet_public_key, uint128 _deploy_evers ) private returns (address) { // stateInit - the message deploying the contract where we establish the code // the contract and its static variables. // Essentially the hash(stateInit) is the contract address. // The contract address depends on the code and the intial variables. // So we can determine the contract address just by knowing its code // and initial variables (not those that are sent in the constructor). // Pay attention to what the wallet address depends on. // It depends on the root_address(this), the wallet code and the owner's public key. TvmCell stateInit = tvm.buildStateInit({ //We specify the contract interface so Solidity correctly packs // varInit into TvmCell (BoC, see the previous chapter). contr: TokenWalletContract, varInit: { //the value of static variables root_address: address(this), wallet_code: wallet_code }, // pubkey - this will return the tvm.pubkey(). // Essentially this is just another static variable that is introduced separately. pubkey: _wallet_public_key, code: wallet_code }); // Here we create one message that will deploy the contract // (if the contract is already deployed , nothing will happen) // also, this message will call the constructor // () without arguments . address wallet = new TokenWalletContract{ stateInit: stateInit, value: _deploy_evers, //the amount of native coins we are sending with the message wid: address(this).wid, flag: 0 //this flag denotes that we are paying for the creation of the message from the value we are sending with the contract. }(); return wallet; } function deployEmptyWallet( uint256 _wallet_public_key, uint128 _deploy_evers ) override external responsible returns (address) { // With the help of this function, any other contract can deploy a wallet. require(_wallet_public_key != 0, TokenRootContractErrors.error_deploy_wallet_pubkey_not_set); require(_deploy_evers &gt;= 0.05 ton, TokenRootContractErrors.error_deploy_ever_to_small); // This function reserves money on the contract account equal to the balance // of the contract at the moment when the transaction is started. In order not to allow the message // to spend money from the contract balance. // This is a complex moment and we will look at the details in the Additional Materials section // in &quot;Carefully working with value&quot; tvm.rawReserve(0, 4); address deployed_contract = deployWallet(_wallet_public_key, _deploy_evers); // Our function is labelled responsible, this means that it is possible to be called // with a smart contract and it will create a message with a callback. // The compiler will simply add a field to the function arguments // answerID, which shows the ID of the function that will be called // by sending a message back to the msg.sender address // Why do we use 128 here and not 64 - because from this transaction // we have two external calls, one is to deploy the wallet contract, // and the second is the answer: responsible. // You can find more details about this in the &quot;Carefully working with value&quot; section. return { value: 0, bounce: false, flag: 128 } deployed_contract; } //minting tokens function mint( address _to, uint128 _tokens ) override external onlyOwner { // This method is called by an external message, // here we have put some fool-proof protection in place. // This way we will pay for the fulfillment of the transaction from the contract account, // then we check that there are more EVERs on the contract account // then there were when it was deployed. This prevents a situation in which // there are no funds on the contract account and it gets deleted from the network // or frozen because it conannot pay for its storage. require(address(this).balance &gt; start_gas_balance, TokenRootContractErrors.error_insufficient_evers_on_contract_balance); require(_tokens &gt; 0); // We agree to pay for the transaction from the contract account. tvm.accept(); // We send a message with a call of the accept function to the contract at the indicated address. // To the message a sum of 0.01 EVER from the account address will be attached // (this will be done automatically, unless otherwise indicated) ITokenWalletContract(_to).accept(_tokens); total_supply += _tokens; } function deployWalletWithBalance( uint256 _wallet_public_key, uint128 _deploy_evers, uint128 _tokens ) override external onlyOwner returns ( address ) { require(_wallet_public_key != 0, TokenRootContractErrors.error_deploy_wallet_pubkey_not_set); require(_deploy_evers &gt;= 0.1 ton, TokenRootContractErrors.error_deploy_ever_to_small); // Similar fool-proof mechanism to the one above, // but here we also add _deploy_evers require(address(this).balance &gt; start_gas_balance + _deploy_evers, TokenRootContractErrors.error_insufficient_evers_on_contract_balance); require(_tokens &gt; 0); tvm.accept(); // we deploy the wallet address deployed_contract = deployWallet(_wallet_public_key, _deploy_evers); // we send tokens to the wallet in the following message. ITokenWalletContract(deployed_contract).accept(_tokens); total_supply += _tokens; return deployed_contract; } onBounce(TvmSlice slice) external { tvm.accept(); // This is a utility function for handling errors. You probably noticed that in // the mint function we did not check if the contract was deployed at the destination // address. By default, when calling another contract, the message // will have a flag bounce value of: true. If when the message is being processed by the contract // an exception occurs at the destination address or the contract // does not exist, then automatically (if there is enough money // attached to the message) a return message is sent with a call to // the onBounce function and with arguments. // Here there is a stupid limitation requiring that arguments fit // into 224 bits (WTF) but hopefully this is changed. // We use this function to show you how to handle a situation // when tokens are minted to a non-existing address and to subtract from the total_supply // as the tokens were not printed. // This function cannot just be called, the message must // have a special bounced: true flag, // which cannot be added manually when sending. // So there is no need to do additional checks that we actually sent the message // as no bad actor can subtract from the total supply by sending an unexpected bounced message. uint32 functionId = slice.decode(uint32); if (functionId == tvm.functionId(ITokenWalletContract.accept)) { uint128 latest_bounced_tokens = slice.decode(uint128); total_supply -= latest_bounced_tokens; } } }  "},{"title":"Wallet.sol​","type":1,"pageTitle":"Distributed programming","url":"develop/smart-contract/learn/distributed-programming#wallet","content":"pragma ton-solidity &gt;= 0.53.0; pragma AbiHeader expire; pragma AbiHeader pubkey; interface ITokenWalletContract { function getBalance() external view responsible returns (uint128); function accept(uint128 _tokens) external; function transferToRecipient(uint256 _recipient_public_key, uint128 _tokens, uint128 _deploy_evers, uint128 _transfer_evers) external; function internalTransfer(uint128 _tokens, uint256 _sender_public_key, address _send_gas_to) external; } library TokenWalletContractErrors { uint8 constant error_tvm_pubkey_not_set = 100; uint8 constant error_message_sender_is_not_my_owner = 101; uint8 constant error_message_transfer_not_enough_balance = 102; uint8 constant error_message_transfer_wrong_recipient = 103; uint8 constant error_message_transfer_low_message_value = 104; uint8 constant error_message_internal_transfer_bad_sender = 105; uint8 constant error_message_transfer_balance_too_low = 106; } contract TokenWalletContract is ITokenWalletContract { address static root_address; TvmCell static wallet_code; uint128 public balance; constructor() public { //We check that the public key has been set require(tvm.pubkey() != 0, TokenWalletContractErrors.error_tvm_pubkey_not_set); tvm.accept(); } modifier onlyRoot() { require(root_address == msg.sender, TokenWalletContractErrors.error_message_sender_is_not_my_owner); _; } modifier onlyOwner() { require(tvm.pubkey() == msg.pubkey(), TokenWalletContractErrors.error_message_sender_is_not_my_owner); _; } function accept(uint128 _tokens) override external onlyRoot { // We simply accept any amount of tokens the Root contract wants to send us tvm.accept(); balance += _tokens; } function getBalance() override external view responsible returns (uint128) { // Any contract can get our wallet balance return { value: 0, bounce: false, flag: 64 } balance; } function transferToRecipient( uint256 _recipient_public_key, uint128 _tokens, uint128 _deploy_evers, uint128 _transfer_evers ) override external onlyOwner { // With this method we can send tokens to any similar wallet // directly. When doing this we can say that we want to first // deploy this wallet. require(_tokens &gt; 0); require(_tokens &lt;= balance, TokenWalletContractErrors.error_message_transfer_not_enough_balance); require(_recipient_public_key != 0, TokenWalletContractErrors.error_message_transfer_wrong_recipient); // You cannot send it to yourself :-) require(_recipient_public_key != tvm.pubkey()); require(address(this).balance &gt; _deploy_evers + _transfer_evers, TokenWalletContractErrors.error_message_transfer_balance_too_low); // A check to make sure we want to add no less than // 0.01 ever to the outgoing message. If we don't add enough, the transaction will fail // and onBounce won't work. // This is an empirical value, as on our network gas does not fluctuate // and will only decrease from the original value. require(_transfer_evers &gt;= 0.01 ever, TokenWalletContractErrors.error_message_transfer_low_message_value); tvm.accept(); // We calculate the destination address of the wallet contract. TvmCell stateInit = tvm.buildStateInit({ contr: TokenWalletContract, varInit: { root_address: root_address, wallet_code: wallet_code }, pubkey: _recipient_public_key, code: wallet_code }); address to; if (_deploy_evers &gt; 0) { // We deploy the wallet, here everything should be familiar. to = new TokenWalletContract{ stateInit: stateInit, value: _deploy_evers, wid: address(this).wid, flag: 1 // this means that we will pay for the creation of the outgoing message not from с _deploy_evers but from the wallet balance }(); } else { // We simply determine the destination wallet address. to = address(tvm.hash(stateInit)); } balance -= _tokens; // Here we send a message with a call to the internalTransfer function, // described below. Since we have a guarantee in the blockchain on the order of // message delivery, even if we just sent a deploy message // for the contract above, we can be sure that it will deploy // before the internalTransfer will be called. We also put in // bounce: true, in case there is an error (we did not // deploy the contract for example) to call the // onBounce function and return the money to ourselves. ITokenWalletContract(to).internalTransfer{ value: _transfer_evers, flag: 1, bounce: true } ( _tokens, tvm.pubkey(), address(this) ); } function internalTransfer( uint128 _tokens, uint256 _sender_public_key, address _send_gas_to ) override external { // Transfer accepting function. This is a very nice concept. // We can send tokens directly from one wallet // to another because in ES a contract address is a uniquely // computed value. We can check that the contract that is // calling us is the same kind of contract as ours and has the same // Root and code. So we know for sure if the contract calls us // these tokens are real and come from the contract root. // We determine the address of the contract that called us // from _sender_public_key address expectedSenderAddress = getExpectedAddress(_sender_public_key); // We make sure that the right address called us. require(msg.sender == expectedSenderAddress, TokenWalletContractErrors.error_message_internal_transfer_bad_sender); // Accept transfer. balance += _tokens; if (_send_gas_to.value != 0) { // We send all the unspent value that was in the message back // to the contract. This is also possible to do via msg.sender, // but we want to show you here that you can send // in a long chain the address to where the change should be returned // if we have a long interaction. _send_gas_to.transfer({ value: 0, flag: 64 }); } } function getExpectedAddress( uint256 _wallet_public_key ) private inline view returns ( address ) { TvmCell stateInit = tvm.buildStateInit({ contr: TokenWalletContract, varInit: { root_address: root_address, wallet_code: wallet_code }, pubkey: _wallet_public_key, code: wallet_code }); return address(tvm.hash(stateInit)); } onBounce(TvmSlice body) external { // This is a utility function, messages will only end up here // if during message processing, an error occurs // but there is enough money to create // an onBounce message. No additional checks that you sent the // message here are needed, you can't send a message here manually. tvm.accept(); uint32 functionId = body.decode(uint32); if (functionId == tvm.functionId(ITokenWalletContract.internalTransfer)) { // Our transfer was not sent, we return the money to our balance. uint128 tokens = body.decode(uint128); balance += tokens; } } }  "},{"title":"ThirdParty.sol​","type":1,"pageTitle":"Distributed programming","url":"develop/smart-contract/learn/distributed-programming#third-party","content":"And here are some examples of ThirdParty.sol to show how to work with responsible. pragma ton-solidity &gt;= 0.53.0; pragma AbiHeader expire; pragma AbiHeader pubkey; import &quot;TokenRoot.sol&quot;; contract ThirdPartyContract { address public lastDeployedWallet; constructor() public { require(tvm.pubkey() != 0, 2); tvm.accept(); } modifier onlyOwner() { require(tvm.pubkey() == msg.pubkey(), 3); _; } function deployWallet( address _root_contract, uint256 _wallet_public_key, uint128 _send_evers, uint128 _deploy_evers ) external onlyOwner { // This entire Third party contract was done to show you how to // call the responsible function. // Everything is simple here, we just call the function and transfer // callback - this is the ID function to call tvm.accept(); ITokenRootContract(_root_contract).deployEmptyWallet{ value: _send_evers, callback: onGetDeployed }(_wallet_public_key, _deploy_evers); } function onGetDeployed( address _address ) public { // The callback which Root will call in answer to deployEmptyWallet. // There is no built-in check to make sure this function // is truly being called in answer to your call. // So you have to check if you really made this call. // For example, by storing the address of root that you are interacting with // and checking that the response is something like require(msg.sender == root_address) // Fun fact, when we get an answer here, that does not mean // that the wallet is deployed. This means that the Root // contract created an outgoing deploy message. // We can receive this message before the wallet is deployed // (the message is en route). // In principle, the LT (see Additional information) guarantees us, // that if we want to call a wallet method from here, // our message will not arrive earlier than the wallet is deployed. lastDeployedWallet = _address; } }  By carefully reading the examples above, and playing around with the code available here https://github.com/mnill/everscale-education-simple-tip3, you should be able to understand the principles of distributed programming, how separate contracts are deployed in ES for different users and why it is safe. If you’ve been able to piece everything together in your head, you are likely to also have appreciated the beauty of such a solution with distributed wallets. It solves several problems at once: There is no single big map where all balances are stored. Validators can load contracts from disks as quickly as possible.Every user deploys their own wallet and pays for the storage of their data on the blockchain.By transferring money directly between wallets, the load is distributed as evenly as possible throughout the blockchain. Each wallet ends up in a random shard, depending on the address of the wallet. So, if there is a sharp increase in the number of transfers, we do not have to rely on the performance of a particular shard, since we do not have a central smart contract through which all transfers must pass and which would cause a bottleneck. "},{"title":"LT Guarantees","type":0,"sectionRef":"#","url":"develop/smart-contract/learn/lt-guarantees","content":"","keywords":""},{"title":"Delivery order for two contracts​","type":1,"pageTitle":"LT Guarantees","url":"develop/smart-contract/learn/lt-guarantees#delivery-order-for-two-contracts","content":"When a contract receives incoming messages, it is guaranteed that it will receive them strictly in ascending order of the LT of those messages. That is, if we send two messages from the same transaction, the one that was sent first will be received first. If two messages are sent by different transactions, then the one that was sent first will be received first (the LT of the second transaction is greater than the first).  In this case, too, Int 1 will come first, but only if Ext 1 happens before Ext 2 (if you send two external messages at the same time or close in time, there is no guarantee regarding the order in which they will be added into the block).   "},{"title":"Complicated cases​","type":1,"pageTitle":"LT Guarantees","url":"develop/smart-contract/learn/lt-guarantees#complicated-cases","content":"note There is no consensus on whether or not you can count on this, so USE ONLY IF YOU UNDERSTAND WHAT YOU ARE DOING 100%, otherwise you should only use delivery order guarantees for two contracts. (This may change after new consensus) If we send two messages from contract A, and message 1 is sent before message 2, then message 1 will arrive earlier than any other message generated by message 2, as in the example below, Int 1 will always arrive before Int 3.  If you have more than 3 contracts, then the order of delivery is mostly undefined. For all other cases, you definitely shouldn’t count on this if you don’t consider yourself a super expert in LT and node operation. Below I will demonstrate several cases where the delivery order is not defined.  Here the order is not defined, G can receive a message from any of the chains first.  This is a more complicated example. If Ext 1 happens before Ext 2, but they occur close to each other in time, then 1 arrives before 3 and 4, but we don’t know in which order C will receive messages 3 and 4.   "},{"title":"Protection against replay attacks for external messages","type":0,"sectionRef":"#","url":"develop/smart-contract/learn/replay-attacks-protection","content":"Protection against replay attacks for external messages External messages can be in any format, for example, an external message could be a plain text without a signature or any data signed with a private key. In the TON protocol itself, there is no built-in protection against validators including your message any number of times. How can this be implemented? Validators can store all external messages and not allow the same message to be inserted into processing twice at the protocol level. But this approach is contrary to the philosophy of TON, because it leads to an ever-increasing tail of data that must be stored by validators and, in our network, all data must pay for its storage in the state. So protection against replay attacks was shifted to smart contracts so that they can implement the protection that suits them. Let me remind you how external messages work. You send a message to a contract out of nowhere, the validator gives it 10k gas credits and tries to apply it. If the contract agrees to do tvm.accept() for 10k gas then it will pay for the message and the transaction will go through. If there is no tvm.accept() call or an exception occurs, then this message will not go to the block. TON-Solidity has built-in protection against replay attacks. It works at the SDK + ABI level. To work with a smart contract using sdk or tonos-cli, you need contract.abi.json, a description of the functions and their variables, so that the SDK can properly package the call. This abi has a header field where Solidity always writes at least :time when compiling. This is an instruction for the SDK to apply a time to each external message, which will be used to protect against replay attacks. Solidity, before processing an external message, performs a check, which can be understood as something similar to the following (pseudocode): note This is not the actual code, so approach this skeptically contract any { uint64 hidden_ts_replay_variable; func beforeAnyExternalMessageProcessing() { uint64 header_time = msg.header.time; require(uint64(now) + 3600 &gt; header_time, 52); require(hidden_ts_replay_variable &lt; header_time, 52); hidden_ts_replay_variable = header_time; } } As you can understand, this default check is very simple but will not work well if you want to send a bunch of parallel external messages to a contract. So you can always come up with a more comprehensive checking mechanism, for example something like this.","keywords":""},{"title":"Phases of transaction execution","type":0,"sectionRef":"#","url":"develop/smart-contract/learn/phases-of-transaction-execution","content":"Phases of transaction execution Storage phase — First, money is withdrawn for storing the contract data in the blockchain, and at this stage the contract can be frozen if it does not have enough money to pay for storage. Credit phase - the account balance is increased from the value sent in the message.Computation phase — execution of the transaction. If there is an error in this phase, then we go from here to phase 5 if we have the bounce: true flag. The subtle point here is that the creation of outgoing messages and computing are separated. If your transaction tries to create outgoing messages, then it simply adds the intentions to create outgoing messages into a special register. This does not check that you have enough money to attach value to all these messages. So, if you have 1 ever on your account and you are trying to create two messages, each of which wants to send 0.8 ever, then the computation phase will succeed, the tvm exit code will be 0 and the success: true. That is, the transaction will not fail at the moment when you do not have enough value to apply, it will only fail if you run out of money to pay for gas.Action phase — in this phase, the outgoing messages are created that were put in a special register in phase 3. And if you do not have enough money to pay for outgoing messages, the transaction will be rolled back and go to phase 5 (if the flag is on). In this situation, you will have the computation - success: true, action - success: false, abort: true. There is also a special flag when creating a message, which says that this message should be ignored if there is not enough money to create it.Bounce phase — if the bounce: true flag was set for the incoming message, then in this phase a back message is created (if there is enough money left to pay for the message), which will call the onBounce utility function. Any remaining value will be attached to the message. See more details in Transaction executor","keywords":""},{"title":"Magic and overheads of Solidity compilers","type":0,"sectionRef":"#","url":"develop/smart-contract/learn/solidity-compiler-overheads","content":"Magic and overheads of Solidity compilers There are some nuances to the TON Solidity compiler. How does responsible work? Under the hood, one more variable has to be added, which points to the id of the function that should be called in the return message. You need to understand that when you receive a response to responsible, there is no magic check that will verify that you really called responsible. You yourself need to check everything here (that you really made this call and that the answer came from the correct contract). function owner() override external responsible returns (address) { return { value: 0, flag: 64, bounce: false }owner_; } // This will be compiled in something like this: function owner(uint32 asnwerID) override external returns (address) { msg.sender.call({ value: 0, flag: 64 bounce: false, functionToCall: asnwerID, values: owner_ }); } There are three utility variables solidity compiler add under the hood: _pubkey — this is just a static variable taken out separately, and it serves for the tvm.pubkey() and verification of the signature of the incoming external message;_constructorFlag — this is a constructor call flag. In general, due to the peculiarities of the blockchain, the internal work constructor in TON Solidity was implemented in a tricky way. When we deploy a contract, we can specify one function that we want to call after the deployment of the contract and its arguments. If we call the constructor, then, if its execution was successful, at the end the _constructorFlag will be set to true. All other functions check before their execution that the constructor has been called, if not, an error will occur. But since we can deploy a contract and not call the constructor, it is possible that the contract will get deployed, but its constructor will not be called. We must keep this in mind;_timestamp — this is the time of the last external call, used in the protection against replay attacks described above. There is also an interesting feature with state variables. At compilation time, Solidity will allocate all state variables to cells in the contract storage, like this: Storage for contracts in TVM is register c4, this is a BoC. There is a service register for temporary data c7 - but this is a tuple and it is always cleared at the end of a transaction. So, every time a transaction begins processing, Solidity unpacks variables from c4 to c7, so that it is easier to work with them in the code by register indexes, and at the end of the work it repacks them back to c4. You can draw your own conclusions, but it is undeniable that the more variables you have, the greater the overhead for unpacking/packing.","keywords":""},{"title":"SMV Contracts","type":0,"sectionRef":"#","url":"develop/smart-contract/smv-contracts","content":"","keywords":""},{"title":"1. Introduction​","type":1,"pageTitle":"SMV Contracts","url":"develop/smart-contract/smv-contracts#1-introduction","content":"You can use the TONOS-CLI utility to deploy contracts and manage them. Available actions in TONOS-CLI include the following: setting the network that the utility should connect to creating seed phrases, private and public keys, which will be used for wallet managementgenerating contract addressdeploying contractchecking contract balance and statusrunning getter contract methodsexecuting contract methodsrun debots "},{"title":"2. TONOS-CLI Installation​","type":1,"pageTitle":"SMV Contracts","url":"develop/smart-contract/smv-contracts#2-tonos-cli-installation","content":""},{"title":"2.1. Install TONOS-CLI and download contract files​","type":1,"pageTitle":"SMV Contracts","url":"develop/smart-contract/smv-contracts#21-install-tonos-cli-and-download-contract-files","content":"Linux​ Create a folder. Download the .tar.gz file from the latest release from here: https://github.com/tonlabs/tonos-cli/releases to this folder. Extract it: tar -xvf tonos-cli_v0.1.27_linux.tar.gz  Download contract files (config.hpp, Budget.*, Contest.*, MultiBallot.*, ProposalRoot.*, SMVStats.*, SuperRoot.*) from https://github.com/tonlabs/ton-labs-contracts/tree/master/governance/SMV. Place them into the folder containing the TONOS-CLI executable. Note: Make sure you have downloaded the raw versions of the files. If you use wget or curl be aware that github can send you a redirection page instead of a file. Use appropriate tool flag to avoid it. Mac OS​ Install Cargo: https://github.com/rust-lang/cargo#compiling-from-source Build TONOS-CLI tool from source: &gt; git clone &lt;https://github.com/tonlabs/tonos-cli.git&gt; &gt; cd tonos-cli &gt; cargo build --release &gt; cd target/release/  Download contract files (config.hpp, Budget.*, Contest.*, MultiBallot.*, ProposalRoot.*, SMVStats.*, SuperRoot.*) from https://github.com/tonlabs/ton-labs-contracts/tree/master/governance/SMV. Place them into the tonos-cli/target/release/ utility folder. Note: Make sure you have downloaded the raw versions of the files. If you use wget or curl be aware that github can send you a redirection page instead of a file. Use appropriate tool flag to avoid it. Note: On Mac OS all calls of the TONOS-CLI utility should be performed from the tonos-cli/target/release/ folder. Windows​ The workflow is the same as for Mac OS (see the section above). However, when using Windows command line, the following syntax should be used for all TONOS-CLI commands: tonos-cli &lt;command_name&gt; &lt;options&gt;  Simply omit the ./ symbols before tonos-cli. "},{"title":"2.2. Set blockchain network​","type":1,"pageTitle":"SMV Contracts","url":"develop/smart-contract/smv-contracts#22-set-blockchain-network","content":"Note: By default TONOS-CLI connects to net.ton.dev network. Use the following command to switch to any other network ./tonos-cli config --url &lt;https://network_url&gt;  You need to do it only once before using the utility. A .json configuration file will be created in the TONOS-CLI utility folder. The URL of the current network will be specified there. All subsequent calls of the utility will use this file to select the network to connect to. "},{"title":"3. Installing clang for TVM​","type":1,"pageTitle":"SMV Contracts","url":"develop/smart-contract/smv-contracts#3-installing-clang-for-tvm","content":"Install clang from https://github.com/tonlabs/TON-Compiler. "},{"title":"4. Build contracts​","type":1,"pageTitle":"SMV Contracts","url":"develop/smart-contract/smv-contracts#4-build-contracts","content":"TON-Compiler clang must be in PATH, check with clang --version:TON Labs clang for TVM. ...  clang++ -o Budget.tvc Budget.cpp clang++ -o MultiBallot.tvc MultiBallot.cpp clang++ -o ProposalRoot.tvc ProposalRoot.cpp clang++ -o SuperRoot.tvc SuperRoot.cpp clang++ -o SMVStats.tvc SMVStats.cpp clang++ -o Contest.tvc Contest.cpp  It will generate both tvc and abi files. Also you may use pre-compiled tvc/abi files from the same repository, or use the provided Makefile for compilation. "},{"title":"5. Deploying super root to the Blockchain​","type":1,"pageTitle":"SMV Contracts","url":"develop/smart-contract/smv-contracts#5-deploying-super-root-to-the-blockchain","content":""},{"title":"5.1. Generating seed phrase​","type":1,"pageTitle":"SMV Contracts","url":"develop/smart-contract/smv-contracts#51-generating-seed-phrase","content":"To generate your seed phrase enter the following command: ./tonos-cli genphrase  Terminal displays the generated seed phrase. Note: The seed phrase (and the corresponding key) is used only in deploy procedure of SuperRoot and will be zeroed when the contract is fully initialized. "},{"title":"5.2. Generating super root address and deployment key pair​","type":1,"pageTitle":"SMV Contracts","url":"develop/smart-contract/smv-contracts#52-generating-super-root-address-and-deployment-key-pair","content":"Use the following command: ./tonos-cli getkeypair &lt;deploy.keys.json&gt; &quot;&lt;seed_phrase&gt;&quot;  deploy.keys.json - the file the key pair will be written to. The utility generates the file that contains the key pair produced from seed phrase. Use it to generate your address: ./tonos-cli genaddr SuperRoot.tvc SuperRoot.abi --setkey deploy.keys.json --wc &lt;workchain_id&gt;  deploy.keys.json - the file the key pair is read from.--wc &lt;workchain_id&gt; - (optional) ID of the workchain the contract will be deployed to (-1 for masterchain, 0 for basechain). By default this value is set to 0. The utility displays the new super root address (Raw_address). Note: The super root address is required for any interactions with the contract. It is better to save super root address into variable: export TVM_SUPER_ROOT_ADDR=&lt;super_root_address&gt;  5.2.1. (Optional) Check that a contract with the address generated on the previous step does not already exist in the blockchain​ Request status for the generated contract address from the blockchain: ./tonos-cli account &lt;super_root_address&gt;  5.2.2. Send a few tokens to the new address from another contract.​ Create, and if necessary, confirm a transaction from some wallet. Ensure that contract address has been created in the blockchain and has Uninit status. ./tonos-cli account &lt;super_root_address&gt;  "},{"title":"5.3. Place ProposalRoot and MultiBallot code into variables​","type":1,"pageTitle":"SMV Contracts","url":"develop/smart-contract/smv-contracts#53-place-proposalroot-and-multiballot-code-into-variables","content":"ProposalRoot and MultiBallot code must be set into SuperRoot after initial deploy (setProposalRootCode, setMultiBallotCode), so we need to save ProposalRoot.tvc and MultiBallot.tvc code into variables: tvm_linker decode --tvc ProposalRoot.tvc &gt; code_proposal.txt tvm_linker decode --tvc MultiBallot.tvc &gt; code_multiballot.txt  Note: tvm_linker utility: https://github.com/tonlabs/TVM-linker Edit code_proposal.txt and code_multiballot.txt to keep only code: section content. Save code_proposal.txt and code_multiballot.txt content into variables: export TVM_PROPOSAL_CODE=`cat code_proposal.txt` export TVM_MULTIBALLOT_CODE=`cat code_multiballot.txt`  "},{"title":"5.4. Deploy the SMV budget and stats contracts​","type":1,"pageTitle":"SMV Contracts","url":"develop/smart-contract/smv-contracts#54-deploy-the-smv-budget-and-stats-contracts","content":"5.4.1. Generate address of Budget and SMVStats​ ./tonos-cli genaddr Budget.tvc Budget.abi --setkey deploy.keys.json --wc &lt;workchain_id&gt; ./tonos-cli genaddr SMVStats.tvc SMVStats.abi --setkey deploy.keys.json --wc &lt;workchain_id&gt;  It is better to save Budget and SMVStats address into variables: export TVM_BUDGET_ADDR=&lt;budget_address&gt; export TVM_STATS_ADDR=&lt;stats_address&gt;  5.4.2. (Optional) You may check that &lt;budget_address&gt; and &lt;stats_address&gt; are not yet occupied:​ ./tonos-cli account $TVM_BUDGET_ADDR ./tonos-cli account $TVM_STATS_ADDR  5.4.3. Send a few tokens to the new addresses from another contract.​ Create, and if necessary, confirm a transaction from some wallet. Ensure that contract addresses have been created in the blockchain and has Uninit status. ./tonos-cli account $TVM_BUDGET_ADDR ./tonos-cli account $TVM_STATS_ADDR  5.4.4. Run deploy commands for Budget and SMVStats contracts​ You should provide calculated &lt;super_root_address&gt; as a constructor parameter SMV_root. SMVStats contract will registrate statistic records from this address. And Budget contract will process funds allocation requests (to an approved contest) from this address. Note: Do not transfer big funds to Budget contract until SuperRoot is deployed and fully initialized. ./tonos-cli deploy Budget.tvc '{&quot;SMV_root&quot;:&quot;'$TVM_SUPER_ROOT_ADDR'&quot;}' --abi Budget.abi --sign deploy.keys.json --wc &lt;workchain_id&gt; ./tonos-cli deploy SMVStats.tvc '{&quot;SMV_root&quot;:&quot;'$TVM_SUPER_ROOT_ADDR'&quot;}' --abi SMVStats.abi --sign deploy.keys.json --wc &lt;workchain_id&gt;  "},{"title":"5.5. Deploy the super root contract to the blockchain​","type":1,"pageTitle":"SMV Contracts","url":"develop/smart-contract/smv-contracts#55-deploy-the-super-root-contract-to-the-blockchain","content":"Note: full deployment of the super root is splitted into three commands because the network has size limit for one message (16k) and the contracts (SuperRoot.tvc + ProposalRoot.tvc + MultiBallot.tvc) break this limit. Use the following commands: ./tonos-cli deploy SuperRoot.tvc '{&quot;budget&quot;:&quot;'$TVM_BUDGET_ADDR'&quot;,&quot;stats&quot;:&quot;'$TVM_STATS_ADDR'&quot;}' --abi SuperRoot.abi --sign deploy.keys.json --wc &lt;workchain_id&gt;  Configuration parameters: budget - address of Budget contract.stats - address of SMVStats contract.--wc &lt;workchain_id&gt; - (optional) ID of the workchain the wallet will be deployed to (-1 for masterchain, 0 for basechain). By default this value is set to 0. ./tonos-cli call &lt;super_root_address&gt; setProposalRootCode '{&quot;code&quot;:&quot;'$TVM_PROPOSAL_CODE'&quot;}' --abi SuperRoot.abi --sign deploy.keys.json ./tonos-cli call &lt;super_root_address&gt; setMultiBallotCode '{&quot;code&quot;:&quot;'$TVM_MULTIBALLOT_CODE'&quot;}' --abi SuperRoot.abi --sign deploy.keys.json  5.5.1. Check the super root status again​ Now it should be Active. ./tonos-cli account &lt;super_root_address&gt;  5.5.2. Check that the super root contract is fully initialized​ ./tonos-cli run &lt;super_root_address&gt; isFullyInitialized {} --abi SuperRoot.abi  "},{"title":"6. Super Root requests​","type":1,"pageTitle":"SMV Contracts","url":"develop/smart-contract/smv-contracts#6-super-root-requests","content":""},{"title":"6.1. Selecting blockchain network​","type":1,"pageTitle":"SMV Contracts","url":"develop/smart-contract/smv-contracts#61-selecting-blockchain-network","content":"Note: By default TONOS-CLI connects to net.ton.dev network. Use the following command to switch to any other network ./tonos-cli config --url &lt;https://network_url&gt;  You need to do it only once before using the utility. A .json configuration file will be created in the TONOS-CLI utility folder. The URL of the current network will be specified there. All subsequent calls of the utility will use this file to select the network to connect to. "},{"title":"6.2. Creating of proposal​","type":1,"pageTitle":"SMV Contracts","url":"develop/smart-contract/smv-contracts#62-creating-of-proposal","content":"Note: SuperRoot is not processing external commands after initialization. You need to prepare and send internal message from another contract (Multisig wallet, for example) to create multiballot or proposal. bool_t createProposal(uint256 id, address depool, uint128 totalVotes, uint32 startime, uint32 endtime, bytes desc, bool_t superMajority, uint256 votePrice, bool_t finalMsgEnabled, cell finalMsg, uint256 finalMsgValue, uint256 finalMsgRequestValue, bool_t whiteListEnabled, dict_array&lt;uint256&gt; whitePubkeys);  The internal call will return success flag with the rest of funds. The deployed proposal address may be known using getProposalAddress getter. "},{"title":"6.3. Creating of multiballot​","type":1,"pageTitle":"SMV Contracts","url":"develop/smart-contract/smv-contracts#63-creating-of-multiballot","content":"6.3.1 Calculating multiballot address for specified public key​ ./tonos-cli run &lt;super_root_address&gt; getMultiBallotAddress '{&quot;pubkey&quot;:&quot;0x&lt;ballot public key&gt;&quot;, &quot;depool&quot;:&quot;&lt;depool address&gt;&quot;}' --abi SuperRoot.abi  6.3.2 Deploying MultiBallot from super root​ Note: SuperRoot is not processing external commands after initialization. You need to prepare and send internal message from another contract (Multisig wallet, for example) to create multiballot or proposal. address createMultiBallot(uint256 pubkey, address depool, uint256 tonsToBallot);  The internal call will return the deployed MultiBallot address with the rest of funds. The returned address should be equal to calculated by getWalletAddress. "},{"title":"7. It is recommended to use SMV DeBots for proposal/multiballot creation and voting.​","type":1,"pageTitle":"SMV Contracts","url":"develop/smart-contract/smv-contracts#7-it-is-recommended-to-use-smv-debots-for-proposalmultiballot-creation-and-voting","content":""},{"title":"7.1 Deploy SMV DeBot​","type":1,"pageTitle":"SMV Contracts","url":"develop/smart-contract/smv-contracts#71-deploy-smv-debot","content":"DeBots should be deployed in the following order: SMVStatDebotProposalRootDebotMultiBallotDebotSuperRootDebot Note: You can see deployall.sh script file for more details. "},{"title":"7.2 How to vote​","type":1,"pageTitle":"SMV Contracts","url":"develop/smart-contract/smv-contracts#72-how-to-vote","content":"7.2.1 Deploy MultiBallot​ To vote for proposals you need to have MultiBallot account(smart-contract). To deploy your MultiBallot first of all you need seed phrase and keypair. You can use tonos-cli to generate it. Run command to generate seed phrase:./tonos-cli genphrase Than you can create a key pair file from a seed phrase using the following command:./tonos-cli getkeypair &lt;keyfile.json&gt; &quot;&lt;seed_phrase&gt;&quot; Now you can start deploy MultiBallot from SMV DeBot. Select command 3) Deploy MultiBallot. Enter the address of the multisig wallet from which you want to pay for the deployment. At second step you should enter your generated public key. And then enter the amount of tons you want to send to you MultiBallot as mainterance (1 ton will be fine). Select 1) Yes - let's deploy! and submit transaction with you multisig seed phrase or keypair file. Now your MultiBallot is deployed. Select 1) Vote and enter your MultiBallot public key. Now you need to make deposit. Select 4) Add deposit from msig or 5) Add deposit from depool and follow instructions. You allways can check you deposit with 3) Get total deposit command. You can withdraw you deposit with command 6) Withdraw deposit. Note: you cannot withdraw your deposit until all proposals you voted for have been completed 7.2.2 Vote​ Select 1) Votecommand from SMV DeBot. Enter your MultiBallot public key and run 1) Vote command to see all proposals you can vote and then vote for them. If you know the specific proposal address you can vote for it with 2) Vote by proposal address command. "},{"title":"7.3 Other commands​","type":1,"pageTitle":"SMV Contracts","url":"develop/smart-contract/smv-contracts#73-other-commands","content":"To see information about budget transfers use command 4) Show statistic.You can use command 2) Deploy proposal for deploy the proposal. Some additional information can be obtain from 5) Additional information command: 1) Get proposal ids - show the list of created proposals id. 2) Get proposal address by id – get the proposal address by its id. 3) Get multiballot address - get the multiballot address by its public key 4) Show proposal info – show proposal info by the proposal address "},{"title":"Comparison with Solidity contracts","type":0,"sectionRef":"#","url":"develop/smart-contract/solidity-developing/comparison","content":"Comparison with Solidity contracts This article has TO DO status. You can contribute by submitting your own version of this page. More details on the Documentation page of the Hot streams section. The documentation in Everscale repository is a community effort. Therefore, everyone can contribute with proposals for new topics, suggest new content elements, participate in editing, and provide ideas that will be of great help for network development. Please be informed that our documentation can be edited via GitHub. Also please make sure to consult our rules and rewards policy via this link. Feel free to join Everscale Documentation Development Telegram chat and Everscale Developers Onboarding Telegram chat!","keywords":""},{"title":"Solidity Compiler","type":0,"sectionRef":"#","url":"develop/smart-contract/solidity-developing/compiler","content":"Solidity Compiler Compile the contract code to TVM assembler with the Solidity Compiler. &lt;PATH_TO&gt;/TON-Solidity-Compiler/compiler/build/solc/solc Wallet.sol The compiler produces Wallet.code and Wallet.abi.json to be used in the following steps. Assemble and link with a standard library into TVM bytecode: &lt;PATH_TO&gt;/tvm_linker compile Wallet.code --lib &lt;path-to&gt;/TON-Solidity-Compiler/lib/stdlib_sol.tvm Binary code of your contract is recorded into WalletAddress.tvc file, where WalletAddress is a temporary address of the contract. The documentation in Everscale repository is a community effort. Therefore, everyone can contribute with proposals for new topics, suggest new content elements, participate in editing, and provide ideas that will be of great help for network development. Please be informed that our documentation can be edited via GitHub. Also please make sure to consult our rules and rewards policy via this link. Feel free to join Everscale Documentation Development Telegram chat and Everscale Developers Onboarding Telegram chat!","keywords":""},{"title":"Getting started","type":0,"sectionRef":"#","url":"develop/smart-contract/solidity-developing/getting-started","content":"","keywords":""},{"title":"You will need:​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/solidity-developing/getting-started#you-will-need","content":"A PC or laptop with a basic set of developer tools(Recommended: Ubuntu 18.04) LinuxWindowsMacOSA Solidity to TVM assembly compiler(Recommended) build from sourcesdownload as a binaryrun in a docker containerContract code in SolidityUse Wallet.sol belowUse your own codeTake one of the samples from the samples repositoryUtilities to link and deploy contract to the blockchainbuild from sourcesdownload as a binaryrun in a docker container "},{"title":"Recommended setup​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/solidity-developing/getting-started#recommended-setup","content":"OS: Ubuntu 18.04 is the easiest to run.tip: running Ubuntu in VM works fine. Check out this install guide.Build Solidity compiler from the source (4-6 minutes)checkout from github (a few seconds);install dependencies as per README (1-2 minutes)build the compiler from source per README (~3-5 minutes)Contract source code:Use Wallet.sol belowCommand line tools, either of:download as a part of a binary packagebuild tvm_linker and tonos-cli from sources "},{"title":"Install the Compiler​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/solidity-developing/getting-started#install-the-compiler","content":"Install TON Labs Solidity Compiler from the open source repository. git clone git@github.com:tonlabs/TON-Solidity-Compiler.git cd compiler sh ./scripts/install_deps.sh mkdir build cd build cmake .. -DUSE_CVC4=OFF -DUSE_Z3=OFF -DTESTS=OFF -DCMAKE_BUILD_TYPE=Debug make -j8  Get the contract source code pragma solidity &gt;= 0.6.0; /// @title Simple wallet /// @author Tonlabs contract Wallet { // Modifier that allows function to accept external call only if it was signed // with contract owner's public key. modifier checkOwnerAndAccept { // Check that inbound message was signed with owner's public key. // Runtime function that obtains sender's public key. require(msg.pubkey() == tvm.pubkey(), 100); // Runtime function that allows contract to process inbound messages spending // its own resources (it's necessary if contract should process all inbound messages, // not only those that carry value with them). tvm.accept(); _; } /* * Public functions */ /// @dev Contract constructor. constructor() public checkOwnerAndAccept { } /// @dev Allows to transfer grams to the destination account. /// @param dest Transfer target address. /// @param value Nanograms value to transfer. /// @param bounce Flag that enables bounce message in case of target contract error. function sendTransaction(address payable dest, uint128 value, bool bounce) public view checkOwnerAndAccept { // Runtime function that allows to make a transfer with arbitrary settings. dest.transfer(value, bounce, 3); } // Function to receive plain transfers. receive() external payable { } }  "},{"title":"Compile​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/solidity-developing/getting-started#compile","content":"Compile the contract code to TVM assembler with the Solidity Compiler. &lt;PATH_TO&gt;/TON-Solidity-Compiler/compiler/build/solc/solc Wallet.sol  The compiler produces Wallet.code and Wallet.abi.json to be used in the following steps. Assemble and link with a standard library into TVM bytecode: &lt;PATH_TO&gt;/tvm_linker compile Wallet.code --lib &lt;path-to&gt;/TON-Solidity-Compiler/lib/stdlib_sol.tvm  Binary code of your contract is recorded into&lt;WalletAddress&gt;.tvcfile, where&lt;WalletAddress&gt;is a temporary address of the contract. "},{"title":"Deploy​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/solidity-developing/getting-started#deploy","content":"Let's deploy the contract to TON Labs development blockchain atnet.ton.dev. 1) Make sure tonos-cli is in $PATH: export PATH=$PATH:&lt;PATH_TO&gt;/tonos-cli tonos-cli config --url net.ton.dev  2) Generate address, keys and seed phrase for your contract: tonos-cli genaddr &lt;WalletAddress&gt;.tvc Wallet.abi.json --genkey Wallet.keys.json  Address of your contract in the blockchain is located after Raw address: IMPORTANT: Save this value - you will need it to deploy your contract and to work with it. We will refer to it as &quot;YourAddress&quot; below. Seed phrase is also printed to stdout. Key pair will be generated and saved to the file Wallet.keys.json. Note that you will need to send some coins to the address before the actual deployment. TON deploy is fee-based, so your new contract will be charged for this. 3) Get some [test] coins to your account. Options are: ask a friend to sponsor your contract deployment;transfer some currency from your wallet account;ask in developer chats. 4) Check the state of the pre-deployed contract. It should be Uninit: tonos-cli account &lt;YourAddress&gt;  5) Deploy your contract to the selected network (TON Labs devnet in the example) with the following command: tonos-cli deploy --abi Wallet.abi.json --sign Wallet.keys.json &lt;contract&gt;.tvc {&lt;constructor_arguments&gt;}  If either of --abi or --sign options is omitted in parameters, it must be specified in the config file. See below. 6) Check the contract state again. This time, it is should be active. 7) Call the function of your contract: tonos-cli call '&lt;YourAddress&gt;' sendTransaction '{&quot;dest&quot;:&quot;DestAddress&quot;, &quot;value&quot;:1000000000, &quot;bounce&quot;:true}' --abi Wallet.abi.json --sign Wallet.keys.json  "},{"title":"Further Steps​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/solidity-developing/getting-started#further-steps","content":"Now your contract is up and running! You can: Check out Solidity API for TONCheck out more contract samplesExplore in depth some aspects of smart-contract development for TONBuild CLI utilities from source in GitHub to make sure you have the latest versionCheck our research papers and TON docs in readable format "},{"title":"Multisignature Wallet","type":0,"sectionRef":"#","url":"develop/smart-contract/multisignature-wallet","content":"","keywords":""},{"title":"Glossary​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#glossary","content":"Multisignature wallet - crypto wallet on the blockchain, which supports multiple owners (custodians), who are authorized to manage the wallet. Wallet address - unique address of the wallet on the blockchain. It explicitly identifies the wallet and is required for any actions with the wallet to be performed. It does not, on its own, provide anyone access to wallet funds. Wallet custodian - authorized owner of the wallet. Owns the private key and corresponding seed phrase, which are required to make any changes to the wallet or wallet funds. Wallet may have more than one custodian. Custodian private key - the unique cryptographic key belonging to the wallet custodian, which authorizes access to the wallet. Should be kept secret. Custodian seed phrase - unique mnemonic phrase exactly corresponding to the custodian private key. Can be used to restore the private key, or to sign transactions in TONOS-CLI instead of it. Should be kept secret and securely backed up. Custodian public key - public key forming a cryptographic key pair with the custodian private key. It is not secret and may be freely shared with anyone. Validator - the entity performing validation of new blocks on the blockchain through a Proof-of-Stake system. Requires a multisignature wallet for staking. 2. Install TONOS-CLI "},{"title":"2.1. Install TONOS-CLI utility​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#21-install-tonos-cli-utility","content":""},{"title":"Install compiled executable​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#install-compiled-executable","content":"Create a folder. Download the .zip file from the latest release from here: https://github.com/tonlabs/tonos-cli/releases to this folder. Extract it. "},{"title":"Install through TONDEV​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#install-through-tondev","content":"You can use TONDEV to install the latest version of TONOS-CLI. tondev tonos-cli install  The installer requires NPM to be installed, so it can install packages globally without using sudo. In case of error, manually set environment variable PATH=$PATH:$HOME./tondev/solidity This command updates TONOS-CLI installed through TONDEV to the latest version: tondev tonos-cli update  This command specifies TONOS-CLI version to use and downloads it if needed: tondev tonos-cli set --version 0.8.0  "},{"title":"Build from source​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#build-from-source","content":"Refer to the TONOS-CLI readme for build from source procedure. "},{"title":"Tails OS secure environment​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#tails-os-secure-environment","content":"For maximum security while working with offline TONOS-CLI features (such as cryptographic commands or encrypted message generation), you can use the Tails OS. You can perform the following actions entirely offline: Generate seed phrases and custodian keysPepare deployment message offlinePrepare new transaction offlinePrepare transaction confirmation offline "},{"title":"A note on Windows syntax​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#a-note-on-windows-syntax","content":"When using Windows command line, the following syntax should be used for all TONOS-CLI commands: Never use the ./ symbols before tonos-cli: &gt; tonos-cli &lt;command_name&gt; &lt;options&gt;  For all commands with nested quotes, the outer single quotes should be changed to double quotes, and the inner double quotes should be shielded by a preceding \\. Example: &gt; tonos-cli deploy SafeMultisigWallet.tvc &quot;{\\&quot;owners\\&quot;:[\\&quot;0x723b2f0fa217cd10fe21326634e66106678f15d5a584babe4f576dffe9dcbb1b\\&quot;,\\&quot;0x127e3ca223ad429ddaa053a39fecd21131df173bb459a4438592493245b695a3\\&quot;,\\&quot;0xc2dd3682ffa9df97a968bef90b63da90fc92b22163f558b63cb7e52bfcd51bbb\\&quot;],\\&quot;reqConfirms\\&quot;:2}&quot; --abi SafeMultisigWallet.abi.json --sign deploy.keys.json  "},{"title":"2.2. Download contract files​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#22-download-contract-files","content":"Download compiled .abi.json and .tvc multisignature contract files from https://github.com/tonlabs/ton-labs-contracts/tree/master/solidity Choose a contract version: SafeMultisig - basic multisignature wallet, does not permit contract code modification. Is required if you use validator scripts. SafeMultisigWallet.abi.json direct link: https://raw.githubusercontent.com/tonlabs/ton-labs-contracts/master/solidity/safemultisig/SafeMultisigWallet.abi.json SafeMultisigWallet.tvc direct link: https://github.com/tonlabs/ton-labs-contracts/raw/master/solidity/safemultisig/SafeMultisigWallet.tvc SetcodeMultisig - more advanced multisignature wallet. SetcodeMultisigWallet.abi.json direct link: https://raw.githubusercontent.com/tonlabs/ton-labs-contracts/master/solidity/setcodemultisig/SetcodeMultisigWallet.abi.json SetcodeMultisigWallet.tvc direct link: https://github.com/tonlabs/ton-labs-contracts/raw/master/solidity/setcodemultisig/SetcodeMultisigWallet.tvc Place both files into the folder containing the tonos-cli executable. Note: Make sure you have downloaded the raw versions of the files. A common error when downloading from the github project page manually is to save the redirection page instead of the raw file.Note: TON Surf uses a specialized version of the SetcodeMultisig contract. It will not be possible to manage a standard Setcode wallet in TON Surf. "},{"title":"2.3. Configure TONOS-CLI environment​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#23-configure-tonos-cli-environment","content":"(Optional, Linux/Mac OS, if you didn't install through tondev) Put tonos-cli into system environment: export PATH=&quot;&lt;tonos_folder_path&gt;:$PATH&quot;  If you skip this step and didn't install through tondev, make sure you run the utility from the utility folder: ./tonos-cli &lt;command&gt; &lt;options&gt;  Use the following command to set the network: tonos-cli config --url &lt;https://network_url&gt;  Some of the frequently used networks: https://net.ton.dev - developer sandbox for testing. https://main.ton.dev - main Everscale network. https://rustnet.ton.dev - test network running on Rust nodes. You need to do it only once before using the utility. tonos-cli.conf.json configuration file will be created in the current folder. The URL of the current network will be specified there. All subsequent calls of the utility will use this file to select the network to connect to. Note: By default tonos-cli connects to net.ton.dev network.Note: Always run tonos-cli utility only from the folder where tonos-cli.conf.json is placed, unless you have configured a different path for the file. Refer to the TONOS-CLI document for additional information. 3. Use the following command to check the set network:  tonos-cli config --list  For additional configuration options, refer to the TONOS-CLI readme. 3. Create Wallet The following actions should be performed to create a wallet: Create wallet seed phraseGenerate deployment key pair file with wallet private/public keys based on the wallet seed phraseGenerate wallet address based on the wallet seed phraseSend some tokens to the wallet addressDeploy wallet (set custodians) All of these steps are detailed in this section. "},{"title":"3.1. Create seed phrases and public keys for all custodians​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#31-create-seed-phrases-and-public-keys-for-all-custodians","content":""},{"title":"3.1.1. Create wallet seed phrase​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#311-create-wallet-seed-phrase","content":"To generate your seed phrase enter the following command: tonos-cli genphrase  Terminal displays the generated seed phrase. Example: $ tonos-cli genphrase Config: /home/user/tonos-cli.conf.json Succeeded. Seed phrase: &quot;rule script joy unveil chaos replace fox recipe hedgehog heavy surge online&quot;  Note: Seed phrases should be created for every custodian of the multisignature wallet. The seed phrase ensures access to the multisignature wallet. If lost, the custodian will no longer be able to manage the wallet. The seed phrase is unique for every custodian and should be kept secret and securely backed up (word order matters). 3.1.2. Generate public key​ To generate your public key enter the following command with your previously generated seed phrase in quotes: tonos-cli genpubkey &quot;&lt;seed_phrase&gt;&quot;  Example: $ tonos-cli genpubkey &quot;rule script joy unveil chaos replace fox recipe hedgehog heavy surge online&quot; Config: /home/user/tonos-cli.conf.json Succeeded. Public key: 88c541e9a1c173069c89bcbcc21fa2a073158c1bd21ca56b3eb264bba12d9340 &lt;QR code with key&gt;  Copy the generated code from Terminal or scan the QR code containing the code with your phone and send it to whichever custodian is responsible for deploying the multisignature wallet. Note: The public key should also be generated for every custodian. The public key is not secret and can be freely transmitted to anyone. 3.2. Generate deployment key pair file​ Any custodian who has received the public keys of all other custodians can deploy the multisignature wallet to the blockchain. To create the key pair file from the seed phrase generated at step 3.1.1 use the following command: tonos-cli getkeypair &lt;deploy.keys.json&gt; &quot;&lt;seed_phrase&gt;&quot;  &lt;deploy.keys.json&gt; - the file the key pair will be written to. The utility generates the file that contains the key pair produced from seed phrase. $ tonos-cli getkeypair key.json &quot;rule script joy unveil chaos replace fox recipe hedgehog heavy surge online&quot; Config: /home/user/tonos-cli.conf.json Input arguments: key_file: key.json phrase: rule script joy unveil chaos replace fox recipe hedgehog heavy surge online Succeeded.  "},{"title":"3.3. Generate wallet address​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#33-generate-wallet-address","content":"Use deployment key pair file to generate your address: tonos-cli genaddr &lt;MultisigWallet.tvc&gt; &lt;MultisigWallet.abi.json&gt; --setkey &lt;deploy.keys.json&gt; --wc &lt;workchain_id&gt;  &lt;MultisigWallet.tvc&gt; - either SafeMultisigWallet.tvc or SetcodeMultisigWallet.tvc depending on the contract you have selected at step 2.2. &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2. &lt;deploy.keys.json&gt; - the file the key pair is read from. --wc &lt;workchain_id&gt; - (optional) ID of the workchain the wallet will be deployed to (-1 for masterchain, 0 for basechain). By default this value is set to 0. Note: Masterchain fees are significantly higher, but masterchain is required for direct staking validator wallets. Make sure to set workchain ID to -1 for any direct staking validator wallets you are deploying: --wc -1. Basechain, on the other hand, is best suited for user wallets and validator wallets that are staking through a DePool. The utility displays the new multisignature wallet address (Raw_address). Example: $ tonos-cli genaddr --genkey key.json --wc -1 SafeMultisigWallet.tvc SafeMultisigWallet.abi.json Config: /home/user/tonos-cli.conf.json Input arguments: tvc: SafeMultisigWallet.tvc wc: -1 keys: key.json init_data: None is_update_tvc: None Seed phrase: &quot;chimney nice diet engage hen sing vocal upgrade column address consider word&quot; Raw address: -1:a021414a79539001ed35d615a646dc8b89df29ccccf143c30df15c7fbcaff086 testnet: Non-bounceable address (for init): 0f-gIUFKeVOQAe011hWmRtyLid8pzMzxQ8MN8Vx_vK_whkeM Bounceable address (for later access): kf-gIUFKeVOQAe011hWmRtyLid8pzMzxQ8MN8Vx_vK_whhpJ mainnet: Non-bounceable address (for init): Uf-gIUFKeVOQAe011hWmRtyLid8pzMzxQ8MN8Vx_vK_whvwG Bounceable address (for later access): Ef-gIUFKeVOQAe011hWmRtyLid8pzMzxQ8MN8Vx_vK_whqHD Succeeded  Note: The wallet address is required for any interactions with the wallet. It should be shared with all wallet custodians. "},{"title":"3.4. Send tokens to the new address from another wallet​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#34-send-tokens-to-the-new-address-from-another-wallet","content":"Use the following command to create a new transaction from another existing wallet: tonos-cli call &lt;source_address&gt; submitTransaction '{&quot;dest&quot;:&quot;&lt;raw_address&gt;&quot;,&quot;value&quot;:&lt;nanotokens&gt;,&quot;bounce&quot;:false,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;}' --abi &lt;MultisigWallet.abi.json&gt; --sign &quot;&lt;source_seed_or_keyfile&gt;&quot;  &lt;source_address&gt; - address of the wallet the funds are sent from. &quot;dest&quot;:&lt;raw_address&gt; - new wallet address generated at step 3.3. Example: &quot;0:f22e02a1240dd4b5201f8740c38f2baf5afac3cedf8f97f3bd7cbaf23c7261e3&quot; &quot;value&quot;: - amount of tokens to transfer in nanotokens (Example: &quot;value&quot;:10000000000 sets up a transfer of 10 tokens). &quot;bounce&quot; - use false to transfer funds to a non-existing contract to create it. &quot;payload&quot; - use &quot;&quot; for simple transfer. Otherwise payload is used as a body of outbound internal message. &quot;allBalance&quot; - used to transfer all funds in the wallet. Use false for a simple transfer. Note: Due to a bug setting allBalance to true currently causes errors. Single-custodian multisig wallets may use sendTransaction method with flag 130 and value 0 instead: tonos-cli call &lt;multisig_address&gt; sendTransaction '{&quot;dest&quot;:&quot;raw_address&quot;,&quot;value&quot;:0,&quot;bounce&quot;:true,&quot;flags&quot;:130,&quot;payload&quot;:&quot;&quot;}' --abi &lt;MultisigWallet.abi.json&gt; --sign &lt;seed_or_keyfile&gt; &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2. &quot;&lt;source_seed_or_keyfile&gt;&quot; - seed phrase in quotes or path to keyfile of the source wallet. Example: $ tonos-cli call 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc submitTransaction '{&quot;dest&quot;:&quot;-1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;,&quot;value&quot;:234000000,&quot;bounce&quot;:false,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;}' --abi SetcodeMultisigWallet.abi.json --sign k1.keys.json Config: /home/user/tonos-cli.conf.json Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: submitTransaction params: {&quot;dest&quot;:&quot;-1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;,&quot;value&quot;:234000000,&quot;bounce&quot;:false,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;} abi: SetcodeMultisigWallet.abi.json keys: k1.keys.json lifetime: None output: None Connecting to net.ton.dev Generating external inbound message... MessageId: c6baac843fefe6b9e8dc3609487a63ef21207e4fdde9ec253b9a47f7f5a88d01 Expire at: Sat, 08 May 2021 14:52:23 +0300 Processing... Succeeded. Result: { &quot;transId&quot;: &quot;6959885776551137793&quot; }  If the sponsoring wallet has multiple custodians, the transaction may require confirmation from its other custodians. To confirm the transaction use the following command: tonos-cli call &lt;source_address&gt; confirmTransaction '{&quot;transactionId&quot;:&quot;&lt;id&gt;&quot;}' --abi &lt;MultisigWallet.abi.json&gt; --sign &quot;&lt;source_seed_or_keyfile&gt;&quot;  &lt;source_address&gt; - address of the wallet to funds are sent from. &quot;&lt;source_seed_or_keyfile&gt;&quot; - seed phrase in quotes or path to keyfile of the source wallet. transactionId – the ID of the transaction transferring tokens to the new wallet. &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2. Example: $ tonos-cli call 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc confirmTransaction '{&quot;transactionId&quot;:&quot;6981478983724354305&quot;}' --abi SetcodeMultisigWallet.abi.json --sign k2.keys.json Config: default Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: confirmTransaction params: {&quot;transactionId&quot;:&quot;6981478983724354305&quot;} abi: SetcodeMultisigWallet.abi.json keys: k2.keys.json lifetime: None output: None Connecting to https://net.ton.dev Generating external inbound message... MessageId: 322e1efffedf73c8009b84a103dd3fdc205796eb4d88a912fa13d931ce9e7c9c Expire at: Mon, 05 Jul 2021 19:28:08 +0300 Processing... Succeeded. Result: {}  Ensure that the new wallet has been created in the blockchain and has Uninit status: tonos-cli account &lt;multisig_address&gt;  &lt;multisig_address&gt; - new wallet address generated at step 3.3. "},{"title":"3.5. Deploy wallet (set custodians)​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#35-deploy-wallet-set-custodians","content":""},{"title":"3.5.1. Deploy the wallet to blockchain​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#351-deploy-the-wallet-to-blockchain","content":"Use the following command: tonos-cli deploy &lt;MultisigWallet.tvc&gt; '{&quot;owners&quot;:[&quot;0x...&quot;, ...],&quot;reqConfirms&quot;:N}' --abi &lt;MultisigWallet.abi.json&gt; --sign &lt;deploy_seed_or_keyfile&gt; --wc &lt;workchain_id&gt;  Configuration parameters: &lt;MultisigWallet.tvc&gt; - either SafeMultisigWallet.tvc or SetcodeMultisigWallet.tvc depending on the contract you have selected at step 2.2. &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2. owners - array of custodian public keys generated by all wallet custodians at step 3.1.2 as uint256 numbers. Make sure all public keys are enclosed in quotes and start with 0x.... Example: &quot;owners&quot;:[&quot;0x8868adbf012ebc349ced852fdcf5b9d55d1873a68250fae1be609286ddb962582&quot;, &quot;0xa0e16ccff0c7bf4f29422b33ec1c9187200e9bd949bb2dd4c7841f5009d50778a&quot;] reqConfirms - number of signatures needed to confirm a transaction ( 0 &lt; N ≤ custodian count). --wc &lt;workchain_id&gt; - (optional) ID of the workchain the wallet will be deployed to (-1 for masterchain, 0 for basechain). By default this value is set to 0. Note: Masterchain fees are significantly higher, but masterchain is required for validator wallets. Make sure to set workchain ID to -1 for any validator wallets you are deploying: --wc -1. Basechain, on the other hand, is best suited for user wallets.&lt;deploy_seed_or_keyfile&gt; - can either be the seed phrase used in step 3.2 to generate the deployment key pair file or the deploy.keys.json file itself. If seed phrase is used, enclose it in double quotes. Example: --sign &quot;flip uncover dish sense hazard smile gun mom vehicle chapter order enact&quot; or --sign deploy.keys.json Deploying a wallet without at least one custodian is not possible, since every transaction from a wallet has to be signed by one or more custodians (depending on wallet configuration) with their private key or equivalent seed phrase. It is a basic security requirement of the system. Example: $ tonos-cli deploy --sign key.json --wc -1 --abi SafeMultisigWallet.abi.json SafeMultisigWallet.tvc '{&quot;owners&quot;:[&quot;0x88c541e9a1c173069c89bcbcc21fa2a073158c1bd21ca56b3eb264bba12d9340&quot;],&quot;reqConfirms&quot;:1}' Config: /home/user/tonos-cli.conf.json Input arguments: tvc: SafeMultisigWallet.tvc params: {&quot;owners&quot;:[&quot;0x88c541e9a1c173069c89bcbcc21fa2a073158c1bd21ca56b3eb264bba12d9340&quot;],&quot;reqConfirms&quot;:1} abi: SafeMultisigWallet.abi.json keys: key.json wc: -1 Connecting to net.ton.dev Deploying... Transaction succeeded. Contract deployed at address: -1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6  Note: After a SafeMultisig wallet is deployed, for reasons of security you cannot add or remove custodians from it. If you want to change the custodian list, you have to create a new wallet, transfer all funds there, and set the new list of custodians. 3.5.2. Check that the wallet is active​ Check the new wallet status again. Now it should be Active. tonos-cli account &lt;multisig_address&gt;  "},{"title":"3.5.3. Request the list of custodian public keys from the blockchain​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#353-request-the-list-of-custodian-public-keys-from-the-blockchain","content":"Verify that they match the keys you have loaded during deploy. tonos-cli run &lt;multisig_address&gt; getCustodians {} --abi SafeMultisigWallet.abi.json  The wallet is deployed and the owners of the listed public keys have access to it. Example: $ tonos-cli run 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc getCustodians {} --abi SetcodeMultisigWallet.abi.json Config: default Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: getCustodians params: {} abi: SetcodeMultisigWallet.abi.json keys: None lifetime: None output: None Connecting to https://net.ton.dev Generating external inbound message... MessageId: 6c3daeeea601ef6c81a516079a3cec2210fea278a06cc7bb118b4529f154e5d7 Expire at: Mon, 05 Jul 2021 19:31:47 +0300 Running get-method... Succeeded. Result: { &quot;custodians&quot;: [ { &quot;index&quot;: &quot;1&quot;, &quot;pubkey&quot;: &quot;0x154bc7ed3088294e4e767e2e7183f43d62bcec820c58a30e2ec730f0bb8792a3&quot; }, { &quot;index&quot;: &quot;4&quot;, &quot;pubkey&quot;: &quot;0x18331765f53c6a50aa3a348fa4536e6f632798d81ff59281aae21d9b5f86a21c&quot; }, { &quot;index&quot;: &quot;3&quot;, &quot;pubkey&quot;: &quot;0x6ee6539d0d8a3800d7525922c25b64874e0645340f2b43a2cb277db458b42fa4&quot; }, { &quot;index&quot;: &quot;0&quot;, &quot;pubkey&quot;: &quot;0x849ee401fde65ad8cda6d937bdc81e2beba0f36ba2f87115f4a2d24a15568203&quot; }, { &quot;index&quot;: &quot;2&quot;, &quot;pubkey&quot;: &quot;0x9ef666feaacf1d65c78af3b1c099c5096aa2e26afc21346fd66b8e7d5d9d6224&quot; } ] }  4. Manage Wallet "},{"title":"4.1. Select blockchain network​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#41-select-blockchain-network","content":"There are two networks currently available: Some of the frequently used networks: https://net.ton.dev - developer sandbox for testing. https://main.ton.dev - main Everscale network. https://rustnet.ton.dev - test network running on Rust nodes. Use the following command to switch to any of these networks: tonos-cli config --url &lt;https://network_url&gt;  You need to do it only once before using the utility. A .json configuration file will be created in the current folder. The URL of the current network will be specified there. All subsequent calls of the utility will use this file to select the network to connect to. "},{"title":"4.2. Convert tokens to nanotokens​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#42-convert-tokens-to-nanotokens","content":"Amounts in most multisig wallet commands are indicated in nanotokens. To convert tokens to nanotokens use the following command: tonos-cli convert tokens &lt;amount&gt;  Example: $ tonos-cli convert tokens 125.8 Config: /home/user/tonos-cli.conf.json 125800000000  "},{"title":"4.3. Check wallet balance and status​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#43-check-wallet-balance-and-status","content":""},{"title":"4.3.1. Check wallet balance and status with TONOS-CLI​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#431-check-wallet-balance-and-status-with-tonos-cli","content":"You may use the following command to check the current status and balance of your wallet: tonos-cli account &lt;multisig_address&gt;  It displays the wallet status: Not found – if the wallet does not existUninit – wallet was created, but contract code wasn’t deployedActive – wallet exists and has the contract code and data It also displays the wallet balance, time of the most recent transaction, contract data block, data in boc format and code hash (which is unique for every contract type). Example: $ tonos-cli account 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc Config: default Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc Connecting to https://net.ton.dev Processing... Succeeded. acc_type: Active balance: 236565978364 nanoton last_paid: 1625502429 last_trans_lt: 0x9274fd9102 data(boc): b5ee9c7201020d010001b10003df849ee401fde65ad8cda6d937bdc81e2beba0f36ba2f87115f4a2d24a155682030000017a777eac3bc24f7200fef32d6c66d36c9bdee40f15f5d079b5d17c388afa5169250aab4101800000000000000000000000000000000000000000000000000000000000000082800000000182700c0a01020120050202016204030043bf3bd99bfaab3c75971e2bcec702671425aa8b89abf084d1bf59ae39f5767588900a0043bf127b9007f7996b63369b64def72078afae83cdae8be1c457d28b4928555a080c0202012007060044bfaee6539d0d8a3800d7525922c25b64874e0645340f2b43a2cb277db458b42fa40302016609080043bec198bb2fa9e3528551d1a47d229b737b193cc6c0ffac940d5710ecdafc3510e0240043beea5e3f6984414a7273b3f1738c1fa1eb15e7641062c5187176398785dc3c95180c01d7a030719912b7df6580b0719912b7df6580800000018201424f7200fef32d6c66d36c9bdee40f15f5d079b5d17c388afa5169250aab410180400255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f30000000000000000000000000df28e800003c0b0000000140 code_hash: e2b60b6b602c10ced7ea8ede4bdf96342c97570a3798066f3fb50a4b2b27a208  SafeMultisig code hash is 80d6c47c4a25543c9b397b71716f3fae1e2c5d247174c52e2c19bd896442b105 SetcodeMultisig code hash is e2b60b6b602c10ced7ea8ede4bdf96342c97570a3798066f3fb50a4b2b27a208 "},{"title":"4.3.2. Check wallet balance and status in the blockchain explorer​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#432-check-wallet-balance-and-status-in-the-blockchain-explorer","content":"The detailed status of the account can also be viewed in the ton.live blockchain explorer. Select the network the wallet is deployed to and enter the raw address of the wallet into the main search field. Account status, balance, message and transaction history for the account will be displayed. "},{"title":"4.4. List custodian public keys​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#44-list-custodian-public-keys","content":"The following command displays the list of public keys, the owners of which have rights to manage the wallet: tonos-cli run &lt;multisig_address&gt; getCustodians {} --abi &lt;MultisigWallet.abi.json&gt;  Example: $ tonos-cli run 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc getCustodians {} --abi SetcodeMultisigWallet.abi.json Config: default Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: getCustodians params: {} abi: SetcodeMultisigWallet.abi.json keys: None lifetime: None output: None Connecting to https://net.ton.dev Generating external inbound message... MessageId: 6c3daeeea601ef6c81a516079a3cec2210fea278a06cc7bb118b4529f154e5d7 Expire at: Mon, 05 Jul 2021 19:31:47 +0300 Running get-method... Succeeded. Result: { &quot;custodians&quot;: [ { &quot;index&quot;: &quot;1&quot;, &quot;pubkey&quot;: &quot;0x154bc7ed3088294e4e767e2e7183f43d62bcec820c58a30e2ec730f0bb8792a3&quot; }, { &quot;index&quot;: &quot;4&quot;, &quot;pubkey&quot;: &quot;0x18331765f53c6a50aa3a348fa4536e6f632798d81ff59281aae21d9b5f86a21c&quot; }, { &quot;index&quot;: &quot;3&quot;, &quot;pubkey&quot;: &quot;0x6ee6539d0d8a3800d7525922c25b64874e0645340f2b43a2cb277db458b42fa4&quot; }, { &quot;index&quot;: &quot;0&quot;, &quot;pubkey&quot;: &quot;0x849ee401fde65ad8cda6d937bdc81e2beba0f36ba2f87115f4a2d24a15568203&quot; }, { &quot;index&quot;: &quot;2&quot;, &quot;pubkey&quot;: &quot;0x9ef666feaacf1d65c78af3b1c099c5096aa2e26afc21346fd66b8e7d5d9d6224&quot; } ] }  "},{"title":"4.5. List transactions awaiting confirmation​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#45-list-transactions-awaiting-confirmation","content":"Use the following command to list the transactions currently awaiting custodian confirmation: tonos-cli run &lt;multisig_address&gt; getTransactions {} --abi &lt;MultisigWallet.abi.json&gt;  If there are some transactions requiring confirmation, they will be displayed. Example: $ tonos-cli run 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc getTransactions {} --abi SafeMultisigWallet.abi.json Config: /home/user/tonos-cli.conf.json Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: getTransactions params: {} abi: SafeMultisigWallet.abi.json keys: None lifetime: None output: None Connecting to net.ton.dev Generating external inbound message... MessageId: ff8b8a73b1a7803a735eb4f620cade78ed45fd1530992fd3bedb91f3c66eacc5 Expire at: Sat, 08 May 2021 15:16:59 +0300 Running get-method... Succeeded. Result: { &quot;transactions&quot;: [ { &quot;id&quot;: &quot;6959890394123980993&quot;, &quot;confirmationsMask&quot;: &quot;1&quot;, &quot;signsRequired&quot;: &quot;4&quot;, &quot;signsReceived&quot;: &quot;1&quot;, &quot;creator&quot;: &quot;0x849ee401fde65ad8cda6d937bdc81e2beba0f36ba2f87115f4a2d24a15568203&quot;, &quot;index&quot;: &quot;0&quot;, &quot;dest&quot;: &quot;-1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;, &quot;value&quot;: &quot;234000000&quot;, &quot;sendFlags&quot;: &quot;3&quot;, &quot;payload&quot;: &quot;te6ccgEBAQEAAgAAAA==&quot;, &quot;bounce&quot;: false } ] }  "},{"title":"4.6. Create transaction online​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#46-create-transaction-online","content":"Use the following command to create a new transaction: tonos-cli call &lt;multisig_address&gt; submitTransaction '{&quot;dest&quot;:&quot;raw_address&quot;,&quot;value&quot;:&lt;nanotokens&gt;,&quot;bounce&quot;:true,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;}' --abi &lt;MultisigWallet.abi.json&gt; --sign &lt;seed__or_keyfile&gt;  &quot;dest&quot; - raw address of a destination smart contract. Example: &quot;0:f22e02a1240dd4b5201f8740c38f2baf5afac3cedf8f97f3bd7cbaf23c7261e3&quot; &quot;value&quot;: - amount of tokens to transfer in nanotokens (Example: &quot;value&quot;:10000000000 sets up a transfer of 10 tokens). &quot;bounce&quot; - use false to transfer funds to a non-existing contract to create it. Use true to transfer funds to an Active contract. Note: at step [3.4]](#34-send-tokens-to-the-new-address-from-another-wallet) of the wallet deployment procedure use false.&quot;payload&quot; - use &quot;&quot; for simple transfer. Otherwise payload is used as a body of outbound internal message. &quot;allBalance&quot; - used to transfer all funds in the wallet. Use false for a simple transfer. Note: Due to a bug setting allBalance to true currently causes errors. Single-custodian multisig wallets may use sendTransaction method with flag 130 and value 0 instead: tonos-cli call &lt;multisig_address&gt; sendTransaction '{&quot;dest&quot;:&quot;raw_address&quot;,&quot;value&quot;:0,&quot;bounce&quot;:true,&quot;flags&quot;:130,&quot;payload&quot;:&quot;&quot;}' --abi &lt;MultisigWallet.abi.json&gt; --sign &lt;seed_or_keyfile&gt; &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2. &lt;seed_or_keyfile&gt; - can either be the custodian seed phrase or the corresponding custodian key pair file. If seed phrase is used, enclose it in double quotes. Example: --sign &quot;flip uncover dish sense hazard smile gun mom vehicle chapter order enact&quot; or --sign keyfile.json If the wallet has multiple custodians and more than one custodian signature is required to execute a transaction, the new transaction is queued in the wallet and waits for the necessary amount of confirmations. Otherwise it is executed immediately. Example: $ tonos-cli call 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc submitTransaction '{&quot;dest&quot;:&quot;-1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;,&quot;value&quot;:234000000,&quot;bounce&quot;:true,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;}' --abi SetcodeMultisigWallet.abi.json --sign k1.keys.json Config: /home/user/tonos-cli.conf.json Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: submitTransaction params: {&quot;dest&quot;:&quot;-1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;,&quot;value&quot;:234000000,&quot;bounce&quot;:true,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;} abi: SetcodeMultisigWallet.abi.json keys: k1.keys.json lifetime: None output: None Connecting to net.ton.dev Generating external inbound message... MessageId: c6baac843fefe6b9e8dc3609487a63ef21207e4fdde9ec253b9a47f7f5a88d01 Expire at: Sat, 08 May 2021 14:52:23 +0300 Processing... Succeeded. Result: { &quot;transId&quot;: &quot;6959885776551137793&quot; }  Note: For maximum security you may also create a transaction message on a machine without internet connection in offline mode. See section 4.8. "},{"title":"4.6.1. Alternative command to create transaction online​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#461-alternative-command-to-create-transaction-online","content":"TONOS-CLI supports alterbative syntax for this command, which does not use quotes and brackets to list parameters and may be more convenient: tonos-cli callex submitTransaction &lt;multisig_address&gt; &lt;MultisigWallet.abi.json&gt; &lt;seed_or_keyfile&gt; --dest &lt;raw_address&gt; --value &lt;tokens&gt;T --bounce &lt;true|false&gt; --allBalance &lt;true|false&gt; --payload &quot;&quot;  &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2. &lt;seed_or_keyfile&gt; - can either be the custodian seed phrase or the corresponding custodian key pair file. If seed phrase is used, enclose it in double quotes. Example: &quot;flip uncover dish sense hazard smile gun mom vehicle chapter order enact&quot; or keyfile.json &lt;raw_address&gt; - raw address of a destination smart contract. Example: 0:f22e02a1240dd4b5201f8740c38f2baf5afac3cedf8f97f3bd7cbaf23c7261e3 value - amount of tokens to transfer: in nanotokens, if specified without the T suffix, or in tokens, if specified with it (Example: --value 10500000000 and --value 10.5T are the same value of 10.5 tokens). bounce - use false to transfer funds to a non-existing contract to create it. Use true to transfer funds to an Active contract. Note: at step 3.4 of the wallet deployment procedure use false.payload - use &quot;&quot; for simple transfer. Otherwise payload is used as a body of outbound internal message. allBalance - used to transfer all funds in the wallet. Use false for a simple transfer. Note: Due to a bug setting allBalance to true currently causes errors. Single-custodian multisig wallets may use sendTransaction method with flag 130 and value 0 instead: tonos-cli callex sendTransaction &lt;multisig_address&gt; &lt;MultisigWallet.abi.json&gt; &lt;seed_or_keyfile&gt; --dest &lt;raw_address&gt; --value 0 --bounce &lt;true|false&gt; --flags 130 --payload &quot;&quot; Example: $ tonos-cli callex submitTransaction 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc SetcodeMultisigWallet.abi.json k1.keys.json --dest -1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6 --value 0.234T --bounce false --allBalance false --payload &quot;&quot; Config: /home/user/tonos-cli.conf.json Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: submitTransaction params: {&quot;dest&quot;:&quot;-1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;,&quot;value&quot;:&quot;0234000000&quot;,&quot;bounce&quot;:&quot;false&quot;,&quot;allBalance&quot;:&quot;false&quot;,&quot;payload&quot;:&quot;&quot;} abi: SetcodeMultisigWallet.abi.json keys: k1.keys.json Connecting to net.ton.dev Generating external inbound message... MessageId: a38f37bfbe3c7427c869b3ee97c3b2d7f4421ca1427ace4e7a92f1a61d7ef234 Expire at: Sat, 08 May 2021 15:10:15 +0300 Processing... Succeeded. Result: { &quot;transId&quot;: &quot;6959890394123980993&quot; }  "},{"title":"4.7. Create transaction confirmation online​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#47-create-transaction-confirmation-online","content":"Once one of the custodians creates a new transaction on the blockchain, it has to get the required number of confirmations from other custodians. To confirm a transaction, use the following command: tonos-cli call &lt;multisig_address&gt; confirmTransaction '{&quot;transactionId&quot;:&quot;&lt;id&gt;&quot;}' --abi &lt;MultisigWallet.abi.json&gt; --sign &lt;seed_or_keyfile&gt;  transactionId – the ID of the transaction can be acquired from the custodian who created it, or by requesting the list of transactions awaiting confirmation from the multisignature wallet. &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2. &lt;seed_or_keyfile&gt; - can either be the custodian seed phrase or the corresponding custodian key pair file. If seed phrase is used, enclose it in double quotes. Example: --sign &quot;flip uncover dish sense hazard smile gun mom vehicle chapter order enact&quot; or --sign keyfile.json Note: If the wallet has only one custodian, or if the number of confirmations required to perform a transaction was set to 1, this action won't be necessary. The transaction will be confirmed automatically. Example: $ tonos-cli call 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc confirmTransaction '{&quot;transactionId&quot;:&quot;6981478983724354305&quot;}' --abi SetcodeMultisigWallet.abi.json --sign k2.keys.json Config: default Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: confirmTransaction params: {&quot;transactionId&quot;:&quot;6981478983724354305&quot;} abi: SetcodeMultisigWallet.abi.json keys: k2.keys.json lifetime: None output: None Connecting to https://net.ton.dev Generating external inbound message... MessageId: 322e1efffedf73c8009b84a103dd3fdc205796eb4d88a912fa13d931ce9e7c9c Expire at: Mon, 05 Jul 2021 19:28:08 +0300 Processing... Succeeded. Result: {}  Note: For maximum security you may also create a transaction confirmation message on a machine without internet connection in offline mode. See section 4.9 4.7.1. Alternative command to confirm transaction online​ TONOS-CLI supports alterbative syntax for this command, which does not use quotes and brackets to list parameters and may be more convenient: tonos-cli callex confirmTransaction &lt;multisig_address&gt; &lt;MultisigWallet.abi.json&gt; &lt;seed_or_keyfile&gt; --transactionId &lt;id&gt;  &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2. &lt;seed_or_keyfile&gt; - can either be the custodian seed phrase or the corresponding custodian key pair file. If seed phrase is used, enclose it in double quotes. Example: &quot;flip uncover dish sense hazard smile gun mom vehicle chapter order enact&quot; or keyfile.json &lt;id&gt; - ID of the transaction that should be confirmed. Example: $ tonos-cli callex confirmTransaction 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc SetcodeMultisigWallet.abi.json k2.keys.json --transactionId 6982528395137505473 Config: default Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: confirmTransaction params: {&quot;transactionId&quot;:&quot;6982528395137505473&quot;} abi: SetcodeMultisigWallet.abi.json keys: k2.keys.json Connecting to https://net.ton.dev Generating external inbound message... MessageId: 00048660c32d95313eeee7e09d89679e0c68f9a7660794736ba399c4c5fab011 Expire at: Thu, 08 Jul 2021 15:26:26 +0300 Processing... Succeeded. Result: {}  "},{"title":"4.8. Create new transaction offline​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#48-create-new-transaction-offline","content":"An internet connection is not required to create a signed transaction message. Use the following command to do it: tonos-cli message &lt;multisig_address&gt; submitTransaction '{&quot;dest&quot;:&quot;raw_address&quot;,&quot;value&quot;:&lt;nanotokens&gt;,&quot;bounce&quot;:true,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;}' --abi &lt;MultisigWallet.abi.json&gt; --sign &lt;seed_or_keyfile&gt; --lifetime 3600  &quot;dest&quot; - raw address of a destination smart contract. Example: &quot;0:f22e02a1240dd4b5201f8740c38f2baf5afac3cedf8f97f3bd7cbaf23c7261e3&quot;. &quot;value&quot;: - amount of tokens to transfer in nanotokens (Example: &quot;value&quot;:10000000000 sets up a transfer of 10 tokens). &quot;bounce&quot; - use false to transfer funds to a non-existing contract to create it. Use true to transfer funds to an Active contract. &quot;payload&quot; - use &quot;&quot; for simple transfer. Otherwise payload is used as a body of outbound internal message. &quot;allBalance&quot; - used to transfer all funds in the wallet. Use false for a simple transfer. Note: Due to a bug setting allBalance to true currently causes errors. Single-custodian multisig wallets may use sendTransaction method with flag 130 and value 0 instead: tonos-cli message &lt;multisig_address&gt; sendTransaction '{&quot;dest&quot;:&quot;raw_address&quot;,&quot;value&quot;:0,&quot;bounce&quot;:true,&quot;flags&quot;:130,&quot;payload&quot;:&quot;&quot;}' --abi &lt;MultisigWallet.abi.json&gt; --sign &lt;seed_or_keyfile&gt; --lifetime 3600 &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2. &lt;seed_or_keyfile&gt; - can either be the custodian seed phrase or the corresponding custodian key pair file. If seed phrase is used, enclose it in double quotes. Example: --sign &quot;flip uncover dish sense hazard smile gun mom vehicle chapter order enact&quot; or --sign keyfile.json lifetime – message lifetime in seconds. Once this time elapses, the message will not be accepted by the contract. The TONOS-CLI utility displays encrypted message text and a QR code that contains the submitTransaction message. Example: $ tonos-cli message 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc submitTransaction '{&quot;dest&quot;:&quot;0:255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f3&quot;,&quot;value&quot;:567000000,&quot;bounce&quot;:true,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;}' --abi SetcodeMultisigWallet.abi.json --sign k1.keys.json --lifetime 3600 Config: default Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: submitTransaction params: {&quot;dest&quot;:&quot;0:255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f3&quot;,&quot;value&quot;:567000000,&quot;bounce&quot;:true,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;} abi: SetcodeMultisigWallet.abi.json keys: k1.keys.json lifetime: 3600 output: None Generating external inbound message... MessageId: 649e36ac7d656d1ce99f3e8b235074ff2483e115596a0233caacdf0c4ccf78a1 Expire at: Thu, 08 Jul 2021 16:32:45 +0300 Message: 7b226d7367223a7b226d6573736167655f6964223a2236343965333661633764363536643163653939663365386232333530373466663234383365313135353936613032333363616163646630633463636637386131222c226d657373616765223a227465366363674542424145413051414252596742534d553677767679593746624464704a365a5748706b4c7846304545726f4b4a36775165555369536633674d415148686d4733712f3553464e2f79317a703749337433586243796874586a51734b48763437654e657479504f6e46524b3939487a444c7974644754307a4e784a50314e3964544a4c444f6766496a2b556f57784c366571686d456e7551422f655a61324d326d32546539794234723636447a61364c34635258306f744a4b46566143417741414158714747793062594f622b66524d64677332414341574f41424b7448577a763146556e6d6b44437456666a36382b6a366f45436a495871734b4f4a77364230324c763567414141414141414141414141414141454f58643446414d4141413d3d222c22657870697265223a313632353735313136352c2261646472657373223a22303a61343632396436313764663933316438616438366564323466346361633364333231373838626130383235373431343466353832306632383934343933666263227d2c226d6574686f64223a227375626d69745472616e73616374696f6e227d &lt;Message QR code&gt;  Copy the message text or scan the QR code and broadcast the message online. "},{"title":"4.9. Create transaction confirmation offline​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#49-create-transaction-confirmation-offline","content":"Once one of the custodians creates a new transaction on the blockchain, it has to get the required number of confirmations from other custodians. To create a confirmation message offline use the following command: tonos-cli message &lt;multisig_address&gt; confirmTransaction '{&quot;transactionId&quot;:&quot;&lt;id&gt;&quot;}' --abi &lt;MultisigWallet.abi.json&gt; --sign &quot;&lt;seed_or_keyfile&gt;&quot; --lifetime 600  transactionId – the ID of the transaction can be acquired from the custodian who created it, or by requesting the list of transactions awaiting confirmation from the multisignature wallet. &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2. &lt;seed_or_keyfile&gt; - can either be the custodian seed phrase or the corresponding custodian key pair file. If seed phrase is used, enclose it in double quotes. Example: --sign &quot;flip uncover dish sense hazard smile gun mom vehicle chapter order enact&quot; or --sign keyfile.json lifetime – message lifetime in seconds. Once this time elapses, the message will not be accepted by the contract. The TONOS-CLI utility displays encrypted transaction text and a QR code that contains the confirmTransaction message. Example: $ tonos-cli message 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc confirmTransaction '{&quot;transactionId&quot;:&quot;6982528395137505473&quot;}' --abi SetcodeMultisigWallet.abi.json --sign k3.keys.json --lifetime 600 Config: default Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: confirmTransaction params: {&quot;transactionId&quot;:&quot;6982528395137505473&quot;} abi: SetcodeMultisigWallet.abi.json keys: k3.keys.json lifetime: 600 output: None Generating external inbound message... MessageId: 1751be3063638271c2590ede75d71bfaa48b0dc76180443f1158ffc3d178148d Expire at: Thu, 08 Jul 2021 15:59:47 +0300 Message: 7b226d7367223a7b226d6573736167655f6964223a2231373531626533303633363338323731633235393065646537356437316266616134386230646337363138303434336631313538666663336431373831343864222c226d657373616765223a227465366363674542416745416f51414252596742534d553677767679593746624464704a365a5748706b4c7846304545726f4b4a36775165555369536633674d41514478394d2b686c7a4a523034444370564d6c586e775954466344495532424a304d51304966654971476f36712b6646526f717545664c326b792f6c766873667133707a77704c4463504a48566b663472412b6a6f5870676565396d622b717338645a63654b383748416d63554a61714c69617677684e472f5761343539585a31694a414141415871474b734b6f594f62327778716e514f3167357579556b6a2f597759413d3d222c22657870697265223a313632353734393138372c2261646472657373223a22303a61343632396436313764663933316438616438366564323466346361633364333231373838626130383235373431343466353832306632383934343933666263227d2c226d6574686f64223a22636f6e6669726d5472616e73616374696f6e227d &lt;QR code&gt;  Copy the message text or scan the QR code and broadcast the message online. "},{"title":"4.10. Generate deploy message offline​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#410-generate-deploy-message-offline","content":"If needed, signed deploy message can be generated without immediately broadcasting it to the blockchain. Generated message can be broadcasted later. tonos-cli deploy_message [--raw] [--output &lt;path_to_file&gt;] [--sign &lt;deploy_seed_or_keyfile&gt;] [--wc &lt;int8&gt;] [--abi &lt;contract.abi.json&gt;] &lt;contract.tvc&gt; &lt;params&gt;  --raw - use to create raw message boc. --output &lt;path_to_file&gt; - specify path to file where the raw message should be written to, instead of printing it to terminal. &lt;deploy_seed_or_keyfile&gt; - can either be the seed phrase used to generate the deployment key pair file or the key pair file itself. If seed phrase is used, enclose it in double quotes. Example: --sign &quot;flip uncover dish sense hazard smile gun mom vehicle chapter order enact&quot; or --sign deploy.keys.json--wc &lt;int8&gt; ID of the workchain the wallet will be deployed to (-1 for masterchain, 0 for basechain). By default this value is set to 0. &lt;contract.abi.json&gt; - contract interface file. &lt;contract.tvc&gt; - compiled smart contract file. &lt;params&gt; - deploy command parameters, depend on the contract. Example (saving to a file contract deployment message to the masterchain): $ tonos-cli deploy_message --raw --output deploy.boc --sign key.json --wc -1 --abi SafeMultisigWallet.abi.json SafeMultisigWallet.tvc '{&quot;owners&quot;:[&quot;0x88c541e9a1c173069c89bcbcc21fa2a073158c1bd21ca56b3eb264bba12d9340&quot;],&quot;reqConfirms&quot;:1}' Config: /home/user/tonos-cli.conf.json Input arguments: tvc: SafeMultisigWallet.tvc params: {&quot;owners&quot;:[&quot;0x88c541e9a1c173069c89bcbcc21fa2a073158c1bd21ca56b3eb264bba12d9340&quot;],&quot;reqConfirms&quot;:1} abi: SafeMultisigWallet.abi.json keys: key.json wc: -1 MessageId: 51da1b8840bd12f9ef5152639bd1fe9062d77ed91829301043bb85b4a4d610ea Expire at: unknown Message saved to file deploy.boc Contract's address: -1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6 Succeeded.  "},{"title":"4.11. Broadcast previously generated message​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#411-broadcast-previously-generated-message","content":"Use the following command to broadcast any previously generated message (transaction message, confirmation message, deploy message): tonos-cli send --abi &lt;MultisigWallet.abi.json&gt; &quot;message&quot;  &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2.message – the content of the message generated by the TONOS-CLI utility during message creation. It should be enclosed in double quotes. Example: $ tonos-cli send --abi SafeMultisigWallet.abi.json &quot;7b226d7367223a7b226d6573736167655f6964223a2266363364666332623030373065626264386365643265333865373832386630343837326465643036303735376665373430376534393037646266663338626261222c226d657373616765223a227465366363674542424145413051414252596742534d553677767679593746624464704a365a5748706b4c7846304545726f4b4a36775165555369536633674d41514868757856507a324c5376534e663344454a2f374866653165562f5a78324d644e6b4b727770323865397a7538376a4d6e7275374c48685965367642523141756c48784b44446e4e62344f47686768386e6b6b7a48386775456e7551422f655a61324d326d32546539794234723636447a61364c34635258306f744a4b465661434177414141586c4d464e7077594a61616b524d64677332414341574f663459757151715976325233654e776d49655834517048686e37537a75624c76524838657931425a6a617a6a414141414141414141414141414141414a4d61735142414d4141413d3d222c22657870697265223a313632303438323730352c2261646472657373223a22303a61343632396436313764663933316438616438366564323466346361633364333231373838626130383235373431343466353832306632383934343933666263227d2c226d6574686f64223a227375626d69745472616e73616374696f6e227d&quot; Config: /home/user/tonos-cli.conf.json Input arguments: message: 7b226d7367223a7b226d6573736167655f6964223a2266363364666332623030373065626264386365643265333865373832386630343837326465643036303735376665373430376534393037646266663338626261222c226d657373616765223a227465366363674542424145413051414252596742534d553677767679593746624464704a365a5748706b4c7846304545726f4b4a36775165555369536633674d41514868757856507a324c5376534e663344454a2f374866653165562f5a78324d644e6b4b727770323865397a7538376a4d6e7275374c48685965367642523141756c48784b44446e4e62344f47686768386e6b6b7a48386775456e7551422f655a61324d326d32546539794234723636447a61364c34635258306f744a4b465661434177414141586c4d464e7077594a61616b524d64677332414341574f663459757151715976325233654e776d49655834517048686e37537a75624c76524838657931425a6a617a6a414141414141414141414141414141414a4d61735142414d4141413d3d222c22657870697265223a313632303438323730352c2261646472657373223a22303a61343632396436313764663933316438616438366564323466346361633364333231373838626130383235373431343466353832306632383934343933666263227d2c226d6574686f64223a227375626d69745472616e73616374696f6e227d abi: SafeMultisigWallet.abi.json Connecting to net.ton.dev MessageId: f63dfc2b0070ebbd8ced2e38e7828f04872ded060757fe7407e4907dbff38bba Expire at: Sat, 08 May 2021 17:05:05 +0300 Calling method submitTransaction with parameters: { &quot;dest&quot;: &quot;-1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;, &quot;value&quot;: &quot;1234000000&quot;, &quot;bounce&quot;: false, &quot;allBalance&quot;: false, &quot;payload&quot;: &quot;te6ccgEBAQEAAgAAAA==&quot; } Processing... Processing... Succeded. Result: { &quot;transId&quot;: &quot;6959904904053506881&quot; }  If transaction requires multiple confirmations, the terminal displays the transaction ID, which should be sent to other wallet custodians. 5. Error codes Errors related to the operation of multisig contracts typically are displayed like this: { &quot;code&quot;: 507, &quot;message&quot;: &quot;Message expired. Contract was not executed on chain. Possible reason: Contract execution was terminated with error: Contract did not accept message, exit code: 103. For more information about exit code check the contract source code or ask the contract developer&quot;, &quot;data&quot;: { &quot;message_id&quot;: &quot;029502efa1f4d5701713de772947de0c9447746abfb1c1191e403220698cf8cb&quot;, &quot;shard_block_id&quot;: &quot;baf38272f69eca4291e58958813d82cbc3e2107f0dc63ed261c2017232e3b714&quot;, &quot;core_version&quot;: &quot;1.14.1&quot;, &quot;waiting_expiration_time&quot;: &quot;Thu, 20 May 2021 18:23:37 +0300 (1621524217)&quot;, &quot;block_time&quot;: &quot;Thu, 20 May 2021 18:23:40 +0300 (1621524220)&quot;, &quot;account_address&quot;: &quot;0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc&quot;, &quot;local_error&quot;: { &quot;code&quot;: 414, &quot;message&quot;: &quot;Contract execution was terminated with error: Contract did not accept message, exit code: 103. For more information about exit code check the contract source code or ask the contract developer&quot;, &quot;data&quot;: { &quot;core_version&quot;: &quot;1.14.1&quot;, &quot;phase&quot;: &quot;computeVm&quot;, &quot;exit_code&quot;: 103, &quot;exit_arg&quot;: &quot;0&quot;, &quot;account_address&quot;: &quot;0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc&quot; } }, &quot;config_servers&quot;: [ &quot;net1.ton.dev&quot;, &quot;net5.ton.dev&quot; ], &quot;query_url&quot;: &quot;https://net5.ton.dev/graphql&quot; } } Error: All attempts have failed Error: 1  Multisig error codes, corresponding to the event that caused the error are specified in the exit_code parameter. The list of possible exit codes and what they mean is as follows:100 - message sender is not a custodian - sendTransaction, submitTransaction or confirmTransaction method was called by someone who is not a wallet custodian.102 - transaction does not exist - ID of the transaction that custodian attempted to confirm is not present in multisig.103 - operation is already confirmed by this custodian - custodian attempted to confirm transaction twice.107 - input value is too low - transaction amount is less than the minimum amount (1000000 nanotons).108 - wallet should have only one custodian - wallet custodian attempted to call sendTransaction in a wallet with more than one custodian.113 - Too many requests for one custodian - the maximum amount of queued submitTransaction and submitUpdate calls was reached (currently, this amount is set to 5). Custodian has to wait until the calls are executed, before queuing any more.117 - invalid number of custodians - the number of custodians specified during multisig deploy exceeds the maximum amount (currently, this amount is set to 32).121 - payload size is too big; submitTransaction payload exceeds the maximum limit.SetcodeMultisig-specific errors115 - update request does not exist - Setcode request with the specified ID is not present in the multisig.116 - update request already confirmed by this custodian - Setcode request with the specified ID is already confirmed by the current custodian.119 - stored code hash and calculated code hash are not equal - the code hash submitted in executeUpdate is not equal to the code previously submitted in submitUpdate .120 - update request is not confirmed; cannot perform executeUpdate as the setcode request was not confirmed by the required number of custodians yet.Currently unused error codes110 - too many custodians - not currently used. 122 - object is expired - not currently used. "},{"title":"Solidity Contracts Examples","type":0,"sectionRef":"#","url":"develop/smart-contract/solidity-developing/samples","content":"","keywords":""},{"title":"1. Accumulator : persistent storage​","type":1,"pageTitle":"Solidity Contracts Examples","url":"develop/smart-contract/solidity-developing/samples#1-accumulator--persistent-storage","content":"Smart-contracts deployed to the blockchain store their state variables in a persistent storage. Call Accumulator.add(uint value). It adds value to its state variable sum. Resulting state of the account can be examined by conventional means. "},{"title":"2. StorageClient: calling another contract​","type":1,"pageTitle":"Solidity Contracts Examples","url":"develop/smart-contract/solidity-developing/samples#2-storageclient-calling-another-contract","content":"Contracts can also call other remote contracts. Call StorageClient.store(Storage storageAddress) to invoke a public function of another contract. The remote contract UintStorage saves the integer value of the argument and the caller address in its state variables. "},{"title":"3. Borrower: EVER transfer​","type":1,"pageTitle":"Solidity Contracts Examples","url":"develop/smart-contract/solidity-developing/samples#3-borrower-ever-transfer","content":"This sample demonstrates how currency transfer works. Call Borrower.askForALoan(Loaner loanerAddress, uint amount). This requests amount of currency from the contract deployed at the specified address. The remote contract LoanerContracttransfers amount of currency to the caller via msg.sender.transfer(amount). Each contract has an internal transaction counter. The counter value increases with each transaction and is stored in the persistent memory. "},{"title":"4. CurrencyExchange: callback implementation​","type":1,"pageTitle":"Solidity Contracts Examples","url":"develop/smart-contract/solidity-developing/samples#4-currencyexchange-callback-implementation","content":"Call CurrencyExchange.updateExchangeRate(address bankAddress, uint16 code). This function allows interacting with a remote contract by calling its function: ICentralBank.GetExchangeRate(uint16 code). The remote contract CentralBankobtains caller's address via msg.sender and performs a callback. Bank: loan interaction between Bank and BankClient Call Bank.setAllowance(address bankClientAddress, uint amount). Bank stores information about loan allowances and current debts for different contracts. This data is recorded in the following state variable: mapping(address =&gt; CreditInfo) clientDB; A contract owner is supposed to call the setAllowance() function to specify limits. BankClient is a client that can interact with Bank. Call BankClient.getMyCredit(IBank bank). This function calls the remote contract Bank to receive allowed credit limit via Bank invoking the callback function setCreditLimit(uint limit). Call BankClient.askForALoan(IBank bank, uint amount). This function call the remote contract Bank to get an amount of credit. According to the current credit info of the BankClient contract Bank will approve the credit via calling the callback function &quot;receiveLoan(uint n_totalDebt)&quot; or refuse the credit via calling the callback functionrefusalCallback(uint availableLimit).receiveLoan function also obtains balance of the contract via address(this).balance and balance of the inbound message via msg.value and saves them in state variables.refusalCallback function saves the argument (available credit limit) in the state variable. "},{"title":"6. DataBase: exchange of different types of values​","type":1,"pageTitle":"Solidity Contracts Examples","url":"develop/smart-contract/solidity-developing/samples#6-database-exchange-of-different-types-of-values","content":"One of contract functions call allows sending to the DataBaseClientdifferent values: uint64 array;five uint arrays;five uint256;struct array. "},{"title":"7. Giver: simple giver contract​","type":1,"pageTitle":"Solidity Contracts Examples","url":"develop/smart-contract/solidity-developing/samples#7-giver-simple-giver-contract","content":"This sample shows usage of different types of currency transactions and usage of a fallback function. Call Giver.transferToAddress(address payable destination, uint amount) orGiver.do_tvm_transfer(address payable remote_addr, uint128 ton_value, bool bounce, uint16 sendrawmsg_flag)to perform a currency transaction. Call Giver.transferToCrashContract(address payable destination, uint amount) to implement a crash during transaction. That will cause an exception in CrashContractand Giver's contract fallback function calling. Call Giver.transferToAbstractContract(address payable destination, uint amount) with a non-existent address AbstractContract will also call a fallback function of Giver. "},{"title":"8. Kamikaze: selfdestruct function​","type":1,"pageTitle":"Solidity Contracts Examples","url":"develop/smart-contract/solidity-developing/samples#8-kamikaze-selfdestruct-function","content":"Call Kamikaze.sendAllMoney(address anotherContract). This function destroys the contract and sends all its funds to the specified address of Heircontract. "},{"title":"9. PiggyBank: Piggy bank with two clients​","type":1,"pageTitle":"Solidity Contracts Examples","url":"develop/smart-contract/solidity-developing/samples#9-piggybank-piggy-bank-with-two-clients","content":"This sample consists of 3 contracts: PiggyBank - piggy bank itself.PiggyBank_Owner - piggy bank's owner - valid user, who can add to piggy bank's deposit and withdraw.PiggyBank_Stranger - stranger - invalid user, who can add to piggy bank but can not withdraw. Call PiggyBank_Owner.addToDeposit(PiggyBank bankAddress, uint amount) orPiggyBank_Stranger.addToDeposit(PiggyBank bankAddress, uint amount) to transfer EVERs from the contract to PiggyBank. Call PiggyBank_Owner.withdrawDeposit(PiggyBank bankAddress) of PiggyBank_Stranger.withdrawDeposit(PiggyBank bankAddress)to try to withdraw the deposit from PiggyBank. Transfer would occur only for the owner. "},{"title":"10. Wallet: Simple wallet​","type":1,"pageTitle":"Solidity Contracts Examples","url":"develop/smart-contract/solidity-developing/samples#10-wallet-simple-wallet","content":"Call Wallet.sendTransaction(address payable dest, uint128 value, bool bounce). This function allows transferring EVERs to the specified account. "},{"title":"11. ContractDeployer: Deploy Contract from contract via new.​","type":1,"pageTitle":"Solidity Contracts Examples","url":"develop/smart-contract/solidity-developing/samples#11-contractdeployer-deploy-contract-from-contract-via-new","content":"The way to get arguments for deploying is described How to deploy contract from contract. "},{"title":"12. BadContract: Contract upgrade​","type":1,"pageTitle":"Solidity Contracts Examples","url":"develop/smart-contract/solidity-developing/samples#12-badcontract-contract-upgrade","content":"Contract code could be changed via using tvm.setcode function. It could be useful for fixing errors and functionality updating. In that example we have a BadContract (it is a PiggyBank contract with added upgrade functionality) and new version of that contract NewVersion. Call &quot;PiggyBank.setCode(TvmCell memory newcode)&quot; with argument that contains code of NewVersion contract to change the code of the contract. "},{"title":"13. BankCollector: Mapping methods​","type":1,"pageTitle":"Solidity Contracts Examples","url":"develop/smart-contract/solidity-developing/samples#13-bankcollector-mapping-methods","content":"Developer can work with mappings using methods: fetch, min, next. This methods allow to check existence of the key, obtain lexicographically minimal key and lexicographically next key respectively. "},{"title":"14. CustomReplayProtection: Custom replay protection​","type":1,"pageTitle":"Solidity Contracts Examples","url":"develop/smart-contract/solidity-developing/samples#14-customreplayprotection-custom-replay-protection","content":"Developer can redefine function afterSignatureCheck to create his own replay protection function instead of default one. "},{"title":"15. MessageSender: Message construction and parsing​","type":1,"pageTitle":"Solidity Contracts Examples","url":"develop/smart-contract/solidity-developing/samples#15-messagesender-message-construction-and-parsing","content":"Developer can use TVM specific types to build message manually and special api functiontvm.sendrawmsg() to send it. Contract MessageSender performs such actions to build a message which will call the function of another contract MessageReceiver. MessageReceiveralso shows how to parse a cell. "},{"title":"16. onBounceHandler: Working with bounced messages​","type":1,"pageTitle":"Solidity Contracts Examples","url":"develop/smart-contract/solidity-developing/samples#16-onbouncehandler-working-with-bounced-messages","content":"Developer can define onBounce function to work with bounced messages. If an error occurs while message transferring or handling it can be bounced back to the source contract. This sample demonstrates how you can handle such bounced message. "},{"title":"17. low_level: Constructor message structure​","type":1,"pageTitle":"Solidity Contracts Examples","url":"develop/smart-contract/solidity-developing/samples#17-low_level-constructor-message-structure","content":""},{"title":"18. Interfaces, OrderClient, OrderDatabase: Order Book​","type":1,"pageTitle":"Solidity Contracts Examples","url":"develop/smart-contract/solidity-developing/samples#18-interfaces-orderclient-orderdatabase-order-book","content":"Interface.sol - interface of DataBase and Client Contract. OrderClient.sol - contract that can create new orders in OrderDatabase contract. OrderDtatabase.sol - stores order information, creates an order, changes the database, etc. "},{"title":"19. Casino, CasinoClient, CasinoOwner, CasinoInterfaces: Casino​","type":1,"pageTitle":"Solidity Contracts Examples","url":"develop/smart-contract/solidity-developing/samples#19-casino-casinoclient-casinoowner-casinointerfaces-casino","content":"Casino - Casino roulette smart contract. CasinoInterfaces.sol - interface of the Casino contract. CasinoOwner.sol, CasinoClient.sol - Casino owner smart contracts. "},{"title":"20. Bomber, Interface, Sink: Bomber​","type":1,"pageTitle":"Solidity Contracts Examples","url":"develop/smart-contract/solidity-developing/samples#20-bomber-interface-sink-bomber","content":""},{"title":"21. Self_deploy: Self Deployer​","type":1,"pageTitle":"Solidity Contracts Examples","url":"develop/smart-contract/solidity-developing/samples#21-self_deploy-self-deployer","content":"This sample shows how the contract can deploy another contract of the same type. "},{"title":"22. Sender, Sink: Sender​","type":1,"pageTitle":"Solidity Contracts Examples","url":"develop/smart-contract/solidity-developing/samples#22-sender-sink-sender","content":"Generates cell which contains message which calls another contract by internal outbound message. Saves received value in state variable. "},{"title":"23. rawReserve, sender: Reserver​","type":1,"pageTitle":"Solidity Contracts Examples","url":"develop/smart-contract/solidity-developing/samples#23-rawreserve-sender-reserver","content":"A contract that reserves a certain amount of EVER from the remaining balance of the account: exactly,at most,or all but. "},{"title":"24. ISquareProvider, LengthProvider, SquareProvider, WidthProvider: Rectangle square​","type":1,"pageTitle":"Solidity Contracts Examples","url":"develop/smart-contract/solidity-developing/samples#24-isquareprovider-lengthprovider-squareprovider-widthprovider-rectangle-square","content":""},{"title":"25. Config: Function arguments specification​","type":1,"pageTitle":"Solidity Contracts Examples","url":"develop/smart-contract/solidity-developing/samples#25-config-function-arguments-specification","content":"Sometimes it can be not obvious in which way function arguments should be specified, especially if it is a large structure with different and complex fields. It is generally described in abi doc. And this example was made to help users clear this moment. "},{"title":"Issue a Fungible Token","type":0,"sectionRef":"#","url":"develop/smart-digital-assets/issue-ft","content":"","keywords":""},{"title":"Reference​","type":1,"pageTitle":"Issue a Fungible Token","url":"develop/smart-digital-assets/issue-ft#reference","content":"TIP-3 Core description The documentation in Everscale repository is a community effort. Therefore, everyone can contribute with proposals for new topics, suggest new content elements, participate in editing, and provide ideas that will be of great help for network development. Please be informed that our documentation can be edited via GitHub. Also please make sure to consult our rules and rewards policy via this link. Feel free to join Everscale Documentation Development Telegram chat and Everscale Developers Onboarding Telegram chat! "},{"title":"Issue a Non-Fungible Token","type":0,"sectionRef":"#","url":"develop/smart-digital-assets/mint-nft","content":"","keywords":""},{"title":"Reference​","type":1,"pageTitle":"Issue a Non-Fungible Token","url":"develop/smart-digital-assets/mint-nft#reference","content":"TIP-4 Core description The documentation in Everscale repository is a community effort. Therefore, everyone can contribute with proposals for new topics, suggest new content elements, participate in editing, and provide ideas that will be of great help for network development. Please be informed that our documentation can be edited via GitHub. Also please make sure to consult our rules and rewards policy via this link. Feel free to join Everscale Documentation Development Telegram chat and Everscale Developers Onboarding Telegram chat! "},{"title":"Ever.bytie.moe","type":0,"sectionRef":"#","url":"develop/tools/ever-bytie","content":"Ever.bytie.moe Via following this link you will get familiar with the tool for interacting with the contract. You just have to upload the ABI, it also works for the local network. Before proceeding, please install Ever wallet. The documentation in Everscale repository is a community effort. Therefore, everyone can contribute with proposals for new topics, suggest new content elements, participate in editing, and provide ideas that will be of great help for network development. Please be informed that our documentation can be edited via GitHub. Also please make sure to consult our rules and rewards policy via this link. Feel free to join Everscale Documentation Development Telegram chat and Everscale Developers Onboarding Telegram chat!","keywords":""},{"title":"Ever.ninja","type":0,"sectionRef":"#","url":"develop/tools/ever-ninja","content":"Ever.ninja Via following this link you will get familiar with Ever.ninja, which is a tool for smart contract visualisation. The documentation in Everscale repository is a community effort. Therefore, everyone can contribute with proposals for new topics, suggest new content elements, participate in editing, and provide ideas that will be of great help for network development. Please be informed that our documentation can be edited via GitHub. Also please make sure to consult our rules and rewards policy via this link. Feel free to join Everscale Documentation Development Telegram chat and Everscale Developers Onboarding Telegram chat!","keywords":""},{"title":"C++","type":0,"sectionRef":"#","url":"develop/tools/everdev/command-line-interface/cpp","content":"","keywords":""},{"title":"Create your first contract​","type":1,"pageTitle":"C++","url":"develop/tools/everdev/command-line-interface/cpp#create-your-first-contract","content":"This command creates a basic C++ contract with comments that you can observe and compile. everdev clang create Contract  "},{"title":"Compile​","type":1,"pageTitle":"C++","url":"develop/tools/everdev/command-line-interface/cpp#compile","content":"This command compiles and links a selected C++ contract. After successful compilation you get .abi.json and .tvc files that you can later use in your DApps to deploy and run contract methods. everdev clang compile Contract.cpp  "},{"title":"Version​","type":1,"pageTitle":"C++","url":"develop/tools/everdev/command-line-interface/cpp#version","content":"This command shows the currently installed C++ compiler version. everdev clang version  "},{"title":"Update​","type":1,"pageTitle":"C++","url":"develop/tools/everdev/command-line-interface/cpp#update","content":"This command updates the compiler to the latest version. everdev clang update  Use --force or -f option to force reinstall, if the compiler is already up to date. "},{"title":"Set​","type":1,"pageTitle":"C++","url":"develop/tools/everdev/command-line-interface/cpp#set","content":"This command sets the compiler version and downloads it if needed. everdev clang set --compiler 7.0.0  Use --force or -f option to force reinstall, if the current version is the same as the requested version. "},{"title":"DeBrowser","type":0,"sectionRef":"#","url":"develop/tools/everdev/command-line-interface/debrowser","content":"","keywords":""},{"title":"Version​","type":1,"pageTitle":"DeBrowser","url":"develop/tools/everdev/command-line-interface/debrowser#version","content":"This command shows the list of available versions. everdev debrowser version Available Versions: 1.1.0, 1.2.0, 1.2.1, 1.3.1  "},{"title":"Interfaces​","type":1,"pageTitle":"DeBrowser","url":"develop/tools/everdev/command-line-interface/debrowser#interfaces","content":"This command shows the list of implemented interfaces. everdev debrowser interfaces Realised interfaces: - Address Input - Amount Input - Confirm Input - Menu - Network - Number Input - QR Code - Signing Box Input - Terminal - User Info  "},{"title":"Start​","type":1,"pageTitle":"DeBrowser","url":"develop/tools/everdev/command-line-interface/debrowser#start","content":"This command downloads image and starts DeBrowser container (Docker must be launched). everdev debrowser start 1.3.1  "},{"title":"Stop​","type":1,"pageTitle":"DeBrowser","url":"develop/tools/everdev/command-line-interface/debrowser#stop","content":"This command stops DeBrowser container. everdev debrowser stop  "},{"title":"Contract Management","type":0,"sectionRef":"#","url":"develop/tools/everdev/command-line-interface/contract-management","content":"","keywords":""},{"title":"View contract info​","type":1,"pageTitle":"Contract Management","url":"develop/tools/everdev/command-line-interface/contract-management#view-contract-info","content":"This command displays a detailed summary for a contract. Contract ABI and TVC files are required to run it. Account address on the network is calculated from TVC and signer. everdev contract info abi_filename  Result example: $ everdev contract info SetcodeMultisigWallet.abi.json Configuration Network: dev (eri01.net.everos.dev, rbx01.net.everos.dev, gra01.net.everos.dev) Signer: test (public ad4bf7bd8da244932c52127a943bfa9217b6e215c1b3307272283c4d64f34486) Address: 0:04dee1edc3f3d6b23529dcf5a6133627d06a39826bb14cc6334ffea272b15d50 (calculated from TVC and signer public) Code Hash: e2b60b6b602c10ced7ea8ede4bdf96342c97570a3798066f3fb50a4b2b27a208 (from TVC file) Account: Active Balance: 1919381000 (≈ 2 tokens) Details: { &quot;json_version&quot;: 5, &quot;id&quot;: &quot;0:04dee1edc3f3d6b23529dcf5a6133627d06a39826bb14cc6334ffea272b15d50&quot;, &quot;workchain_id&quot;: 0, &quot;boc&quot;: &quot;te6ccgECZwEAGvQAAm/AAE3uHtw/PW ... 4MEDIoIQ/////byxkOAB8AH4R26Q3o (6912 bytes)&quot;, &quot;last_paid&quot;: 1619084675, &quot;bits&quot;: &quot;0xcbc7&quot;, &quot;cells&quot;: &quot;0x67&quot;, &quot;public_cells&quot;: &quot;0x0&quot;, &quot;last_trans_lt&quot;: &quot;0x3baac81fb43&quot;, &quot;balance&quot;: &quot;0x72676e08&quot;, &quot;code&quot;: &quot;te6ccgECXwEAGcoAAib/APSkICLAAZ ... wQMighD////9vLGQ4AHwAfhHbpDeg= (6614 bytes)&quot;, &quot;code_hash&quot;: &quot;e2b60b6b602c10ced7ea8ede4bdf96342c97570a3798066f3fb50a4b2b27a208&quot;, &quot;data&quot;: &quot;te6ccgEBBwEA7gAC361L972NokSTLF ... S/Xy90TNN3lUFM1WGpdlIcBQDAAAFA (249 bytes)&quot;, &quot;data_hash&quot;: &quot;ec28abd34e75f40a66561bdc06b436cbe24d10d5da7519a7d5db41026c67155d&quot;, &quot;acc_type&quot;: 1, &quot;acc_type_name&quot;: &quot;Active&quot; }  Network, signer, data and account address parameters can be overridden with the following options: $ everdev contract info -h EverDev Version: 0.5.0 Use: everdev contract info file [options] Args: file ABI file Options: --help, -h Show command usage --network, -n Network name --signer, -s Signer key name --data, -d Deploying initial data as name:value,... This data is required to calculate the account address and to deploy contract. Array values must be specified as [item,...]. Spaces are not allowed. If value contains spaces or special symbols &quot;[],:&quot; it must be enclosed in &quot;&quot; or '' --address, -a Account address  "},{"title":"Deploy contract​","type":1,"pageTitle":"Contract Management","url":"develop/tools/everdev/command-line-interface/contract-management#deploy-contract","content":"This command deploys a contract to the blockchain. Contract ABI and TVC files are required to run it. everdev contract deploy abi_filename  Command displays deployment summary and requests constructor function parameters. Result example: $ everdev contract deploy Contract.abi.json Configuration Network: dev Signer: sign1 Address: 0:0435cb4e70585759ac514bb9fd1770caeb8c3941d882b5a16d589b368cb49261 Enter constructor parameters param1 (uint256[]): value Enter constructor parameters param2 (uint8): value Deploying...  Deploy parameters can be specified in the deploy command with the following options: $ everdev contract deploy -h EverDev Version: 0.5.0 Use: everdev contract deploy file function [options] Args: file ABI file function Function name Options: --help, -h Show command usage --network, -n Network name --signer, -s Signer key name --input, -i Function parameters as name:value,... Array values must be specified as [item,...]. Spaces are not allowed. If value contains spaces or special symbols &quot;[],:&quot; it must be enclosed in &quot;&quot; or '' --data, -d Deploying initial data as name:value,... This data is required to calculate the account address and to deploy contract. Array values must be specified as [item,...]. Spaces are not allowed. If value contains spaces or special symbols &quot;[],:&quot; it must be enclosed in &quot;&quot; or '' --value, -v Deploying balance value in nano tokens --prevent-ui, -p Prevent user interaction Useful in shell scripting e.g. on server or in some automating to disable waiting for the user input. Instead everdev will abort with error. For example when some parameters are missing in command line then ton dev will prompt user to input values for missing parameters (or fails if prevent-ui option is specified).  Example of a 2/3 multisig wallet deployment command: everdev contract deploy SetcodeMultisigWallet.abi.json constructor -n dev -s sign1 -i owners:[0xad4bf7bd8da244932c52127a943bfa9217b6e215c1b3307272283c4d64f34486,0x5c2e348c5caeb420a863dc5e972f897ebe5ee899a6ef2a8299aac352eca4380a,0x8534c46f7a135058773fa1298cb3a299a5ddd40dafe41cb06c64f274da360bfb],reqConfirms:2  "},{"title":"Run contract deployed on the network​","type":1,"pageTitle":"Contract Management","url":"develop/tools/everdev/command-line-interface/contract-management#run-contract-deployed-on-the-network","content":"This command runs any function of a contract deployed on the blockchain. Contract ABI and TVC files are required to run it. everdev contract run abi_filename  Command displays available functions and asks to select one. Result example: $ everdev contract run Contract.abi.json Configuration Network: dev Signer: sign1 Address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc Available functions: 1) func1 2) func2 Select function (number): 2 Running...  Network, signer and account address parameters can be overridden and function parameters specified in the command with the following options: $ everdev contract run -h EverDev Version: 0.5.0 Use: everdev contract run file function [options] Args: file ABI file function Function name Options: --help, -h Show command usage --network, -n Network name --signer, -s Signer key name --data, -d Deploying initial data as name:value,... This data is required to calculate the account address and to deploy contract. Array values must be specified as [item,...]. Spaces are not allowed. If value contains spaces or special symbols &quot;[],:&quot; it must be enclosed in &quot;&quot; or '' --address, -a Account address --input, -i Function parameters as name:value,... Array values must be specified as [item,...]. Spaces are not allowed. If value contains spaces or special symbols &quot;[],:&quot; it must be enclosed in &quot;&quot; or '' --prevent-ui, -p Prevent user interaction Useful in shell scripting e.g. on server or in some automating to disable waiting for the user input. Instead everdev will abort with error. For example when some parameters are missing in command line then ton dev will prompt user to input values for missing parameters (or fails if prevent-ui option is specified).  Example of creating a transaction and confirming it in a multisig wallet: everdev contract run SetcodeMultisigWallet.abi.json submitTransaction -n dev -s sign1 -i dest:255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f3,value:500000000,bounce:true,allBalance:false,payload:&quot;&quot;  everdev contract run SetcodeMultisigWallet.abi.json confirmTransaction -n dev -a 0:04dee1edc3f3d6b23529dcf5a6133627d06a39826bb14cc6334ffea272b15d50 -s sign2 -i transactionId:6954030467099431873  To execute a contract without signing, use signer none option: everdev contract run --signer none --address &lt;address&gt;  or everdev contract run -s none -a &lt;address&gt;  In this case you have to explicitly specify address in run function because otherwise everdev may calculate a wrong address from empty pubkey. To execute a smart contract function with bytes argument, the argument needs to be in hex format. Example: cat bytes | xxd -p | tr -d '\\n' &gt; bytes.hex everdev contract run contract.abi.json function_name -i value:$(cat bytes.hex)  Execute a smart contract function with structure arguments: everdev contract run shapes.tvc \\ savePoint \\ --address 0:540c1837656674d548c934258ddec9b5fd11b543da977b0016c14b5650bc7eb5 \\ --input '{ &quot;point&quot;: { &quot;color&quot;: &quot;red&quot;, &quot;center&quot;: { &quot;x&quot;: 1, &quot;y&quot;: 2 } } }'  or with an array of structures: everdev contract run shapes.tvc \\ savePoints \\ --address 0:540c1837656674d548c934258ddec9b5fd11b543da977b0016c14b5650bc7eb5 \\ --input \\ '{ &quot;points&quot;: [ { &quot;color&quot;: &quot;pink&quot;, &quot;center&quot;: { &quot;x&quot;: 4, &quot;y&quot;: 5 }}, { &quot;color&quot;: &quot;gray&quot;, &quot;center&quot;: { &quot;x&quot;: 6, &quot;y&quot;: 7 }} ]}'  Run contract locally on TVM​ This command downloads a contract and runs it locally on TVM. Contract ABI and TVC files are required to run it. everdev contract run-local abi_filename  Command displays available functions and asks to select one. Result example: $ everdev contract run-local Contract.abi.json Configuration Network: dev Signer: sign1 Address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc Available functions: 1) func1 2) func1 Select function (number):  Network, signer and account address parameters can be overridden and function parameters specified in the command with the following options: $ everdev contract run-local -h EverDev Version: 0.5.0 Use: everdev contract run-local file function [options] Args: file ABI file function Function name Options: --help, -h Show command usage --network, -n Network name --signer, -s Signer key name --data, -d Deploying initial data as name:value,... This data is required to calculate the account address and to deploy contract. Array values must be specified as [item,...]. Spaces are not allowed. If value contains spaces or special symbols &quot;[],:&quot; it must be enclosed in &quot;&quot; or '' --address, -a Account address --input, -i Function parameters as name:value,... Array values must be specified as [item,...]. Spaces are not allowed. If value contains spaces or special symbols &quot;[],:&quot; it must be enclosed in &quot;&quot; or '' --prevent-ui, -p Prevent user interaction Useful in shell scripting e.g. on server or in some automating to disable waiting for the user input. Instead everdev will abort with error. For example when some parameters are missing in command line then ton dev will prompt user to input values for missing parameters (or fails if prevent-ui option is specified).  "},{"title":"Emulate transaction executor locally on TVM​","type":1,"pageTitle":"Contract Management","url":"develop/tools/everdev/command-line-interface/contract-management#emulate-transaction-executor-locally-on-tvm","content":"This command downloads a contract and emulates transaction execution locally on TVM. Contract ABI and TVC files are required to run it. everdev contract run-executor abi_filename  Command displays available functions and asks to select one. Result: $ everdev contract run-executor Contract.abi.json Configuration Network: dev Signer: sign1 Address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc Available functions: 1) func1 2) func2 Select function (number):  Network, signer and account address parameters can be overridden and function parameters specified in the command with the following options: $ everdev contract run-executor -h EverDev Version: 0.5.0 Use: everdev contract run-executor file function [options] Args: file ABI file function Function name Options: --help, -h Show command usage --network, -n Network name --signer, -s Signer key name --data, -d Deploying initial data as name:value,... This data is required to calculate the account address and to deploy contract. Array values must be specified as [item,...]. Spaces are not allowed. If value contains spaces or special symbols &quot;[],:&quot; it must be enclosed in &quot;&quot; or '' --address, -a Account address --input, -i Function parameters as name:value,... Array values must be specified as [item,...]. Spaces are not allowed. If value contains spaces or special symbols &quot;[],:&quot; it must be enclosed in &quot;&quot; or '' --prevent-ui, -p Prevent user interaction Useful in shell scripting e.g. on server or in some automating to disable waiting for the user input. Instead everdev will abort with error. For example when some parameters are missing in command line then ton dev will prompt user to input values for missing parameters (or fails if prevent-ui option is specified).  "},{"title":"Top up contract balance from giver​","type":1,"pageTitle":"Contract Management","url":"develop/tools/everdev/command-line-interface/contract-management#top-up-contract-balance-from-giver","content":"If you have set a giver for a network, you can top up contract balances on it with the following command. everdev contract topup abi_filename  Defalt signer and giver parameters will be used, unless otherwise specified through the following options: $ everdev contract topup -h EverDev Version: 0.5.0 Use: everdev contract topup file [options] Args: file ABI file Options: --help, -h Show command usage --address, -a Account address --network, -n Network name --signer, -s Signer key name --data, -d Deploying initial data as name:value,... This data is required to calculate the account address and to deploy contract. Array values must be specified as [item,...]. Spaces are not allowed. If value contains spaces or special symbols &quot;[],:&quot; it must be enclosed in &quot;&quot; or '' --value, -v Deploying balance value in nano tokens  To top up any known address without providing keys or contract files, use the following command: everdev contract topup --address &lt;address&gt;  or everdev ct -a &lt;addrress&gt;  "},{"title":"Evernode SE","type":0,"sectionRef":"#","url":"develop/tools/everdev/command-line-interface/evernode-platform-startup-edition-se","content":"","keywords":""},{"title":"Start​","type":1,"pageTitle":"Evernode SE","url":"develop/tools/everdev/command-line-interface/evernode-platform-startup-edition-se#start","content":"This command starts the Evernode SE container (Docker must be launched). When executed for the first time downloads the latest SE image from dockerhub. everdev se start  To make sure ArangoDB starts, set the ArangoDB port. "},{"title":"Version​","type":1,"pageTitle":"Evernode SE","url":"develop/tools/everdev/command-line-interface/evernode-platform-startup-edition-se#version","content":"This command shows the default Evernode SE version and list of other available versions. everdev se version default: 0.24.12 Available Versions: 0, 0.24, 0.24.5, 0.24.6, 0.24.8, 0.24.9, 0.24.10, 0.24.11, 0.24.12, latest  "},{"title":"Set​","type":1,"pageTitle":"Evernode SE","url":"develop/tools/everdev/command-line-interface/evernode-platform-startup-edition-se#set","content":"This command switches Evernode SE to the specified version and port and downloads it, if it is missing. Attention! This command does not start TON OS SE, you need to run start command separately. everdev se set --version 0.24.11 --port 2020  To make sure ArangoDB starts, use --db-port option to set the ArangoDB port: everdev se set --db-port 8081  "},{"title":"Reset​","type":1,"pageTitle":"Evernode SE","url":"develop/tools/everdev/command-line-interface/evernode-platform-startup-edition-se#reset","content":"This command resets the Evernode SE container (Docker must be launched) - restarts it from scratch with a clean database. everdev se reset  "},{"title":"Update​","type":1,"pageTitle":"Evernode SE","url":"develop/tools/everdev/command-line-interface/evernode-platform-startup-edition-se#update","content":"This command downloads the latest Evernode SE image (Docker must be launched) and starts it. everdev se update  "},{"title":"Stop​","type":1,"pageTitle":"Evernode SE","url":"develop/tools/everdev/command-line-interface/evernode-platform-startup-edition-se#stop","content":"This command stops Evernode SE container. everdev se stop  "},{"title":"Info​","type":1,"pageTitle":"Evernode SE","url":"develop/tools/everdev/command-line-interface/evernode-platform-startup-edition-se#info","content":"This command shows info about the downloaded versions. everdev se info Instance State Version GraphQL Port ArangoDB Port Docker Container Docker Image -------- ------- ------- ------------ ------------- -------------------------- -------------------------- default running 0.24.12 2020 tonlabs-tonos-se-ekaterina tonlabs/local-node:0.24.12  "},{"title":"SDK","type":0,"sectionRef":"#","url":"develop/tools/everdev/command-line-interface/sdk","content":"","keywords":""},{"title":"See the list of available demo projects​","type":1,"pageTitle":"SDK","url":"develop/tools/everdev/command-line-interface/sdk#see-the-list-of-available-demo-projects","content":"This command shows the list of available demo projects everdev js demo  Result: $ everdev js demo Demo Description ------------ ------------------------- hello-wallet Simple NodeJs Application  "},{"title":"Install demo project​","type":1,"pageTitle":"SDK","url":"develop/tools/everdev/command-line-interface/sdk#install-demo-project","content":"This command installs the specified demo project to the current directory. Proceed the instructions in the terminal to run it. everdev js demo hello-wallet  "},{"title":"Create an empty project​","type":1,"pageTitle":"SDK","url":"develop/tools/everdev/command-line-interface/sdk#create-an-empty-project","content":"This command creates a Node.js project with SDK latest dependencies and index.js file with main Client object creation. everdev js create test_project  "},{"title":"Create contract JS wrapper​","type":1,"pageTitle":"SDK","url":"develop/tools/everdev/command-line-interface/sdk#create-contract-js-wrapper","content":"This command takes abi and, optionally, tvc file and generates a JS wrapper with abi and tvc converted into base64 that can be used further in SDK. tvc file must have the same name as abi. everdev js wrap contractName.abi.json  The result name of the wrapper will be &quot;ContractName||&quot;Contract&quot;.js&quot;. See other available generation options with help command: everdev js wrap -h EverDev Version: 0.4.0 Use: everdev js wrap file [options] Args: file ABI file Options: --help, -h Show command usage --print, -p Print code to console --output, -o Set output file name (default is built from source ABI file name) --export, -e Export type and options commonjs Use CommonJS modules (NodeJs) commonjs-default Use CommonJS modules (NodeJS) with default export es6 Use ES6 modules es6-default Use ES6 modules with default export  "},{"title":"Network Tool","type":0,"sectionRef":"#","url":"develop/tools/everdev/command-line-interface/network-tool","content":"","keywords":""},{"title":"Add a network​","type":1,"pageTitle":"Network Tool","url":"develop/tools/everdev/command-line-interface/network-tool#add-a-network","content":"This command adds a network to the everdev registry. everdev network add network_name network_endpoints  See other available network addition options with help command: $ everdev network add -h EverDev Version: 0.5.0 Use: everdev network add name endpoints [options] Args: name endpoints Comma separated endpoints Options: --help, -h Show command usage --force, -f Overwrite key if already exists  Example with mainnet endpoints: everdev network add main eri01.main.everos.dev,gra01.main.everos.dev,gra02.main.everos.dev,lim01.main.everos.dev,rbx01.main.everos.dev  "},{"title":"Set a giver for a network​","type":1,"pageTitle":"Network Tool","url":"develop/tools/everdev/command-line-interface/network-tool#set-a-giver-for-a-network","content":"This command sets a giver account for a network. Giver will be used to top up your account balances on the network, including during deployment. everdev network giver network_name giver_address  See other available network addition options with help command: $ everdev network giver -h EverDev Version: 0.5.0 Use: everdev network giver name address [options] Args: name Network name address Giver address Options: --help, -h Show command usage --signer, -s Signer to be used with giver --value, -v Deploying account initial balance in nanotokens  Note: The default signer and the initial balance value of 10 tokens will be used, unless otherwise specified through options. Also note, that some contracts may require a higher initial balance for successful deployment. DePool contract, for instance, requires a minimun of 21 tokens. Only one giver can be set for a network. Setting another one will overwrite the current giver. To view the current giver settings for all networks, use the everdev network list command (for details see the section below). "},{"title":"List registered networks​","type":1,"pageTitle":"Network Tool","url":"develop/tools/everdev/command-line-interface/network-tool#list-registered-networks","content":"This command lists all registered networks, their public endpoints, and their giver addresses, if any. everdev network list  Result: $ everdev network list Network Endpoints Giver ------------- ----------------------------------------------- ------------------------------------------------------------------ se http://localhost 0:b5e9240fc2d2f1ff8cbb1d1dee7fb7cae155e5f6320e585fcc685698994a19a5 dev (Default) eri01.net.everos.dev, rbx01.net.everos.dev, gra01.net.everos.dev 0:255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f3  "},{"title":"Set default network​","type":1,"pageTitle":"Network Tool","url":"develop/tools/everdev/command-line-interface/network-tool#set-default-network","content":"This command sets a previously added network as default (initially the mainnet is used by default). everdev network default network_name  "},{"title":"Delete a network​","type":1,"pageTitle":"Network Tool","url":"develop/tools/everdev/command-line-interface/network-tool#delete-a-network","content":"This command deletes a network from everdev registry. everdev network delete network_name  "},{"title":"Solidity","type":0,"sectionRef":"#","url":"develop/tools/everdev/command-line-interface/solidity","content":"","keywords":""},{"title":"Create your first contract​","type":1,"pageTitle":"Solidity","url":"develop/tools/everdev/command-line-interface/solidity#create-your-first-contract","content":"This command creates a hello-world Solidity contract with comments that you can observe and compile. everdev sol create Contract  "},{"title":"Compile​","type":1,"pageTitle":"Solidity","url":"develop/tools/everdev/command-line-interface/solidity#compile","content":"This command compiles and links a selected Solidity contract. After successful compilation you get .abi.json and .tvc files that you can later use in your DApps to deploy and run contract methods. everdev sol compile Contract.sol  To save generated assembler code use -c option (default is false) everdev sol compile Contract.sol -c path/to/output/file  Assembler code will be saved in path/to/output/file with the extension code You can specify the output files location with the -o option: everdev sol compile Contract.sol -o path/to/output/file  "},{"title":"Ast​","type":1,"pageTitle":"Solidity","url":"develop/tools/everdev/command-line-interface/solidity#ast","content":"This command parses a ton-solidity file and creates an abstract syntax tree (AST) to the output directory. everdev sol ast Contract.sol  To specify the ast format type, use -f or --format option: everdev sol ast-json Contract.sol -f &lt;json | compact-json&gt;  To point the location of the output folder, use the -o or --output-dir option: everdev sol ast-json Contract.sol -f &lt;json | compact-json&gt; -o path/to/output/file  "},{"title":"Version​","type":1,"pageTitle":"Solidity","url":"develop/tools/everdev/command-line-interface/solidity#version","content":"This command shows the currently installed Solidity compiler version. everdev sol version  "},{"title":"Update​","type":1,"pageTitle":"Solidity","url":"develop/tools/everdev/command-line-interface/solidity#update","content":"This command updates the compiler and linker to the latest version. everdev sol update  Attention! Use --force option to force update of components that do not update their version. "},{"title":"Set​","type":1,"pageTitle":"Solidity","url":"develop/tools/everdev/command-line-interface/solidity#set","content":"This command sets the compiler and linker versions and downloads them if needed. everdev sol set --compiler 0.38.0 --linker 0.23.54  Attention! Use --force option to force update of components that do not update their version. "},{"title":"Signer Tool","type":0,"sectionRef":"#","url":"develop/tools/everdev/command-line-interface/signer-tool","content":"","keywords":""},{"title":"Add a signer with randomly generated keys​","type":1,"pageTitle":"Signer Tool","url":"develop/tools/everdev/command-line-interface/signer-tool#add-a-signer-with-randomly-generated-keys","content":"This command adds a signer with randomly generated keys. everdev signer generate signer_name  See other available generation options with help command: everdev signer generate -h EverDev Version: 0.5.0 Use: everdev signer generate name [options] Args: name Signer name Options: --help, -h Show command usage --mnemonic, -m Use mnemonic phrase --dictionary, -d Mnemonic dictionary 0 TON 1 English 2 Chinese Simplified 3 Chinese Traditional 4 French 5 Italian 6 Japanese 7 Korean 8 Spanish --words, -w Number of mnemonic words --force, -f Overwrite signer if already exists  "},{"title":"Add a signer with specific keys​","type":1,"pageTitle":"Signer Tool","url":"develop/tools/everdev/command-line-interface/signer-tool#add-a-signer-with-specific-keys","content":"This command adds a signer with previously generated (e.g. with tonos-cli) keys. everdev signer add signer_name signer_secret_key_or_seed_phrase_in_quotes  See other available signer addition options with help command: everdev signer add -h EverDev Version: 0.5.0 Use: everdev signer add name secret [options] Args: name Signer name secret Secret key or seed phrase Options: --help, -h Show command usage --dictionary, -d Mnemonic dictionary 0 TON 1 English 2 Chinese Simplified 3 Chinese Traditional 4 French 5 Italian 6 Japanese 7 Korean 8 Spanish --force, -f Overwrite signer if already exists  Note: By default the dictionary is set to english, which allows using seed phrases generated by other TONOS tools, such as tonos-cli. "},{"title":"List registered signers​","type":1,"pageTitle":"Signer Tool","url":"develop/tools/everdev/command-line-interface/signer-tool#list-registered-signers","content":"This command lists all registered signers with their public keys. everdev signer list  Result: $ everdev signer list Signer Public Key --------------- ---------------------------------------------------------------- sign1 (Default) cffd3a2f1d241807b2205220a7d6df980e67a3cc7c47eba2766cdc1bbddfc0e3 sign2 0fc4e781720d80f76257db333c6b6934090562418652cf30352878c87707aa94  "},{"title":"Get signer details​","type":1,"pageTitle":"Signer Tool","url":"develop/tools/everdev/command-line-interface/signer-tool#get-signer-details","content":"This command lists all information (including secret data) for a specified signer. everdev signer info signer_name  Result: $ everdev signer info sign2 { &quot;name&quot;: &quot;sign2&quot;, &quot;description&quot;: &quot;&quot;, &quot;keys&quot;: { &quot;public&quot;: &quot;760d69964d038997d891fca0a0407c2ffefb701e7cb2f9ff0a87fbbf1e8098f2&quot;, &quot;secret&quot;: &quot;72571b5a9392e6bb215b460ca3c0545c34d790e185f66f5b2e7564329ffea86c&quot; } }  "},{"title":"Set default signer​","type":1,"pageTitle":"Signer Tool","url":"develop/tools/everdev/command-line-interface/signer-tool#set-default-signer","content":"This command sets a previously added signer as default (initially the first added signer is used by default). everdev signer default signer_name  "},{"title":"Delete a signer​","type":1,"pageTitle":"Signer Tool","url":"develop/tools/everdev/command-line-interface/signer-tool#delete-a-signer","content":"This command deletes a previously added signer from signer registry. everdev signer delete signer_name  "},{"title":"TestSuite4","type":0,"sectionRef":"#","url":"develop/tools/everdev/command-line-interface/testsuite4","content":"","keywords":""},{"title":"Version​","type":1,"pageTitle":"TestSuite4","url":"develop/tools/everdev/command-line-interface/testsuite4#version","content":"This command shows the currently installed and available TestSuite4 framework versions. everdev ts4 version  "},{"title":"Install​","type":1,"pageTitle":"TestSuite4","url":"develop/tools/everdev/command-line-interface/testsuite4#install","content":"This command installs (using pip) TestSuite4's latest or selected version and downloads them if needed. everdev ts4 install # install latest version everdev ts4 install 0.2.0 # install version 0.2.0  "},{"title":"Update​","type":1,"pageTitle":"TestSuite4","url":"develop/tools/everdev/command-line-interface/testsuite4#update","content":"This command updates TestSuite4 to the latest version. everdev ts4 update  "},{"title":"Create​","type":1,"pageTitle":"TestSuite4","url":"develop/tools/everdev/command-line-interface/testsuite4#create","content":"This command creates a TestSuite4's template of the test (TestName.py). everdev ts4 create TestName everdev ts4 create TestName --folder tests # creates tests/TestName.py (folder must exist)  "},{"title":"Run​","type":1,"pageTitle":"TestSuite4","url":"develop/tools/everdev/command-line-interface/testsuite4#run","content":"This command runs selected test (TestName.py). everdev ts4 run TestName  "},{"title":"TONOS-CLI","type":0,"sectionRef":"#","url":"develop/tools/everdev/command-line-interface/tonos-cli","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/everdev/command-line-interface/tonos-cli#install","content":"This command installs the latest tonos-cli everdev tonos-cli install  The installer requires NPM to be installed, so it can install packages globally without using sudo. In case of error, manually set environment variable PATH=$PATH:$HOME/.everdev/solidity "},{"title":"Version​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/everdev/command-line-interface/tonos-cli#version","content":"This command shows the used tonos-cli version and list of available for download versions everdev tonos-cli version Version Available --------- ------------------------------------------------------ 0.8.1 0.6.0, 0.6.1, 0.6.2, 0.7.1, 0.6.3, 0.7.0, 0.8.0, 0.8.1  "},{"title":"Set​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/everdev/command-line-interface/tonos-cli#set","content":"This command specifies tonos-cli version to use and downloads it if needed. everdev tonos-cli set --version 0.8.0  "},{"title":"Update​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/everdev/command-line-interface/tonos-cli#update","content":"This command updates tonos-cli version to the latest everdev tonos-cli update  "},{"title":"How to view controller info","type":0,"sectionRef":"#","url":"develop/tools/everdev/guides/controller-info","content":"How to view controller info This command displays a summary of all controller configurations. everdev info Output example: $ everdev info C++ compiler Component Version Available --------- ------- --------- clang 7.0.0 7.0.0 Solidity Compiler Component Available --------- ---------------------------------------------- compiler 0.42.0, 0.41.0, 0.40.0, 0.39.0, 0.38.2, 0.38.1 linker 0.3.0, 0.1.0 stdlib 0.42.0, 0.41.0, 0.40.0, 0.39.0, 0.38.2, 0.38.1 TON OS SE Instance State Version GraphQL Port Docker Container Docker Image -------- ------------- ------- ------------ -------------------- ----------------------- default not installed 0.27 80 tonlabs-tonos-se-test tonlabs/local-node:0.27 Network Registry Network Endpoints Giver ------------- ----------------------------------------------- ------------------------------------------------------------------ se http://localhost 0:b5e9240fc2d2f1ff8cbb1d1dee7fb7cae155e5f6320e585fcc685698994a19a5 dev (Default) net.ton.dev, net1.ton.dev, net5.ton.dev 0:255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f3 main main.ton.dev, main2.ton.dev, main3.ton.dev, ... Signer Registry Signer Public Key -------------- ---------------------------------------------------------------- surf 8534c46f7a135058773fa1298cb3a299a5ddd40dafe41cb06c64f274da360bfb test (Default) ad4bf7bd8da244932c52127a943bfa9217b6e215c1b3307272283c4d64f34486 test2 5c2e348c5caeb420a863dc5e972f897ebe5ee899a6ef2a8299aac352eca4380a TON OS CLI Component Version Available --------- ------- -------------------------------------------------------------------------------- tonoscli 0.11.3 0.11.4, 0.11.3, 0.11.2, 0.11.1, 0.11.0, 0.10.1, 0.10.0, 0.9.2, 0.9.1, 0.9.0, ... ","keywords":""},{"title":"How to create controller","type":0,"sectionRef":"#","url":"develop/tools/everdev/guides/create-controller","content":"","keywords":""},{"title":"What a controller should and what it shouldn't do​","type":1,"pageTitle":"How to create controller","url":"develop/tools/everdev/guides/create-controller#what-a-controller-should-and-what-it-shouldnt-do","content":"Controller should: Expose functionality to the user as a list of commands.Install the required tool components on demand (on first usage).Start and stop the tool components that act like demons.Define three commands to control the tool version: version to show the currently installed tool version;update to update the tool to the latest available version;use to select the specified tool version as the current version. Controller shouldn't: Implement tool functionality itself. The controller is a connector between the user and the existing development tool.Implement user interaction itself. All user interaction must be implemented exactly in terms of Everdev extensibility. "},{"title":"How to implement a Controller​","type":1,"pageTitle":"How to create controller","url":"develop/tools/everdev/guides/create-controller#how-to-implement-a-controller","content":"Create a folder for a new controller: mkdir src/controllers/foo cd src/controllers/foo  Create index.ts with the controller's definition: import { ToolController } from &quot;../../core&quot;; import { versionCommand } from &quot;./version&quot;; import { updateCommand } from &quot;./update&quot;; import { runCommand } from &quot;./run&quot;; export const Foo: ToolController = { name: &quot;foo&quot;, title: &quot;Foo Tool&quot;, commands: [ versionCommand, updateCommand, runCommand, ], };  Create installer.ts to implement all the code related to the tool installation: import path from &quot;path&quot;; import fs from &quot;fs&quot;; import { Terminal, everdevHome } from &quot;../../core&quot;; function fooHome() { return path.resolve(everdevHome(), &quot;foo&quot;); } async function ensureInstalled(terminal: Terminal) { } export async function getVersion(): Promise&lt;string&gt; { return &quot;1.0.0&quot;; } export async function updateVersion(terminal: Terminal) { if (fs.existsSync(fooHome())) { fs.rmdirSync(fooHome(), { recursive: true }); } ensureInstalled(terminal); } export async function runFoo(terminal: Terminal, workDir: string, args: string[]): Promise&lt;void&gt; { ensureInstalled(terminal); terminal.log(&quot;Foo succeeded&quot;); };  Create version.ts command handler: import { getVersion } from &quot;./installer&quot;; import { Command, Terminal } from &quot;../../core&quot;; export const versionCommand: Command = { name: &quot;version&quot;, title: &quot;Show Foo Version&quot;, async run(terminal: Terminal, _args: {}): Promise&lt;void&gt; { terminal.log(await getVersion()); }, };  Create update.ts command handler: import { updateVersion } from &quot;./installer&quot;; import { Command, Terminal } from &quot;../../core&quot;; export const versionCommand: Command = { name: &quot;update&quot;, title: &quot;Update Foo Version&quot;, async run(terminal: Terminal, _args: {}): Promise&lt;void&gt; { await updateVersion(terminal); }, };  Create run.ts command handler: import { runFoo } from &quot;./installer&quot;; import { Command, Terminal } from &quot;../../core&quot;; export const runCommand: Command = { name: &quot;run&quot;, title: &quot;Run Foo&quot;, async run(terminal: Terminal, args: {}): Promise&lt;void&gt; { await runFoo(terminal, args); }, };  "},{"title":"Controller API Reference​","type":1,"pageTitle":"How to create controller","url":"develop/tools/everdev/guides/create-controller#controller-api-reference","content":"You can find API reference in form of TSDoc in src/core/index.ts. "},{"title":"Quick start","type":0,"sectionRef":"#","url":"develop/tools/everdev/guides/quick-start","content":"","keywords":""},{"title":"Guide overview​","type":1,"pageTitle":"Quick start","url":"develop/tools/everdev/guides/quick-start#guide-overview","content":"This guide will help you get started with such essensial Everscale tools as: Solidity CompilerLocal BlockchainEverscale Blockchain ExplorerGraphQL API You will learn how to: Create and compile your first Solidity contractRun Local blockchain for testingDeploy your first contractRun it on-chainRun a getter-function "},{"title":"Install everdev​","type":1,"pageTitle":"Quick start","url":"develop/tools/everdev/guides/quick-start#install-everdev","content":"everdev — single interface to access all the developer tools. npm install -g everdev  If you experience any problems with installation, check out our troubleshooting section. "},{"title":"Create helloWorld contract​","type":1,"pageTitle":"Quick start","url":"develop/tools/everdev/guides/quick-start#create-helloworld-contract","content":"npx everdev sol create helloWorld  "},{"title":"Compile it​","type":1,"pageTitle":"Quick start","url":"develop/tools/everdev/guides/quick-start#compile-it","content":"npx everdev sol compile helloWorld.sol  "},{"title":"Run Local Blockchain​","type":1,"pageTitle":"Quick start","url":"develop/tools/everdev/guides/quick-start#run-local-blockchain","content":"Attention Docker should be running. npx everdev se start  "},{"title":"Configure default network​","type":1,"pageTitle":"Quick start","url":"develop/tools/everdev/guides/quick-start#configure-default-network","content":"Set Local Blockchain SE (Simple Emulator) as the default network: npx everdev network default se  "},{"title":"Configure Giver wallet that will sponsor deploy operation​","type":1,"pageTitle":"Quick start","url":"develop/tools/everdev/guides/quick-start#configure-giver-wallet-that-will-sponsor-deploy-operation","content":"Here we use address and private key of SE High Load Giver. Attention! This giver is available only in SE. If you work in DevNet or MainNet, you need to deploy your own giver. Check how to do it in this guide. npx everdev signer add giver_keys 172af540e43a524763dd53b26a066d472a97c4de37d5498170564510608250c3 npx everdev network giver se 0:b5e9240fc2d2f1ff8cbb1d1dee7fb7cae155e5f6320e585fcc685698994a19a5 --signer giver_keys  "},{"title":"Generate the keys for contract ownership​","type":1,"pageTitle":"Quick start","url":"develop/tools/everdev/guides/quick-start#generate-the-keys-for-contract-ownership","content":"npx everdev signer generate owner_keys npx everdev signer default owner_keys npx everdev signer list Signer Public Key Used -------------------- --------------- --------------------------- giver_keys 2ada2e...b25a16 se network giver signer owner_keys (Default) 382620...1ecf7b  Note That there are shortcuts for all the commands: sl = signer list and sd = signer default :) Don't forget to make the owner key default otherwize giver keys will be used as default. "},{"title":"Calculate the contract address​","type":1,"pageTitle":"Quick start","url":"develop/tools/everdev/guides/quick-start#calculate-the-contract-address","content":"npx everdev contract info helloWorld Configuration Network: se (http://localhost) Signer: owner_keys (public 3826202b129ea8c041b8d49a655512648fc94377d1958a7a4fc9f4b3051ecf7b) Address: 0:e74c4258496e79e62e014ca96911acbf5cb0e286fd55dd6f4e3da54e4197ddf5 (calculated from TVC and signer public) Code Hash: c517820144a4daf5a3414c9233556b2b0ad34cdd228f200ea68a4c0327e0bd29 (from TVC file) Account: Doesn't exist  You can see that the contract does not exist yet (is not deployed) but you can already see its future address. "},{"title":"Deploy​","type":1,"pageTitle":"Quick start","url":"develop/tools/everdev/guides/quick-start#deploy","content":"Here we deploy the contract, sponsoring it with 10 Tokens (Everscale native currency has 9 decimals). The money for deploy are taken from the giver we configured in the previous steps. npx everdev contract deploy -v 10000000000 helloWorld Configuration Network: se (http://localhost) Signer: owner_keys (public 3826202b129ea8c041b8d49a655512648fc94377d1958a7a4fc9f4b3051ecf7b) Address: 0:e74c4258496e79e62e014ca96911acbf5cb0e286fd55dd6f4e3da54e4197ddf5 (calculated from TVC and signer public) Deploying... Contract has deployed at address: 0:e74c4258496e79e62e014ca96911acbf5cb0e286fd55dd6f4e3da54e4197ddf5  "},{"title":"View contract information with Explorer​","type":1,"pageTitle":"Quick start","url":"develop/tools/everdev/guides/quick-start#view-contract-information-with-explorer","content":"Go to localhost and search for your contract address in search bar. Open your account page. You will need it later to see its transactions and messages, that we will produce in the next steps. "},{"title":"Explore contract information with GraphQL​","type":1,"pageTitle":"Quick start","url":"develop/tools/everdev/guides/quick-start#explore-contract-information-with-graphql","content":"Go to localhost/graphql. Enter in the left pane and click Run button (replace the contract's address with the one you got in the previous steps). query { accounts( filter: { id: { eq: &quot;0:e74c4258496e79e62e014ca96911acbf5cb0e286fd55dd6f4e3da54e4197ddf5&quot; } } ) { acc_type_name balance code code_hash data } }  You will see: { &quot;data&quot;: { &quot;accounts&quot;: [ { &quot;acc_type_name&quot;: &quot;Active&quot;, &quot;balance&quot;: &quot;0x1db0832ba&quot;, &quot;code&quot;: &quot;te6ccgECEwEAAnkABCj/AIrtUyDjAyDA/+MCIMD+4wLyCxECARICoiHbPNMAAY4SgQIA1xgg+QFY+EIg+GX5EPKo3tM/AY4d+EMhuSCfMCD4I4ED6KiCCBt3QKC53pMg+GPg8jTYMNMfAfgjvPK50x8B2zz4R27yfAUDATQi0NcLA6k4ANwhxwDcIdMfId0B2zz4R27yfAMDQCCCEDtj1H67joDgIIIQaBflNbuOgOAgghBotV8/uuMCCwYEAlgw+EFu4wD4RvJzcfhm0fhC8uBl+EUgbpIwcN74Qrry4Gb4APgj+GrbPH/4ZwUPAHjtRNAg10nCAY4U0//TP9MA1wsf+Gp/+GH4Zvhj+GKOG/QFcPhqcAGAQPQO8r3XC//4YnD4Y3D4Zn/4YeICKCCCEFTWvRi64wIgghBoF+U1uuMCCAcBSts8+EqNBHAAAAAAAAAAAAAAAAA6BflNYMjOIc8LH8lw+wB/+GcQAnIw0ds8IcD/jikj0NMB+kAwMcjPhyDOjQQAAAAAAAAAAAAAAAANTWvRiM8WIc8UyXD7AN4w4wB/+GcJDwECiAoAFGhlbGxvV29ybGQCKCCCEDcxLkW64wIgghA7Y9R+uuMCDgwDSDD4QW7jAPpA1w1/ldTR0NN/39cMAJXU0dDSAN/R2zzjAH/4ZxANDwBU+EUgbpIwcN74Qrry4Gb4AFRxIMjPhYDKAHPPQM4B+gKAa89AyXD7AF8DAkAw+EFu4wDR+EUgbpIwcN74Qrry4Gb4APgj+GrbPH/4ZxAPAC74QsjL//hDzws/+EbPCwD4SgHLH8ntVAAu7UTQ0//TP9MA1wsf+Gp/+GH4Zvhj+GIBCvSkIPShEgAA&quot;, &quot;code_hash&quot;: &quot;c517820144a4daf5a3414c9233556b2b0ad34cdd228f200ea68a4c0327e0bd29&quot;, &quot;data&quot;: &quot;te6ccgEBAQEALwAAWTgmICsSnqjAQbjUmmVVEmSPyUN30ZWKek/J9LMFHs97AAABesq/uBawfEB6wA==&quot; } ] } }  You can specify any other fields in the result section that are available in GraphQL Schema. (Click Docs on the right side of your screen to explore it). What is GraphQL? This is the API of blockchain, to retrieve data from it and to send data into it. You can use this playground later, if you will need need to test some queries. "},{"title":"Run on-chain​","type":1,"pageTitle":"Quick start","url":"develop/tools/everdev/guides/quick-start#run-on-chain","content":"Let's move on and run an on-chain method. npx everdev contract run helloWorld Configuration Network: se (http://localhost) Signer: owner_key (public 3826202b129ea8c041b8d49a655512648fc94377d1958a7a4fc9f4b3051ecf7b) Address: 0:e74c4258496e79e62e014ca96911acbf5cb0e286fd55dd6f4e3da54e4197ddf5 (calculated from TVC and signer public) Available functions: 1) constructor 2) renderHelloWorld 3) touch 4) sendValue 5) timestamp Select function (number):  Let's enter 3. You will see the transaction ID of the operation. &quot;transaction&quot;: { &quot;json_version&quot;: 5, &quot;id&quot;: &quot;8087f774d4b8b4d4716cb31a74deea32550a04b40e853f55c64579fa3897108f&quot;, &quot;boc&quot;: &quot;te6ccgECBw...... ........................  You can also execute it inline like this: npx everdev contract run helloWorld touch In the result you can see the transaction_id. Search for it on your Contract's page in Explorer and in GraphQL playground (use transactions collection instead of accounts). "},{"title":"Run a getter function​","type":1,"pageTitle":"Quick start","url":"develop/tools/everdev/guides/quick-start#run-a-getter-function","content":"npx everdev contract run-local helloWorld timestamp Configuration Network: se (http://localhost) Signer: owner_keys (public 3826202b129ea8c041b8d49a655512648fc94377d1958a7a4fc9f4b3051ecf7b) Address: 0:e74c4258496e79e62e014ca96911acbf5cb0e286fd55dd6f4e3da54e4197ddf5 (calculated from TVC and signer public) Execution has finished with result: { &quot;output&quot;: { &quot;timestamp&quot;: &quot;1626898677&quot; }, &quot;out_messages&quot;: [] }  "},{"title":"Transfer some tokens​","type":1,"pageTitle":"Quick start","url":"develop/tools/everdev/guides/quick-start#transfer-some-tokens","content":"npx everdev contract run helloWorld sendValue Configuration Network: se (http://localhost) Signer: owner_keys (public 3826202b129ea8c041b8d49a655512648fc94377d1958a7a4fc9f4b3051ecf7b) Address: 0:e74c4258496e79e62e014ca96911acbf5cb0e286fd55dd6f4e3da54e4197ddf5 (calculated from TVC and signer public) Parameters of sendValue: dest (address): 0:b5e9240fc2d2f1ff8cbb1d1dee7fb7cae155e5f6320e585fcc685698994a19a5 amount (uint128): 1000000000 bounce (bool): true Running... Execution has finished with result: { &quot;transaction&quot;: { &quot;json_version&quot;: 5, &quot;id&quot;: &quot;550731bb26e5054387a781257e077dbdd769367f16b19bfa529c20475e2a08f6&quot;, &quot;boc&quot;: &quot;te6ccgECCwEAAkwAA7V+dMQlhJbnnmLgFMqWkRrL9csOKG/VXdb049pU5Bl931AAAAAAAAADdx7fDdz4W9u1NnBVF9To555bwxWhiXk8pjgn1OO6cR6wAAAAAAAAAzYPiDAAADRxN2doBQQBAg8MSMYbFBYEQAMCAG/Jh6EgTBRYQAAAAAAAAgAAAAAAAmHZXn3oj36iIsmePH9xls7+ruVE+XB4H24a  Attention! Contracts take value in nanotokens, so in this step we transfered 1 token.Bounce = true means that if the recipient does not exist, money will be returned back. If you plan to transfer money for deploy, specify Bounce = false! Again, now you can find this transaction in Explorer or GraphQL API. "},{"title":"What's next?​","type":1,"pageTitle":"Quick start","url":"develop/tools/everdev/guides/quick-start#whats-next","content":"If you want to migrate to Dev Network, read Working with DevNet guide.Also take a look at our blockchain basics page that will help you understand the core concepts of Everscale:)If you want to integrate your application with Everscale - dive into our SDK Quick Start!If you are an exchange - check out our exchange guide! If you have any difficulties/questions/suggestions/etc please write to telegram channel @everdev. "},{"title":"How to work with contracts","type":0,"sectionRef":"#","url":"develop/tools/everdev/guides/work-with-contracts","content":"How to work with contracts This article has TO DO status. You can contribute by submitting your own version of this page. More details on the Documentation page of the Hot streams section. The documentation in Everscale repository is a community effort. Therefore, everyone can contribute with proposals for new topics, suggest new content elements, participate in editing, and provide ideas that will be of great help for network development. Please be informed that our documentation can be edited via GitHub. Also please make sure to consult our rules and rewards policy via this link. Feel free to join Everscale Documentation Development Telegram chat and Everscale Developers Onboarding Telegram chat!","keywords":""},{"title":"How to work with Devnet","type":0,"sectionRef":"#","url":"develop/tools/everdev/guides/work-with-devnet","content":"","keywords":""},{"title":"Deploying your own Giver​","type":1,"pageTitle":"How to work with Devnet","url":"develop/tools/everdev/guides/work-with-devnet#deploying-your-own-giver","content":"In order to deploy the Giver, do the following steps, like for an ordinary contract: "},{"title":"Generate Giver keys​","type":1,"pageTitle":"How to work with Devnet","url":"develop/tools/everdev/guides/work-with-devnet#generate-giver-keys","content":"$ everdev signer generate devnet_giver_keys $ everdev s l Signer Public Key ----------------- ---------------------------------------------------------------- test (Default) de101cde5c94540926fe862e965cf109b1b803989e7048657cf7c4caaa2a257d devnet_giver_keys 5a343ccbd62c15e3df1076bc34957ad2717469d84e4d6b3ef26112db80ac8e1b  "},{"title":"Compile Giver code​","type":1,"pageTitle":"How to work with Devnet","url":"develop/tools/everdev/guides/work-with-devnet#compile-giver-code","content":"You can find compiled giver v2 contract with code here. You need to recompile code only if you want to change its code, so you can use compiled GiverV2.tvc file and move to the next step. Attention!The code in repo is not compatible with the latest Solidity compilers, so if you would like to compile it yourself, you would need to migrate code to the latest Solidity version first. After modifying code, compile it: $ everdev sol compile GiverV2.sol  In a case of success, compiler will generate two files: compiled code (GiverV2.tvc) and ABI (GiverV2.abi.json). You need these files for the next steps. "},{"title":"Calculate Giver address​","type":1,"pageTitle":"How to work with Devnet","url":"develop/tools/everdev/guides/work-with-devnet#calculate-giver-address","content":"In order to deploy contract, you need to know its address: $ everdev contract info -n dev -s devnet_giver_keys GiverV2.tvc Configuration Network: dev (net.ton.dev, net1.ton.dev, net5.ton.dev) Signer: devnet_giver_keys (public 5a343ccbd62c15e3df1076bc34957ad2717469d84e4d6b3ef26112db80ac8e1b) Address: 0:93139197f2f58d674bee4ee71a42d8f1e7b6a3c3e041ded7a54d330bcc44f3b3 (calculated from TVC and signer public) Code Hash: ccbfc821853aa641af3813ebd477e26818b51e4ca23e5f6d34509215aa7123d9 (from TVC file) Account: Doesn't exist  "},{"title":"Sponsor Giver with public faucet​","type":1,"pageTitle":"How to work with Devnet","url":"develop/tools/everdev/guides/work-with-devnet#sponsor-giver-with-public-faucet","content":"In the next step, you need to sponsor your Giver's address, which you have obtained in the previous step, with funds in order to be able to deploy a contract. The easiest way to do it on DevNet is to use EverGiver[DevNet] Telegram bot. It can give you 111 rubies maximum per address. If you need more, or in the case of a different test network, you can contact the owner of a particular network (for DevNet it is EverX). In EverGiver Telegram bot type (change Giver's address to the address obtained at previous step): /give 111 0:93139197f2f58d674bee4ee71a42d8f1e7b6a3c3e041ded7a54d330bcc44f3b3  Wait for operation completion. Check address balance in Blockchain Explorer. "},{"title":"Deploy Giver contract​","type":1,"pageTitle":"How to work with Devnet","url":"develop/tools/everdev/guides/work-with-devnet#deploy-giver-contract","content":"For contract deployment you need to have compiled contract files (GiverV2.tvc and GiverV2.abi.json) and giver keys. To deploy contract execute next command: $ everdev contract deploy -n dev -s devnet_giver_keys GiverV2.tvc Configuration Network: dev (eri01.net.everos.dev, rbx01.net.everos.dev, gra01.net.everos.dev) Signer: devnet_giver_keys (public 5a343ccbd62c15e3df1076bc34957ad2717469d84e4d6b3ef26112db80ac8e1b) Address: 0:93139197f2f58d674bee4ee71a42d8f1e7b6a3c3e041ded7a54d330bcc44f3b3 (calculated from TVC and signer public) Deploying... Contract has deployed at address: 0:93139197f2f58d674bee4ee71a42d8f1e7b6a3c3e041ded7a54d330bcc44f3b3  Done, now you have your own Giver, deployed to the DevNet! Let's configure everdev to use your Giver by default. "},{"title":"Configure everdev to use your Giver​","type":1,"pageTitle":"How to work with Devnet","url":"develop/tools/everdev/guides/work-with-devnet#configure-everdev-to-use-your-giver","content":"For convenience, you might need to configure everdev in order to use your Giver as default. To do it, execute the next command (change address to your Giver's address, obtained in previous steps): $ everdev network giver dev 0:93139197f2f58d674bee4ee71a42d8f1e7b6a3c3e041ded7a54d330bcc44f3b3 --signer devnet_giver_keys  Check: $ everdev n l Network Endpoints Giver ------------ ----------------------------------------------- ------------------------------------------------------------------ se (Default) http://localhost 0:b5e9240fc2d2f1ff8cbb1d1dee7fb7cae155e5f6320e585fcc685698994a19a5 GiverV2 dev eri01.net.everos.dev, rbx01.net.everos.dev, gra01.net.everos.dev 0:93139197f2f58d674bee4ee71a42d8f1e7b6a3c3e041ded7a54d330bcc44f3b3 GiverV2 signed by devnet_giver_keys main eri01.main.everos.dev, gra01.main.everos.dev, gra02.main.everos.dev ...  If Giver is set, you will see you Giver's address and keypair name for the dev network. "},{"title":"Testing your new Giver​","type":1,"pageTitle":"How to work with Devnet","url":"develop/tools/everdev/guides/work-with-devnet#testing-your-new-giver","content":"For testing your new Giver, try to top up any address, for example, one of the contract's addresses, which you need to deploy: $ everdev contract topup --network dev --address &lt;address&gt; --value 10000 Configuration Network: dev (eri01.net.everos.dev, rbx01.net.everos.dev, gra01.net.everos.dev) Signer: test (public de101cde5c94540926fe862e965cf109b1b803989e7048657cf7c4caaa2a257d) Address: &lt;address&gt; 0.00001 tokens (10000 nano) were sent to address &lt;address&gt;  "},{"title":"Use in JS Application","type":0,"sectionRef":"#","url":"develop/tools/everdev/js-application","content":"Use in JS Application This article has TO DO status. You can contribute by submitting your own version of this page. More details on the Documentation page of the Hot streams section. The documentation in Everscale repository is a community effort. Therefore, everyone can contribute with proposals for new topics, suggest new content elements, participate in editing, and provide ideas that will be of great help for network development. Please be informed that our documentation can be edited via GitHub. Also please make sure to consult our rules and rewards policy via this link. Feel free to join Everscale Documentation Development Telegram chat and Everscale Developers Onboarding Telegram chat!","keywords":""},{"title":"TestSuite4","type":0,"sectionRef":"#","url":"develop/tools/everdev/testsuite4","content":"TestSuite4 Via following this link you will get familiar with TestSuite4. It is a framework designed to simplify development and testing of Ever Contracts.","keywords":""},{"title":"Overview","type":0,"sectionRef":"#","url":"develop/tools/everdev/overview","content":"","keywords":""},{"title":"Quick Start​","type":1,"pageTitle":"Overview","url":"develop/tools/everdev/overview#quick-start","content":""},{"title":"What is EverDev?​","type":1,"pageTitle":"Overview","url":"develop/tools/everdev/overview#what-is-everdev","content":"EverDev is a Node.js package with a CLI interface that allows developers to perform from one interface the following use cases: "},{"title":"Use-cases​","type":1,"pageTitle":"Overview","url":"develop/tools/everdev/overview#use-cases","content":"Easily manage all core Ever OS Developer ToolsConfigure networks (including Local Blockchain, Developer Network, Everscale (main) network): add, configure giver;Manage keys: add, removeWork with Everscale blockchain from CLI Also, this project serves as a backend for the EverDev VS Code extension. "},{"title":"Evernode SE","type":0,"sectionRef":"#","url":"develop/tools/evernode-se","content":"Evernode SE Via following this link you will get familiar with Everscale Simple Emulator. It is a light-weight Evernode instance with GraphQL API. Importantly, it is a perfect suit for DApp and smart contract testing. The documentation in Everscale repository is a community effort. Therefore, everyone can contribute with proposals for new topics, suggest new content elements, participate in editing, and provide ideas that will be of great help for network development. Please be informed that our documentation can be edited via GitHub. Also please make sure to consult our rules and rewards policy via this link. Feel free to join Everscale Documentation Development Telegram chat and Everscale Developers Onboarding Telegram chat!","keywords":""},{"title":"EverDev Troubleshooting","type":0,"sectionRef":"#","url":"develop/tools/everdev/troubleshooting","content":"","keywords":""},{"title":"EACCESS errors during installation​","type":1,"pageTitle":"EverDev Troubleshooting","url":"develop/tools/everdev/troubleshooting#eaccess-errors-during-installation","content":"These errors can occur, if npm was installed without the use of a version manager. Refer to this article for ways to resolve the issue. "},{"title":"command not found: everdev​","type":1,"pageTitle":"EverDev Troubleshooting","url":"develop/tools/everdev/troubleshooting#command-not-found-everdev","content":"This error may happen because PATH environment variable was not correctly updated to contain path to Node.js binary. If you use Linux, ensure the following command is in your ~/.bashrc for bash shell or ~/.zshrc for zsh shell: export PATH=~/.npm-global/bin:$PATH  If you have installed Node.js using Homebrew on MacOS, npm binaries could be found in /usr/local/share/npm/bin. So, in your ~/.zshrc file add the following: export PATH=/usr/local/share/npm/bin:$PATH  If you use Windows, add path to NodeJS bin directory via environment variables settings dialogue and relaunch console window. Additionally, make sure permissions are alright. "},{"title":"Unspecified Error on everdev sol compile in Windows 10​","type":1,"pageTitle":"EverDev Troubleshooting","url":"develop/tools/everdev/troubleshooting#unspecified-error-on-everdev-sol-compile-in-windows-10","content":"1) Run \\Users\\UserName\\everdev\\solidity\\solc.exe and review error messages. 2) Update Visual Studio components and make sure vc_redist is installed. "},{"title":"TON OS SE: Couldn’t connect to Docker daemon​","type":1,"pageTitle":"EverDev Troubleshooting","url":"develop/tools/everdev/troubleshooting#ton-os-se-couldnt-connect-to-docker-daemon","content":"This error occurs in two cases. Either the docker daemon isn't running, or current user doesn't have rights to access docker. You can fix the rights issue either by running relevant commands as the superuser or adding the user to the docker group: sudo usermod -a -G docker $USER  Make sure to restart the system or log out and back in, for the new group settings to take effect. "},{"title":"After everdev is installed on Ubuntu WSL on Windows 10 old version is there​","type":1,"pageTitle":"EverDev Troubleshooting","url":"develop/tools/everdev/troubleshooting#after-everdev-is-installed-on-ubuntu-wsl-on-windows-10-old-version-is-there","content":"This issue can occur if npm was installed without correct permissions for Linux/Ubuntu. Refer to this article for ways to resolve it. After it is done, reload terminal and install everdev via `npm i everdev -g' again. "},{"title":"Locklift","type":0,"sectionRef":"#","url":"develop/tools/locklift","content":"Locklift Via following this link you will get familiar with Locklift. It is a development environment aiming to help you with Ever contracts development. The documentation in Everscale repository is a community effort. Therefore, everyone can contribute with proposals for new topics, suggest new content elements, participate in editing, and provide ideas that will be of great help for network development. Please be informed that our documentation can be edited via GitHub. Also please make sure to consult our rules and rewards policy via this link. Feel free to join Everscale Documentation Development Telegram chat and Everscale Developers Onboarding Telegram chat!","keywords":""},{"title":"Overview","type":0,"sectionRef":"#","url":"develop/tools/overview","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Overview","url":"develop/tools/overview#introduction","content":"Before you start developing or integrating anything into Everscale, we would like to tell you about the tools and environment that you will use in your work. First of all, it is worth noting that Everscale is really a decentralized blockchain, not only from a technical point of view, but also from a management side, so the key tools and approaches to development may differ from different teams, technical contributors on the network. At the moment, there are two active companies of technical contributors in Everscale network: EverX Broxus And it is their solutions and tools that you will use when developing, while you will have every opportunity to write your own solutions as well, if necessary or desired. "},{"title":"Tools​","type":1,"pageTitle":"Overview","url":"develop/tools/overview#tools","content":""},{"title":"Set up Development Environment​","type":1,"pageTitle":"Overview","url":"develop/tools/overview#set-up-development-environment","content":"everdev(by EverX) - CLI tool and Javascript package that helps set up all the core developer tools and work with Everscale blockchain from a single interface "},{"title":"Interaction with blockchain​","type":1,"pageTitle":"Overview","url":"develop/tools/overview#interaction-with-blockchain","content":"TONOS CLI(by EverX) - is a multi-platform command line interface for Ever OS. It allows you to work with keys and seed phrases, deploy contracts, call any of their methods, generate and broadcast messages. It supports specific commands for DeBot(текст-ссылка на страницу DeBot), DePools(текст-ссылка на страницу DePools в Validate) and Multisig contracts, as well as a number of supplementary functions. "},{"title":"Tools for contract developers:​","type":1,"pageTitle":"Overview","url":"develop/tools/overview#tools-for-contract-developers","content":"everdev(by EverX) - helps manage keys and networks and local testing blockchain, and compile, deploy and call contracts from CLI or from Javascript with a convenient API. Evernode-SE - local blockchain for contract and Dapp testing, exposing GraphQL API. Can be managed from everdev. Locklift(by Broxus) - development environment, analogous to Hardhat. TestSuite4(by EverX) - a framework designed to simplify development and testing of Everscale Contracts. It contains a lightweight blockchain emulator making it easy to develop contracts in a TDD-friendly style. Ever.bytie.moe(by Broxus) - smart contracts interaction playground. "},{"title":"TVM Linker","type":0,"sectionRef":"#","url":"develop/tools/tvm-linker","content":"TVM Linker Via following this link you will get familiar with Contract management in everdev. It gives you the ability to easily deploy and run your smart contracts on blockchain network(s). The documentation in Everscale repository is a community effort. Therefore, everyone can contribute with proposals for new topics, suggest new content elements, participate in editing, and provide ideas that will be of great help for network development. Please be informed that our documentation can be edited via GitHub. Also please make sure to consult our rules and rewards policy via this link. Feel free to join Everscale Documentation Development Telegram chat and Everscale Developers Onboarding Telegram chat!","keywords":""},{"title":"Getting started","type":0,"sectionRef":"#","url":"develop/tutorial/getting-started","content":"","keywords":""},{"title":"Overview​","type":1,"pageTitle":"Getting started","url":"develop/tutorial/getting-started#overview","content":"This page will give you an insight into how to choose development tools and approaches for building decentralised applications with the help of Everscale. Attention! Before you read this article, we recommend that you study the Everscale Overview section and the block of pages in the Architecture section if you want to develop complex products on the Everscale blockchain. "},{"title":"Let's start​","type":1,"pageTitle":"Getting started","url":"develop/tutorial/getting-started#lets-start","content":"Before you start developing or integrating anything into Everscale, we would like to tell you about the tools that you will use in your work. First of all, it is worth noting that Everscale is really a decentralized blockchain, both from the technical point of view, and the way it is managed. Thus, for the purpose of achieving its outstanding functionality, Everscale is supplied with key tools and development approaches from different leading technological providers. At the moment, there are two active technological providers: BroxusEverX It is their solutions and tools that you will use when developing, while you will have every opportunity to write your own solutions as well, if necessary or desired. You can learn more in the Development tools section. "},{"title":"Ways to dive into development on Everscale for any case you need​","type":1,"pageTitle":"Getting started","url":"develop/tutorial/getting-started#ways-to-dive-into-development-on-everscale-for-any-case-you-need","content":"We assume that there are several main cases of developers interacting with Everscale: Build your dApp - knowledge of network architecture, understanding of smart contracts, standards and node devices will be useful to you. Learn the network architectureLearn the standardsLearn the development toolsLearn the specifics of writing smart contracts Learn how to issue tokens Explore the development team incentive programs in Everscale Migrate your dApp from another network Learn the network architectureLearn the comparison with EthereumLearn the development toolsLearn how to write contracts on Solidity Integrate Everscale blockchain in your on-chain or off-chain project - you will find it helpful to explore the Everscale Overview page as well as the Architecture page. Afterwards, please follow the Getting Started page in the Integrate section. Learn Everscale Overview sectionLearn how to integrate anyting with Everscale.Learn the development toolsLearn popular integration cases (exchange integration) "},{"title":"Other useful links​","type":1,"pageTitle":"Getting started","url":"develop/tutorial/getting-started#other-useful-links","content":"Join onboarding chat for developersExplore helpful development articlesLearn developer tools "},{"title":"DeBot Consortium","type":0,"sectionRef":"#","url":"learn/decentralization/debot-consortium","content":"","keywords":""},{"title":"DeBot-IS-consortium​","type":1,"pageTitle":"DeBot Consortium","url":"learn/decentralization/debot-consortium#debot-is-consortium","content":"DeBot Interface Specifications (IS) Consortium. IS a place where community defines interfaces every DeBot browser should support. DeBot-IS-consortium repository "},{"title":"Application Rules:​","type":1,"pageTitle":"DeBot Consortium","url":"learn/decentralization/debot-consortium#application-rules","content":"Each new interface must create a folder, which has a readme.md desciption of an interface, example of its implementaion in both Solidity and C++ placed in an &quot;examples&quot; sub folder. "},{"title":"Interface submission proccess:​","type":1,"pageTitle":"DeBot Consortium","url":"learn/decentralization/debot-consortium#interface-submission-proccess","content":"You should create a specifications proposal, discuss it.After the discussion is over and proposal is accepted you should submit examples in both Solidity and C++.Only proposals with examples will be published. "},{"title":"Supported browsers:​","type":1,"pageTitle":"DeBot Consortium","url":"learn/decentralization/debot-consortium#supported-browsers","content":"If you implemented a DeBot browser we will be happy to list it. Please let us know.Your browser should clearly state interfaces which it supports (by version number as stated in repository). "},{"title":"DeBot Specifications","type":0,"sectionRef":"#","url":"learn/decentralization/debot-specifications","content":"","keywords":""},{"title":"Objective​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#objective","content":"Provide a secure and convenient environment to work with smart-contracts emulate calling smart-contract functions locally on the client;debug blockchain transactions;interact with smart-contracts deployed in the blockchain. "},{"title":"Basic terms​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#basic-terms","content":"DeBot — a smart contract facilitating conversation-like flow communication with a target smart contract;Target smart contract — a smart contract for which DeBot is created. DeBot is an interface to this smart contract;DeBot protocol — a set of rules describing the communication between browser and DeBot: how to call DeBot functions and how to interpret its answers;DeBot engine (DEngine) — a program component that executes DeBot and parses its answer using DeBot protocol;DeBot browser — a program, which creates instances of DEngine for executed DeBot and renders the user interface. "},{"title":"Architecture​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#architecture","content":" DeBot platform consists of the following elements: DeBot smart contract;DeBot browser;Target smart contract(s). One target smart contract can have several DeBot and vise versa. DeBot is deployed to the blockchain. DeBot browser runs on client. It downloads DeBot code and runs it inside the DEngine. "},{"title":"Proof of State​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#proof-of-state","content":"Transactions can be verified by running DeBot locally and comparing the result of execution to the account state in the blockchain. "},{"title":"DeBot Interfaces​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#debot-interfaces","content":""},{"title":"Motivation​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#motivation","content":"DeBot is a smart contract and smart contracts are isolated from each other and from the blockchain, their capabilities are limited by the commands of the virtual machine on which they are executed. But DeBot must have more possibilities. DeBot need to: receive input from users;query info about other smart contracts;query transactions and messages;receive data from external subsystems (like file system) and external devices (like NFC, camera and so on);call external function libraries that allow to do operations that are not supported by VM. For example, work with json, convert numbers to string and vice versa, encrypt/decrypt/sign data. To cover all these needs we should design different DeBot Interfaces (DInterfaces) which can be used in DeBot and which must be supported in DeBot Browsers. These interfaces should match the requirements: comprehensive — interfaces should describe all types of communication accessible on modern devices;universal — interfaces should be abstract from certain OS and hardware;atomic — every communication channel should be separately described in the interface for further flexible resource access management;convenient — even low-skilled developers should be able to use this interface in their DeBot. In this model DeBot Engine should act like a proxy between DeBot Browser and DeBot. But it can have builtin implementation of very basic DInterfaces (e.g. working with json). Also, we need to describe the manifest for DeBot. DeBot developer will describe all needed interfaces in this manifest and the DeBot Browser will check it before running DeBot. We need this manifest to keep users secure and private when using DeBot. "},{"title":"Description​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#description","content":"Every DeBot must declare which DInterfaces it will use. For this purpose it must have getRequiredInterfaces() function which returns array of required interfaces. Every interface must have an id which is an unsigned 256-bit integer and an address which is used in DeBot as a destination address of internal messages. Address must be a standard Everscale address consisting of DEBOT_WC (equal to 0xDB) as a workchain_id part and interface id as address part (see &quot;Telegram Open Network Blockchain&quot;specification, section 3.1.2 for details about TL-B scheme for address). For example, in solidity getRequiredInterfaces can be implemented like this: // Base contract for all DeBot abstract contract Debot { i32 constant DEBOT_WC = - 31; function getRequiredInterfaces() virtual returns (uint256[] interfaces); } contract DebotA is Debot { function getRequiredInterfaces() override returns (uint256[] interfaces) { return [ID_TERMINAL, ID_MENU, ...]; } }  "},{"title":"How to use DInterface in DeBot​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#how-to-use-dinterface-in-debot","content":"To use an interface DeBot should import source file with DInterface declaration and call its methods as any other smart contract methods in Everscale — by sending internal messages to interface address. Before running the DeBot, DeBot Browser should provide callbacks for DEngine to receive all requests to DInterfaces. Requests are packed into internal messages. When Browser receives a message from DEngine it should unpack the message, decode its body, call DInterface function, pack results to internal message and return it to DEngine using Dengine.send(msg). interface BrowserCallbacks { // Message from Debot to Browser with encoded DInterface call send(message: string): Promise&lt;void&gt; // Request from DEngine to approve some action (for example, send mesage to blockchain) approve(action: {}): boolean // Request from DeBot to call another DeBot invoke(debotAddress: string, message: string): Promise&lt;void&gt; }  "},{"title":"DeBot Start​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#debot-start","content":"Befor starting DeBot should also provide metadata, which includes its name, version, authorship information, description, language and ABI. This is accomplished through the getDebotInfo() mandatory function. Along with getRequiredInterfaces() this function is defined in the base contract Debot.sol. // Base contract for all DeBots abstract contract Debot { /// @notice ACTION structure struct Action { // String that describes action step, should be printed to user string desc; // Name of debot function that runs this action string name; // Action type uint8 actionType; // Action attributes. // Syntax: &quot;attr1,attr2,attr3=value,...&quot;. // Example: &quot;instant,fargs=fooFunc,sign=by-user,func=foo&quot; string attrs; // Context to transit to uint8 to; // Action internal data TvmCell misc; } struct Context { uint8 id; // Context ordinal string desc; // message to be printed to the user Action[] actions; // list of actions } string s_dabi; /* * Public debot interface */ /// @notice Returns list of interfaces used by DeBot. function getRequiredInterfaces() public view virtual returns (uint256[] interfaces); /// @notice Used for error handling for external messages if error code &gt;= 400 (TVM) and &lt; 500 (PROCESSING) function getErrorDescription(uint32 error) public pure virtual returns (string desc); /// @notice Invoked by DeBot Browser at debot startup. Returns array of debot contexts. function fetch() public virtual returns (Context[] contexts); /// @notice DeBot entry point. function start() public virtual; /// @notice Returns DeBot metadata. /// @return name String with name of debot, e.g. &quot;DePool&quot;. /// @return version Semver version of debot, that will be converted to string like &quot;x.y.z&quot;. /// @return publisher String with info about who has deployed debot to blokchain, e.g. &quot;TON Labs&quot;. /// @return caption (10-20 ch.) String with short description, e.g. &quot;Work with Smthg&quot;. /// @return author String with name of author of DeBot, e.g. &quot;Ivan Ivanov&quot;. /// @return support Everscale address of author for questions and donations. /// @return hello String with first messsage with DeBot description. /// @return language (ISO-639) String with debot interface language, e.g. &quot;en&quot;. /// @return dabi String with debot ABI. function getDebotInfo() public functionID(0xDEB) view virtual returns( string name, string version, string publisher, string caption, string author, address support, string hello, string language, string dabi, bytes icon ); /// @notice Allow to set debot ABI. Do it before using debot. function setABI(string dabi) public { require(tvm.pubkey() == msg.pubkey(), 100); tvm.accept(); s_dabi = dabi; } /// @notice Returns DeBot ABI. /// @dev Deprecated. Remove later. https://github.com/tonlabs/TON-SDK/blob/dc0631a726295c4e7190361c417214c301ec4e01/ton_client/src/debot/dengine.rs#L175 function getDebotOptions() public view returns ( uint8 options, string debotAbi, string targetAbi, address targetAddr ) { debotAbi = s_dabi; targetAbi = &quot;&quot;; targetAddr = address(0); options = 1; } } contract MyDeBot is Debot { function getErrorDescription(uint32 error) public pure override returns (string desc) { tvm.log(format(&quot;getErrorDescription: {}&quot;, error)); desc = format(&quot;some description about code {}&quot;, error); // TODO description error codes } function fetch() public override returns (Context[] contexts) { tvm.log(&quot;fetch&quot;); // TODO fetch Context } function start() public override { tvm.log(&quot;start&quot;); // TODO start } function getDebotInfo() public functionID(0xDEB) view override returns( string name, string version, string publisher, string caption, string author, address support, string hello, string language, string dabi, bytes icon ) { tvm.log(&quot;getDebotInfo&quot;); name = &quot;MyDeBot&quot;; version = &quot;1.0.0-alpha.0&quot;; publisher = &quot;Everscale&quot;; caption = &quot;My first DeBot&quot;; author = &quot;Everscale&quot;; support = address.makeAddrStd(0, 0x0); hello = &quot;Hello first user!&quot;; language = &quot;en&quot;; dabi = s_dabi; icon = &quot;&quot;; } function getRequiredInterfaces() public view override returns (uint256[] interfaces) { tvm.log(&quot;getRequiredInterfaces&quot;); // TODO add dependency interfaces } }  Run debug log: npx tonos-cli debot --debug fetch &lt;ADDRESS&gt; 19:43:58 [DEBUG] (1) ton_client::debot::dengine: running getRequiredInterfaces, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:43:58 [INFO] getRequiredInterfaces 19:43:58 [DEBUG] (1) ton_client::debot::dengine: running getDebotInfo, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:43:58 [INFO] getDebotInfo 19:43:58 [DEBUG] (1) ton_client::debot::dengine: run_debot_external getDebotOptions, args: {} 19:43:58 [DEBUG] (1) ton_client::debot::dengine: running getDebotOptions, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:43:58 [DEBUG] (1) ton_client::debot::dengine: run_debot_external fetch, args: {} 19:43:58 [DEBUG] (1) ton_client::debot::dengine: running fetch, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:43:58 [INFO] fetch DeBot Info: Name : MyDeBot Version: 1.0.0-alpha.0 Author : Everscale Publisher: Everscale Support: 0:0000000000000000000000000000000000000000000000000000000000000000 Description: My first DeBot Hello first user! Run the DeBot (y/n)? y 19:44:02 [DEBUG] (1) ton_client::debot::dengine: running getRequiredInterfaces, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:44:02 [INFO] getRequiredInterfaces 19:44:02 [DEBUG] (1) ton_client::debot::dengine: running getDebotInfo, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:44:02 [INFO] getDebotInfo 19:44:02 [DEBUG] (1) ton_client::debot::dengine: run_debot_external getDebotOptions, args: {} 19:44:02 [DEBUG] (1) ton_client::debot::dengine: running getDebotOptions, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:44:02 [DEBUG] (1) ton_client::debot::dengine: run_debot_external fetch, args: {} 19:44:02 [DEBUG] (1) ton_client::debot::dengine: running fetch, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:44:02 [INFO] fetch 19:44:02 [DEBUG] (1) ton_client::debot::dengine: switching to 0 19:44:02 [DEBUG] (1) tonos_cli::debot::callbacks: switched to ctx 0 19:44:02 [DEBUG] (1) ton_client::debot::dengine: run_action: start 19:44:02 [DEBUG] (1) ton_client::debot::dengine: run_debot_external start, args: {} 19:44:02 [DEBUG] (1) ton_client::debot::dengine: running start, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:44:02 [INFO] start 19:44:02 [DEBUG] (1) ton_client::debot::dengine: instant_switch = false, state_to = 0 19:44:02 [DEBUG] (1) tonos_cli::debot::callbacks: no more actions, exit loop  Before starting the DeBot, DeBot Browser creates new instance of DEngine with address of DeBot;DEngine downloads DeBot state, queries metadata and list of DInterfaces required by DeBot and returns the list to Browser;Browser must check that it supports all required DInterfaces. If one of interfaces is not supported, Browser must report error to the user (application) and not start the DeBot otherwise Browser must list requested interfaces to user (application);All required interfaces should be approved by user (application);After the list of interfaces is approved, the DeBot Browser starts DeBot using Dengine.start(callback). On every interface call Browser should check permission for DeBot and on success execute it according to isolation requirement if needed. Below you can see DeBot start sequence:  "},{"title":"DInterface specification​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#dinterface-specification","content":"Every DInterface must be discussed and accepted by DeBot Interface Specifications (DIS) Consortium before it can be used in DeBot. All accepted interfaces are published in DeBot Interface Specifications Consortium. Everybody can suggest new DInterface. Go to repo and follow the instructions. "},{"title":"DInterfaces support in DeBot Browser​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#dinterfaces-support-in-debot-browser","content":"DeBot Browser can support and implement any or all DInterfaces published in DIS repo depending on browser's capabilities. For example, console browser cannot support external devices like camera, NFC, microphone and so on. Some interfaces required for basic DeBot operation are built into the DEngine itself (SDK, Hex, JsonDeserialize). They are marked as such in their respective readme files in the DeBot Interface Specifications Consortium. "},{"title":"DEngine versioning​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#dengine-versioning","content":"DEngine as a SDK module should have a version of SDK itself. DIS statuses: Proposed, Accepted, Published. "},{"title":"Example of DInterface​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#example-of-dinterface","content":"Name\tIDRawInput\t8796536366ee21852db56dccb60bc564598b618c865fc50c8b1ab740bba128e3 "},{"title":"Description​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#description-1","content":"Allows to get string from user "},{"title":"Functions​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#functions","content":"Function input arguments: answerId: uint32 — function id of result callbackprompt: bytes — string printed to the user and describing what to enter returns: text: bytes — string entered by user "},{"title":"Declaration in Solidity​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#declaration-in-solidity","content":"interface IRawInput { function input(uint32 answerId, string prompt) external returns (string value); } Library RawInput { uint256 constant ID_RAWINPUT = 0x8796536366ee21852db56dccb60bc564598b618c865fc50c8b1ab740bba128e3 // Callback Function Prototype function inputResult(uint32 answerId, string prompt) public { address addr = address.makeAddrStd(DEBOT_WC, ID_RAWINPUT); IRawInput(addr).input(answerId, prompt); } }  "},{"title":"Declaration in C++​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#declaration-in-c","content":"namespace tvm { namespace schema { __interface IRawInput { [[internal, answer_id]] string input(string prompt); };  "},{"title":"Code Example​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#code-example","content":"Solidity​ pragma solidity &gt;=0.6.0; import &quot;Debot.sol&quot;; import &quot;RawInput.sol&quot;; contract ExampleDebot is Debot, RawInput { function start() public { RawInput.input(tvm.functionId(inputResult), &quot;enter your name:&quot;); RawInput.input(tvm.functionId(inputResult), &quot;enter your wallet address:&quot;); } function inputResult(string text) public override { require(text == &quot;Debot&quot;); } }  Note: C++ DeBot are currently in the state of early development, and not all features all completely defined for them yet. "},{"title":"DeBot Special Features​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#debot-special-features","content":"DeBot have 3 special features: calling — get-methods of target smart contracts;calling — external functions of target smart contracts onchain;invoking — other DeBot in a local environment. Ordinary Everscale smart contracts cannot use 1st and 2nd features because they cannot produce external inbound messages. But DeBot can, due to the fact that they are executed in DEngine, that allows DeBot to generate these kinds of messages, send them to blockchain and return results to DeBot. In terms of DeBot, all these features are implemented without DInterfaces but in a native way, like two smart contracts communicating with each other — by sending messages directly to target address. But with only one difference — to call a get-method or call a function onchain DeBot must generate external inbound message, while to invoke another DeBot, it should generate an internal message to the invoked DeBot address. DEngine distinguishes between get-methods and onchain calls by examining the sign header of the message. Signed messages (sign: true) are considered onchain calls, while unsigned messages (sign: false) are considered to be get-method calls. "},{"title":"Get-methods​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#get-methods","content":"Developer Example​ Solidity function showTasks(uint32 index) public view { index = index; optional(uint256) none; ITodo(m_address).getTasks{ abiVer: 2, extMsg: true, sign: false, pubkey: none, time: uint64(now), expire: 0, callbackId: tvm.functionId(showTasks_), onErrorId: tvm.functionId(onError) }(); }  Support in DEngine​ DEngine executes DeBot and checks if it produces external inbound messages. If yes, then DEngine analyzes each message by scanning signature and public key bits in message body to understand if message is for get-method call. If bits are zero DEngine downloads target contract and runs its get-method, then returns results to DeBot by calling its function set in the callbackId or onErrorId (in case of errors) headers of message body. "},{"title":"Onchain function call​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#onchain-function-call","content":"Developer example​ Solidity IMsig(m_msigAddress).sendTransaction{ abiVer: 2, extMsg: true, sign: true, pubkey: pubkey, time: uint64(now), expire: 0, callbackId: tvm.functionId(waitBeforeDeploy), onErrorId: tvm.functionId(onErrorRepeatCredit) }(m_address, INITIAL_BALANCE, false, 3, empty); }  Support in DEngine​ DEngine executes DeBot and checks if it produces external inbound messages. If there is one, DEngine analyzes if it is onchain call by scanning signature and public key bits in message body. If signature bit is 1 then DEngine does the following things. Downloads target smart contract, signs the message and emulates its transaction locally;Checks if transaction produces outbound internal messages with funds;Requests permission from DeBot Browser to send this message onchain. Request contains information about funds that will be spent if message will be executed onchain and message itself;If DeBot Browser allows to send message, DEngine sends message to blockchain. "},{"title":"Invoking DeBot​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#invoking-debot","content":"DeBot can call another DeBot by simply sending internal message to it. After DeBot execution DEngine filters all internal messages produced by DeBot with destination addresses with workchain 0. This filter allows to separate DInterface calls (which have 0xDB workchain id) from DeBot invokes. If there are invoke messages, DEngine sends them to Browser through BrowserCallbacks interface. Browser (or user) has to approve the invoke of a new DeBot, at which point Browser creates a new DEngine instance, downloads target DeBot and transfers the message to it. Browsers should generally support a common queue for messages from several DeBot. "},{"title":"Security notes​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#security-notes","content":"At start browser creates a DEngine instance, and receives DeBot metadata and list of required DInterfaces through DEngine, and checks them for compatibility and security. When DeBot is running, DEngine proxies all DInterface calls (except calls to builtin interfaces supported by engine itself like SDK calls) directly to Browser which must decide to execute or reject them. Get-method calls are always allowed. Executed by DEngine. External function calls must be approved by Browser. Executed by DEngine. Other DeBot calls are always allowed. But executed by Browser which can block invoke if needed. "},{"title":"DePool Specifications","type":0,"sectionRef":"#","url":"learn/decentralization/depool-specifications","content":"","keywords":""},{"title":"Background​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#background","content":"It is quite evident that to achieve high-performance properties, a network needs powerful, reliable servers with fast connectivity. At the same time, to achieve sufficient decentralization, these servers have to belong to as many owners as possible. There seems to be a contradiction between these goals. In Proof-of-Work networks, performance is often sacrificed for decentralization. Yet, claims arise that the centralization of Bitcoin, Ethereum etc. mining power is not entirely prevented. Mining Pools centralization remains an issue, as these pools are controlled by particular entities distributing rewards. For example, almost 60% of Bitcoin mining power is concentrated in just 4 pools and around 80% of all mining power originates in China. Just 2 mining pools control 52% of Ethereum hashrate, more than 50% of which originates in China. In Proof-of-Stake, the correlation between network performance and concentration of power (money in this case) is even more apparent, as one does not need to buy, set up, and manage complicated mining farms. It can ultimately be claimed that POS is trading performance for decentralization (look no further than EOS centralization, Steemit network overtaking etc.). It seems that enabling small token holders to participate in network governance is a very important decentralization property. "},{"title":"Motivation​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#motivation","content":"Everscale blockchain needs all newly created blocks to be validated in order to run correctly. For this it relies on special designated nodes called &quot;Validators&quot;, and offers substantial reward for their work. However, becoming a validator requires a substantial cryptocurrency deposit. The required amount might far exceed an individual validator budget. On the other hand, blockchain users with no validating system might be interested in investing in validation duty. This is where the Decentralized Pool (DePool) smart contract comes in. There are two main use cases of DePool: User has no Validator capabilities but some free funds. User can support a third-party Validator and receive rewards.User has Validator capabilities and but doesn't have necessary amount of funds to participate in validator elections and subsequent rewards. "},{"title":"Basic terms​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#basic-terms","content":"DePool — a smart contract that allows other smart contracts to invest stakes into a common pool of funds and after some period of time to receive it back with interest.Elector — a system level smart contract, deployed to masterchain from zero state. Runs validator elections periodically.DePool Proxy (proxy) — a smart contract that delivers messages between DePool and Elector.Participant — a smart contract that invests funds into DePool.Validator — software running blockchain node. Each DePool works with one node only. This node must be a DePool participant.Validator wallet — a smart contract that is used by Validator to send election requests to DePool and receive the Validator reward. Validator wallet should be a Multisig contract with 3 custodians.DePool Helper — a smart contract that stores the address of the actual DePool and works with the Timer contract.Global Validators Set (GVS) — current set of validators chosen in the latest elections.Validation period — period of time for which GVS is elected.Investment round — period of time between Participant investing a stake in DePool and receiving it back (with or without interest).Timer — a smart contract that can call other smart contracts periodically. "},{"title":"Architecture​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#architecture","content":" DePool is designed to receive investment stakes from Participants, allocate the pool funds to a validator in order to participate in elections of the GVS and, after the end of the validation cycle, distribute stakes with certain rewards back to the Participants.DePool is deployed to basechain. But it cannot communicate with Elector directly, because Elector rejects messages from non-masterchain contracts. Thus there are DePool proxies that are deployed to masterchain and deliver messages from DePool to Elector and back. This is done, because DePool is a large and complex contract, and gas and storage fees are 10 times lower in basechain compared to masterchain. Keeping DePool on masterchain would be unreasonably expensive.DePool is open for Participants’ stakes at all times, however, there is a deadline for participation in the upcoming elections. The deadline depends on the timer of the Elector. After the deadline, the incoming stakes will be accumulated for participation in the next elections.DePool distinguishes stakes received before the deadline and after the deadline, therefore it stores information on Participant stakes in separate investment rounds (or rounds), one for every elections, to facilitate subsequent distribution of stakes and rewards. To separate Elector communication, DePool uses 2 proxies: one for even rounds, one for odd.In order to be time-aware, the DePool should be called from time to time. For this purpose the Timer contract is used. DePool Helper asks Timer to call it periodically and transmits every call from Timer to DePool. Interval between calls is chosen according to the elections interval.DePool must be linked to a validator wallet to participate in elections on behalf of the latter. This validator wallet address is specified during DePool deployment and cannot be changed afterwards. When elections start, DePool waits for signed election requests from linked wallet, then attaches round stake to request and transmits it to Elector.Validator can validate many DePools with 1 Validator wallet. Reputation of Validator wallet therefore is available and can be analyzed over time.To ensure that the validator will perform its functions correctly (be always online and not &quot;lie&quot; to other validators), the validator wallet must itself become a Participant and invest in every investment round at least m_validatorAssurance, which is initialized in DePool constructor. This can be achieved with any of the three available types of stakes.When Elector unfreezes validator stakes, DePool returns its stake back with round rewards. Part of the total reward is used to top up the DePool's own balance to a certain value. The rest is distributed as follows: m_validatorRewardFraction% goes to Validator wallet balance. m_participantRewardFraction% is distributed among all Participants in investment round (validator is also participant). m_associationRewardFraction% (can be equal to zero) goes to m_association address.DePool keeps a balance for each Participant and can automatically reinvest Participant's stake into the next investment round if appropriate flag is enabled.Participant can transfer part of its total stake to another Participant's stake inside DePool storage. This function allows for collateralization of the stake to provide liquidity to stake holders. "},{"title":"Special kinds of stakes​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#special-kinds-of-stakes","content":"Along with the basic ordinary stake, that functions according to the rules detailed above, there are 2 types of special stakes: vesting and lock stake. While the entire ordinary stake is invested into the current pooling round (and will thus be reinvested every second round), lock and vesting stakes are split into two equal parts upon reception, which are invested into the current pooling round, and the next round. This way they can be continuously reinvested into both odd and even rounds. "},{"title":"Vesting Stake​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#vesting-stake","content":"Any address can make a vesting stake and define a target participant address (beneficiary) who will own this stake. But not the whole stake is available to the beneficiary at once. Instead it is split into logical parts and the next part of stake becomes available to the participant only when next vesting period is ended. At completion step of every round DePool decides how many vesting parts should be unlocked and subtracted from vesting stake and become available to owner since last unlocking. These funds are added to beneficiary's ordinary stake. Example: address A makes a vesting stake of 120 tons for 1 year with vesting period of 1 month and defines address B as the stake beneficiary. It means that after 1 month 10 tons become available to address B and 110 tons are still locked in the pool. After 1 year vesting stake will be equal to 0 and last 10 tons will become available to owner. Vesting for validator beneficiaries is subject to additional rules: At the end of every withdrawal period, the part of the vesting stake to be released is divided proportionally into 2 parts — for rounds in this period when DePool successfully completed validation and received a reward (without slashing) and for rounds when DePool missed elections or was slashed. The portion of the stake corresponding to the successful rounds is sent to the validator, while the portion corresponding to the failed rounds is returned to the vesting stake owner. For example, if there were 100 rounds within the withdrawal period, and DePool successfully completed 80 of them, missed elections in 5 more and was slashed in the remaining 15, the validator will receive 80% of the unlocked part of the vesting stake, and the stake owner will get back 20% of it. "},{"title":"Lock Stake​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#lock-stake","content":"Any address can make a lock stake, in which it locks its funds in DePool for a defined period, but rewards from this stake will be payed to another target participant (beneficiary). At the end of a period the Lock Stake should be returned to the address which locked it. Example: address A makes a lock stake of 120 tons for 1 year with vesting period of 1 month and defines address B as the stake beneficiary. It means that after 1 month 10 tons become available to address A (as opposed to vesting, where these 10 tons would become available to address B, the beneficiary) and 110 tons are still locked in round. DePool will reinvest the gradually diminishing lock stake for a 1 year and pay rewards to B address. After 1 year DePool will return the remainder of the lock stake to address A. One Participant can be a beneficiary only of one lock and one vesting stake. Once current lock or vesting stake of the participant expires, it can be repeated. When a stake of either of these types is created, it is split equally into two last rounds, which means that the minimal value for such stake is 2 * minStake + fee. "},{"title":"Specification​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#specification","content":""},{"title":"Data Structures​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#data-structures","content":"DePool contract uses library and inheritance from several simple base contacts to separate functionality and facilitate development and debugging of the contract. The core data set stored by DePool is the following: DePoolLib.sol // Describes contract who deposit stakes in DePool pool struct Participant { // Count of rounds in which participant takes a part uint8 roundQty; // Sum of all rewards from completed rounds (for logging) uint64 reward; // count of parts of vesting stakes in the rounds uint8 vestingParts; // count of parts of lock stakes in the rounds uint8 lockParts; // Flag whether to reinvest ordinary stakes and rewards bool reinvest; // Target tons that will be transferred to participant after rounds are completed // After each round this value is decreased uint64 withdrawValue; } // Request for elections from validator wallet. struct Request { // Random query id. uint64 queryId; // Validator's public key that will be used as validator key if validator will win elections. uint256 validatorKey; // current election id. uint32 stakeAt; // Validator's stake factor. uint32 maxFactor; // Validator's address in adnl overlay network. uint256 adnlAddr; // Ed25519 signature of above values. bytes signature; }  DePoolRounds.sol // roundPre0 = m_rounds[m_roundQty - 1] — pre-pooling. Helper round for adding vesting and lock // stakes. When vesting/lock stake is added than stake is // split into two part. And first part invested into pooling // round and second part — pre-pooling. // // round0 = m_rounds[m_roundQty - 2] — pooling // round1 = m_rounds[m_roundQty - 3] — election or validation // round2 = m_rounds[m_roundQty - 4] — validation or investigation // Algo of round rotation: // delete round2 // round1 -&gt; round2 // round0 -&gt; round1 // roundPre0 -&gt; round0 // createNewRound -&gt; roundPre0 mapping(uint64 =&gt; Round) m_rounds; // count of created rounds uint64 m_roundQty = 0;  DePoolBase.sol // Dictionary of participants for rounds mapping (address =&gt; Participant) m_participants; // Address of the validator wallet address m_validatorWallet; // Array of proxies addresses. address[] m_proxies;  DePool.sol // Indicates that pool is closed. Closed pool doesn't accept stakes from other contracts. bool m_poolClosed; // Min stake accepted to the pool in nTon (for gas efficiency reasons): 10 tons is recommended. uint64 m_minStake; // Minimum validator stake in each round uint64 m_validatorAssurance; // % of participant rewards uint8 m_participantRewardFraction; // % of validator rewards uint8 m_validatorRewardFraction; // % of dePool association rewards uint8 m_associationRewardFraction; // Association address address m_association; // Minimum balance uint64 m_minimumBalance;  "},{"title":"DePool Initialization​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#depool-initialization","content":"When deployed, the DePool constructor is called with the following parameters: /// @dev DePool's constructor. /// @param minStake Min stake that participant may have in one round. /// @param validatorAssurance Min validator stake. /// @param proxyCode Code of proxy contract. /// @param validatorWallet Address of validator wallet. /// @param participantRewardFraction % of reward that distributed among participants. constructor( uint64 minStake, uint64 validatorAssurance, TvmCell proxyCode, address validatorWallet, uint8 participantRewardFraction, )  At initialization the variable m_balanceThreshold is set as current DePool account balance — 5 tokens. DePool will replenish its balance from validation rewards to this value every round it receives rewards. "},{"title":"Participant functions​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#participant-functions","content":"DePool stores some participant information in a dictionary (m_participants) where key — Participant's address and value — Participant structure. Functions used by participants perform checks and send receiveAnswer message back to the caller with an error code and a comment in case of failure. If all conditions are met, DePool sends a confirmation message (receiveAnswer with status 0) back to the caller. All functions can be called by internal messages only. addOrdinaryStake(uint64 stake) — allows to make an ordinary stake in the current pooling round. The source address of the message is taken as Participant's address. The Participant's total stake is increased by stake amount. Parameters: stake — value of participant's stake in nanotons. Function checks that: inbound message value is at least (stake + ADD_STAKE_FEE);stake is at least min stake;pool is not closed. Function returns change (part of unused ADD_STAKE_FEE). addVestingStake(uint64 stake, address beneficiary, uint32 withdrawalPeriod, uint32 totalPeriod) — allows to add a vesting stake for another participant (beneficiary). The source address of the message is saved as the vesting stake owner. Parameters: stake — value of participant's stake in nanotons (Note: this value is divided into 2 parts and is added to 2 rounds).beneficiary — address of target participant (beneficiary);withdrawalPeriod — the period in seconds after which the part of the vesting becomes available for beneficiary;totalPeriod — total period of vesting in seconds after which beneficiary becomes owner of the whole stake. Function checks that: DePool is not closed (m_poolClosed ≠ true);beneficiary is an addr_std. It's not zero address. It's not the message sender (not self vesting);inbound msg.value ≥ (m_minStake + ADD_STAKE_FEE);Message value is at least stake + STAKE_FEE;stake / 2 is at least min stake;withdrawalPeriod ≤ totalPeriod;totalPeriod &lt; 18 years;withdrawalPeriod ≠ 0;totalPeriod % withdrawalPeriod = 0;beneficiary doesn't have a vesting stake. addLockStake(uint64 stake, address beneficiary, uint32 withdrawalPeriod, uint32 totalPeriod) — allows to add a stake that will bring rewards to another participant (beneficiary). The source address of the message is saved as the lock stake owner. It has the same parameters and checks as addVestingStake, but it checks that participant doesn't have a lock stake instead of a vesting stake. withdrawFromPoolingRound(uint64 withdrawValue) — allows to remove Participant's stake from the current pooling round. Parameters: withdrawValue — desired amount of stake to be removed. Function checks that: inbound msg.sender address is address of an existing participant. If real ordinary stake is less than withdrawValue, then DePool returns the whole stake from pooling round. If the remaining stake in the pooling round is less than m_minStake, then the whole stake is transferred to Participant. If the remaining total stake of Participant is 0, then it is removed from the m_stakeholders dictionary. withdrawPart(uint64 withdrawValue) — Allows a participant to withdraw some value from DePool. This function withdraws withdrawValue nanotons when rounds are completed. If participant stake becomes less than minStake, then the whole stake is sent to participant. Parameters: withdrawValue — desired amount of stake to be removed. Function checks that: pool is not closed (m_poolClosed ≠ true);inbound msg.sender address is address of an existing participant. If the remaining stake in the round is less than m_minStake, then the whole stake will be transferred to Participant (after completing round). If the remaining total stake of Participant is 0, then it is removed from the m_stakeholders dictionary. 6. withdrawAll() — Set global flag for the participant that indicates to return participant's ordinary stake after completing rounds. Function checks that: pool is not closed (m_poolClosed ≠ true);inbound msg.sender address is address of an existing participant. After transferring all Participant's stake, the Participant will be removed from the m_stakeholders dictionary. cancelWithdrawal() — Cancel effect of calls of functions withdrawAll and withdrawPart. transferStake(address dest, uint64 amount) — allows to move amount of stake from msg.sender Participant to dest Participant inside DePool storage. Parameters: dest — stake beneficiary;amount — stake value transferred to dest in nanotons. Function checks that: pool is not closed (m_poolClosed ≠ true);destination is a non-zero addr_std;msg.sender ≠ dest;neither destination nor msg.sender is the validator wallet;inbound msg.sender address is address of an existing participant;desired amount can be transferred and transfer doesn't leave stake less than m_minStake in any round. In case of success DePool sends back a notification via onTransfer function calling to beneficiary. "},{"title":"Functions of interface DePoolInfoGetter:​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#functions-of-interface-depoolinfogetter","content":"function getLastRoundInfo() public If there is no completed round yet, call callback function receiveDePoolInfo with struct containing default values, else send call with struct containing info about last completed round. // Represent info about last completed round struct LastRoundInfo { uint32 supposedElectedAt; uint8 participantRewardFraction; uint8 validatorRewardFraction; uint32 participantQty; uint64 roundStake; address validatorWallet; uint256 validatorPubkey; uint64 validatorAssurance; }  "},{"title":"Participant callback functions:​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#participant-callback-functions","content":"These functions are called by DePool to send notifications to Participant. receiveAnswer(uint32 errcode, uint64 comment) — function, which is called as an answer from DePool to Participant. Arguments: errcode — error code. List of codes: uint8 constant STATUS_SUCCESS = 0; uint8 constant STATUS_STAKE_TOO_SMALL = 1; uint8 constant STATUS_DEPOOL_CLOSED = 3; uint8 constant STATUS_NO_PARTICIPANT = 6; uint8 constant STATUS_PARTICIPANT_HAVE_ALREADY_VESTING = 9; uint8 constant STATUS_WITHDRAWAL_PERIOD_GREATER_TOTAL_PERIOD = 10; uint8 constant STATUS_TOTAL_PERIOD_MORE_18YEARS = 11; uint8 constant STATUS_WITHDRAWAL_PERIOD_IS_ZERO = 12; uint8 constant STATUS_TOTAL_PERIOD_IS_NOT_DIVED_BY_WITHDRAWAL_PERIOD = 13; uint8 constant STATUS_PERIOD_PAYMENT_IS_ZERO = 14; uint8 constant STATUS_REMAINING_STAKE_LESS_THAN_MINIMAL = 16; uint8 constant STATUS_PARTICIPANT_HAVE_ALREADY_LOCK = 17; uint8 constant STATUS_TRANSFER_AMOUNT_IS_TOO_BIG = 18; uint8 constant STATUS_TRANSFER_SELF = 19; uint8 constant STATUS_TRANSFER_TO_OR_FROM_VALIDATOR = 20; uint8 constant STATUS_FEE_TOO_SMALL = 21; uint8 constant STATUS_INVALID_ADDRESS = 22; uint8 constant STATUS_INVALID_BENEFICIARY = 23; uint8 constant STATUS_NO_ELECTION_ROUND = 24; uint8 constant STATUS_INVALID_ELECTION_ID = 25;  comment — some value attached to error code. onTransfer(address source, uint128 amount) — function, which is called after successful transferStake to inform beneficiary. Arguments: source — address of Participant who made transfer;amount — funds that were transferred. onRoundComplete(uint64 roundId, uint64 reward, uint64 ordinaryStake, uint64 vestingStake, uint64 lockStake, bool reinvest, uint8 reason) — send a notification from DePool to Participant when round is completed: roundId — Id of completed round;reward — Participant's reward in completed round in nanotons;ordinaryStake — ordinary stake in completed round;vestingStake — vesting stake in completed round;lockStake — lock stake in completed round;reinvest — are ordinary stakes automatically reinvested (prolonged)?reason — reason why round is completed (See enum CompletionReason). "},{"title":"DePool owner functions:​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#depool-owner-functions","content":"These functions can be called only by the DePool owner, as they have to be signed with the deploy keypair. terminator() [external msg only] — a method to close DePool. All stakes from all rounds are returned in several phases: a. first of all, stakes from pooling round are returned immediately. b.m_poolClosed = true; c. All other rounds will return stakes after their &quot;completed&quot; step. Important: remaining parts of vesting/lock stakes will be sent to owners of those stakes (not to beneficiaries) setValidatorRewardFraction(uint8 fraction) [external msg only] Sets new validator's reward fraction and calculates new participants' reward fraction. New validator's reward fraction must be less than current one and be not zero. fraction — new validator's reward fraction. "},{"title":"Events​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#events","content":"DePoolClosed() — event emitted when pool is closed by terminator() function.RoundStakeIsAccepted(uint64 queryId, uint32 comment) — event is emitted on accepting stake by elector.RoundStakeIsRejected(uint64 queryId, uint32 comment) — event is emitted on rejecting stake by elector.ProxyHasRejectedTheStake(uint64 queryId) — event is emitted if stake is returned by proxy (IProxy.process_new_stake) because too low balance of proxy contract.ProxyHasRejectedRecoverRequest(uint64 roundId) — event is emitted if stake cannot be returned from elector (IProxy.recover_stake) because too low balance of proxy contract.RoundCompleted(TruncatedRound round) — event is emitted on completing round.StakeSigningRequested(uint32 electionId, address proxy) — Event emitted when round is switched from pooling to election. DePool is waiting for signed election request from validator wallet.TooLowDePoolBalance(uint replenishment) — event emitted when pure DePool's balance becomes too low. replenishment minimal value that must be sent to DePool via receiveFunds function.RewardFractionsChanged(uint8 validator, uint8 participants) — event emitted when contract owner changes reward fractions. validator — validator's reward fraction. participants — participants' reward fraction. "},{"title":"Get-methods​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#get-methods","content":"These get-methods are used for local run. getParticipantInfo(address addr) — returns participant's information about stakes in every rounds;getDePoolInfo() — returns DePool configuration parameters and constants;getParticipants() — return list of all participants;getRounds() — returns information about all rounds.getDePoolBalance() — returns DePool's own balance in nanotokens. The DePool does not store validator public keys or ADNL address, because, according to the official Everscale guide, the Validator generates a new keypair and ADNL for every elections. The contract stores only Validator wallet address. "},{"title":"State update function​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#state-update-function","content":"ticktock() — this function is the &quot;engine&quot; of DePool. This function rotates rounds: creates a new round if necessary and removes an old one. Switches steps of rounds and calls various internal functions if certain conditions are satisfied and so on. ticktock() — does not accept external inbound messages and can be called only from other contracts ticktock returns unspent message value (change) back to caller. "},{"title":"Multi-Round elections​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#multi-round-elections","content":" Every round goes through several steps: &quot;PrePooling&quot; step (RoundStep.PrePooling) — it's an imaginary round introduced to store half of vesting/lock stake from participants. See addVestingStake/addLockStake functions.&quot;Pooling&quot; step (RoundStep.Pooling) — round is ready to accept stakes from Participants. This round receives ordinary, vesting and lock stakes.&quot;waiting for election requests&quot; step (RoundStep.WaitingValidatorRequest) — round is switched to this step when validator elections begin. DePool is waiting for signed election request from validator wallet. See process_new_stake function of Elector to properly generate election request. Important: Validator wallet must also be a Participant and invest at least m_validatorAssurance stake in the round. If it doesn't, round is completed and stakes are reinvested in another round or are returned to participants. &quot;Waiting if stake is accepted by elector&quot; (RoundStep.WaitingIfStakeAccepted) — DePool has received the validator signed election request. DePool has sent the whole round stake to elector through one of its proxies. Now DePool is waiting for elector answer. Note: elector will call DePool's onStakeAccept function if election request is accepted successfully or onStakeReject in case of an error.&quot;waiting for validation start&quot; (RoundStep.WaitingValidationStart) — round stake was accepted by elector. Validator is a candidate. DePool now is waiting for the start of the validation to find out if validator won the elections.&quot;waiting for election result&quot; (RoundStep.WaitingIfValidatorWinElections) — DePool has tried to recover stake in validation period to find out if validator won elections. Waiting for elector answer. Note: If validator won the elections, elector returns no stake. If Validator lost the elections, elector returns the whole stake.&quot;waiting stake unfreeze&quot; (RoundStep.WaitingUnfreeze) — If CompletionReason != Undefined, the round is waiting round rotation to return/reinvest funds because elections were lost. Else validator won elections. DePool is waiting for ending of unfreeze period to recover funds from elector.&quot;waiting for a reward&quot; (RoundStep.WaitingReward) — Unfreeze period has been ended. Request to recover stake has been sent to elector. DePool is waiting for answer from elector.&quot;completing&quot; step (RoundStep.Completing) — DePool receives reward and replenishes its balance from it. Then it returns or reinvests participant's stakes. Also on this step DePool recounts vesting and lock stakes and modifies them if necessary.&quot;completed&quot; (RoundStep.Completed) — round switches to this step after processing all the Participants in the round. In next ticktock this round will be deleted. "},{"title":"Round completion​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#round-completion","content":"When a round switches to &quot;completing&quot; step (completeRound function), the DePool replenishes its balance from received rewards and then starts to cycle through all stakes in the round. If Participant's reinvestment flag is false, DePool sends it back to the Participant, otherwise — adds it to the pooling round. Also DePool sends notification message (onRoundComplete) to Participant. DePool goes through all vesting and lock stakes of the completing round and checks whether a withdrawal period has finished for the current stake. If it has, DePool modifies the stake via transferring part of it to Participants ordinary stake (in case of Vesting) and/or transferring part of the stake back to the owner (in case of Lock or in case of Vesting for validator which was slashed or lost elections over the course of the completed withdrawal period). Remark: if there are 15000 stakes in round, then the contract should split completion to 375 transactions sending 375 completePendingRound messages to itself. All these transactions can fit in 1-2 blocks and the whole operation will take about 5-20 seconds. "},{"title":"DePool decentralization​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#depool-decentralization","content":"No inherent way to replace the contract code (no SETCODE);No inherent way to transfer an arbitrary amount of currency from the DePool;Any contract can call the ticktock() function to update the state of the DePool;No one has special privileges, except for deployer of DePool who can only close DePool and start a procedure of returning all stakes back to Participants;Fees cannot be changed after the contract is deployed;Validator wallet must be a Participant as well to share risks with other Participants. "},{"title":"DePool contract fee​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#depool-contract-fee","content":"Caller of DePool's ticktock function must pay for consumed gas. Unused message value is returned back when ticktock is finished. At the beginning of completing step DePool first takes from the total reward an amount of tokens to replenish it's balance to m_balanceThreshold, and then additionally RET_OR_REINV_FEE * (N + 1), where N is the number of participants, to cover the costs of stake processing. "},{"title":"Links​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#links","content":"DePool contract is available on github. DePool deployment instructions can be found here. "},{"title":"TONOS-CLI","type":0,"sectionRef":"#","url":"develop/tools/tonos-cli","content":"","keywords":""},{"title":"About TONOS-CLI​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#about-tonos-cli","content":"TONOS-CLI is a multi-platform command line interface for EVER OS. It allows you to work with keys and seed phrases, deploy contracts, call any of their methods, generate and broadcast messages. It supports specific commands for DeBot, DePool and Multisig contracts, as well as a number of supplementary functions. To access built-in help, use --help or -h flag: tonos-cli --help tonos-cli &lt;subcommand&gt; -h  1. Installation "},{"title":"Install compiled executable​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#install-compiled-executable","content":"Create a folder. Download the .zip file from the latest release from here: https://github.com/tonlabs/tonos-cli/releases to this folder. Extract it. "},{"title":"Install through EVERDEV​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#install-through-everdev","content":"You can use EVERDEV to install the latest version of TONOS-CLI. everdev tonos-cli install  The installer requires NPM to be installed, so it can install packages globally without using sudo. In case of error, manually set environment variable PATH=$PATH:$HOME./everdev/solidity This command updates TONOS-CLI installed through EVERDEV to the latest version: everdev tonos-cli update  This command specifies TONOS-CLI version to use and downloads it if needed: everdev tonos-cli set --version 0.8.0  "},{"title":"Build from source​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#build-from-source","content":""},{"title":"Prerequisites​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#prerequisites","content":"Rust latest versionOpenSSL For Linux: sudo apt-get install libssl-dev (openssl-devel on Fedora) sudo apt-get install pkg-config  "},{"title":"Build from source on Linux and Mac OS​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#build-from-source-on-linux-and-mac-os","content":"Install Cargo: https://github.com/rust-lang/cargo#compiling-from-source Build TONOS-CLI tool from source: git clone https://github.com/tonlabs/tonos-cli.git cd tonos-cli cargo update cargo build --release cd target/release  The tonos-cli executable is built in the tonos-cli/target/release folder. Create a folder elsewhere. Copy the tonos-cli executable into the new folder you have created. "},{"title":"Build from source on Windows​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#build-from-source-on-windows","content":"Install Cargo: https://github.com/rust-lang/cargo#compiling-from-source Build TONOS-CLI tool from source: &gt; git clone https://github.com/tonlabs/tonos-cli.git &gt; cd tonos-cli &gt; cargo update &gt; cargo build --release &gt; cd target/release  The tonos-cli executable is built in the tonos-cli/target/release folder. Create a folder elsewhere. Copy the tonos-cli executable into the new folder you have created. "},{"title":"Windows debug build troubleshooting​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#windows-debug-build-troubleshooting","content":"Default debug executable built after cargo build command may have an issue with binary default stack size: &gt; cargo build Finished dev [unoptimized + debuginfo] target(s) in 0.66s &gt; .\\target\\debug\\tonos-cli.exe --version thread 'main' has overflowed its stack  User can fix this issue by using editbin tool from MSVC Tools. This tool allows user to increase binary stack reserve. Increase it by 2 times will help to fix tonos-cli: &gt; editbin /STACK:2097152 tonos-cli.exe Microsoft (R) COFF/PE Editor Version 14.28.29914.0 Copyright (C) Microsoft Corporation. All rights reserved. &gt; tonos-cli.exe --version tonos_cli 0.26.7 COMMIT_ID: 1e1397b5561ea79d2fd7cce47cd033450b123f25 BUILD_DATE: Unknown COMMIT_DATE: 2022-05-13 14:15:47 +0300 GIT_BRANCH: master  "},{"title":"Tails OS secure environment​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#tails-os-secure-environment","content":"For maximum security while working with offline TONOS-CLI features (such as cryptographic commands or encrypted message generation), you can use the Tails OS. "},{"title":"Put TONOS-CLI into system environment​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#put-tonos-cli-into-system-environment","content":"Optional, Linux/Mac OS. Use the following command to put the utility into system environment: export PATH=&quot;&lt;tonos_folder_path&gt;:$PATH&quot;  This step can be skipped, if TONOS-CLI was installed through EVERDEV. Otherwise, if you skip this step, make sure you always run the utility from folder containing the utility: ./tonos-cli &lt;command&gt; &lt;options&gt;  "},{"title":"Check version​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#check-version","content":"You can check version of the current TONOS-CLI installation with the following command: tonos-cli version  Output example: $ tonos-cli version Config: default tonos-cli 0.2.0 COMMIT_ID: 21ebd53c35bf22696bf1eb434e408ed33318136a BUILD_DATE: 2021-01-26 15:06:18 +0300 COMMIT_DATE: 2021-01-14 16:13:32 +0300 GIT_BRANCH: master  "},{"title":"A note on Windows syntax​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#a-note-on-windows-syntax","content":"When using Windows command line, the following syntax should be used for all TONOS-CLI commands: Never use the ./ symbols before tonos-cli: &gt; tonos-cli &lt;command_name&gt; &lt;options&gt;  For all commands with nested quotes, the outer single quotes should be changed to double quotes, and the inner double quotes should be shielded by a preceding \\. Example: &gt; tonos-cli deploy SafeMultisigWallet.tvc &quot;{\\&quot;owners\\&quot;:[\\&quot;0x723b2f0fa217cd10fe21326634e66106678f15d5a584babe4f576dffe9dcbb1b\\&quot;,\\&quot;0x127e3ca223ad429ddaa053a39fecd21131df173bb459a4438592493245b695a3\\&quot;,\\&quot;0xc2dd3682ffa9df97a968bef90b63da90fc92b22163f558b63cb7e52bfcd51bbb\\&quot;],\\&quot;reqConfirms\\&quot;:2}&quot; --abi SafeMultisigWallet.abi.json --sign deploy.keys.json  If this is not done, arguments are not in json format: key must be a string at line 1 column error may occur. 2. Configuration "},{"title":"2.1. Set the network and parameter values​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#21-set-the-network-and-parameter-values","content":"TONOS-CLI can remember some parameter values and use it automatically in various subcommands. After that you can omit the corresponding parameters in subsequent subcommands. tonos-cli.config.json configuration file will be created in the current working directory. All subsequent calls of the utility will use this file. Use the following command to create a configuration file: tonos-cli config &lt;--option&gt; &lt;option_value&gt;  All other TONOS-CLI commands will indicate the configuration file currently used. List of available options: --abi &lt;ABI&gt; - - - Path to the contract ABI file. --addr &lt;ADDR&gt; - - - Contract address. --async_call &lt;ASYNC_CALL&gt; - - Disables wait for transaction to appear in the network after call command. --balance_in_tons &lt;BALANCE_IN_TONS&gt; - Print balance for account command in tons. If false balance is printed in nanotons. --debug_fail &lt;DEBUG_FAIL&gt; - - When enabled tonos-cli executes debug command on fail of run or call command. Can be enabled with values 'full' or 'minimal' which set the trace level for debug run and disabled with value 'none'. --depool_fee &lt;DEPOOL_FEE&gt; - - Value added to the message sent to depool to cover its fees (change will be returned). --keys &lt;KEYS&gt; - - - Path to the file with keypair. --lifetime &lt;LIFETIME&gt; - - Period of time in seconds while message is valid. Change of this parameter may affect &quot;out_of_sync&quot; parameter, because &quot;lifetime&quot; should be at least 2 times greater than &quot;out_of_sync&quot;. --local_run &lt;LOCAL_RUN&gt; - - Enable preliminary local run before deploy and call commands. --message_processing_timeout &lt;MSG_TIMEOUT&gt; Network message processing timeout in ms. --no-answer &lt;NO_ANSWER&gt; - - Flag whether to wait for depool answer when calling a depool function. --out_of_sync &lt;OUT_OF_SYNC&gt; - - Network connection &quot;out_of_sync_threshold&quot; parameter in seconds. Mind that it cant exceed half of the &quot;lifetime&quot; parameter. --pubkey &lt;PUBKEY&gt; - - - User public key. Used by DeBot Browser. --retries &lt;RETRIES&gt; - - - Number of attempts to call smart contract function if previous attempt was unsuccessful. --timeout &lt;TIMEOUT&gt; - - - Network `wait_for` timeout in ms. --url &lt;URL&gt; - - - Url to connect. --wallet &lt;WALLET&gt; - - - Multisig wallet address. --wc &lt;WC&gt; - - - - Workchain id.  Example: $ tonos-cli config --url https://main.ton.dev --wc -1 --keys key.json --abi SafeMultisigWallet.abi.json --lifetime 3600 --local_run true --retries 3 --timeout 600 Config: /home/user/TONLabs/tonos-cli/tonos-cli.conf.json Succeeded. { &quot;url&quot;: &quot;main.ton.dev&quot;, &quot;wc&quot;: -1, &quot;addr&quot;: null, &quot;wallet&quot;: null, &quot;pubkey&quot;: null, &quot;abi_path&quot;: &quot;SafeMultisigWallet.abi.json&quot;, &quot;keys_path&quot;: &quot;key.json&quot;, &quot;retries&quot;: 3, &quot;timeout&quot;: 600, &quot;message_processing_timeout&quot;: 40000, &quot;out_of_sync_threshold&quot;: 15, &quot;is_json&quot;: false, &quot;depool_fee&quot;: 0.5, &quot;lifetime&quot;: 3600, &quot;no_answer&quot;: true, &quot;balance_in_tons&quot;: false, &quot;local_run&quot;: true, &quot;async_call&quot;: false, &quot;debug_fail&quot;: &quot;None&quot;, &quot;endpoints&quot;: [ &quot;https://eri01.main.everos.dev&quot;, &quot;https://gra01.main.everos.dev&quot;, &quot;https://gra02.main.everos.dev&quot;, &quot;https://lim01.main.everos.dev&quot;, &quot;https://rbx01.main.everos.dev&quot; ] }  Some frequently used networks: https://net.ever.live - developer sandbox for testing. TONOS-CLI connects to it by default. https://ever.live - main Everscale network. https://rustnet.ever.live - test network running on Rust nodes. TONOS-CLI supports the use of multiple endpoints for networks: if several endpoints are specified in the endpoint map for a network, TONOS-CLI will use them all when accessing it. Otherwise, the network URL will be treated as the only endpoint. main.ton.dev and net.ton.dev networks already have their current endpoints specified in the default endpoint map. See section 2.4 below on how to edit and add endpoints to the endpoint map. Note: This change was introduced in version 0.16.1 and is fully compatible with scripts written for previous versions, where main.ton.dev and net.ton.dev networks were specified with a single url. TONOS-CLI will simply use the default endpoint map to access these networks. Network configuration can be overridden for any single subcommand. To connect to a DApp Server you are running, it should have domain name and a DNS record. Then its URL may be used to access it with TONOS-CLI: tonos-cli config --url &lt;dapp_server_url&gt;  Note: Either run tonos-cli utility only from the directory where tonos-cli.config.json is placed, or use one of the available methods (see section 2.5) to make the utility look for the file elsewhere. "},{"title":"2.2. Check configuration​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#22-check-configuration","content":"You can check the current configuration parameters with the following command: tonos-cli config --list  "},{"title":"2.3. Clear configuration​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#23-clear-configuration","content":"Use the following command to reset configuration to default values: tonos-cli config clear  "},{"title":"2.4. Configure endpoints map​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#24-configure-endpoints-map","content":"TONOS-CLI config file also stores an endpoints map that can be updated by the user. Each time user changes the url, endpoints also change in accordance to endpoints map. To print the map use the following command: tonos-cli config endpoint print  User can reset map to the default state: tonos-cli config endpoint reset  Default state of the map: { &quot;net.ton.dev&quot;: [ &quot;https://eri01.net.everos.dev&quot;, &quot;https://rbx01.net.everos.dev&quot; &quot;https://gra01.net.everos.dev&quot; ], &quot;main.ton.dev&quot;: [ &quot;https://eri01.main.everos.dev&quot;, &quot;https://gra01.main.everos.dev&quot;, &quot;https://gra02.main.everos.dev&quot;, &quot;https://lim01.main.everos.dev&quot;, &quot;https://rbx01.main.everos.dev&quot; ], &quot;http://127.0.0.1/&quot;: [ &quot;http://0.0.0.0/&quot;, &quot;http://127.0.0.1/&quot;, &quot;http://localhost/&quot; ] }  Map can be changed with remove and add subcommands: tonos-cli config endpoint remove &lt;url&gt; tonos-cli config endpoint add &lt;url&gt; &lt;list_of_endpoints&gt;  Example: tonos-cli config endpoint remove main.ton.dev tonos-cli config endpoint add main.ton.dev &quot;https://eri01.main.everos.dev&quot;,&quot;https://gra01.main.everos.dev&quot;,&quot;https://gra02.main.everos.dev&quot;,&quot;https://lim01.main.everos.dev&quot;,&quot;https://rbx01.main.everos.dev&quot;  Note: If url used in add command already exists, endpoints lists will be merged. If a network that doesn't have mapped endpoints is specified in the config file, its url will be automatically treated as the only endpoint. For example, configuring TONOS-CLI to connect to RustNet with the command tonos-cli config --url https://rustnet.ton.dev will result in TONOS-CLI using this url as a single endpoint, without the user having to specify it in the endpoints map additionally. "},{"title":"2.5. Override configuration file location​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#25-override-configuration-file-location","content":"You can move the tonos-cli.config.json configuration file to any other convenient location and/or rename it. There are several ways you can point the utility to the new location of the file: define environment variable TONOSCLI_CONFIG with the path to your configuration file: export TONOSCLI_CONFIG=&lt;path_to_config_file&gt;  Example: export TONOSCLI_CONFIG=/home/user/config.json  define global option --config &lt;path_to_config_file&gt; before any other subcommand: tonos-cli --config &lt;path_to_config_file&gt; &lt;any_subcommand&gt;  Example: tonos-cli --config /home/user/config.json account &lt;address&gt;  The --config global option has higher priority than the TONOSCLI_CONFIG environment variable. Note: You cannot use the config subcommand to create or edit a configuration file located outside the current working directory. It should either be called from the directory containing the file, or the file should be manually copied to the desired directory later. However, config --list subcommand displays the parameters of the currently used configuration file, wherever it is located. "},{"title":"2.6. Override network settings​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#26-override-network-settings","content":"You can also separately override preconfigured network settings for a single subcommand. Use the --url &lt;network_url&gt; global option for this purpose: tonos-cli --url &lt;network_url&gt; &lt;any_subcommand&gt;  Example: tonos-cli --url https://main.ton.dev account &lt;address&gt;  "},{"title":"2.7. Force json output​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#27-force-json-output","content":"You can force TONOS-CLi to print output in json format. To do so, add --json flag before a subcommand: tonos-cli --json &lt;any_subcommand&gt;  "},{"title":"2.8. Debug on fail option​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#28-debug-on-fail-option","content":"You can force TONOS-CLi to debug call and run executions if they fail with error code 414. tonos-cli config --debug_fail &lt;trace_level&gt;  Possible &lt;trace_level&gt; values: 'full''minimal''none' 3. Cryptographic commands "},{"title":"3.1. Create seed phrase​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#31-create-seed-phrase","content":"To generate a mnemonic seed phrase enter the following command: tonos-cli genphrase  Example: $ tonos-cli genphrase Config: /home/user/tonos-cli.conf.json Succeeded. Seed phrase: &quot;rule script joy unveil chaos replace fox recipe hedgehog heavy surge online&quot;  "},{"title":"3.2. Generate public key​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#32-generate-public-key","content":"To generate a public key from a seed phrase enter the following command with the seed phrase in quotes: tonos-cli genpubkey &quot;rule script joy unveil chaos replace fox recipe hedgehog heavy surge online&quot;  The generated QR code also contains the public key. Example: $ tonos-cli genpubkey &quot;rule script joy unveil chaos replace fox recipe hedgehog heavy surge online&quot; Config: /home/user/tonos-cli.conf.json Succeeded. Public key: 88c541e9a1c173069c89bcbcc21fa2a073158c1bd21ca56b3eb264bba12d9340 &lt;QR code with key&gt;  "},{"title":"3.3. Generate key pair file​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#33-generate-key-pair-file","content":"To create a key pair file from a seed phrase use the following command: tonos-cli getkeypair [-o &lt;keyfile.json&gt;] [-p &quot;&lt;seed_phrase&gt;&quot;]  &lt;keyfile.json&gt; - the file the key pair will be written to. If not specified keys will be printed to the stdout.&quot;&lt;seed_phrase&gt;&quot; - seed phrase or secret key. If not specified a new phrase will be generated. Example: $ tonos-cli getkeypair -o key.json -p &quot;rule script joy unveil chaos replace fox recipe hedgehog heavy surge online&quot; Config: /home/user/TONLabs/tonos-cli/tonos-cli.conf.json Input arguments: key_file: key.json phrase: rule script joy unveil chaos replace fox recipe hedgehog heavy surge online Keypair successfully saved to key.json. Succeeded. $ tonos-cli getkeypair -o key.json Config: /home/user/TONLabs/tonos-cli/tonos-cli.conf.json Input arguments: key_file: key.json phrase: None Generating seed phrase. Seed phrase: &quot;elephant tone error jazz scrap wise kick walk panda snake right feature&quot; Keypair successfully saved to key.json. Succeeded. $ tonos-cli getkeypair Config: /home/user/TONLabs/tonos-cli/tonos-cli.conf.json Input arguments: key_file: None phrase: None Generating seed phrase. Seed phrase: &quot;behave early mammal cart grape wolf pulse once helmet shop kit this&quot; Keypair: { &quot;public&quot;: &quot;d5218be1502c98019a2c08ae588f73abd56b4c72411e8d2ee37e5c2d821e075f&quot;, &quot;secret&quot;: &quot;842bd2b9df2ec4ed07b6b66d6d0c2858769ba4ed9005ffe58cba26783504a3ff&quot; } Succeeded. $ tonos-cli -j getkeypair { &quot;public&quot;: &quot;09889cd2f085a693ef04a6dad4b6533c7019014a7e0ca9b5b146e66e550973d9&quot;, &quot;secret&quot;: &quot;021196259435d54dfb5c41970db5bcfc2306d59877665c3b573486d441cf021a&quot; }  4. Smart contract commands When working with smart contracts, TONOS-CLI requires the following files: ABI file - a .json file that describes the contract interface, the methods and parameters used to interact with it.TVC file - the compiled smart contract file. Used only when generating contract address and deploying contract code to the blockchain.Key pair file - used in contracts with implemented authorization. It is the file containing private and public keys authorized to access the contract. In --sign parameter the corresponding seed phrase may be used instead of it. By default, the utility looks for these files in the current working directory. "},{"title":"4.1. Generate contract address​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#41-generate-contract-address","content":"Contract address uniquely identifies the contract on the blockchain. Contract balance is attached to its address, the address is used for any interactions with the contract, such as calling contract functions, sending messages, etc. Contract address is generated based on contract TVC file and selected keys. To get a different address for the same type of contract, use different keys. Note: If your contract has static variables, they can be initialized through TVM linker before deployment. Use the following command to generate the contract address: tonos-cli genaddr [--genkey|--setkey &lt;keyfile.json&gt;] [--wc &lt;int8&gt;] [--abi &lt;contract.abi.json&gt;] &lt;contract.tvc&gt;  --genkey &lt;keyfile.json&gt; - generate new keyfile.json key pair file and use it to calculate the contract address. Note: if you use --genkey, the corresponding seed phrase will be displayed. Write it down, if you mean to keep using this key pair. --abi &lt;contract.abi.json&gt; - contract ABI interface file. If not specified tonos-cli can use ABI path from config of obtained from tvc path (for &lt;contrac&gt;.tvc checks &lt;contract&gt;.abi.json). --setkey &lt;keyfile.json&gt; - use already existing keyfile.json key pair file to calculate the contract address. Seed phrase cannot be used instead of the file. --wc &lt;int8&gt; ID of the workchain the contract will be deployed to (-1 for masterchain, 0 for basechain). By default, this value is set to 0. &lt;contract.tvc&gt; - compiled smart contract file. As result the utility displays the new contract address (Raw address). Example (multisignature wallet address generation for the masterchain): $ tonos-cli genaddr --genkey key.json --wc -1 SafeMultisigWallet.tvc --abi SafeMultisigWallet.abi.json Config: /home/user/tonos-cli.conf.json Input arguments: tvc: SafeMultisigWallet.tvc wc: -1 keys: key.json init_data: None is_update_tvc: None Seed phrase: &quot;chimney nice diet engage hen sing vocal upgrade column address consider word&quot; Raw address: -1:a021414a79539001ed35d615a646dc8b89df29ccccf143c30df15c7fbcaff086 testnet: Non-bounceable address (for init): 0f-gIUFKeVOQAe011hWmRtyLid8pzMzxQ8MN8Vx_vK_whkeM Bounceable address (for later access): kf-gIUFKeVOQAe011hWmRtyLid8pzMzxQ8MN8Vx_vK_whhpJ mainnet: Non-bounceable address (for init): Uf-gIUFKeVOQAe011hWmRtyLid8pzMzxQ8MN8Vx_vK_whvwG Bounceable address (for later access): Ef-gIUFKeVOQAe011hWmRtyLid8pzMzxQ8MN8Vx_vK_whqHD Succeeded  "},{"title":"4.2. Deploy contract​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#42-deploy-contract","content":"Note: If your contract has static variables, they can be initialized through TVM linker before deployment. Use the following command to deploy a contract: tonos-cli deploy [--sign &lt;deploy_seed_or_keyfile&gt;] [--wc &lt;int8&gt;] [--abi &lt;contract.abi.json&gt;] &lt;contract.tvc&gt; &lt;params&gt;  &lt;deploy_seed_or_keyfile&gt; - can either be the seed phrase used to generate the deployment key pair file or the key pair file itself. If seed phrase is used, enclose it in double quotes. Example: --sign &quot;flip uncover dish sense hazard smile gun mom vehicle chapter order enact&quot; or --sign deploy.keys.json--wc &lt;int8&gt; ID of the workchain the wallet will be deployed to (-1 for masterchain, 0 for basechain). By default, this value is set to 0. &lt;contract.abi.json&gt; - contract interface file. &lt;contract.tvc&gt; - compiled smart contract file. &lt;params&gt; - deploy command parameters, depend on the contract. Example (multisignature wallet contract deployment to the masterchain): $ tonos-cli deploy --sign key.json --wc -1 --abi SafeMultisigWallet.abi.json SafeMultisigWallet.tvc '{&quot;owners&quot;:[&quot;0x88c541e9a1c173069c89bcbcc21fa2a073158c1bd21ca56b3eb264bba12d9340&quot;],&quot;reqConfirms&quot;:1}' Config: /home/user/tonos-cli.conf.json Input arguments: tvc: SafeMultisigWallet.tvc params: {&quot;owners&quot;:[&quot;0x88c541e9a1c173069c89bcbcc21fa2a073158c1bd21ca56b3eb264bba12d9340&quot;],&quot;reqConfirms&quot;:1} abi: SafeMultisigWallet.abi.json keys: key.json wc: -1 Connecting to net.ton.dev Deploying... Transaction succeeded. Contract deployed at address: -1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6  "},{"title":"4.3. Generate deploy message offline​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#43-generate-deploy-message-offline","content":"If needed, signed deploy message can be generated without immediately broadcasting it to the blockchain. Generated message can be broadcasted later. tonos-cli deploy_message [--raw] [--output &lt;path_to_file&gt;] [--sign &lt;deploy_seed_or_keyfile&gt;] [--wc &lt;int8&gt;] [--abi &lt;contract.abi.json&gt;] &lt;contract.tvc&gt; &lt;params&gt;  --raw - use to create raw message boc. --output &lt;path_to_file&gt; - specify path to file where the raw message should be written to, instead of printing it to terminal. &lt;deploy_seed_or_keyfile&gt; - can either be the seed phrase used to generate the deployment key pair file or the key pair file itself. If seed phrase is used, enclose it in double quotes. Example: --sign &quot;flip uncover dish sense hazard smile gun mom vehicle chapter order enact&quot; or --sign deploy.keys.json--wc &lt;int8&gt; ID of the workchain the wallet will be deployed to (-1 for masterchain, 0 for basechain). By default, this value is set to 0. &lt;contract.abi.json&gt; - contract interface file. &lt;contract.tvc&gt; - compiled smart contract file. &lt;params&gt; - deploy command parameters, depend on the contract. Example (saving to a file multisignature wallet contract deployment message to the masterchain): $ tonos-cli deploy_message --raw --output deploy.boc --sign key.json --wc -1 --abi SafeMultisigWallet.abi.json SafeMultisigWallet.tvc '{&quot;owners&quot;:[&quot;0x88c541e9a1c173069c89bcbcc21fa2a073158c1bd21ca56b3eb264bba12d9340&quot;],&quot;reqConfirms&quot;:1}' Config: /home/user/tonos-cli.conf.json Input arguments: tvc: SafeMultisigWallet.tvc params: {&quot;owners&quot;:[&quot;0x88c541e9a1c173069c89bcbcc21fa2a073158c1bd21ca56b3eb264bba12d9340&quot;],&quot;reqConfirms&quot;:1} abi: SafeMultisigWallet.abi.json keys: key.json wc: -1 MessageId: 51da1b8840bd12f9ef5152639bd1fe9062d77ed91829301043bb85b4a4d610ea Expire at: unknown Message saved to file deploy.boc Contract's address: -1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6 Succeeded.  "},{"title":"4.3. Get contract status​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#43-get-contract-status","content":"You may use the following command to check the current status of a contract: tonos-cli account &lt;list_of_addresses&gt; [--dumptvc &lt;tvc_path&gt;] [--dumpboc &lt;boc_path&gt;]  &lt;list_of_addresses&gt; - contract addresses.--dumptvc &lt;tvc_path&gt; - this flag can be specified to dump account StateInit to the &lt;tvc_path&gt; file.--dumpboc &lt;boc_path&gt; - this flag can be specified to dump account boc to the &lt;boc_path&gt; file. Example: $ tonos-cli account 0:2bb4a0e8391e7ea8877f4825064924bd41ce110fce97e939d3323999e1efbb13 0:14014af4a374bdd13dae2379063ea2597634c2c2fc8e99ca9eab431a7ab6f566 0:f89d946b5b4b8a06f01dc20dceef30caff844d5285abea8a21ad3730c0f3dd12 Config: /home/user/TONLabs/tonos-cli/tonos-cli.conf.json Input arguments: addresses: 0:2bb4a0e8391e7ea8877f4825064924bd41ce110fce97e939d3323999e1efbb13, 0:14014af4a374bdd13dae2379063ea2597634c2c2fc8e99ca9eab431a7ab6f566, 0:f89d946b5b4b8a06f01dc20dceef30caff844d5285abea8a21ad3730c0f3dd12 Connecting to net.ton.dev Processing... Succeeded. address: 0:2bb4a0e8391e7ea8877f4825064924bd41ce110fce97e939d3323999e1efbb13 acc_type: Active balance: 11466383488239689 nanoton last_paid: 1640619135 last_trans_lt: 0x530197a143 data(boc): b5ee9c720101060100b000014195c06aa743d1f9000dd64b75498f106af4b7e7444234d7de67ea26988f6181dfe001020120050202012004030052bf874da2f56d034e11773c58331900e0e1e91a137e1b4c2ca15607634c2d63e1af0000000061c9dca50052bfbddf9156dc04cca88cf25d9c766b1bd2f1ab7d0878c4d761862fc524758767f10000000061c9dc820053bfd627d55f960de2235b3f1537884d5968e5e486c58c581bc9ea4068c8da164ce18000000030e4ee49c0 code_hash: ccbfc821853aa641af3813ebd477e26818b51e4ca23e5f6d34509215aa7123d9 address: 0:14014af4a374bdd13dae2379063ea2597634c2c2fc8e99ca9eab431a7ab6f566 acc_type: Active balance: 2082745497066 nanoton last_paid: 1640619517 last_trans_lt: 0x530a3c2782 data(boc): b5ee9c7201020c0100022e000373000000befe45557e0000000000000000000000000002faf04e577e5cf5b28c2a81afc5ae534a0f3f494cc4ee62ef675ca8e36af911a3c8767a400b0a010183801f13b28d6b697140de03b841b9dde6195ff089aa50b57d514435a6e6181e7baba318b50f6f18c9d307d500216c80d6ecd77d13e437bdfcaf0b4fa6b9204b7847500203a1c00b620939e214cadb7481682034e58a853a77874f473c69cc7d3b1ad9da7f0bafa0000000280000000c0000000bddcfa66622a7b9c955271c779b92448cff442b8efead77d43bd7f50b07a45f380030010706030203cca005040045b41bda168cd2322b5dcd28989176a9eae590288db4d548f2b6948d214de0c9bdb372700045b6554f714ca768f21ad18cff20c7af62091e9fc2d40c06d32d1ace7495f5dd1605781000bda90017d76e405363a8a494a3a8d8c38fcadd4f2c7fb550244fd6d2a77ac12eb029bce000000000000255400000000000000000000000000000034c3babc06000000000000000000000000000000000000000000000000000000000000000100201200908009bbfe85a3348c8ad7734a26245daa7ab9640a236d35523cada523485378326f6cdc9800000000000106f0000000000000000000000000002035ac0000000000000000000000000000000187c4b00e0007bbffdc5329da3c86b4633fc831ebd88247a7f0b50301b4cb46b39d257d7745815e0000000000000095500000000000000000000000002f8eb24987c490760000454310010546f6b656e202331 code_hash: eee7d3331153dce4aa938e3bcdc922467fa215c77f56bbea1debfa8583d22f9c 0:f89d946b5b4b8a06f01dc20dceef30caff844d5285abea8a21ad3730c0f3dd12 not found $ tonos-cli account 0:2bb4a0e8391e7ea8877f4825064924bd41ce110fce97e939d3323999e1efbb13 Config: /home/user/TONLabs/tonos-cli/tonos-cli.conf.json Input arguments: addresses: 0:2bb4a0e8391e7ea8877f4825064924bd41ce110fce97e939d3323999e1efbb13 Connecting to net.ton.dev Processing... Succeeded. address: 0:2bb4a0e8391e7ea8877f4825064924bd41ce110fce97e939d3323999e1efbb13 acc_type: Active balance: 11463682795615708 nanoton last_paid: 1640624439 last_trans_lt: 0x5379939282 data(boc): b5ee9c7201010401008100014195c06aa743d1f9000dd64b75498f106af4b7e7444234d7de67ea26988f6181dfe00102012003020053bfde8d98393e5db0ea2f609ed9266cf61a7487759d679ea9792adbdcfc137f6caf8000000030e4f89dc00053bfc8658b6b027767d9addd720a0bf8b157379a9b0e9208bab53ad4ee54358c6ce98000000030e4f89dc0 code_hash: ccbfc821853aa641af3813ebd477e26818b51e4ca23e5f6d34509215aa7123d9  "},{"title":"4.4. Call method​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#44-call-method","content":""},{"title":"4.4.1. Call contract on the blockchain​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#441-call-contract-on-the-blockchain","content":"tonos-cli call [--abi &lt;contract.abi.json&gt;] [--sign &lt;seed_or_keyfile&gt;] &lt;address&gt; &lt;method&gt; &lt;params&gt;  &lt;contract.abi.json&gt; - contract interface file. &lt;seed_or_keyfile&gt; - can either be the seed phrase or the corresponding key pair file. If seed phrase is used, enclose it in double quotes. Example: --sign &quot;flip uncover dish sense hazard smile gun mom vehicle chapter order enact&quot; or --sign keyfile.json &lt;address&gt; - contract address. &lt;method&gt; - the method being called. &lt;params&gt; - parameters of the called method. Example (transaction creation in a multisignature wallet contract): $ tonos-cli call 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc submitTransaction '{&quot;dest&quot;:&quot;-1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;,&quot;value&quot;:234000000,&quot;bounce&quot;:false,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;}' --abi SetcodeMultisigWallet.abi.json --sign k1.keys.json Config: /home/user/tonos-cli.conf.json Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: submitTransaction params: {&quot;dest&quot;:&quot;-1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;,&quot;value&quot;:234000000,&quot;bounce&quot;:false,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;} abi: SetcodeMultisigWallet.abi.json keys: k1.keys.json lifetime: None output: None Connecting to net.ton.dev Generating external inbound message... MessageId: c6baac843fefe6b9e8dc3609487a63ef21207e4fdde9ec253b9a47f7f5a88d01 Expire at: Sat, 08 May 2021 14:52:23 +0300 Processing... Succeeded. Result: { &quot;transId&quot;: &quot;6959885776551137793&quot; }  Note: If your function is marked as responsible, TONOS-CLI expects _answer_id field, and you may encounter errors, if it's missing. "},{"title":"4.4.2. Alternative command to call contract in the blockchain​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#442-alternative-command-to-call-contract-in-the-blockchain","content":"tonos-cli callex &lt;method&gt; [&lt;address&gt;] [&lt;contract.abi.json&gt;] [&lt;seed_or_keyfile&gt;] params...  Note: this command is deprecated, use callx instead. &lt;method&gt; - the method being called. &lt;address&gt; - contract address. &lt;contract.abi.json&gt; - contract interface file. &lt;seed_or_keyfile&gt; - can either be the seed phrase or the corresponding key pair file. If seed phrase is used, enclose it in double quotes. Example: --sign &quot;flip uncover dish sense hazard smile gun mom vehicle chapter order enact&quot; or --sign keyfile.json params... - one or more parameters of the called method in the form of --name value. address, abi, and keys parameters can be omitted. In this case default values will be used from config file. Integer and address types can be supplied without quotes. --value 1.5T - suffix T converts integer to nanotokens -&gt; 1500000000. The same as --value 1500000000. Arrays can be used without [] brackets. Example of transaction creation in a multisignature wallet contract, equivalent to the example in section 4.4.1. above: $ tonos-cli callex submitTransaction 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc SetcodeMultisigWallet.abi.json k1.keys.json --dest -1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6 --value 0.234T --bounce false --allBalance false --payload &quot;&quot; Config: /home/user/tonos-cli.conf.json Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: submitTransaction params: {&quot;dest&quot;:&quot;-1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;,&quot;value&quot;:&quot;0234000000&quot;,&quot;bounce&quot;:&quot;false&quot;,&quot;allBalance&quot;:&quot;false&quot;,&quot;payload&quot;:&quot;&quot;} abi: SetcodeMultisigWallet.abi.json keys: k1.keys.json Connecting to net.ton.dev Generating external inbound message... MessageId: a38f37bfbe3c7427c869b3ee97c3b2d7f4421ca1427ace4e7a92f1a61d7ef234 Expire at: Sat, 08 May 2021 15:10:15 +0300 Processing... Succeeded. Result: { &quot;transId&quot;: &quot;6959890394123980993&quot; }  "},{"title":"4.4.3. Run contract method locally​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#443-run-contract-method-locally","content":"tonos-cli run [--abi &lt;contract.abi.json&gt;] &lt;address&gt; &lt;method&gt; &lt;params&gt;  &lt;contract.abi.json&gt; - contract interface file. &lt;address&gt; - contract address. &lt;method&gt; - the method being called. &lt;params&gt; - parameters of the called method. Example of a transaction list request in a multisignature wallet: $ tonos-cli run 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc getTransactions {} --abi SafeMultisigWallet.abi.json Config: /home/user/tonos-cli.conf.json Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: getTransactions params: {} abi: SafeMultisigWallet.abi.json keys: None lifetime: None output: None Connecting to net.ton.dev Generating external inbound message... MessageId: ff8b8a73b1a7803a735eb4f620cade78ed45fd1530992fd3bedb91f3c66eacc5 Expire at: Sat, 08 May 2021 15:16:59 +0300 Running get-method... Succeeded. Result: { &quot;transactions&quot;: [ { &quot;id&quot;: &quot;6959890394123980993&quot;, &quot;confirmationsMask&quot;: &quot;1&quot;, &quot;signsRequired&quot;: &quot;4&quot;, &quot;signsReceived&quot;: &quot;1&quot;, &quot;creator&quot;: &quot;0x849ee401fde65ad8cda6d937bdc81e2beba0f36ba2f87115f4a2d24a15568203&quot;, &quot;index&quot;: &quot;0&quot;, &quot;dest&quot;: &quot;-1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;, &quot;value&quot;: &quot;234000000&quot;, &quot;sendFlags&quot;: &quot;3&quot;, &quot;payload&quot;: &quot;te6ccgEBAQEAAgAAAA==&quot;, &quot;bounce&quot;: false } ] }  "},{"title":"4.4.4. Run funC get-method​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#444-run-func-get-method","content":"tonos-cli runget [--boc] [--tvc] &lt;address&gt; &lt;method&gt; [&lt;params&gt;...] [--bc_config &lt;config_path&gt;]  &lt;address&gt; - contract address or path to the file with: account boc (It can be obtained from the TON Live) if --boc option is used;account state init if flag --tvc is used. &lt;method&gt; - the method being called. &lt;params&gt; - parameters of the called method. Can have multiple values: one for each function parameter. Parameters should be specified separately without json wrap and argument names. --bc_config &lt;config_path&gt; - this option can be used with --boc option to specify the file with the blockchain config BOC. It can be obtained with dump blockchain config command. Example: $ tonos-cli runget -1:3333333333333333333333333333333333333333333333333333333333333333 active_election_id Config: /home/user/tonos-cli.conf.json Input arguments: address: -1:3333333333333333333333333333333333333333333333333333333333333333 method: active_election_id params: None Connecting to net.ton.dev Running get-method... Succeded. Result: [&quot;1619901678&quot;] $ tonos-cli runget --boc acc.boc compute_returned_stake 0x0166d0181a19f87af9397040a68671e1b239f12152824f7d987fd6897d6a9587 Config: /home/user/TONLabs/tonos-cli/tonos-cli.conf.json Input arguments: address: acc.boc method: compute_returned_stake params: [&quot;0x0166d0181a19f87af9397040a68671e1b239f12152824f7d987fd6897d6a9587&quot;] Connecting to main.ton.dev Running get-method... Succeeded. Result: [&quot;125387107580525&quot;] $ tonos-cli runget --tvc acc.tvc compute_returned_stake 0x0166d0181a19f87af9397040a68671e1b239f12152824f7d987fd6897d6a9587 Config: /home/user/TONLabs/tonos-cli/tonos-cli.conf.json Input arguments: address: acc.boc method: compute_returned_stake params: [&quot;0x0166d0181a19f87af9397040a68671e1b239f12152824f7d987fd6897d6a9587&quot;] Connecting to main.ton.dev Running get-method... Succeeded. Result: [&quot;125387107580525&quot;]  "},{"title":"4.4.5. Run contract method locally for saved account BOC​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#445-run-contract-method-locally-for-saved-account-boc","content":"tonos-cli run [--boc] [--tvc] [--abi &lt;contract.abi.json&gt;] &lt;account&gt; &lt;method&gt; &lt;params&gt; [--bc_config &lt;config_path&gt;]  &lt;contract.abi.json&gt; - contract interface file. &lt;account&gt; - path to the file with account boc for flag --boc or account state init for flag --tvc(they can be obtained from the network with account command). &lt;method&gt; - the method being called. &lt;params&gt; - parameters of the called method. --bc_config &lt;config_path&gt; - this option can be used with --boc option to specify the file with the blockchain config BOC. It can be obtained with dump blockchain config command. Example: $ tonos-cli run --boc tests/depool_acc.boc getData '{}' --abi tests/samples/fakeDepool.abi.json Config: /home/user/TONLabs/tonos-cli/tonos-cli.conf.json Input arguments: account: tests/depool_acc.boc method: getData params: {} abi: tests/samples/fakeDepool.abi.json Generating external inbound message... Succeeded. Result: { &quot;stake&quot;: &quot;65535&quot;, &quot;sender&quot;: &quot;0:1e0739795a20263747ba659785a791fc2761295593a694f53116ab53439cc0a4&quot;, &quot;receiver&quot;: &quot;0:0123456789012345012345678901234501234567890123450123456789012346&quot;, &quot;withdrawal&quot;: &quot;172800&quot;, &quot;total&quot;: &quot;172800&quot;, &quot;reinvest&quot;: false, &quot;value&quot;: &quot;1000000000&quot; } $ tonos-cli run --tvc tests/depool_acc.tvc getData '{}' --abi tests/samples/fakeDepool.abi.json Config: /home/user/TONLabs/tonos-cli/tonos-cli.conf.json Input arguments: account: tests/depool_acc.boc method: getData params: {} abi: tests/samples/fakeDepool.abi.json Generating external inbound message... Succeeded. Result: { &quot;stake&quot;: &quot;65535&quot;, &quot;sender&quot;: &quot;0:1e0739795a20263747ba659785a791fc2761295593a694f53116ab53439cc0a4&quot;, &quot;receiver&quot;: &quot;0:0123456789012345012345678901234501234567890123450123456789012346&quot;, &quot;withdrawal&quot;: &quot;172800&quot;, &quot;total&quot;: &quot;172800&quot;, &quot;reinvest&quot;: false, &quot;value&quot;: &quot;1000000000&quot; }  "},{"title":"4.5. Generate encrypted message offline​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#45-generate-encrypted-message-offline","content":"An internet connection is not required to create an encrypted message. Use the following command to do it: tonos-cli message [--raw] [--output &lt;path_to_file&gt;] [--abi &lt;contract.abi.json&gt;] [--sign &lt;seed_or_keyfile&gt;] &lt;address&gt; &lt;method&gt; &lt;params&gt; [--lifetime &lt;seconds&gt;]  --raw - use to create raw message boc. --output &lt;path_to_file&gt; - specify path to file where the raw message should be written to, instead of printing it to terminal. &lt;contract.abi.json&gt; - contract interface file. &lt;seed_or_keyfile&gt; - can either be the seed phrase or the corresponding key pair file. If seed phrase is used, enclose it in double quotes. Example: --sign &quot;flip uncover dish sense hazard smile gun mom vehicle chapter order enact&quot; or --sign keyfile.json &lt;address&gt; - contract address. &lt;method&gt; - the method being called. &lt;params&gt; - parameters of the called method. lifetime – message lifetime in seconds. Once this time elapses, the message will not be accepted by the contract. The TONOS-CLI utility displays encrypted message text and a QR code that also contains the message.Copy the message text or scan the QR code and broadcast the message online. Example (raw boc of create new multisig transaction message with a lifetime of 1 hour saved to file): $ tonos-cli message --raw --output message.boc --sign k1.keys.json --abi SafeMultisigWallet.abi.json 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc submitTransaction '{&quot;dest&quot;:&quot;-1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;,&quot;value&quot;:234000000,&quot;bounce&quot;:false,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;}' --lifetime 3600 Config: /home/user/tonos-cli.conf.json Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: submitTransaction params: {&quot;dest&quot;:&quot;-1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;,&quot;value&quot;:234000000,&quot;bounce&quot;:false,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;} abi: SafeMultisigWallet.abi.json keys: k1.keys.json lifetime: 3600 output: message.boc Generating external inbound message... MessageId: 59d698efe871cf9ffa8f6eb4c784b294538cd2223b4c876bb4e999a8edf8d410 Expire at: Sat, 08 May 2021 16:42:03 +0300 Message saved to file message.boc  "},{"title":"4.6. Broadcast previously generated message​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#46-broadcast-previously-generated-message","content":"Use the following command to broadcast a previously generated message, that is not in raw format, and not in a file: tonos-cli send [--abi &lt;contract.abi.json&gt;] &quot;&lt;message_text&gt;&quot;  &lt;contract.abi.json&gt; - contract interface file. Message – the content of the message generated by the TONOS-CLI utility during message creation. It should be enclosed in double quotes. Example: $ tonos-cli send --abi SafeMultisigWallet.abi.json &quot;7b226d7367223a7b226d6573736167655f6964223a2266363364666332623030373065626264386365643265333865373832386630343837326465643036303735376665373430376534393037646266663338626261222c226d657373616765223a227465366363674542424145413051414252596742534d553677767679593746624464704a365a5748706b4c7846304545726f4b4a36775165555369536633674d41514868757856507a324c5376534e663344454a2f374866653165562f5a78324d644e6b4b727770323865397a7538376a4d6e7275374c48685965367642523141756c48784b44446e4e62344f47686768386e6b6b7a48386775456e7551422f655a61324d326d32546539794234723636447a61364c34635258306f744a4b465661434177414141586c4d464e7077594a61616b524d64677332414341574f663459757151715976325233654e776d49655834517048686e37537a75624c76524838657931425a6a617a6a414141414141414141414141414141414a4d61735142414d4141413d3d222c22657870697265223a313632303438323730352c2261646472657373223a22303a61343632396436313764663933316438616438366564323466346361633364333231373838626130383235373431343466353832306632383934343933666263227d2c226d6574686f64223a227375626d69745472616e73616374696f6e227d&quot; Config: /home/user/tonos-cli.conf.json Input arguments: message: 7b226d7367223a7b226d6573736167655f6964223a2266363364666332623030373065626264386365643265333865373832386630343837326465643036303735376665373430376534393037646266663338626261222c226d657373616765223a227465366363674542424145413051414252596742534d553677767679593746624464704a365a5748706b4c7846304545726f4b4a36775165555369536633674d41514868757856507a324c5376534e663344454a2f374866653165562f5a78324d644e6b4b727770323865397a7538376a4d6e7275374c48685965367642523141756c48784b44446e4e62344f47686768386e6b6b7a48386775456e7551422f655a61324d326d32546539794234723636447a61364c34635258306f744a4b465661434177414141586c4d464e7077594a61616b524d64677332414341574f663459757151715976325233654e776d49655834517048686e37537a75624c76524838657931425a6a617a6a414141414141414141414141414141414a4d61735142414d4141413d3d222c22657870697265223a313632303438323730352c2261646472657373223a22303a61343632396436313764663933316438616438366564323466346361633364333231373838626130383235373431343466353832306632383934343933666263227d2c226d6574686f64223a227375626d69745472616e73616374696f6e227d abi: SafeMultisigWallet.abi.json Connecting to net.ton.dev MessageId: f63dfc2b0070ebbd8ced2e38e7828f04872ded060757fe7407e4907dbff38bba Expire at: Sat, 08 May 2021 17:05:05 +0300 Calling method submitTransaction with parameters: { &quot;dest&quot;: &quot;-1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;, &quot;value&quot;: &quot;1234000000&quot;, &quot;bounce&quot;: false, &quot;allBalance&quot;: false, &quot;payload&quot;: &quot;te6ccgEBAQEAAgAAAA==&quot; } Processing... Processing... Succeded. Result: { &quot;transId&quot;: &quot;6959904904053506881&quot; }  "},{"title":"4.7. Broadcast previously generated message from a file​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#47-broadcast-previously-generated-message-from-a-file","content":"Use the following command to broadcast a previously generated message, that is stored in a .boc file: tonos-cli sendfile &lt;path_to_boc_file&gt;  &lt;path_to_boc_file&gt; – path to the file where the message was saved. Example: $ tonos-cli sendfile /home/user/ton/message.boc Config: /home/user/tonos-cli.conf.json Input arguments: boc: /home/user/ton/message.boc Connecting to net.ton.dev Sending message to account 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc Succeded.  "},{"title":"4.8. Decode commands​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#48-decode-commands","content":""},{"title":"4.8.1. Decode BOC file​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#481-decode-boc-file","content":"Use the following command to decode previously generated messages in .boc files. tonos-cli decode msg --abi &lt;contract.abi.json&gt; &lt;path_to_boc_file&gt;  &lt;contract.abi.json&gt; - contract interface file. &lt;path_to_boc_file&gt; – path to the file where the message was saved. Example: $ tonos-cli decode msg --abi SafeMultisigWallet.abi.json /home/user/ton/message.boc Config: /home/user/tonos-cli.conf.json Input arguments: msg: /home/user/ton/message.boc abi: SafeMultisigWallet.abi.json &quot;Type&quot;: &quot;external inbound message&quot;, &quot;Header&quot;: { &quot;source&quot;: &quot;&quot;, &quot;destination&quot;: &quot;0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc&quot;, &quot;import_fee&quot;: &quot;0&quot; }, &quot;Body&quot;: &quot;te6ccgEBAwEAqwAB4diOBnSVls3D8/zEb/Uj6hIfwKrdG2uRyCWmWx+mpFtdbaZNBcTW3yS3QiwLR8NgoqLcqoDsGwDA/RbrJLen+wXhJ7kAf3mWtjNptk3vcgeK+ug82ui+HEV9KLSShVWggMAAAF5S//FEWCWlSsTHYLNgAQFjn+GLqkKmL9kd3jcJiHl+EKR4Z+0s7my70R/HstQWY2s4wAAAAAAAAAAAAAAAAb5R0AQCAAA=&quot;, submitTransaction: { &quot;dest&quot;: &quot;-1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;, &quot;value&quot;: &quot;234000000&quot;, &quot;bounce&quot;: false, &quot;allBalance&quot;: false, &quot;payload&quot;: &quot;te6ccgEBAQEAAgAAAA==&quot; }  "},{"title":"4.8.2. Decode message body​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#482-decode-message-body","content":"Use the following command to decode previously generated message body (can be obtained by decoding message .boc file). tonos-cli decode body --abi &lt;contract.abi.json&gt; &quot;&lt;message_body&gt;&quot;  &lt;contract.abi.json&gt; - contract interface file. &lt;message_body&gt; - Message body encoded as base64. $ tonos-cli decode body --abi SafeMultisigWallet.abi.json &quot;te6ccgEBAwEAqwAB4diOBnSVls3D8/zEb/Uj6hIfwKrdG2uRyCWmWx+mpFtdbaZNBcTW3yS3QiwLR8NgoqLcqoDsGwDA/RbrJLen+wXhJ7kAf3mWtjNptk3vcgeK+ug82ui+HEV9KLSShVWggMAAAF5S//FEWCWlSsTHYLNgAQFjn+GLqkKmL9kd3jcJiHl+EKR4Z+0s7my70R/HstQWY2s4wAAAAAAAAAAAAAAAAb5R0AQCAAA=&quot; Config: /home/user/tonos-cli.conf.json Input arguments: body: te6ccgEBAwEAqwAB4diOBnSVls3D8/zEb/Uj6hIfwKrdG2uRyCWmWx+mpFtdbaZNBcTW3yS3QiwLR8NgoqLcqoDsGwDA/RbrJLen+wXhJ7kAf3mWtjNptk3vcgeK+ug82ui+HEV9KLSShVWggMAAAF5S//FEWCWlSsTHYLNgAQFjn+GLqkKmL9kd3jcJiHl+EKR4Z+0s7my70R/HstQWY2s4wAAAAAAAAAAAAAAAAb5R0AQCAAA= abi: SafeMultisigWallet.abi.json submitTransaction: { &quot;dest&quot;: &quot;-1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;, &quot;value&quot;: &quot;234000000&quot;, &quot;bounce&quot;: false, &quot;allBalance&quot;: false, &quot;payload&quot;: &quot;te6ccgEBAQEAAgAAAA==&quot; }  "},{"title":"4.8.3. Decode account commands​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#483-decode-account-commands","content":"4.8.3.1. Decode account data fields​ Use the following command to decode data fields of the contract. tonos-cli decode account data --abi &lt;contract.abi.json&gt; --addr &lt;contract_address&gt; tonos-cli decode account data --abi &lt;contract.abi.json&gt; --tvc &lt;contract_file&gt;  &lt;contract.abi.json&gt; - contract interface file. Contract address on blockchain or path to the file with contract's StateInit can be specified with options --addr and --tvc respectively. $ tonos-cli decode account data --abi tests/test_abi_v2.1.abi.json --tvc tests/decode_fields.tvc Config: /home/user/TONLabs/tonos-cli/tonos-cli.conf.json Input arguments: tvc: tests/decode_fields.tvc abi: tests/test_abi_v2.1.abi.json TVC fields: { &quot;__pubkey&quot;: &quot;0xe8b1d839abe27b2abb9d4a2943a9143a9c7e2ae06799bd24dec1d7a8891ae5dd&quot;, &quot;__timestamp&quot;: &quot;1626254942358&quot;, &quot;fun&quot;: &quot;22&quot;, &quot;opt&quot;: &quot;48656c6c6f&quot;, &quot;big&quot;: { &quot;value0&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot;, &quot;value1&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000008&quot;, &quot;value2&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot;, &quot;value3&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot; }, &quot;a&quot;: &quot;I like it.&quot;, &quot;b&quot;: &quot;&quot;, &quot;length&quot;: &quot;0x000000000000000000000000000000000000000000000000000000000000000f&quot; }  4.8.3.2. Decode data from the account BOC file​ Use the following command to decode data from the file with BOC of the account and save StateInit to a separate file if needed. tonos-cli decode account boc &lt;boc_file&gt; [--dumptvc &lt;tvc_path&gt;]  &lt;boc_file&gt; - path to the file with BOC of the account. E.g. it can be obtained from the TON Live.--dumptvc &lt;tvc_path&gt; - this flag can be specified to dump account StateInit to the &lt;tvc_path&gt; file. $ tonos-cli decode account boc tests/account.boc --dumptvc acc.tvc Config: /home/user/TONLabs/tonos-cli/tonos-cli.conf.json Input arguments: boc: tests/account.boc tvc_path: acc.tvc address: 0:2bb4a0e8391e7ea8877f4825064924bd41ce110fce97e939d3323999e1efbb13 acc_type: Active balance: 908097175476967754 last_paid: 1626706323 last_trans_lt: 246923000003 code_hash: 4e92716de61d456e58f16e4e867e3e93a7548321eace86301b51c8b80ca6239b state_init: split_depth: None special: None data: te6ccgEBAgEAUAABQZXAaqdD0fkADdZLdUmPEGr0t+dEQjTX3mfqJpiPYYHf4AEAU6AFqBJgJG7Ncw9arsqLrQ5Aoeenp6RgXcbQ7vUibecz0mAAAAAMHrI00A== code: te6ccgECFAEAA6EAAib/APSkICLAAZL0oOGK7VNYMPShAwEBCvSkIPShAgAAAgEgBgQB/P9/Ie1E0CDXScIBn9P/0wD0Bfhqf/hh+Gb4Yo4b9AVt+GpwAYBA9A7yvdcL//hicPhjcPhmf/hh4tMAAY4SgQIA1xgg+QFY+EIg+GX5EPKo3iP4QvhFIG6SMHDeuvLgZSHTP9MfNDH4IyEBvvK5IfkAIPhKgQEA9A4gkTHeswUATvLgZvgAIfhKIgFVAcjLP1mBAQD0Q/hqIwRfBNMfAfAB+EdukvI83gIBIAwHAgFYCwgBCbjomPxQCQH++EFujhLtRNDT/9MA9AX4an/4Yfhm+GLe0XBtbwL4SoEBAPSGlQHXCz9/k3BwcOKRII43IyMjbwJvIsgizwv/Ic8LPzExAW8iIaQDWYAg9ENvAjQi+EqBAQD0fJUB1ws/f5NwcHDiAjUzMehfA8iCEHdEx+KCEIAAAACxzwsfIQoAom8iAssf9ADIglhgAAAAAAAAAAAAAAAAzwtmgQOYIs8xAbmWcc9AIc8XlXHPQSHN4iDJcfsAWzDA/44S+ELIy//4Rs8LAPhKAfQAye1U3n/4ZwDFuRar5/8ILdHG3aiaBBrpOEAz+n/6YB6Avw1P/ww/DN8MUcN+gK2/DU4AMAgegd5XuuF//wxOHwxuHwzP/ww8W98I0l5Gcm4/DNxfABo/CFkZf/8I2eFgHwlAPoAZPaqP/wzwAgEgDw0B17sV75NfhBbo4S7UTQ0//TAPQF+Gp/+GH4Zvhi3vpA1w1/ldTR0NN/39cMAJXU0dDSAN/RIiIic8hxzwsBIs8KAHPPQCTPFiP6AoBpz0Byz0AgySL7AF8F+EqBAQD0hpUB1ws/f5NwcHDikSCA4Ako4t+CMiAbuf+EojASEBgQEA9FswMfhq3iL4SoEBAPR8lQHXCz9/k3BwcOICNTMx6F8DXwP4QsjL//hGzwsA+EoB9ADJ7VR/+GcCASAREADHuORhh18ILdHCXaiaGn/6YB6Avw1P/ww/DN8MW9qaPwhfCKQN0kYOG9deXAy/AB8IWRl//wjZ4WAfCUA+gBk9qp8B5B9ghBodo92qfgBGHwhZGX//CNnhYB8JQD6AGT2qj/8M8AIC2hMSAC2vhCyMv/+EbPCwD4SgH0AMntVPgP8gCAB1pwIccAnSLQc9ch1wsAwAGQkOLgIdcNH5LyPOFTEcAAkODBAyKCEP////28sZLyPOAB8AH4R26S8jzeg= lib:  "},{"title":"4.8.4. Decode stateInit fields​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#484-decode-stateinit-fields","content":"StateInit can be decoded for network account or file with account BOC or TVC. tonos-cli decode stateinit [--tvc] [--boc] &lt;input&gt;  &lt;input&gt; - depending on the flags this parameter should contain: path to the file with account BOC if --boc flag is specified;path to the TVC file if --tvc flag is specified;contract network address otherwise. $ tonos-cli decode stateinit --boc account.boc Config: /home/user/TONLabs/tonos-cli/tonos-cli.conf.json Input arguments: input: account.boc Decoded data: { &quot;split_depth&quot;: &quot;None&quot;, &quot;special&quot;: &quot;None&quot;, &quot;data&quot;: &quot;te6ccgEBAgEAkQABowWvkA5qHmFvsIUxqyOHGegsw+mhvvuZc5taNDPm+bI8AAABfFtnzLOAAAAAAAAAAEAMpbXqnWxVq2MH9mu2c3ABPAlgHxYzBcVVGea3KTKb6UgBAHOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAO5rKAI&quot;, &quot;code&quot;: &quot;te6ccgECKwEABs0ABCSK7VMg4wMgwP/jAiDA/uMC8gsoAgEqAuDtRNDXScMB+GaNCGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAT4aSHbPNMAAZ+BAgDXGCD5AVj4QvkQ8qje0z8B+EMhufK0IPgjgQPoqIIIG3dAoLnytPhj0x8B+CO88rnTHwHbPPI8CwMDUu1E0NdJwwH4ZiLQ0wP6QDD4aak4ANwhxwDjAiHXDR/yvCHjAwHbPPI8JycDAiggghB7lnbGu+MCIIIQf7YUIrrjAgYEAh4w+Eby4EzT/9HbPOMA8gAFJQAKcrYJ8vAEUCCCEBM3c0q74wIgghBJt6tBu+MCIIIQaETH67vjAiCCEHuWdsa74wIcEwwHBFAgghBotV8/uuMCIIIQcXluqLrjAiCCEHTvWym64wIgghB7lnbGuuMCChYICAMoMPhG8uBM+EJu4wDTP9HbPNs88gAjCSUAcPhJ+Gtopv5g+HD4anAg+EnIz4WIzo0FkB1vNFQAAAAAAAAAAAAAAAAAH4hPIkDPFssfyz/JcPsAAiIw+EJu4wD4RvJz0fgA2zzyAAslAfTtRNDXScIBio5vcO1E0PQFcPhqjQhgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE+GuNCGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAT4bHD4bXD4bnD4b3D4cIBA9A7yvdcL//hicPhj4iMEUCCCEE5mPkG64wIgghBX1CDIuuMCIIIQaBC/TrrjAiCCEGhEx+u64wIRFA8NAyQw+Eby4Ez4Qm7jANHbPNs88gAjDiUAFPhJ+Gtopv5g+HADSjD4RvLgTPhCbuMA+kGV1NHQ+kDf1w0/ldTR0NM/39HbPNs88gAjECUAdPhJ+Gtopv5g+HD4avhscCD4ScjPhYjOjQWQHW80VAAAAAAAAAAAAAAAAAAfiE8iQM8Wyx/LP8lw+wACGjD4RvLgTNHbPOMA8gASJQAybXCVIIEnD7ueVHABWMjL/1mBAQD0QzLoWwRQIIIQKICYI7rjAiCCEDsU9ku64wIgghBAegYiuuMCIIIQSberQbrjAhoYFhQDNjD4RvLgTPhCbuMA+kGV1NHQ+kDf0ds82zzyACMVJQBc+GxwIPhJyM+FiM6NBZAdbzRUAAAAAAAAAAAAAAAAAB+ITyJAzxbLH8s/yXD7AANiMPhG8uBM+EJu4wDTP/pBldTR0PpA39cNH5XU0dDTH9/XDR+V1NHQ0x/f0ds82zzyACMXJQCE+En4a2im/mD4cFUC+GpY+GwB+G34bnAg+EnIz4WIzo0FkB1vNFQAAAAAAAAAAAAAAAAAH4hPIkDPFssfyz/JcPsAA5Aw+Eby4Ez4Qm7jANHbPCeOLynQ0wH6QDAxyM+HIM5xzwthXmDIz5LsU9kuyz/OVUDIzssfyx/KAMt/zc3JcPsAkl8H4uMA8gAjGSUAHPhK+Ev4TPhN+E74T/hQAyQw+Eby4Ez4Qm7jANHbPNs88gAjGyUA1vhJ+Gtopv5g+HD4ScjPhYjOi/F7AAAAAAAAAAAAAAAAABDPFslx+wCNCGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABSNBXAAAAAAAAAAAAAAAAARRY3EgAAAAGDIzs7JcPsABE4ggghUryu64wIgghAKrBj9uuMCIIIQEvQDcLrjAiCCEBM3c0q64wIkIR8dAyQw+Eby4Ez4Qm7jANHbPNs88gAjHiUAcvhJ+Gtopv5g+HB/+G9wIPhJyM+FiM6NBZAdbzRUAAAAAAAAAAAAAAAAAB+ITyJAzxbLH8s/yXD7AAMkMPhG8uBM+EJu4wDR2zzbPPIAIyAlAHL4SfhraKb+YPhwcPhvcCD4ScjPhYjOjQWQHW80VAAAAAAAAAAAAAAAAAAfiE8iQM8Wyx/LP8lw+wADKDD4RvLgTPhCbuMA0z/R2zzbPPIAIyIlAHb4avhJ+Gtopv5g+HCBAN6AC/hJyM+FiM6NBZAdbzRUAAAAAAAAAAAAAAAAAB+ITyJAzxbLH8s/yXD7AABc7UTQ0//TP9MAMdM/+kDU0dD6QNMf0x/SANN/0fhw+G/4bvht+Gz4a/hq+GP4YgIaMPhG8uBM0ds84wDyACYlAFj4UPhP+E74TfhM+Ev4SvhD+ELIy//LP8+Dyz/OVUDIzssfyx/KAMt/zcntVABcgQDegAv4ScjPhYjOjQVOYloAAAAAAAAAAAAAAAAAAB+ITyJAzxbLH8s/yXD7AAAK+Eby4EwCCvSkIPShKikAFHNvbCAwLjUxLjAAAA==&quot;, &quot;code_hash&quot;: &quot;82236b6062da156069b3cbf5020daf1a17b76869d676df216177fca950ab37df&quot;, &quot;data_hash&quot;: &quot;7197d8544363ac2b2718240a84448584a675727ec8d42efd3726e82a4c8a3853&quot;, &quot;code_depth&quot;: &quot;7&quot;, &quot;data_depth&quot;: &quot;1&quot;, &quot;version&quot;: &quot;sol 0.51.0&quot;, &quot;lib&quot;: &quot;&quot; } $ tonos-cli decode stateinit --tvc fakeDepool.tvc Config: default Input arguments: input: fakeDepool.tvc Decoded data: { &quot;split_depth&quot;: &quot;None&quot;, &quot;special&quot;: &quot;None&quot;, &quot;data&quot;: &quot;te6ccgEBAgEAKAABAcABAEPQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAg&quot;, &quot;code&quot;: &quot;te6ccgECKwEABs0ABCSK7VMg4wMgwP/jAiDA/uMC8gsoAgEqAuDtRNDXScMB+GaNCGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAT4aSHbPNMAAZ+BAgDXGCD5AVj4QvkQ8qje0z8B+EMhufK0IPgjgQPoqIIIG3dAoLnytPhj0x8B+CO88rnTHwHbPPI8CwMDUu1E0NdJwwH4ZiLQ0wP6QDD4aak4ANwhxwDjAiHXDR/yvCHjAwHbPPI8JycDAiggghB7lnbGu+MCIIIQf7YUIrrjAgYEAh4w+Eby4EzT/9HbPOMA8gAFJQAKcrYJ8vAEUCCCEBM3c0q74wIgghBJt6tBu+MCIIIQaETH67vjAiCCEHuWdsa74wIcEwwHBFAgghBotV8/uuMCIIIQcXluqLrjAiCCEHTvWym64wIgghB7lnbGuuMCChYICAMoMPhG8uBM+EJu4wDTP9HbPNs88gAjCSUAcPhJ+Gtopv5g+HD4anAg+EnIz4WIzo0FkB1vNFQAAAAAAAAAAAAAAAAAH4hPIkDPFssfyz/JcPsAAiIw+EJu4wD4RvJz0fgA2zzyAAslAfTtRNDXScIBio5vcO1E0PQFcPhqjQhgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE+GuNCGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAT4bHD4bXD4bnD4b3D4cIBA9A7yvdcL//hicPhj4iMEUCCCEE5mPkG64wIgghBX1CDIuuMCIIIQaBC/TrrjAiCCEGhEx+u64wIRFA8NAyQw+Eby4Ez4Qm7jANHbPNs88gAjDiUAFPhJ+Gtopv5g+HADSjD4RvLgTPhCbuMA+kGV1NHQ+kDf1w0/ldTR0NM/39HbPNs88gAjECUAdPhJ+Gtopv5g+HD4avhscCD4ScjPhYjOjQWQHW80VAAAAAAAAAAAAAAAAAAfiE8iQM8Wyx/LP8lw+wACGjD4RvLgTNHbPOMA8gASJQAybXCVIIEnD7ueVHABWMjL/1mBAQD0QzLoWwRQIIIQKICYI7rjAiCCEDsU9ku64wIgghBAegYiuuMCIIIQSberQbrjAhoYFhQDNjD4RvLgTPhCbuMA+kGV1NHQ+kDf0ds82zzyACMVJQBc+GxwIPhJyM+FiM6NBZAdbzRUAAAAAAAAAAAAAAAAAB+ITyJAzxbLH8s/yXD7AANiMPhG8uBM+EJu4wDTP/pBldTR0PpA39cNH5XU0dDTH9/XDR+V1NHQ0x/f0ds82zzyACMXJQCE+En4a2im/mD4cFUC+GpY+GwB+G34bnAg+EnIz4WIzo0FkB1vNFQAAAAAAAAAAAAAAAAAH4hPIkDPFssfyz/JcPsAA5Aw+Eby4Ez4Qm7jANHbPCeOLynQ0wH6QDAxyM+HIM5xzwthXmDIz5LsU9kuyz/OVUDIzssfyx/KAMt/zc3JcPsAkl8H4uMA8gAjGSUAHPhK+Ev4TPhN+E74T/hQAyQw+Eby4Ez4Qm7jANHbPNs88gAjGyUA1vhJ+Gtopv5g+HD4ScjPhYjOi/F7AAAAAAAAAAAAAAAAABDPFslx+wCNCGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABSNBXAAAAAAAAAAAAAAAAARRY3EgAAAAGDIzs7JcPsABE4ggghUryu64wIgghAKrBj9uuMCIIIQEvQDcLrjAiCCEBM3c0q64wIkIR8dAyQw+Eby4Ez4Qm7jANHbPNs88gAjHiUAcvhJ+Gtopv5g+HB/+G9wIPhJyM+FiM6NBZAdbzRUAAAAAAAAAAAAAAAAAB+ITyJAzxbLH8s/yXD7AAMkMPhG8uBM+EJu4wDR2zzbPPIAIyAlAHL4SfhraKb+YPhwcPhvcCD4ScjPhYjOjQWQHW80VAAAAAAAAAAAAAAAAAAfiE8iQM8Wyx/LP8lw+wADKDD4RvLgTPhCbuMA0z/R2zzbPPIAIyIlAHb4avhJ+Gtopv5g+HCBAN6AC/hJyM+FiM6NBZAdbzRUAAAAAAAAAAAAAAAAAB+ITyJAzxbLH8s/yXD7AABc7UTQ0//TP9MAMdM/+kDU0dD6QNMf0x/SANN/0fhw+G/4bvht+Gz4a/hq+GP4YgIaMPhG8uBM0ds84wDyACYlAFj4UPhP+E74TfhM+Ev4SvhD+ELIy//LP8+Dyz/OVUDIzssfyx/KAMt/zcntVABcgQDegAv4ScjPhYjOjQVOYloAAAAAAAAAAAAAAAAAAB+ITyJAzxbLH8s/yXD7AAAK+Eby4EwCCvSkIPShKikAFHNvbCAwLjUxLjAAAA==&quot;, &quot;code_hash&quot;: &quot;82236b6062da156069b3cbf5020daf1a17b76869d676df216177fca950ab37df&quot;, &quot;data_hash&quot;: &quot;55a703465a160dce20481375de2e5b830c841c2787303835eb5821d62d65ca9d&quot;, &quot;code_depth&quot;: &quot;7&quot;, &quot;data_depth&quot;: &quot;1&quot;, &quot;version&quot;: &quot;sol 0.51.0&quot;, &quot;lib&quot;: &quot;&quot; } $ tonos-cli decode stateinit 989439e29664a71e57a21bff0ff9896b5e58018fcac32e83fade913c4f43479e Config: /home/user/TONLabs/tonos-cli/tonos-cli.conf.json Input arguments: input: 989439e29664a71e57a21bff0ff9896b5e58018fcac32e83fade913c4f43479e Connecting to http://127.0.0.1/ Decoded data: { &quot;split_depth&quot;: &quot;None&quot;, &quot;special&quot;: &quot;None&quot;, &quot;data&quot;: &quot;te6ccgEBAQEASwAAkWOlCuhADbJ3v+8vaQu9RUczWADX7uP05UFjmpt/sOAVAAABfF7iC8SAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMsA=&quot;, &quot;code&quot;: &quot;te6ccgECDwEAAakABCSK7VMg4wMgwP/jAiDA/uMC8gsMAgEOApztRNDXScMB+GYh2zzTAAGOEoECANcYIPkBWPhCIPhl+RDyqN7TPwH4QyG58rQg+COBA+iogggbd0CgufK0+GPTHwH4I7zyudMfAds88jwFAwNK7UTQ10nDAfhmItDXCwOpOADcIccA4wIh1w0f8rwh4wMB2zzyPAsLAwM8IIIQJe+yCLrjAiCCEETv7Oy64wIgghBotV8/uuMCBwYEAkgw+EJu4wD4RvJz0fhC8uBl+EUgbpIwcN74Qrry4Gb4ANs88gAFCAFK7UTQ10nCAYqOGnDtRND0BXD4aoBA9A7yvdcL//hicPhjcPhq4goBUDDR2zz4SiGOHI0EcAAAAAAAAAAAAAAAADE7+zsgyM7L/8lw+wDe8gAKAygw+Eby4Ez4Qm7jANP/0ds82zzyAAoJCAAk+Er4Q/hCyMv/yz/Pg8v/ye1UACr4RSBukjBw3vhCuvLgZvgA+Eqg+GoAJu1E0NP/0z/TADHT/9H4avhj+GIACvhG8uBMAgr0pCD0oQ4NABRzb2wgMC41MS4wAAA=&quot;, &quot;code_hash&quot;: &quot;d840258803b9d7472f2d959a5db7bb42d246f5e8f0dc6a94bb459ebb730a0e01&quot;, &quot;data_hash&quot;: &quot;0ea45bfc864790ee1d66301059fa2cbdaba7a75e9e4f4bc1d2fbffd8401ee798&quot;, &quot;code_depth&quot;: &quot;5&quot;, &quot;data_depth&quot;: &quot;0&quot;, &quot;version&quot;: &quot;sol 0.51.0&quot;, &quot;lib&quot;: &quot;&quot; }  "},{"title":"4.9. Generate payload for internal function call​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#49-generate-payload-for-internal-function-call","content":"Use the following command to generate payload for internal function call: tonos-cli body [--abi &lt;contract.abi.json&gt;] &lt;method&gt; &lt;params&gt;  &lt;contract.abi.json&gt; - contract interface file. &lt;method&gt; - the method being called. &lt;params&gt; - parameters of the called method. Example: $ tonos-cli body submitTransaction '{&quot;dest&quot;:&quot;-1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;,&quot;value&quot;:234000000,&quot;bounce&quot;:false,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;}' --abi SetcodeMultisigWallet.abi.json Config: /home/user/tonos-cli.conf.json Input arguments: method: submitTransaction params: {&quot;dest&quot;:&quot;-1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;,&quot;value&quot;:234000000,&quot;bounce&quot;:false,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;} abi: SetcodeMultisigWallet.abi.json output: None Message body: te6ccgEBAgEAOwABaxMdgs2f4YuqQqYv2R3eNwmIeX4QpHhn7SzubLvRH8ey1BZjazjAAAAAAAAAAAAAAAABvlHQBAEAAA==  "},{"title":"4.10. Alternative syntax for call, deploy and run commands​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#410-alternative-syntax-for-call-deploy-and-run-commands","content":"To facilitate usage of tonos-cli use commands callx, runx and deployx instead of call, run and deploy. These alternative syntax commands have almost the same syntax as classic, but allow to specify address, abi and keys options in the config file. Also, this commands allow to skip params option if command doesn't need it. Examples: # specify options manually tonos-cli callx --keys giver.key --abi giver.abi.json --addr 0:841288ed3b55d9cdafa806807f02a0ae0c169aa5edfe88a789a6482429756a94 sendGrams --dest 841288ed3b55d9cdafa806807f02a0ae0c169aa5edfe88a789a6482429756a94 --amount 1000000000 # options are taken from the config tonos-cli config --abi giver.abi.json --addr 0:841288ed3b55d9cdafa806807f02a0ae0c169aa5edfe88a789a6482429756a94 --keys giver.key tonos-cli callx sendGrams --dest 841288ed3b55d9cdafa806807f02a0ae0c169aa5edfe88a789a6482429756a94 --amount 1000000000 # if contract function or constructor doesn't take arguments, parameters can be skipped tonos-cli deployx contract.tvc tonos-cli runx getParameters  5. DeBot commands TONOS-CLI has a built-in DeBot browser, which is regularly updated with the most recent versions of DEngine. To call a DeBot, use the following command: tonos-cli debot fetch &lt;--debug&gt; &lt;debot_address&gt;  &lt;debot_address&gt; - address of the DeBot contract. &lt;--debug&gt; - runs DeBot in verbose mode. Example: $ tonos-cli debot fetch 0:09403116d2d04f3d86ab2de138b390f6ec1b0bc02363dbf006953946e807051e Config: /home/user/tonos-cli.conf.json Connecting to net.ton.dev DeBot Info: Name : Multisig Version: 1.2.0 Author : TON Labs Publisher: TON Labs Support: 0:66e01d6df5a8d7677d9ab2daf7f258f1e2a7fe73da5320300395f99e01dc3b5f Description: DeBot for multisig wallets Hi, I will help you work with multisig wallets that can have multiple custodians. Run the DeBot (y/n)? y Which wallet do you want to work with?  Further input depends on the DeBot, which usually explains any actions it offers you to perform. 6. Multisig commands Multisig commands allow you to work with any existing Multisig wallets in a more convenient way and with no need of ABI files. "},{"title":"6.1. Send tokens​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#61-send-tokens","content":"Use the following command to send tokens to any recipient: tonos-cli multisig send --addr &lt;sender_address&gt; --dest &lt;recipient_address&gt; --purpose &lt;&quot;text_in_quotes&quot;&gt; --sign &lt;path_to_keys_or_seed_phrase&gt; --value *number*  &lt;sender_address&gt; - address of the multisig wallet that tokens are sent from. &lt;recipient_address&gt; - address of the account tokens are sent to. &lt;&quot;text_in_quotes&quot;&gt; - accompanying message. Only the recipient will be able to decrypt and read it. &lt;path_to_keys_or_seed_phrase&gt; - path to sender wallet key file or the corresponding seed phrase in quotes. --value *number* - value to be transferred (in tokens). Example: $ tonos-cli multisig send --addr 0:255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f3 --dest 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc --purpose &quot;test transaction&quot; --sign key.json --value 6 Config: /home/user/tonos-cli.conf.json Connecting to net.ton.dev Generating external inbound message... MessageId: 62b1420ac98e586f29bf79bc2917a0981bb3f15c4757e8dca65370c19146e327 Expire at: Thu, 13 May 2021 13:26:06 +0300 Processing... Succeeded. Result: { &quot;transId&quot;: &quot;0&quot; }.  6.2. Deploy wallet Use the following command to deploy a multisignature wallet: tonos-cli multisig deploy [--setcode] [--owners &lt;owners_list&gt;] [--confirms &lt;confirms_cnt&gt;] [--local &lt;local_giver_value&gt;] --keys &lt;path_to_keys_or_seed_phrase&gt;  --setcode - flag that changes type of the wallet to the SetcodeMultisigWallet. If not specified, a SafeMultisigWallet is deployed. --owners &lt;owners_list&gt; - option that sets wallet owners. If not specified, the only owner is deploy signed (set with --keys option). List of owners must be specified by their public keys in hex format, split by the ,. --confirms &lt;confirms_cnt&gt; - option that sets required number of confirmations. If not specified, is set to 1. --local &lt;local_giver_value&gt; - value that should be transferred from the local giver if wallet is deployed onto the Node SE (in nanotons). --keys &lt;path_to_keys_or_seed_phrase&gt; - path to the wallet key file or the corresponding seed phrase in quotes. Example: $ tonos-cli multisig deploy -k &quot;young tell target alter sport dignity enforce improve pottery fashion alert genuine&quot; --local 1_000_000_000 Config: /home/user/TONLabs/tonos-cli/tonos-cli.conf.json Wallet address: 0:4d892e63989c1c0ad64b0bbe22e8d036b0da271c19b6686d01bd29a99dcbc86d Connecting to http://127.0.0.1/ Expire at: Mon, 13 Sep 2021 14:55:29 +0300 MessageId: 3c3537e36e2a4a4018b7463db2bf57efad5dc0dc0233b040c2f5e165cb43e887 MessageId: 8102067efc190b2e728d91d632c985634fc4717b7ae1137a4bbcf756c4cf8705 Wallet successfully deployed Wallet address: 0:4d892e63989c1c0ad64b0bbe22e8d036b0da271c19b6686d01bd29a99dcbc86d # deploy with owners tonos-cli multisig deploy -l 5000000000 -c 2 -o 8b445b0feab10b9abf4e039d649348ec8662e3673fe9c37b7208c4d9d04c9b3f,ddc5bc7198c90feb75d9ce09e1b1f25a7e14a252fef31b50fac048c6ac3ee46c -k test.key  7. DePool commands "},{"title":"7.1. Configure TONOS-CLI for DePool operations​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#71-configure-tonos-cli-for-depool-operations","content":"For all commands listed below, the DePool address, the wallet making the stake, the amount of fee to pay for DePool's services and the path to the keyfile/seed phrase may be specified in the TONOS-CLI config file in advance: tonos-cli config --addr &lt;address&gt; --wallet &lt;address&gt; --no-answer true | false --keys &lt;path_to_keys or seed_phrase&gt; --depool_fee &lt;depool_fee&gt;  --addr &lt;address&gt; - the address of the DePool --wallet &lt;address&gt; - the address of the wallet making the stake --no-answer true | false - no-answer flag, which determines, whether TONOS-CLI waits for DePool answer when performing various actions and prints it out, or simply generates and sends a transaction through the specified multisig wallet, without monitoring transaction results in the DePool. By default is set to true. Setting to false can be useful for catching rejected stakes or other errors on the DePool side. &lt;path_to_keys or seed_phrase&gt; - either the keyfile for the wallet making the stake, or the seed phrase in quotes --depool_fee &lt;depool_fee&gt; - value in tons, that is additionally attached to the message sent to the DePool to cover its fees. Change is returned to the sender. The default value, used if this option isn't configured, is 0.5 tons. It should be increased only if it proves insufficient and DePool begins to run out of gas on execution. Example: tonos-cli config --addr 0:37fbcb6e3279cbf5f783d61c213ed20fee16e0b1b94a48372d20a2596b700ace --wallet 0:1b91c010f35b1f5b42a05ad98eb2df80c302c37df69651e1f5ac9c69b7e90d4e --no-answer false --keys &quot;dizzy modify exotic daring gloom rival pipe disagree again film neck fuel&quot; --depool_fee 0.8  In this case all DePool commands allow to omit --addr, --wallet, --wait-answer and --sign options. Below is an example of similar DePool commands with and without waiting for DePool answer. With waiting for DePool answer: $ tonos-cli depool --addr 0:127ae93241278304fff6b7e5b7b182fd382b6e95b200551061a7354e032e50bf stake ordinary --value 25 --wallet 0:255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f3 --sign key.json --wait-answer Config: /home/user/tonos-cli.conf.json Input arguments: depool: 0:127ae93241278304fff6b7e5b7b182fd382b6e95b200551061a7354e032e50bf wallet: 0:255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f3 stake: 25 keys: key.json Connecting to https://net.ton.dev Generating external inbound message... MessageId: bf3cfc02dd8eff3edbd7a70e63ce3e91e61340676bf46c43cf534ccbebc9865a Expire at: unknown Multisig message processing... Message was successfully sent to the multisig, waiting for message to be sent to the depool... Request was successfully sent to depool. Waiting for depool answer... Answer: Id: 453c03c3ad4985330237ed16998e3f7a5b6936c717b2aac753967fd9c03f2926 Value: 25.489215000 Created at: 1620907654 (2021-05-13 12:07:34.000) Decoded body: receiveAnswer {&quot;errcode&quot;:&quot;1&quot;,&quot;comment&quot;:&quot;100000000000&quot;} Answer status: STAKE_TOO_SMALL Comment: 100000000000 Done  Same command without waiting for DePool answer: $ tonos-cli depool --addr 0:127ae93241278304fff6b7e5b7b182fd382b6e95b200551061a7354e032e50bf stake ordinary --value 25 --wallet 0:255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f3 --sign key.json Config: /home/user/tonos-cli.conf.json Input arguments: depool: 0:127ae93241278304fff6b7e5b7b182fd382b6e95b200551061a7354e032e50bf wallet: 0:255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f3 stake: 25 keys: key.json Connecting to https://net.ton.dev Generating external inbound message... MessageId: e1b0aba39233e07daf6a65c2426e273e9d68a75e3b440893251fbce56c6a756d Expire at: Thu, 13 May 2021 15:09:43 +0300 Processing... Succeeded. Result: { &quot;transId&quot;: &quot;0&quot; }  In both cases the stake is rejected for being too small, but with no-answer set to false it isn't immediately apparent, as only the results of the sussecful multisig transaction are displayed. "},{"title":"7.2. Deposit stakes​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#72-deposit-stakes","content":""},{"title":"7.2.1. Ordinary stake​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#721-ordinary-stake","content":"Ordinary stake is the most basic type of stake. It and the rewards from it belong to the wallet that made it. It is invested completely in the current pooling round, and can be reinvested every second round (as odd and even rounds are handled by DePool separately). Thus to participate in every DePool round, an ordinary stake should be invested in two consecutive rounds, so it can later be reinvested in odd and even rounds both. Ordinary stake must exceed DePool minimum stake. Check DePool's page on ton.live to find out the minimum stake. tonos-cli depool [--addr &lt;depool_address&gt;] stake ordinary [--wallet &lt;msig_address&gt;] --value &lt;number&gt; [--sign &lt;key_file or seed_phrase&gt;] [--wait-answer]  &lt;depool_address&gt; - address of the DePool contract. &lt;msig_address&gt; - address of the wallet making a stake. all --value parameters must be defined in tons, like this: --value 10.5, which means the value is 10,5 tons. &lt;key_file or seed_phrase&gt; - either the keyfile for the wallet making the stake, or the seed phrase in quotes. --wait-answer - optional flag, which forces TONOS-CLI to wait for DePool answer when performing the action and print out the resulting message. Without it only the results of the multisig transaction to DePool will be displayed. Example: tonos-cli depool --addr 0:37fbcb6e3279cbf5f783d61c213ed20fee16e0b1b94a48372d20a2596b700ace stake ordinary --wallet 0:1b91c010f35b1f5b42a05ad98eb2df80c302c37df69651e1f5ac9c69b7e90d4e --value 100.5 --sign &quot;dizzy modify exotic daring gloom rival pipe disagree again film neck fuel&quot;  "},{"title":"7.2.2. Vesting stake​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#722-vesting-stake","content":"A wallet can make a vesting stake and define a target participant address (beneficiary) who will own this stake, provided the beneficiary has previously indicated the donor as its vesting donor address. This condition prevents unauthorized vestings from blocking the beneficiary from receiving an expected vesting stake from a known address. To receive a vesting stake beneficiary must: already have an ordinary stake of any amount in the DePoolset the donor address with the following command: tonos-cli depool [--addr &lt;depool_address&gt;] donor vesting [--wallet &lt;beneficiary_address&gt;] --donor &lt;donor_address&gt; [--sign &lt;key_file or seed_phrase&gt;] [--wait-answer]  &lt;depool_address&gt; - address of the DePool contract. &lt;beneficiary_address&gt; - address of the beneficiary wallet . &lt;donor_address&gt; - address of the donor wallet. &lt;key_file or seed_phrase&gt; - either the keyfile for the beneficiary wallet, or the seed phrase in quotes. --wait-answer - optional flag, which forces TONOS-CLI to wait for DePool answer when performing the action and print out the resulting message. Without it only the results of the multisig transaction to DePool will be displayed. Example: tonos-cli depool --addr 0:3187b4d738d69776948ca8543cb7d250c042d7aad1e0aa244d247531590b9147 donor vesting --wallet 0:255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f3 --donor 0:279afdbd7b2cbf9e65a5d204635a8630aec2baec60916ffdc9c79a09d2d2893d --sign &quot;deal hazard oak major glory meat robust teach crush plastic point edge&quot;  Not the whole stake is available to the beneficiary at once. Instead it is split into parts and the next part of stake becomes available to the beneficiary (is transformed into beneficiary's ordinary stake) at the end of the round that coincides with the end of the next withdrawal period. Rewards from vesting stake are always added to the beneficiary's ordinary stake. To withdraw these funds, beneficiary should use use one of the withdrawal functions. Please note, that the vesting stake is split into two equal parts by the DePool, to be used in both odd and even rounds, so to ensure DePool can participate in elections with just one vesting stake where validator wallet is beneficiary, the stake should exceed validatorAssurance 2. Similarly, to ensure any vesting stake is accepted, make sure it exceeds minStake 2. Donor uses the following command to make a vesting stake: tonos-cli depool [--addr &lt;depool_address&gt;] stake vesting [--wallet &lt;msig_address&gt;] --value &lt;number&gt; --total &lt;days&gt; --withdrawal &lt;days&gt; --beneficiary &lt;address&gt; [--sign &lt;key_file or seed_phrase&gt;] [--wait-answer]  Where &lt;depool_address&gt; - address of the DePool contract. &lt;msig_address&gt; - address of the donor wallet making a stake. all --value parameters must be defined in tons, like this: --value 10.5, which means the value is 10,5 tons. total &lt;days&gt; - total period, for which the stake is made. withdrawal &lt;days&gt; - withdrawal period (each time a withdrawal period ends, a portion of the stake is released to the beneficiary). There are limitations for period settings: withdrawalPeriod should be &lt;= totalPeriod, totalPeriod cannot exceed 18 years or be &lt;=0, totalPeriod should be exactly divisible by withdrawalPeriod. beneficiary &lt;address&gt; - address of the beneficiary (wallet that will receive rewards from the stake and, in parts over time, the vesting stake itself). Cannot be the same as the wallet making the stake. &lt;key_file or seed_phrase&gt; - either the keyfile for the donor wallet making the stake, or the seed phrase in quotes. --wait-answer - optional flag, which forces TONOS-CLI to wait for DePool answer when performing the action and print out the resulting message. Without it only the results of the multisig transaction to DePool will be displayed. Example: tonos-cli depool --addr 0:37fbcb6e3279cbf5f783d61c213ed20fee16e0b1b94a48372d20a2596b700ace stake vesting --wallet 0:1b91c010f35b1f5b42a05ad98eb2df80c302c37df69651e1f5ac9c69b7e90d4e --value 1000 --total 360 --withdrawal 30 --beneficiary 0:f22e02a1240dd4b5201f8740c38f2baf5afac3cedf8f97f3bd7cbaf23c7261e3 --sign &quot;dizzy modify exotic daring gloom rival pipe disagree again film neck fuel&quot;  Note: Each participant can concurrently be the beneficiary of only one vesting stake. Once the current vesting stake expires, another can be made for the participant. "},{"title":"7.2.3. Lock stake​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#723-lock-stake","content":"A wallet can make a lock stake, in which it locks its funds in DePool for a defined period, but rewards from this stake will be payed to another target participant (beneficiary). As with vesting, the beneficiary has to indicate the donor as its lock donor address before receiving a lock stake. This condition prevents unauthorized lock stakes from blocking the beneficiary from receiving an expected lock stake from a known address. To receive a lock stake beneficiary must: already have an ordinary stake of any amount in the DePoolset the donor address with the following command: tonos-cli depool [--addr &lt;depool_address&gt;] donor lock [--wallet &lt;beneficiary_address&gt;] --donor &lt;donor_address&gt; [--sign &lt;key_file or seed_phrase&gt;] [--wait-answer]  Where &lt;depool_address&gt; - address of the DePool contract. &lt;beneficiary_address&gt; - address of the beneficiary wallet . &lt;donor_address&gt; - address of the donor wallet. &lt;key_file or seed_phrase&gt; - either the keyfile for the beneficiary wallet, or the seed phrase in quotes. --wait-answer - optional flag, which forces TONOS-CLI to wait for DePool answer when performing the action and print out the resulting message. Without it only the results of the multisig transaction to DePool will be displayed. Example: tonos-cli depool --addr 0:3187b4d738d69776948ca8543cb7d250c042d7aad1e0aa244d247531590b9147 donor lock --wallet 0:255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f3 --donor 0:279afdbd7b2cbf9e65a5d204635a8630aec2baec60916ffdc9c79a09d2d2893d --sign &quot;deal hazard oak major glory meat robust teach crush plastic point edge&quot;  Like vesting stake, lock stake can be configured to be unlocked in parts at the end of each round that coincides with the end of the next withdrawal period. At the end of each period the Lock Stake is returned to the wallet which locked it. The rewards of a lock stake are always added to the ordinary stake of the beneficiary. To withdraw these funds, beneficiary should use use one of the withdrawal functions. Please note that the lock stake is split into two equal parts by the DePool, to be used in both odd and even rounds, so to ensure DePool can participate in elections with just one lock stake where validator wallet is beneficiary, the stake should equal validatorAssurance 2. Similarly, to ensure any vesting stake is accepted, make sure it exceeds minStake 2. Donor uses the following command to make a lock stake: tonos-cli depool [--addr &lt;depool_address&gt;] stake lock [--wallet &lt;msig_address&gt;] --value &lt;number&gt; --total &lt;days&gt; --withdrawal &lt;days&gt; --beneficiary &lt;address&gt; [--sign &lt;key_file or seed_phrase&gt;] [--wait-answer]  Where &lt;depool_address&gt; - address of the DePool contract. &lt;msig_address&gt; - address of the donor wallet making a stake. all --value parameters must be defined in tons, like this: --value 10.5, which means the value is 10,5 tons. total &lt;days&gt; - total period, for which the stake is made. withdrawal &lt;days&gt; - withdrawal period (each time a withdrawal period ends, a portion of the stake is returned to the wallet that made the stake). There are limitations for period settings: withdrawalPeriod should be &lt;= totalPeriod, totalPeriod cannot exceed 18 years or be &lt;=0, totalPeriod should be exactly divisible by withdrawalPeriod. beneficiary &lt;address&gt;address of the beneficiary (wallet that will receive rewards from the stake). Cannot be the same as the wallet making the stake. key_file or seed_phrase - either the keyfile for the donor wallet making the stake, or the seed phrase in quotes. --wait-answer - optional flag, which forces TONOS-CLI to wait for DePool answer when performing the action and print out the resulting message. Without it only the results of the multisig transaction to DePool will be displayed. Example: tonos-cli depool --addr 0:37fbcb6e3279cbf5f783d61c213ed20fee16e0b1b94a48372d20a2596b700ace stake lock --wallet 0:1b91c010f35b1f5b42a05ad98eb2df80c302c37df69651e1f5ac9c69b7e90d4e --value 1000 --total 360 --withdrawal 30 --beneficiary 0:f22e02a1240dd4b5201f8740c38f2baf5afac3cedf8f97f3bd7cbaf23c7261e3 --sign &quot;dizzy modify exotic daring gloom rival pipe disagree again film neck fuel&quot;  Note: Each participant can concurrently be the beneficiary of only one lock stake. Once the current lock stake expires, another can be made for the participant. "},{"title":"7.3. Remove stakes​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#73-remove-stakes","content":"This command removes an ordinary stake from a pooling round (while it has not been staked in the Elector yet): tonos-cli depool [--addr &lt;depool_address&gt;] stake remove [--wallet &lt;msig_address&gt;] --value &lt;number&gt; [--sign &lt;key_file or seed_phrase&gt;] [--wait-answer]  Where &lt;depool_address&gt; - address of the DePool contract. &lt;msig_address&gt; - address of the wallet that made the stake. all --value parameters must be defined in tons, like this: --value 10.5, which means the value is 10,5 tons. &lt;key_file or seed_phrase&gt; - either the keyfile for the wallet making the stake, or the seed phrase in quotes. --wait-answer - optional flag, which forces TONOS-CLI to wait for DePool answer when performing the action and print out the resulting message. Without it only the results of the multisig transaction to DePool will be displayed. Example: tonos-cli depool --addr 0:37fbcb6e3279cbf5f783d61c213ed20fee16e0b1b94a48372d20a2596b700ace stake remove --wallet 0:1b91c010f35b1f5b42a05ad98eb2df80c302c37df69651e1f5ac9c69b7e90d4e --value 100 --sign &quot;dizzy modify exotic daring gloom rival pipe disagree again film neck fuel&quot;  "},{"title":"7.4. Transfer stakes​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#74-transfer-stakes","content":"The following command assigns an existing ordinary stake or its part to another participant wallet. If the entirety of the stake is transferred, the transferring wallet is removed from the list of participants in the DePool. If the receiving wallet isn't listed among the participants, it will become a participant as the result of the command. tonos-cli depool [--addr &lt;depool_address&gt;] stake transfer [--wallet &lt;msig_address&gt;] --value &lt;number&gt; --dest &lt;address&gt; [--sign &lt;key_file or seed_phrase&gt;] [--wait-answer]  Where &lt;depool_address&gt; - address of the DePool contract. &lt;msig_address&gt; - address of the wallet that made the stake. all --value parameters must be defined in tons, like this: --value 10.5, which means the value is 10,5 tons. dest &lt;address&gt; - address of the new owner of the stake. &lt;key_file or seed_phrase&gt; - either the keyfile for the wallet making the stake, or the seed phrase in quotes. --wait-answer - optional flag, which forces TONOS-CLI to wait for DePool answer when performing the action and print out the resulting message. Without it only the results of the multisig transaction to DePool will be displayed. Example: tonos-cli depool --addr 0:37fbcb6e3279cbf5f783d61c213ed20fee16e0b1b94a48372d20a2596b700ace stake transfer --wallet 0:1b91c010f35b1f5b42a05ad98eb2df80c302c37df69651e1f5ac9c69b7e90d4e --value 1000 --dest 0:1b91c010f35b1f5b42a05ad98eb2df80c302c37df69651e1f5ac9c69b7e90d4e --sign &quot;dizzy modify exotic daring gloom rival pipe disagree again film neck fuel&quot;  Note: Stakes cannot be transferred from or to DePool's validator wallet, and between any wallets during round completion step. "},{"title":"7.5. Withdraw Stakes​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#75-withdraw-stakes","content":""},{"title":"7.5.1. Withdraw entire stake​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#751-withdraw-entire-stake","content":"The following command allows to withdraw an ordinary stake to the wallet that owns it, as soon as the stake becomes available. Use withdraw on to receive the stake, once it's unlocked. If you then make another stake, and want to keep reinvesting it every round, run the command with withdraw off. tonos-cli depool [--addr &lt;depool_address&gt;] withdraw on | off [--wallet &lt;msig_address&gt;] [--sign &lt;key_file or seed_phrase&gt;] [--wait-answer]  Where &lt;depool_address&gt; - address of the DePool contract. &lt;msig_address&gt; - address of the wallet that made the stake. &lt;key_file or seed_phrase&gt; - either the keyfile for the wallet that made the stake, or the seed phrase in quotes. --wait-answer - optional flag, which forces TONOS-CLI to wait for DePool answer when performing the action and print out the resulting message. Without it only the results of the multisig transaction to DePool will be displayed. Example: tonos-cli depool --addr 0:37fbcb6e3279cbf5f783d61c213ed20fee16e0b1b94a48372d20a2596b700ace withdraw on --wallet 0:1b91c010f35b1f5b42a05ad98eb2df80c302c37df69651e1f5ac9c69b7e90d4e --sign &quot;dizzy modify exotic daring gloom rival pipe disagree again film neck fuel&quot;  "},{"title":"7.5.2. Withdraw part of the stake​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#752-withdraw-part-of-the-stake","content":"The following command allows to withdraw part of an ordinary stake to the wallet that owns it, as soon as the stake becomes available. If, as result of this withdrawal, participant's ordinary stake becomes less than minStake, then participant's whole stake is sent to participant. tonos-cli depool [--addr &lt;depool_address&gt;] stake withdrawPart [--wallet &lt;msig_address&gt;] --value &lt;number&gt; [--sign &lt;key_file or seed_phrase&gt;] [--wait-answer]  Where &lt;depool_address&gt; - address of the DePool contract. &lt;msig_address&gt; - address of the wallet that made the stake. all --value parameters must be defined in tons, like this: --value 10.5, which means the value is 10,5 tons. &lt;key_file or seed_phrase&gt; - either the keyfile for the wallet that made the stake, or the seed phrase in quotes. --wait-answer - optional flag, which forces TONOS-CLI to wait for DePool answer when performing the action and print out the resulting message. Without it only the results of the multisig transaction to DePool will be displayed. Example: tonos-cli depool --addr 0:37fbcb6e3279cbf5f783d61c213ed20fee16e0b1b94a48372d20a2596b700ace stake withdrawPart --wallet 0:1b91c010f35b1f5b42a05ad98eb2df80c302c37df69651e1f5ac9c69b7e90d4e --value 1000 --sign &quot;dizzy modify exotic daring gloom rival pipe disagree again film neck fuel&quot;  "},{"title":"7.6. Reinvest Stakes​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#76-reinvest-stakes","content":"Ordinary stake reinvestment is controlled by the DePool reinvest flag. By default this flag is set to yes, and the the participant's available ordinary stake will be reinvested every round, no additional action required. It gets set to no when withdrawing the entire stake. After stake withdrawal it remains set to no. To re-enable ordinary stake reinvesting after withdrawing a stake, run the withdraw command with option off: tonos-cli depool [--addr &lt;depool_address&gt;] withdraw off [--wallet &lt;msig_address&gt;] [--sign &lt;key_file or seed_phrase&gt;] [--wait-answer]  &lt;depool_address&gt; - address of the DePool contract. &lt;msig_address&gt; - address of the wallet that made the stake. &lt;key_file or seed_phrase&gt; - either the keyfile for the wallet that made the stake, or the seed phrase in quotes. --wait-answer - optional flag, which forces TONOS-CLI to wait for DePool answer when performing the action and print out the resulting message. Without it only the results of the multisig transaction to DePool will be displayed. Example: tonos-cli depool --addr 0:37fbcb6e3279cbf5f783d61c213ed20fee16e0b1b94a48372d20a2596b700ace withdraw off --wallet 0:1b91c010f35b1f5b42a05ad98eb2df80c302c37df69651e1f5ac9c69b7e90d4e --sign &quot;dizzy modify exotic daring gloom rival pipe disagree again film neck fuel&quot;  Note: Withdrawing a part of the stake does not affect the reinvest flag. Lock and vesting stakes are reinvested according to their initial settings for the full duration of the staking period. There is no way to change these settings once lock and vesting stakes are made. "},{"title":"7.7. Read DePool answers​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#77-read-depool-answers","content":"Every time anything happens with the participant stake in the DePool, e.g. a round completes and rewards are distributed, DePool sends the participant a message with the relevant details. Use the following command to read these messages: tonos-cli depool --addr &lt;depool_address&gt; answers --wallet &lt;msig_address&gt; [--since &lt;unixtime&gt;]  &lt;depool_address&gt; - address of the DePool contract. &lt;msig_address&gt; - address of the wallet that made the stake. &lt;unixtime&gt; - unixtime, since which you want to view DePool answers. If --since is omitted, all DePool answers are printed. Example: $ tonos-cli depool --addr 0:127ae93241278304fff6b7e5b7b182fd382b6e95b200551061a7354e032e50bf answers --wallet 0:255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f3 Config: /home/user/tonos-cli.conf.json Connecting to net.ton.dev 34 answers found Answer: Id: 7cacf43d2e748a5c9209e93c41c0aeccc71a5b05782dbfb3c8ac538948b67c49 Value: 0.000000001 Created at: 1619803878 (2021-04-30 17:31:18.000) Decoded body: onRoundComplete {&quot;roundId&quot;:&quot;104&quot;,&quot;reward&quot;:&quot;2907725565&quot;,&quot;ordinaryStake&quot;:&quot;211269425171&quot;,&quot;vestingStake&quot;:&quot;0&quot;,&quot;lockStake&quot;:&quot;0&quot;,&quot;reinvest&quot;:true,&quot;reason&quot;:&quot;5&quot;}  "},{"title":"7.8. View DePool events​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#78-view-depool-events","content":"Various events occurring in the DePool are broadcasted to the blockchain and can be monitored. use the following command to view them: tonos-cli depool [--addr &lt;depool_address&gt;] events [--since &lt;unixtime&gt;]  &lt;depool_address&gt; - address of the DePool contract. &lt;unixtime&gt; - unixtime, since which you want to view DePool events. If --since is omitted, all DePool events are printed. Example: $ tonos-cli depool --addr 0:127ae93241278304fff6b7e5b7b182fd382b6e95b200551061a7354e032e50bf events --since 1619803870 Config: /home/user/tonos-cli.conf.json Input arguments: depool: 0:127ae93241278304fff6b7e5b7b182fd382b6e95b200551061a7354e032e50bf since: 1619803870 Connecting to net.ton.dev 3 events found event ba71ce0889adb4740515dd714c0ce5757373448abe20835990a7c19910bcedaf RoundStakeIsAccepted 1619803936 (2021-04-30 17:32:16.000) {&quot;queryId&quot;:&quot;1619803887&quot;,&quot;comment&quot;:&quot;0&quot;} event 9c5fca5548a57809cadac1b8943ac5c60f24cf8132cf6221023e7076373764e1 StakeSigningRequested 1619803878 (2021-04-30 17:31:18.000) {&quot;electionId&quot;:&quot;1619836142&quot;,&quot;proxy&quot;:&quot;-1:ed1976efa2bc727e49079de13620881fb63a1d1ca688cb9e6300da9c157e4a19&quot;} event b705534fed098b49897591cedc76a71c6d0c71988454dd34730be97c0cfbf604 RoundCompleted 1619803878 (2021-04-30 17:31:18.000) {&quot;round&quot;:{&quot;id&quot;:&quot;104&quot;,&quot;supposedElectedAt&quot;:&quot;1619705070&quot;,&quot;unfreeze&quot;:&quot;1619803374&quot;,&quot;stakeHeldFor&quot;:&quot;32768&quot;,&quot;vsetHashInElectionPhase&quot;:&quot;0x000000000000000000000000000000000000000000000000000000006089bcee&quot;,&quot;step&quot;:&quot;8&quot;,&quot;completionReason&quot;:&quot;5&quot;,&quot;stake&quot;:&quot;412362311390363&quot;,&quot;recoveredStake&quot;:&quot;95976319560878&quot;,&quot;unused&quot;:&quot;322363311390363&quot;,&quot;isValidatorStakeCompleted&quot;:false,&quot;participantReward&quot;:&quot;5675390246734&quot;,&quot;participantQty&quot;:&quot;7&quot;,&quot;validatorStake&quot;:&quot;328635369379831&quot;,&quot;validatorRemainingStake&quot;:&quot;0&quot;,&quot;handledStakesAndRewards&quot;:&quot;0&quot;}} Done  To wait for a new event, use the following command: tonos-cli depool [--addr &lt;depool_address&gt;] events --wait-one  TONOS-CLI waits until new event will be emitted and then prints it to terminal. "},{"title":"7.9. Replenish DePool balance​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#79-replenish-depool-balance","content":"To operate correctly, DePool needs to maintain a balance over 20 tokens. Normally, this happens automatically, but in some cases, when normal operation is interrupted, DePool balance may drop lower. Use the following command to replenish DePool balance (this is not counted towards any stake): tonos-cli depool [--addr &lt;depool_address&gt;] replenish --value *number* [--wallet &lt;msig_address&gt;] [--sign &lt;key_file_or_seed_phrase&gt;]  &lt;depool_address&gt; - address of the DePool contract. all --value parameters must be defined in tons, like this: --value 150.5, which means the value is 150,5 tons. &lt;msig_address&gt; - address of the wallet that made the stake. &lt;key_file_or_seed_phrase&gt; - either the keyfile for the wallet, or the seed phrase in quotes. Example: $ tonos-cli depool --addr 0:127ae93241278304fff6b7e5b7b182fd382b6e95b200551061a7354e032e50bf replenish --value 5 --wallet 0:255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f3 --sign key.json Config: /home/user/tonos-cli.conf.json Input arguments: depool: 0:127ae93241278304fff6b7e5b7b182fd382b6e95b200551061a7354e032e50bf wallet: 0:255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f3 stake: 5 keys: key.json Connecting to net.ton.dev Generating external inbound message... MessageId: 43f45f2590ba3c7afec1974f3a2bcc726f98d8ed0bcf216656ea321606f5bf60 Expire at: Thu, 13 May 2021 14:17:44 +0300 Processing... Succeeded. Result: { &quot;transId&quot;: &quot;0&quot; }  "},{"title":"7.10. Send ticktock to DePool​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#710-send-ticktock-to-depool","content":"To operate correctly, DePool needs to receive regular ticktock (state update) calls. One way to set them up, is through a TONOS-CLI with the use of a multisig wallet. Use the following command to send a ticktock call (you may set up a script to run this command regularly): tonos-cli depool [--addr &lt;depool_address&gt;] ticktock [--wallet &lt;msig_address&gt;] [--sign &lt;path_to_keys_or_seed_phrase&gt;]  --addr &lt;depool_address&gt; - the address of the DePool--wallet &lt;msig_address&gt; - the address of the multisig wallet used to call DePool--sign &lt;path_to_keys_or_seed_phrase&gt; - either the keyfile for the wallet, or the seed phrase in quotes 1 token is always attached to this call. Change will be returned. Example: $ tonos-cli depool --addr 0:127ae93241278304fff6b7e5b7b182fd382b6e95b200551061a7354e032e50bf ticktock --wallet 0:255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f3 --sign key.json Config: /home/user/tonos-cli.conf.json Input arguments: depool: 0:127ae93241278304fff6b7e5b7b182fd382b6e95b200551061a7354e032e50bf wallet: 0:255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f3 keys: key.json Connecting to https://net.ton.dev Generating external inbound message... MessageId: 903bb44b8286fc679e4cd08178fcaac1fb126519ecf6f7cea5794db7337645c4 Expire at: Thu, 20 May 2021 12:59:25 +0300 Processing... Succeeded. Result: { &quot;transId&quot;: &quot;0&quot; }  8. Proposal commands The following commands are used when voting for various Everscale proposals "},{"title":"8.1. Create proposal and cast the first vote​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#81-create-proposal-and-cast-the-first-vote","content":"Use the following command: tonos-cli proposal create &lt;msig_address&gt; &lt;proposal_address&gt; &quot;&lt;comment&gt;&quot; &lt;path_to_keyfile_or_seed_phrase&gt;  &lt;msig_address&gt; - address of judge wallet. &lt;proposal_address&gt; - address of proposal contract. &quot;&lt;comment&gt;&quot; - proposal description (max symbols: 382). Should be enclosed in double quotes. &lt;path_to_keyfile_or_seed_phrase&gt; - path to key file or seed phrase for the judge wallet. Seed phrase should be enclosed in double quotes. The utility generates the proposal transaction ID and casts the first vote for the proposal. The proposal transaction ID can be used to vote for the proposal by all other wallet custodians and should be communicated to them. "},{"title":"8.2. Vote for proposal​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#82-vote-for-proposal","content":"Receive proposal transaction ID and use the following command to cast a vote: tonos-cli proposal vote &lt;msig_address&gt; &lt;proposal_id&gt; &lt;path_to_keyfile_or_seed_phrase&gt;  &lt;msig_address&gt; - address of judge wallet. &lt;proposal_id&gt; - proposal transaction ID. &quot;&lt;seed_phrase&gt;&quot; - path to key file or seed phrase for the judge wallet. Seed phrase should be enclosed in double quotes. Once the proposal transaction receives the required amount of votes (depends on judge wallet configuration), the transaction is executed and the proposal is considered approved. "},{"title":"8.3. Decode proposal comment​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#83-decode-proposal-comment","content":"Use the following command to read the proposal comment added when the proposal transaction was created: tonos-cli proposal decode &lt;msig_address&gt; &lt;proposal_id&gt;  &lt;msig_address&gt; - address of judge wallet. &lt;proposal_id&gt; - proposal transaction ID. 9. Supplementary commands "},{"title":"9.1. Convert tokens to nanotokens​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#91-convert-tokens-to-nanotokens","content":"Transaction amounts in tonos-cli are indicated in nanotokens. To convert tokens to nanotokens use the following command: tonos-cli convert tokens &lt;amount&gt;  Example: $ tonos-cli convert tokens 125.8 Config: /home/user/tonos-cli.conf.json 125800000000  "},{"title":"9.2. Get global config​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#92-get-global-config","content":"tonos-cli getconfig &lt;index&gt;  &lt;index&gt; - number of the global config parameter (equals the numeric part of the config parameter field name). Example (requesting the maximum and minimum numbers of validators on the blockchain): $ tonos-cli getconfig 16 Config: /home/user/tonos-cli.conf.json Input arguments: index: 16 Connecting to net.ton.dev Config p16: { &quot;max_validators&quot;: 1000, &quot;max_main_validators&quot;: 100, &quot;min_validators&quot;: 13 }  "},{"title":"9.3. NodeID​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#93-nodeid","content":"The following command calculates node ID from validator public key: tonos-cli nodeid --pubkey &lt;validator_public_key&gt; | --keypair &lt;path_to_key_or_seed_phrase&gt;  &lt;validator_public_key&gt; - public key of the validator wallet. &lt;path_to_key_or_seed_phrase&gt; - path to validator wallet keyfile or the corresponding seed phrase in quotes. Example: $ tonos-cli nodeid ---keypair &quot;dizzy modify exotic daring gloom rival pipe disagree again film neck fuel&quot; Config: /home/user/tonos-cli.conf.json Input arguments: key: None keypair: dizzy modify exotic daring gloom rival pipe disagree again film neck fuel 50232655f2ad44f026b03ec1834ae8316bfa1f3533732da1e19b3b31c0f04143  "},{"title":"9.4. Dump blockchain config​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#94-dump-blockchain-config","content":"tonos-cli dump config &lt;path&gt;  &lt;path&gt; - path where to save the blockchain config dump. Example: $ tonos-cli dump config config.boc Config: /home/user/TONLabs/tonos-cli/tonos-cli.conf.json Input arguments: path: config.boc Connecting to main.ton.dev Config successfully saved to config.boc  "},{"title":"9.5. Dump several account states​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#95-dump-several-account-states","content":"Dumps the list of accounts. Files will have address without workchain id as a name. tonos-cli dump account &lt;list_of_addresses&gt; [--path &lt;dir_path&gt;]  &lt;list_of_addresses&gt; - list of account addresses. Addresses should be specified separately with space delimiter. Example: 0:2bb4a0e8391e7ea8877f4825064924bd41ce110fce97e939d3323999e1efbb13 0:14014af4a374bdd13dae2379063ea2597634c2c2fc8e99ca9eab431a7ab6f566 f89d946b5b4b8a06f01dc20dceef30caff844d5285abea8a21ad3730c0f3dd12 3333333333333333333333333333333333333333333333333333333333333333. &lt;dir_path&gt; - path to the directory where to save dumps. Defaults to current directory. Example: $ tonos-cli dump account 0:2bb4a0e8391e7ea8877f4825064924bd41ce110fce97e939d3323999e1efbb13 0:14014af4a374bdd13dae2379063ea2597634c2c2fc8e99ca9eab431a7ab6f566 f89d946b5b4b8a06f01dc20dceef30caff844d5285abea8a21ad3730c0f3dd12 3333333333333333333333333333333333333333333333333333333333333333 Config: /home/user/TONLabs/tonos-cli/tonos-cli.conf.json Input arguments: addresses: 0:2bb4a0e8391e7ea8877f4825064924bd41ce110fce97e939d3323999e1efbb13, 0:14014af4a374bdd13dae2379063ea2597634c2c2fc8e99ca9eab431a7ab6f566, 0:f89d946b5b4b8a06f01dc20dceef30caff844d5285abea8a21ad3730c0f3dd12, 0:3333333333333333333333333333333333333333333333333333333333333333 path: None Connecting to net.ton.dev Processing... ./2bb4a0e8391e7ea8877f4825064924bd41ce110fce97e939d3323999e1efbb13.boc successfully dumped. ./14014af4a374bdd13dae2379063ea2597634c2c2fc8e99ca9eab431a7ab6f566.boc successfully dumped. 0:f89d946b5b4b8a06f01dc20dceef30caff844d5285abea8a21ad3730c0f3dd12 was not found. 0:3333333333333333333333333333333333333333333333333333333333333333 was not found. Succeeded.  "},{"title":"9.6. Wait for account change​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#96-wait-for-account-change","content":"The command account-wait waits for the change of the last_trans_lt account field. It exits with zero exit code upon success (the field has changed before timeout). Otherwise, it exits with non-zero code. tonos-cli account-wait &lt;address&gt; [--timeout &lt;timeout_in_secs&gt;]  &lt;address&gt; - address of account to wait for. &lt;timeout_in_secs&gt; - timeout in seconds (the default is 30). Example: $ tonos-cli account-wait --timeout 10 0:2bb4a0e8391e7ea8877f4825064924bd41ce110fce97e939d3323999e1efbb13 ... Succeeded. $ echo $? 0  "},{"title":"9.7. Make a raw GraphQL query​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#97-make-a-raw-graphql-query","content":"The command query-raw executes a raw network query by directly calling the ton_client::net::query_collection SDK interface. tonos-cli query-raw &lt;collection&gt; &lt;result&gt; [--filter &lt;filter&gt;] [--limit &lt;limit&gt;] [--order &lt;order&gt;]  See relevant SDK documentation to learn about the command's parameters. Examples: $ tonos-cli --json query-raw accounts &quot;id bits cells&quot; --filter '{ &quot;id&quot;: { &quot;eq&quot;: &quot;0:2bb4a0e8391e7ea8877f4825064924bd41ce110fce97e939d3323999e1efbb13&quot; } }' [ { &quot;id&quot;: &quot;0:2bb4a0e8391e7ea8877f4825064924bd41ce110fce97e939d3323999e1efbb13&quot;, &quot;bits&quot;: &quot;0x20bc&quot;, &quot;cells&quot;: &quot;0x25&quot; } ] $ tonos-cli --json query-raw accounts &quot;id bits cells&quot; --order '[ { &quot;path&quot;: &quot;balance&quot;, &quot;direction&quot;: &quot;DESC&quot; } ]' --limit 3 [ { &quot;id&quot;: &quot;-1:7777777777777777777777777777777777777777777777777777777777777777&quot;, &quot;bits&quot;: &quot;0xe635&quot;, &quot;cells&quot;: &quot;0x6f&quot; }, { &quot;id&quot;: &quot;0:5a70f26b94d500a5dc25c6f1b19d802beb97b89f702001dc46bfaf08922d4a6f&quot;, &quot;bits&quot;: &quot;0x87&quot;, &quot;cells&quot;: &quot;0x1&quot; }, { &quot;id&quot;: &quot;0:2bb4a0e8391e7ea8877f4825064924bd41ce110fce97e939d3323999e1efbb13&quot;, &quot;bits&quot;: &quot;0x20ba&quot;, &quot;cells&quot;: &quot;0x25&quot; } ]  For more information and syntax read docs section on playground. "},{"title":"10. Fetch and replay​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#10-fetch-and-replay","content":"These two commands are commonly used in pairs to recover a state of the account at the specific point before a given transaction. Example: 1) Dump blockchain config history to the file. $ tonos-cli fetch -- -1:5555555555555555555555555555555555555555555555555555555555555555 config.txns  2) Dump account transactions from the network to the file. $ tonos-cli fetch 0:570ddeb8f632e5f9fde198dd4a799192f149f01c8fd360132b38b04bb7761c5d 570ddeb8.txns  where 0:570ddeb8f632e5f9fde198dd4a799192f149f01c8fd360132b38b04bb7761c5d is an example of account address, 570ddeb8.txns - name of the output file. $ tonos-cli replay [-e] [-c config.txns] 570ddeb8.txns 197ee1fe7876d4e2987b5dd24fb6701e76d76f9d08a5eeceb7fe8ca73d9b8270  Transaction can be replayed with config using option -c or with the current network config (option -e). where 197ee1fe7876d4e2987b5dd24fb6701e76d76f9d08a5eeceb7fe8ca73d9b8270 is a txn id before which account state should be restored. Note 1: last command generates 3 files. The file with the longest name in the form of &lt;addr&gt;-&lt;txn_id&gt;.boc is a replayed and serialized Account state. Note 2: to get StateInit (tvc) from Account state use tonos-cli decode account boc command with --dumptvc option. "},{"title":"10.1. How to unfreeze account​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#101-how-to-unfreeze-account","content":"1) Dump Account state before transaction in which account changed state from Active to Frozen. 2) Extract tvc from the generated Account state. 1) Use contract deployer (address in mainnet: 0:51616debd4296a4598530d57c10a630db6dc677ecbe1500acaefcfdb9c596c64) to deploy the extracted tvc to the frozen account. Send 1 ton to its address and then run its deploy method. Example: `tonos-cli --url main.ton.dev call 0:51616debd4296a4598530d57c10a630db6dc677ecbe1500acaefcfdb9c596c64 deploy --abi deployer.abi.json &quot;{\\&quot;stateInit\\&quot;:\\&quot;$(cat state.tvc | base64 -w 0)\\&quot;,\\&quot;value\\&quot;:500000000,\\&quot;dest\\&quot;:\\&quot;-1:618272d6b15fd8f1eaa3cdb61ab9d77ae47ebbfcf7f28d495c727d0e98d523eb\\&quot;}&quot;` where `dest` - an address of frozen account, `state.tvc` - extracted account StateInit in step 2.  Deployer.abi.json: { &quot;ABI version&quot;: 2, &quot;header&quot;: [&quot;time&quot;, &quot;expire&quot;], &quot;functions&quot;: [ { &quot;name&quot;: &quot;deploy&quot;, &quot;inputs&quot;: [ {&quot;name&quot;:&quot;stateInit&quot;,&quot;type&quot;:&quot;cell&quot;}, {&quot;name&quot;:&quot;value&quot;,&quot;type&quot;:&quot;uint128&quot;}, {&quot;name&quot;:&quot;dest&quot;,&quot;type&quot;:&quot;address&quot;} ], &quot;outputs&quot;: [ ] }, { &quot;name&quot;: &quot;constructor&quot;, &quot;inputs&quot;: [ ], &quot;outputs&quot;: [ ] } ], &quot;data&quot;: [ ], &quot;events&quot;: [ ] }  11. Debug commands Debug commands allow user to replay transaction locally or execute a function call locally and obtain TVM trace. "},{"title":"11.1. Debug transaction​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#111-debug-transaction","content":"tonos-cli debug transaction [FLAGS] [OPTIONS] &lt;tx_id&gt;  FLAGS: dump_config - Dump the replayed config contract account state. dump_contract - Dump the replayed target contract account state. e, empty_config - Replay transaction without full dump of the config contract. min_trace - Flag that changes trace to minimal version. OPTIONS: -c, --config &lt;CONFIG_PATH&gt; - Path to the file with saved config contract transactions. If not set transactions will be fetched to file &quot;config.txns&quot;. -t, --contract &lt;CONTRACT_PATH&gt; - Path to the file with saved target contract transactions. If not set transactions - will be fetched to file &quot;contract.txns&quot;. -d, --dbg_info &lt;DBG_INFO&gt; - Path to the file with debug info. --decode_abi &lt;DECODE_ABI&gt; - Path to the ABI file used to decode output messages. -o, --output &lt;LOG_PATH&gt; - Path where to store the trace. Default path is &quot;./trace.log&quot;. Note: old file will be removed. ARGUMENTS: tx_id - ID of the transaction that should be replayed. This command allows user to replay remote transaction locally and obtain TVM trace. Full replay requires transactions dump of the debugged contract and of the config contract. This command fetches them automatically, but config contract may have too many transactions and full dump of them can take a very long time, that's why user can use option --empty-config to limit number of the queried transactions and speed up the execution if the debugged contract doesn't check network configuration parameters. Another way to speed up execution if the contract needs config is to reuse dump of config transactions by passing the file with --config &lt;CONFIG_PATH&gt; option. Example: $ tonos-cli debug transaction -o tvm_trace.log 74acbd354e605519d799c7e1e90e52030e8f9e781453e48ecad18bb035fe1586 --empty-config Config: /home/user/TONLabs/sol2tvm/scripts/tonos-cli.conf.json Input arguments: address: 0:e5b3856d4d6b45f33ea625b9c4d949c601b8b6fb60fe6b968c5c0e5000a6aa78 tx_id: 74acbd354e605519d799c7e1e90e52030e8f9e781453e48ecad18bb035fe1586 trace_path: tvm_trace.log config_path: None contract_path: None Fetching config contract transactions... Fetching contract transactions... Replaying the last transactions... DONE Log saved to tvm_trace.log.  "},{"title":"11.2. Debug call​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#112-debug-call","content":"tonos-cli debug call [FLAGS] [OPTIONS] &lt;address&gt; &lt;method&gt; &lt;params&gt;  FLAGS:--boc- Flag that changes behavior of the command to work with the saved account state (account BOC). --min_trace - Flag that changes trace to minimal version. --tvc - Flag that changes behavior of the command to work with the saved contract state (stateInit TVC). OPTIONS:--abi &lt;ABI&gt; - Path to the contract ABI file. Can be specified in the config file. --tvc_address &lt;ACCOUNT_ADDRESS&gt; - Account address for account constructed from TVC.-c, --config &lt;CONFIG_PATH&gt; - Path to the file with saved config contract state. -d, --dbg_info &lt;DBG_INFO&gt; - Path to the file with debug info. --decode_abi &lt;DECODE_ABI&gt; - Path to the ABI file used to decode output messages. -o, --output &lt;LOG_PATH&gt; - Path where to store the trace. Default path is &quot;./trace.log&quot;. Note: old file will be removed. --now &lt;NOW&gt; - Now timestamp (in milliseconds) for execution. If not set it is equal to the current timestamp. --sign &lt;SIGN&gt; - Seed phrase or path to the file with keypair used to sign the message. Can be specified in the config. ARGUMENTS: &lt;address&gt; - Contract address or path the file with saved contract state if corresponding flag is used. &lt;method&gt; - Name of the function being called. &lt;params&gt; - Function arguments. Can be specified with a filename, which contains json data. This command allows user locally emulate contract call and obtain TVM trace. Command can work with contract in the network by querying its boc and running message on it or with saved account state in format of account BOC or pure StateInit TVC. If contract is passed via TVC file, contract address can be specified with --address &lt;tvc_address&gt; option. Also, execution timestamp can be specified with option --now &lt;timestamp&gt;. $ tonos-cli debug call --abi samples/1_Accumulator.abi.jso n --sign keys/key0 0:e5b3856d4d6b45f33ea625b9c4d949c601b8b6fb60fe6b968c5c0e5000a6aa78 add2 '{&quot;value&quot;:1}' Config: /home/user/TONLabs/sol2tvm/scripts/tonos-cli.conf.json Input arguments: input: 0:e5b3856d4d6b45f33ea625b9c4d949c601b8b6fb60fe6b968c5c0e5000a6aa78 method: add2 params: {&quot;value&quot;:1} sign: keys/key0 abi: samples/1_Accumulator.abi.json output: ./trace.log Execution finished. Log saved to ./trace.log  "},{"title":"11.3. Debug run​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#113-debug-run","content":"tonos-cli debug run [FLAGS] [OPTIONS] &lt;address&gt; &lt;method&gt; &lt;params&gt;  FLAGS: --boc - Flag that changes behavior of the command to work with the saved account state (account BOC). --min_trace - Flag that changes trace to minimal version. --tvc - Flag that changes behavior of the command to work with the saved contract state (stateInit TVC). OPTIONS: --abi &lt;ABI&gt; - Path to the contract ABI file. Can be specified in the config file. --tvc_address &lt;ACCOUNT_ADDRESS&gt; - Account address for account constructed from TVC. -c, --config &lt;CONFIG_PATH&gt; - Path to the file with saved config contract state. -d, --dbg_info &lt;DBG_INFO&gt; - Path to the file with debug info. --decode_abi &lt;DECODE_ABI&gt; - Path to the ABI file used to decode output messages. -o, --output &lt;LOG_PATH&gt; - Path where to store the trace. Default path is &quot;./trace.log&quot;. Note: old file will be removed. --now &lt;NOW&gt; - Now timestamp (in milliseconds) for execution. If not set it is equal to the current timestamp. ARGUMENTS: &lt;address&gt; - Contract address or path the file with saved contract state if corresponding flag is used. &lt;method&gt; - Name of the function being called. &lt;params&gt; - Function arguments. Can be specified with a filename, which contains json data. This command is similar to tonos-cli debug call but allows user to debug get methods. $ tonos-cli debug run --abi sol2tvm/samples/1_Accumulator.abi.json 0:04a12b2e001a4144b70ddb244838f8627f8d11cade399dc0892aded7b82d6d68 sum '{}' Config: /home/user/TONLabs/tonos-cli/tonos-cli.conf.json Input arguments: input: 0:04a12b2e001a4144b70ddb244838f8627f8d11cade399dc0892aded7b82d6d68 method: sum params: {} sign: None opt_abi: sol2tvm/samples/1_Accumulator.abi.json output: ./trace.log debug_info: None Execution finished. Log saved to ./trace.log  "},{"title":"11.4. Debug replay transaction on the saved account state​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#114-debug-replay-transaction-on-the-saved-account-state","content":" tonos-cli debug replay [FLAGS] [OPTIONS] &lt;TX_ID&gt; &lt;INPUT&gt;  FLAGS: --min_trace - Flag that changes trace to minimal version. --update_state - Update state of the contract. "},{"title":"11.5 Debug deploy​","type":1,"pageTitle":"TONOS-CLI","url":"develop/tools/tonos-cli#115-debug-deploy","content":"tonos-cli debug deploy [FLAGS] [OPTIONS] &lt;tvc&gt; &lt;params&gt;  FLAGS: --full_trace - Flag that changes trace to full version. --init_balance - Do not fetch account from the network, but create dummy account with big balance. OPTIONS: --abi &lt;ABI&gt; - Path to the contract ABI file. Can be specified in the config file. -c, --config &lt;CONFIG_PATH&gt; - Path to the file with saved config contract state. -d, --dbg_info &lt;DBG_INFO&gt; - Path to the file with debug info. --decode_abi &lt;DECODE_ABI&gt; - Path to the ABI file used to decode output messages. Can be specified in the config file. -o, --output &lt;LOG_PATH&gt; - Path where to store the trace. Default path is &quot;./trace.log&quot;. Note: old file will be removed. --now &lt;NOW&gt; - Now timestamp (in milliseconds) for execution. If not set it is equal to the current timestamp. --sign &lt;SIGN&gt; - Seed phrase or path to the file with keypair used to sign the message. Can be specified in the config. --wc &lt;WC&gt; - Workchain ID. ARGUMENTS: &lt;tvc&gt; - Path to the tvc file with contract StateInit. &lt;params&gt; - Constructor arguments. This command allows user locally emulate contract deploy. Command can work with prepared network account or create a dummy one with big balance (if --init_balance flag is specified). 11.6 Debug message $ tonos-cli debug message [--boc] &lt;address_or_path&gt; [-u] [-o &lt;log_path&gt;] &lt;message_in_base64_or_path_to_file&gt;  FLAGS: --boc - Flag that changes behavior of the command to work with the saved account state (account BOC). --full_trace - Flag that changes trace to full version. -u, --update - Update contract BOC after execution. OPTIONS: -c, --config &lt;CONFIG_PATH&gt;- Path to the file with saved config contract state. -d, --dbg_info &lt;DBG_INFO&gt; - Path to the file with debug info. --decode_abi &lt;DECODE_ABI&gt; - Path to the ABI file used to decode output messages. Can be specified in the config file. -o, --output &lt;LOG_PATH&gt; - Path where to store the trace. Default path is &quot;./trace.log&quot;. Note: old file will be removed. ARGUMENTS: &lt;address_or_path&gt;- Contract address or path the file with saved contract state if corresponding flag is used. &lt;message_in_base64_or_path_to_file&gt; - Message in Base64 or path to fil with message. This command allows to play message on the contract state locally with trace. It can be useful when user wants to play contract interaction locally. User can call one contract locally with tonos-cli debug call and find output messages in trace log: Output messages: ---------------- { &quot;Type&quot;: &quot;internal message&quot;, &quot;Header&quot;: { &quot;ihr_disabled&quot;: &quot;true&quot;, &quot;bounce&quot;: &quot;true&quot;, &quot;bounced&quot;: &quot;false&quot;, &quot;source&quot;: &quot;0:c015125ec7788fe31c8ff246ad58ca3dda476f74d544f6b161535b7e8ad995e3&quot;, &quot;destination&quot;: &quot;0:9677580d26bd9d316323470526d94186354698092f62ea63e65cebcd5c6ad7a8&quot;, &quot;value&quot;: &quot;9000000&quot;, &quot;ihr_fee&quot;: &quot;0&quot;, &quot;fwd_fee&quot;: &quot;666672&quot;, &quot;created_lt&quot;: &quot;4786713000003&quot;, &quot;created_at&quot;: &quot;1652270294&quot; }, &quot;Body&quot;: &quot;te6ccgEBAQEAJgAASEhEWrgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3g==&quot;, &quot;BodyCall&quot;: &quot;Undefined&quot;, &quot;Message_base64&quot;: &quot;te6ccgEBAQEAfgAA92gBgCokvY7xH8Y5H+SNWrGUe7SO3umqie1iwqa2/RWzK8cAJZ3WA0mvZ0xYyNHBSbZQYY1RpgJL2LqY+Zc681cateoOJVEABhRYYAAACLT8p/CGxPdJrCQiLVwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAb0A=&quot; }  Message_base64 then can be passed to tonos-cli debug message to play it on another account. "},{"title":"End-to-end Decentralization","type":0,"sectionRef":"#","url":"learn/decentralization/end-to-end-decentralization","content":"","keywords":""},{"title":"Background​","type":1,"pageTitle":"End-to-end Decentralization","url":"learn/decentralization/end-to-end-decentralization#background","content":"Decentralization is an important property of public blockchain technology 1. Despite its claims of decentralization, blockchain keeps on fighting to achieve it through improvements and optimizations mainly related to consensus mechanisms and data exchange protocols. Proof-of-Work and Proof-of-Stake consensus protocols (and their derivatives) have issues related to centralization at both mining/staking and at the front-end levels. Considerable amounts of centralization exist in development ecosystems of some blockchains as well. Decentralization claims can only be made when the whole system is decentralized, and therefore, should be judged by its weakest (or rather most centralized) link. In the current invention we present an end-to-end Decentralization framework (E2ED). In today's blockchains that support smart contracts (or in other words the ability to perform and validate arbitrary computations), user interaction with results of such computations is performed using some front end library (such as Web3 in Ethereum blockchain). The Web3 library takes care of performing blockchain related tasks with blockchain data presented to a user. The IPFS is used to store data in a decentralized manner. Yet as shown below neither is enough to preserve full decentralization of end user interactions with a blockchain system to ensure censorship resistance and security. "},{"title":"Web3​","type":1,"pageTitle":"End-to-end Decentralization","url":"learn/decentralization/end-to-end-decentralization#web3","content":"Web3.0 js is a collection of libraries which allow you to interact with a local or remote Ethereum node, using a HTTP or IPC connection2. Web3.0 is a collection of JavaScript libraries that allow users to interact with a local or remote Ethereum node using an HTTP or IPC connection. In other words, it’s a kind of SDK which gives users the ability to work with blockchain in the browser. That’s why it actually has a Web in the name and not something else. Web3.0 is numbered 3.0 quite obviously because 2.0 and 1.0 versions of Web already exist, referring to the World Wide Web's evolution where the 2.0 version unlike the 1.0 version, for instance, allows for display of user-generated content, dynamically making websites more sophisticated. Web 3.0 on the other hand is seen as part of the World Wide Web’s evolution due to the fact that it can be considered as a first attempt to access decentralized (blockchain) applications on the web. The purpose of Web3 is to give the ability to create decentralized apps on the web connecting sites to the world of blockchain, in particular Ethereum blockchain. The main problem with this approach is that a user does not really interact with the blockchain when using Web3 based applications, because most of the time the user interacts with many elements of information outside of the blockchain, presented to them by the application user interface. This presents quite a significant problem as all such information and user interface elements are not decentralized, which means they are not immutable, not censorship resistant, and not fault tolerant. Moreover, blockchain related elements that are supposedly temper proofed lose their properties once they are part of this centralized model. "},{"title":"IPFS​","type":1,"pageTitle":"End-to-end Decentralization","url":"learn/decentralization/end-to-end-decentralization#ipfs","content":"Enters IPFS. The InterPlanetary File System (IPFS) is a protocol and peer-to-peer network for storing and sharing data in a distributed file system. IPFS uses content-addressing to uniquely identify each file in a global namespace connecting all computing devices3. An IPFS developer or user can store the content somewhere that’s always online and accessible and make sure that when the user comes online they know where to find the content. This way we theoretically could use IPFS to store all user interfaces somewhere, save a hash and an address of said content on the blockchain and therefore prove to the user that whatever is displayed in their browser is true and correct by way of verifying it using Web3 library. Yet even an IPFS and Web3 combination does not guarantee end-to-end decentralization as described below in more detail. "},{"title":"User interaction (DeBot)​","type":1,"pageTitle":"End-to-end Decentralization","url":"learn/decentralization/end-to-end-decentralization#user-interaction-debot","content":"A system is needed to create a comprehensive user experience without relying on trusted infrastructure. To achieve this, we introduced technology for writing the user interface inside the smart contract itself. Decentralized Bot (DeBot) is a technology enabling end-to-end Decentralization at a user interaction level. Using E2ED, any front-end application (be it in a web browser or a purposely built software) can draw an entire user experience without relying on a server. Comparing Web 2.0, Web 3.0 and E2ED based systems (which for the purpose of the diagram below we named Web3.11 as a reminiscent to the famous Windows 3.11), E2ED is not a contradiction to Web3.0 but rather a continuation that closes some centralization loopholes to achieve end-to-end decentralization. Web3.0 itself is not a monolithic system. It has many components such as an IPFS database for storage and others for address discovery and storage query on top. The Web3.0 approach is fragmented. A smart contract is executed in one place and the data it manipulates is stored in another. The data meets the business logic only on an end user device, therefore, the computation performed on such data can not be verified by a blockchain. For that reason we have verifiable business logic (smart contract) operating with the data it can not verify. The only limited verification available is the hash of data stored somewhere else. The interaction with said data is static. If a man-in-the-middle attack is performed on the user device level, the security of Web3 can be compromised. In practice today what happens in almost 100% of cases is shown in the middle column of the diagram below. A user interface is provided by a web server. An application is running on the server and displayed in the user browser (or on a mobile device). The user performs many usual operations with the website content on the server and only when needed to interact with the blockchain does the Web3.0.js get called, which then interacts with the blockchain calling it from the end user device and signed with the user private key. Even if Web3.0 is really advanced and stores the application data (say a website), in the IPFS database the Web3.0.js will be called to perform operations with a blockchain and again not the library nor the smart contract it interacts with, and will not be able to verify what has actually happened to the data that was stored and received from the IPFS on the user device.  In E2ED the smart contract contains the actual user interface in a form of DeBot. The DeBot system described herein is just one way of performing user interface functions by a smart contract. The whole graphical user interface could be drawn if needed. In DeBot the sequence of user actions is performed by calling DeBot smart contract functions using the local virtual machine of any particular blockchain. The result of those actions could at any time be transmitted to the remote smart contract together with the sequence of user performed actions and the whole interface interaction could be verified remotely by the blockchain, including the resulting transaction. In terms of addressing the user, it just needs to know the address of a smart contract DeBot, which is a blockchain address that in turn can be abstracted further using a blockchain based DNS service. "},{"title":"References​","type":1,"pageTitle":"End-to-end Decentralization","url":"learn/decentralization/end-to-end-decentralization#references","content":"The Meaning of Decentralization↩web3.js - Ethereum JavaScript API↩InterPlanetary File System↩ "},{"title":"Bridges","type":0,"sectionRef":"#","url":"learn/everscale-overview/bridges","content":"","keywords":""},{"title":"What is a cross-chain bridge?​","type":1,"pageTitle":"Bridges","url":"learn/everscale-overview/bridges#what-is-a-cross-chain-bridge","content":"Cross-chain bridges were made for transferring assets between chains. They lock assets in the source chain and creates an equivalent number of wrapped assets in the destination blockchain. When you initiate an asset transfer from one blockchain to another using a bridge, assets are not actually moved or sent anywhere. Instead, the transfer functionality is used in a two-step process and handled by a smart contract. In simple terms - Let's say you want to move tokens from chain A to chain B. What the bridge does is it temporarily locks or freezes your asset in chain A. They then create an equivalent number of new tokens that will be unlocked for you in chain B. When you want to redeem the tokens, that is, when you want to move the original assets back from chain B to the original chain (chain A), the tokens created in chain B will be burned and the original assets will be unlocked. The concept of interchain communication and token transfer is done using a two-way binding system; where the value of a token in either blockchain is the same, as it remains tied to the value of the initial ones. "},{"title":"Everscale Bridges​","type":1,"pageTitle":"Bridges","url":"learn/everscale-overview/bridges#everscale-bridges","content":""},{"title":"Octus Bridge​","type":1,"pageTitle":"Bridges","url":"learn/everscale-overview/bridges#octus-bridge","content":"Octus Bridge is a platform built by the Broxus team that enables cross-chain asset transfers between Everscale and other networks such as Ethereum, BNB Chain, Fantom, Polygon, Avalanche and Milkomeda. The platform also implements the Governance interface or DAO, which provides a level of decentralization unprecedented for bridges due to the ability to make decisions directly by network participants, as well as a staking interface. "},{"title":"Adaever​","type":1,"pageTitle":"Bridges","url":"learn/everscale-overview/bridges#adaever","content":"Cross-chain bridge between Cardano and Everscale built by the Broxus team. "},{"title":"Ecosystem","type":0,"sectionRef":"#","url":"learn/everscale-overview/ecosystem","content":"","keywords":""},{"title":"Wallets​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#wallets","content":"Go to the Wallets section to get acquainted with the Everscale network's wallets. "},{"title":"Exchanges​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#exchanges","content":""},{"title":"Gate.io (EVER/USDT)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#gateio-everusdt","content":""},{"title":"MEXC (EVER/USDT)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#mexc-everusdt","content":""},{"title":"Bitrue (EVER/USDT)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#bitrue-everusdt","content":""},{"title":"Digifinex (EVER/USDT)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#digifinex-everusdt","content":""},{"title":"HitBTC (EVER/USDT, EVER/BTC)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#hitbtc-everusdt-everbtc","content":""},{"title":"KUNA (EVER/USDT)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#kuna-everusdt","content":""},{"title":"Changelly PRO (EVER/BTC)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#changelly-pro-everbtc","content":""},{"title":"CEX.io (EVER/USDT, EVER/USD)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#cexio-everusdt-everusd","content":""},{"title":"FMFW.io (EVER/BTC)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#fmfwio-everbtc","content":""},{"title":"GameFi​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#gamefi","content":""},{"title":"Pokerton​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#pokerton","content":"Telegram Poker – Win EVER by participating in free daily tournaments. "},{"title":"EverBall.io​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#everballio","content":"The world's first game where you mine EVER by absorbing opponents. "},{"title":"Everscale Gaming​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#everscale-gaming","content":"Esports tournaments with prize pools in EVER. "},{"title":"EverCraft​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#evercraft","content":"A plugin to connect Everscale with Minecraft. "},{"title":"Galaxy Online​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#galaxy-online","content":"A great MMO with playable blockchain-based races. "},{"title":"Bridges​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#bridges","content":"Go to the Bridges to get acquainted with the Everscale network's bridges. "},{"title":"NFT​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#nft","content":""},{"title":"GrandBaraz​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#grandbaraz","content":"Everscale's first NFT marketplace. Buy, sell, and craft rare digital items. "},{"title":"ChessNFT​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#chessnft","content":"An NFT platform from the FIDE Chess Federation. "},{"title":"Third Place NFT​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#third-place-nft","content":"An NFT platform from the St. Petersburg creative space Third Place. "},{"title":"Most Expensive​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#most-expensive","content":"Real expensive NFT items! "},{"title":"ScalePunks.com​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#scalepunkscom","content":"A collection of 10,000 unique punks. "},{"title":"DeFi​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#defi","content":""},{"title":"FlatQube​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#flatqube","content":"DEX solution. Easy and fast exchange of tokens and participation in liquidity pools for farming income. "},{"title":"Surf Staking​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#surf-staking","content":"A staking service from the popular Ever Surf. "},{"title":"Surf Depooler​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#surf-depooler","content":"Top depooler rating, performance analysis and depooler selection for more income. "},{"title":"Surf Payments​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#surf-payments","content":"Payments framework built on low-fees Everscale blockchain. "},{"title":"EVER DAO​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#ever-dao","content":"Everscale decentralized project management platform. "},{"title":"EverStart​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#everstart","content":"DAO-controlled multi-chain launchpad to connect with curated projects "},{"title":"EverLand​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#everland","content":"A P2P secured lending platform with interest on funds. "},{"title":"EverKit Coin​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#everkit-coin","content":"Everscale Coin Information (EVER): stats, wallets, and resources to buy: Exchanges, DEX, and P2P. "},{"title":"KWPC​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#kwpc","content":"The Killer Whale Pod Cast is a launch pad for young blockchain projects developed on the Everscale network. "},{"title":"EVER Pools​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#ever-pools","content":"Depool analysis by Broxus – the developer of FlatQube and Octus Bridge. "},{"title":"Ever Live​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#ever-live","content":"Everscale Blockchain Explorer by EverX. "},{"title":"EVER Scan​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#ever-scan","content":"Everscale Blockchain Explorer by Broxus. "},{"title":"Wrapped EVER​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#wrapped-ever","content":"WEVER is Wrapped EVER. Similar to Wrapped Ether but for Everscale. "},{"title":"Ientix.Space​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#ientixspace","content":"Learn-2-earn quests platform for onboarding into #web3. Several Everscale quests with $EVER rewards. "},{"title":"Overview","type":0,"sectionRef":"#","url":"learn/everscale-overview/overview","content":"Overview Everscale is one of the most advanced blockchain networks that lets users transfer digital assets to anyone for a small fee. It also powers numerous leading applications that everyone can take advantage of. The blockchain was created on the basis of the initial code of the Telegram Open Network (TON) blockchain designed by Nikolai Durov. Fundamentally, Everscale blockchain is constructed in accordance with this TON Whitepaper. Despite the fact that Everscale builds on TON's innovation, there are, however, some big advancements deployed by network developers in order to address the fundamental issues faced by most blockchains, Everscale constantly works on implementing the most secure solutions to achieve maximum scalability. The main solution that permits Everscale to offer one of the highest Transaction Per Second rates available among currently operating blockchains is sharding. Generally speaking, sharding is a method for distributing data across multiple machines. This makes it a scaling technique, and can be used by blockchain networks to partition states and transaction processing, so that each node of the network would only need to process a fraction of all the transactions. Moreover, sharding allows for the parallel processing of transactions. As long as there is a sufficient number of nodes verifying each transaction, ensuring high reliability and security, then splitting a blockchain into shards will allow it to process far more transactions. However, Everscale went even further than classical sharding. Below we briefly describe technological solutions, besides sharding, that permit Everscale to be amongst the leading blockchain ecosystems. 1. Infinite Sharding On Everscale, shards are dynamically added as the load increases and then merged back. This is possible because all contracts on the chain communicate with each other asynchronously, and therefore, we can split one shard into two shards without any problems occurring (shards are just divided in half according to the ranges of contract addresses). 2. Distributed programming There is a reasonable question. Let's consider that we have a contract with a token, for example, USDT. Then, a user with a larger account balance is more motivated to pay for storage, than, respectively, the user with a lesser balance. This way, wouldn't there arise situations when some users will be obliged to pay for storage on behalf of others, so that their contract is not deleted? In order to solve this problem, another truly genius idea was invented, called distributing programming. In Everscale, for each entity, balance or even trading pair, its own small smart contract is deployed. The owner of the respective smart contract decides on his own for how long to store the data and pays only for that. 3. Validation The Everscale blockchain was not built to allow just anyone to become a validator. Validation is a critical process, and requires professional equipment and access to an appropriate server. The total number of validators will at most be in the thousands, not in the tens of thousands. And validator machines have high server and channel requirements (the current requirements are 48 CPUs, 128 RAM and 1TB SSD) and a 1GB channel (the network is used extensively). This allows for the blockchain to support a very quick block release speed and often rotate validators in the shards. 4. Paid storage There is also the issue of blockchain state growth faced by most networks. For instance, If someone recorded something on the blockchain, at least once, for example, bought a memcoin for 0.001. Then, even if the price of the memcoin goes to zero, the validators will still be required to store the information about your purchase forever. That is, you pay for the record once, but it will be stored forever. And here comes the interesting economics - blockchains are forced to limit the rate of recording transactions artificially so that the size of the blockchain state does not grow faster than data storage becomes cheaper. As a result, users are forced to compete with each other for the right to record data on the blockchain via an auction, and subsequently, transaction fees are increasing all the time. Everscale, as a leading blockchain developer, never looks for easy and uncostly ways to solve blockchain issues. Therefore, the highlighted problem was resolved with the maximum efficiency and accuracy possible. In the Everscale blockchain, each contract is required to pay rent for storing its data in the state. This rent corresponds to the size of the data. When the money runs out, the contract is deleted with the possibility of recovery, and then deleted completely. Essentially, Everscale aims to be a decentralized replacement for AWS. Just as you can host your application on AWS, you can host it on Everscale. Hosting it on Everscale will not be much more expensive (if it is rarely used, it will be cheaper), but it will have maximum fault tolerance. Please follow this page in order to get started with the components of the Everscale blockchain and start learning it's architecture.","keywords":""},{"title":"Manage a Wallet","type":0,"sectionRef":"#","url":"learn/everscale-overview/wallets","content":"","keywords":""},{"title":"Non-custodial wallets​","type":1,"pageTitle":"Manage a Wallet","url":"learn/everscale-overview/wallets#non-custodial-wallets","content":"Non-custodial - the user has full control over the keys and their funds. If the private key and the password to recover it are lost, the funds will be irretrievably lost. EVER Wallet (IOS, Android, Web) Ever Surf (IOS, Android, Windows, Linux, MacOS) Everspace (IOS, Android, Telegram) ScaleWallet (Web) Lumi (Android, Web) "},{"title":"Custodial wallets​","type":1,"pageTitle":"Manage a Wallet","url":"learn/everscale-overview/wallets#custodial-wallets","content":"Custodial wallets are similar to bank instruments. The user does not have full control over their funds because an operator (custodian) has access to the private key. Pros: having lost passwords or keys, the user has the opportunity to gain access to the funds again. Combot (Web, Telegram) Koshelek (Android, IOS) Crypterium (IOS, Android) FreeWallet (IOS, Android, Web) Kilox (IOS, Android) "},{"title":"Exchange Wallets​","type":1,"pageTitle":"Manage a Wallet","url":"learn/everscale-overview/wallets#exchange-wallets","content":"Crypterium (IOS, Android) Koshelek (Android, IOS) "},{"title":"Governance","type":0,"sectionRef":"#","url":"learn/governance","content":"Governance In the recent past, the Everscale network was governed by a structure composed of the Main Governance and Subgovernances. The roles of these two bodies were separated, which, in turn, did not permit us to achieve full-fledged decentralization. As a result, a new, innovative management system was delivered - Ever DAO. The abbreviation “DAO” stands for Decentralized Autonomous Organization. DAO is a specific form of organization in which the coordination of activities between participants is carried out without centralized control, but using automatic algorithms. In the crypto industry, DAO work is usually based on smart contracts. Today, it is possible to build a DAO on any blockchain that supports smart contracts. The Everscale network is probably the only blockchain network that strives to provide DAOs for most of the products built on its blockchain. This is done in order to achieve as much decentralization as possible at the level of the ecosystem management. Therefore, Ever DAO is currently the main decision making body used as a tool to create proposals on the Everscale network. It sets up development directions for the entire ecosystem and makes strategic decisions on the products. Thus, holders of EVER, Everscale's native coin, get the opportunity to participate in decision-making on the development of the project. Using EverDAO is simple, however, there are some prerequisites for participation: To create a proposal on EverDAO platform you’ll need to stake 100,000 wEVER tokens.To vote on already created proposals you’ll need to stake any amount of wEVER tokens.Individual voting power depends on the amount of staked wEVER tokens you own. At the moment, the main multi-chain Everscale Dapp, Octus Bridge, has its own DAO control mechanism. Other network projects are also planning to launch their own DAO, namely: EverStart, EverLend and FlatQube","keywords":""},{"title":"FAQ","type":0,"sectionRef":"#","url":"learn/faq","content":"","keywords":""},{"title":"What is Everscale?​","type":1,"pageTitle":"FAQ","url":"learn/faq#what-is-everscale","content":"Everscale is a peer-to-peer multi-blockchain system. It is a new and unique blockchain design that proposes a scalable decentralized world computer, paired with a distributed operating system — Ever OS. "},{"title":"Why Everscale?​","type":1,"pageTitle":"FAQ","url":"learn/faq#why-everscale","content":"It is important to understand that Everscale, unlike many other new networks, does not aim to create a second Ethereum. Even at the design stage, Everscale took into account the errors and shortcomings of the Ethereum architecture, thanks to which Everscale is now a truly unique blockchain. Consider its main advantages: Record speed, reliability, and thoughtful architecture.Smart contracts can perform operations on different nodes, which allows the blockchain to scale (sharding) and increases the speed of smart contract execution to an absolute record.Everscale is an asynchronous blockchain that is flexible in software development and rich in languages. You can write smart contracts in C ++, Solidity, and other high-level programming languages for your projects. Everscale has already implemented wallets, bridges, decentralized bots and exchanges, NFTs. It is also a promising and decentralized ecosystem, each participant of which can offer the community an idea for development, competition, or partnership. "},{"title":"Everscale blockchain explorer​","type":1,"pageTitle":"FAQ","url":"learn/faq#everscale-blockchain-explorer","content":"Blockchain explorer is a tool that allows you to track and view blocks, messages, transactions and other information contained in the network. Currently available blockchain explorers for use: Evescan.io by BroxusEver.live by EverX "},{"title":"How does Everscale works?​","type":1,"pageTitle":"FAQ","url":"learn/faq#how-does-everscale-works","content":"To understand the basic principles and mechanisms of Everscale, we recommend that you familiarize yourself with the following sections of the documentation: Architecture section ( Blockchain basics, fee calculation, security, account, messages, EVER OS, etc.) Decentralization sectionSmart Contracts section IntroductionFAQDeBots Standards section "},{"title":"What is EVER?​","type":1,"pageTitle":"FAQ","url":"learn/faq#what-is-ever","content":"EVER - is the native coin of Everscale blockchain, unique blockchain design that proposes a scalable decentralized world computer, paired with a distributed operating system. EVER is the token that captures the value of all community sponsored projects, therefore optimized for a value capturing, it also used for network usage fee payments. It has a max supply of ~2 billion EVER coins. "},{"title":"Wrapped EVER​","type":1,"pageTitle":"FAQ","url":"learn/faq#wrapped-ever","content":"EVER is a cryptocurrency that runs on blockchain, but different blockchains have different functions, features, and protocols. Because of this difference, EVER is not able to interact with other blockchains. While this increases the security of a blockchain-based digital asset, it creates immense difficulties for the development of an interoperable exchange or system of cryptocurrencies where the data of one crypto gets transferred into another crypto. However, for decentralized finance to exist, the exchange of information from one to another cryptocurrency is crucial. This is where Wrapped EVER comes in. In simple words, WEVER represents a cryptocurrency based on a separate blockchain and is worth the same, but can be used on non-native blockchains and later, redeemed for the original cryptocurrency. Putting it in reference, Wrapped EVER (wEVER) is a digital token that has the same value as one EVER but is based on TIP-3 standard, which makes it usable on the Decentralised Finance ecosystem. WEVER is also available on ETH and BNB (BSC) networks, which makes it usable on the Decentralized Finance ecosystem. Contracts of EVER (Wrapped EVER): TIP-3: 0:a49cd4e158a9a15555e624759e2e4e766d22600b7800d891e46f9291f044a93dEthereum: 0x29d578CEc46B50Fa5C88a99C6A4B70184C062953BNB Smart Chain: 0x0A7e7D210C45c4abBA183C1D0551B53AD1756ecA "},{"title":"Use-cases​","type":1,"pageTitle":"FAQ","url":"learn/faq#use-cases","content":"Cross-chain transaction fees.  Using the cross-chain bridge Octus Bridge, it is possible to transfer crypto-assets between Everscale, Ethereum, BNB Chain (Binance Smart Chain), Fantom Opera, Polygon, Avalanche, Milkomeda networks and pay commission in EVER. Validating  Validators stakes required to maintain the blockchain. To raise a validator node in the Everscale network, a Validator will need to purchase EVERs to provide a stake, as well as acquire a server that will withstand the projected loads due to block validation. Participation in DAO.  Using EVER DAO, a new decentralized governance mechanism that brings users into the fold on decisions that affect the entire Everscale ecosystem. Any user can stake their wEVER on the platform to submit proposals and vote on proposals submitted by others. Payment for services.  Many apps and bots use EVER, for example, you can pay Combot subscription, play PokerTON, etc. "},{"title":"How can i store and trade EVER?​","type":1,"pageTitle":"FAQ","url":"learn/faq#how-can-i-store-and-trade-ever","content":"For storing your TIP-3 tokens you need to use appropriate wallets - check out the wallets section. To buy EVER you can use exchange wallets, CEX (centralize exchanges) or DEX (decentralize exchanges). "},{"title":"What are the Everscale earning opportunities?​","type":1,"pageTitle":"FAQ","url":"learn/faq#what-are-the-everscale-earning-opportunities","content":""},{"title":"Earning EVERs​","type":1,"pageTitle":"FAQ","url":"learn/faq#earning-evers","content":"Staking​ In Everscale, here is DePool, which is a specialized smart contract that collects stakes from various participants to be pooled together and forwarded as one stake to the Elector on behalf of a validator node. The validator node owner supports the DePool providing a guaranteed minimal stake, and allowing smaller token holders to participate in and benefit from validation. The owner's benefit, in turn, is the increased stake for their node. Stake collection is continuous. Stakes can be made at any time, and will be distributed to whichever round is currently in the pooling stage. Every time an election begins on the blockchain, the accumulated pool is locked and staked in this election, and the pooling stage of the next round begins. Farming​ Yield-farming is an increasingly popular product in many various DeFi protocols, and Everscale is no different in this respect! Similar to staking, farming income is expressed as a percentage per year, and is added to your tokens as long as they are locked into a farming pool. These farming pool consist of LP tokens (Liquidity provider tokens) which are obtained through providing liquidity to the exchange pools in their respective pairs. Depending on which tokens are paired for farming, the amount of income can vary greatly. Generally speaking, pairs with better known coins and stable tokens offer a lower percentage yield than those pairs with less known tokens. The income indicator for the year is APR and is expressed as a percentage. Grants​ Everscale Grants is a new method of funding teams to develop Everscale blockchain that has come to replace contests. Grants aim to help promising IT startups launch and onramp into the Everscale ecosystem. In a word, the program was successful. Take a look for yourself at the results. A total of 17 projects were interviewed as part of the project. Of those 17, 8 of the best and brightest were selected to be part of the project. As of right now, the elite 8 are going through DD procedures and more technical interviews as partnership terms are being negotiated. You’ll be able to read the full details about each participant once all of the procedures have been completed and partnership terms have been agreed upon. While DeFi is our thing, the projects that are involved with the grants program come from all different sectors and stand to add some diversity to the Everscale ecosystem. In the first round, Everscale had projects from GameFi, the NFT space, DeFi, AML and the crypto news sphere apply. Everscale Grants campaign has grand pool of 15 000 000 EVERs. Validation​ "},{"title":"What about validation process?​","type":1,"pageTitle":"FAQ","url":"learn/faq#what-about-validation-process","content":"Everscale validator is a network node (server) that participates in the validation of generated new blocks of the blockchain. These nodes are selected as validators for a certain period (validation cycle), during which they participate in validation together. Validation is the signing of blocks by several nodes in order to reach a consensus (general agreement) on the correctness of the block. The very procedure of reaching consensus is necessary for the network to ensure the reliability of its functioning, that is, resistance to failures of individual nodes or deliberate attacks. In fact, validators provide the basis for the functioning of a decentralized network. For their work, they receive remuneration consisting of a processing fee (1,7 EVER for a new block in the masterchain, 1 EVER for a new block in the shardchain), as well as from the emission of new tokens distributed to validators. In the current network parameters, the emission is fixed at the level of ~0.5% per year. It is distributed each validation cycle to all validators in proportion to their stakes. Check out the Validation section for more information. "},{"title":"What can I do as a developer?​","type":1,"pageTitle":"FAQ","url":"learn/faq#what-can-i-do-as-a-developer","content":"Since Everscale is quite a young network, there are a lot of opportunities for developers here: hachatons and grants, Smart Contracts developing, DAO, etc. Check out the developer section to learn more. "},{"title":"How to contribute to Everscale?​","type":1,"pageTitle":"FAQ","url":"learn/faq#how-to-contribute-to-everscale","content":"Since Everscale was created on the principles of decentralization, the management and development of the network is completely decentralized with the help of a community where each participant can contribute, through DAOs, grants, making improvements to the network documentation, etc. Go to the Contributing section and see the main features of Everscale's self-improvement "},{"title":"How to integrate with Everscale?​","type":1,"pageTitle":"FAQ","url":"learn/faq#how-to-integrate-with-everscale","content":"Everscale is open to everything new, including integrations with other projects, teams and products. You can add EVER to your exchange, integrate your network into Octus Bridge, etc. For a detailed introduction to integration options and their implementation, see the Integration section. "},{"title":"What about Everscale ecosystem?​","type":1,"pageTitle":"FAQ","url":"learn/faq#what-about-everscale-ecosystem","content":"Check out the Ecosystem section. "},{"title":"History","type":0,"sectionRef":"#","url":"learn/history","content":"","keywords":""},{"title":"History behind TON blockchain​","type":1,"pageTitle":"History","url":"learn/history#history-behind-ton-blockchain","content":"The Telegram messenger project was created by brothers Nikolay and Pavel Durov in 2013. Nikolay Durov invented the MTProto encryption scheme, which formed the basis of the project. The main concept of Telegram messenger was privacy and secure communication of users. The messenger existed on Pavel Durov's personal funds until 2017. In 2017, Pavel Durov develops the concept of TON - Telegram Open Network. The Telegram Open Network project is inextricably linked with the Telegram Messenger, with plans to integrate the Gram cryptocurrency [1]. In December 2018 TON virtual machine delivired. In February 2018, Pavel Durov is raising $850 million in investments in the first round of ICO for the development of blockchain platform TON (price of the Gram token was $0.38). The ICO notification is officially registered by the US Securities and Exchange Commission (SEC). From the business plan of Pavel Durov, it follows that Telegram as a messenger is the first phase of a more global project, and was created mainly to form a huge customer base. As TON develops, the messenger itself will become just one of its applications, so in 2021 it is planned to rebrand Telegram Open Network into The Open Network, and the Telegram brand will remain with the messenger. The real goal of the project is the Telegram Open Network platform, which offers Gram cryptocurrency with fast transaction speeds, as well as various services from Proxy for bypassing censorship to bots and file storage that can be paid for with Gram cryptocurrency. In the second round of ICO, an additional $850 million are raised(price of the Gram is up to $1.33)[2]. At the same time, Pavel Durov rejected about half of the applications for investment until the third round of placement - investors wanted to invest more than $3.7 billion in the project. Pavel Durov's refusal to receive new investments is justified by the fact that his plan to raise money exceeded his expectations many times. The cost of establishing the Telegram Open Network is estimated at $400 million. At the same time, the total amount of raised investments amounted to $1.7 billion for both rounds. The whole amount was received from private investors who got Gram tokens in return for their investments. The list of investors includes quite famous personalities: Roman Arkadievich Abramovich (entrepreneur, included in the list of Forbes, invested $10 million through the fund Norma Investments Limited), David Mikhailovich Yakobashvili (founder of the company Wimm-Bill-Dann, invested $10 million), Sergey Alexandrovich Solonin (founder of the platform Qiwi, invested $ 17 million), Mikhail Safarbekovich Gutseriev (main shareholder of the group Safmar, the owner of the company M.Video and Eldorado, invested $15 million through Larnabel Ventures) [3]. TON blockchain platform was launched in autumn 2018. The developers then said that the network is 70% ready and most of the components have already been finalized. The launch of testnet should have taken place in January 2019, however, was postponed. Ferbuary 2019: TON Labs launches the first EVER blockchain with proof of authority (PoA). July 2019: TON Labs Launch of the alpha version of TON OS. On September 6, 2019, TON test portal for developers with official project specifications was opened - https://test.ton.org/, and on https://test.ton.org/testnet/ TON network explorer was available, displaying the first hundreds of working nodes of the network. The New York Times, commenting on these events, noted that the project produces test tokens ahead of schedule, which should satisfy investors. Observers, referring to experts in crypto, also note that Durov's strategy to keep the development of TON in relative secrecy has given rise to some skepticism in the cryptographic society about the competing Libra cryptocurrency project from Facebook, but in the end, it turned out to be correct, because Facebook, after making the development of Libra transparent, immediately incurred the anger of regulators. At the same time, crypto experts such as David Gerard note that despite the TON team's efforts to meet the KYC-AML principles, the project's central risk is similar to Libra - government regulators may be afraid of losing control of the financial system [4]. TON OS startup edition goes public. In October 2019, the U.S. Securities and Exchange Commission (SEC) demanded a ban on the issuance of Gram. The SEC, in its report, recognized Gram as security (not a commodity or utility token) and the Gram issue itself violated securities laws. On November 2019 TON Labs launches its own TON testnet. On January 7 and 8, 2020, the SEC interrogated Pavel Durov about TON ICO. The interrogation took place in Dubai, UAE. The American regulator was trying to find out why Durov launched the ICO, how much money he spent on Telegram and TON, and why Gram token is not a security. Durov replied that the money was needed to buy equipment and maintain the blockchain platform, and Gram was a utility token, not a security. On March 25, Telegram challenged the U.S. court ban on transferring Gram tokens to investors. The court of the Southern District of New York State in a preliminary decision agreed with the SEC's opinion that the project's cryptocurrency is a security. The U.S. authorities claim that investors purchased coins to sell on the secondary market to earn money. On May 12, 2020, Pavel Durov announced in his Telegram channel that he has closed the TON blockchain project. According to Pavel Durov, Telegram's participation in TON development is over. He urged users not to trust money or data to projects that use the name of the messenger or platform. No one from the company team participates in any of these projects, Durov said. He added that networks that use TON's developments may appear, but Telegram has nothing to do with them and is unlikely to ever support them. TON Labs participates in the community launch of the Free TON blockchain as the core developer On Thursday, May 7th, the Free TON Community (consisting of developers and potential TON users) launched the Free TON blockchain platform. Instead of Gram participants will get tokens called TON Crystal. To become a community member you need to sign Free TON Declaration of Decentralization. On August 2021 Everscale achieves world record high throughput. In 8 November, 2021, Free TON has announced an ecosystem rebrand to Everscale. The new brand identity comes as the network prepares to migrate from C++ to Rust programming language implementation, enabling unmatched scalability and throughput capable of bringing the world on-chain. December 2021: Free TON rebrands to Everscale Source: Everscale Wiki "},{"title":"Support","type":0,"sectionRef":"#","url":"learn/support","content":"Support This article has TO DO status. You can contribute by submitting your own version of this page. More details on the Documentation page of the Hot streams section.","keywords":""},{"title":"Terminology","type":0,"sectionRef":"#","url":"learn/terminology","content":"","keywords":""},{"title":"Everscale​","type":1,"pageTitle":"Terminology","url":"learn/terminology#everscale","content":"Decentralised blockchain network that comprises many leading applications and services. Everscale has powerful developer tools, such as compilers for Solidity and C++, API, an SDK that includes client libraries for 13 programming languages and other convenient instruments designed for developers to build outstanding blockchain applications. "},{"title":"Blockchain​","type":1,"pageTitle":"Terminology","url":"learn/terminology#blockchain","content":"The chain of all blocks that have been added to the Everscale network throughout the history of the network. Each block has a reference to the previous block. Thus, it permits us to maintain a sequence of all blocks in the chain. "},{"title":"Ever​","type":1,"pageTitle":"Terminology","url":"learn/terminology#ever","content":"Ever is the native cryptocurrency of Everscale. Besides being an investment opportunity for users, it has multiple uses inside as well as outside the Everscale network. "},{"title":"TVM​","type":1,"pageTitle":"Terminology","url":"learn/terminology#tvm","content":"TVM is the virtual machine used to execute smart-contract code in the masterchain and in the basic workchain. Any user can request the execution of arbitrary code on the TVM. For more information about TVM please consult this page "},{"title":"Nodes​","type":1,"pageTitle":"Terminology","url":"learn/terminology#nodes","content":"Nodes are ordinary computers on which the Everscale program is running. Each node is connected to other nodes, which allows to come to a consensus, which is a special mechanism by which information about the correctness of transactions on the network is checked. The Everscale network is the aggregate of all Everscale nodes and their communications. "},{"title":"Accounts​","type":1,"pageTitle":"Terminology","url":"learn/terminology#accounts","content":"This is the place for storing Ever. Besides storage, users with an account are able to deposit and transfer Ever. The account record stores account address and account balance. Accounts are ultimately stored in TVM. For more information about Accounts please consult this page. "},{"title":"Transactions​","type":1,"pageTitle":"Terminology","url":"learn/terminology#transactions","content":"A transaction is the result of a contract execution. In general, a transaction is generated with one incoming message (external or internal) and can generate several outcoming messages (external or internal) as a result. Any user can broadcast a transaction request to the Everscale network from a node. "},{"title":"Blocks​","type":1,"pageTitle":"Terminology","url":"learn/terminology#blocks","content":"There is a very high number of transactions on the Everscale network. Due to this, transactions are grouped in blocks. Each block counts hundreds of transactions. "},{"title":"Smart contracts​","type":1,"pageTitle":"Terminology","url":"learn/terminology#smart-contracts","content":"SMs are a kind of algorithm, or program that runs on Everscale or other blockchains, like Ethereum, which was the first to come up with the idea of smart contracts. They work in accordance to a prescribed set of rules that are programmed by developers. When all conditions prescribed in the contract are met, the contract is executed. For more information about smart contracts please consult this page "},{"title":"Shards​","type":1,"pageTitle":"Terminology","url":"learn/terminology#shards","content":"Shards in Everscale are used for solving the classical issue faced by blockchains, which is low throughput. Sharding is merely partition of data in a database, in our case in the Everscale blockchain. Due to sharding, Everscale achieved one of the highest transactions per second rate available out there. For detailed information about how sharding works please consult this page. "},{"title":"Multisig","type":0,"sectionRef":"#","url":"learn/tutorial/institutionals/multisig","content":"","keywords":""},{"title":"What is multisignature wallet?​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#what-is-multisignature-wallet","content":"As a simple analogy, we can imagine a secure deposit box that has two locks and two keys. One key is held by Alice and the other one is held by Bob. The only way they can open the box is by providing their both keys at the same time, so one cannot open the box without the consent of the other. Basically speaking, the funds stored on a multi-signature address can only be accessed by using 2 or more signatures. Therefore, the use of a multisig wallet enables users to create an additional layer of security to their funds. "},{"title":"Use cases for a multisignature wallet​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#use-cases-for-a-multisignature-wallet","content":""},{"title":"Increasing security​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#increasing-security","content":"By using a multisig wallet, users are able to prevent the problems caused by the loss or theft of a private key. So even if one of the keys is compromised, the funds are still safe. Imagine that Alice creates a 2-of-3 multisig address and then stores each private key into a different place or device (e.g. mobile phone, laptop, and tablet). Even if her mobile device is stolen, the thief won’t be able to access her funds using only 1 of the 3 keys. Similarly, phishing attacks and malware infections are less likely to succeed because the hacker would most likely have access to a single device and key. Malicious attacks aside, if Alice loses one of her private keys, she can still access her funds using the other 2 keys. "},{"title":"Two-factor authentication​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#two-factor-authentication","content":"By creating a multisig wallet that requires two keys, Alice is able to create a two-factor authentication mechanism to access her funds. For instance, she could have one private key stored in her laptop and the other one in her mobile device (or even on a piece of paper). This would ensure that only someone who has access to both keys is able to make a transaction. Keep in mind, however, that using multisig technology as two-factor authentication can be dangerous – especially if it is set as a 2-of-2 multisig address. If one of the keys are lost, you won’t be able to access your funds. "},{"title":"Escrow transactions​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#escrow-transactions","content":"Creating a 2-of-3 multisig wallet can allow for an escrow transaction between two parties (Alice and Bob) that includes a third party (Charlie) as a mutually trusted arbiter in case anything goes wrong. Charlie, the arbiter, would only need to step in if there was a dispute, at which point he could use his key to create a signature that would be provided to either Alice or Bob, according to Charlie’s judgment. "},{"title":"Decision making​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#decision-making","content":"A board of directors might use a multisig wallet to control access to a company’s funds. For example, by setting up a 4-of-6 wallet where each board member holds one key, no individual board member is able to misuse the funds. Therefore, only decisions that are agreed upon by the majority can be executed. "},{"title":"Everscale multisignature wallets​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#everscale-multisignature-wallets","content":"Let's move on to choosing a multi-signature wallet. "},{"title":"EVERSPACE​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#everspace","content":"Native wallet for iOS and Android from ByteHub and ITGold teams. Very good design. Fast and responsive interface. Support for most types of multisig wallets. The ability to receive notifications of transactions for signature. Convenient transaction subscription mechanism. Download link "},{"title":"EVER Wallet​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#ever-wallet","content":"Everscale native wallet created by the Broxus team. Access on IOS, Android and as a Google Chrome browser extension. It has several types of multisignature wallets, including those with the ability to add new custodians. A distinctive feature of the wallet is the ability to connect it with Everscale's most popular DeFi products: FlatQube (DEX), Octus Bridge, Everstart (launchpad), etc. Download link "},{"title":"Ever Sufr​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#ever-sufr","content":"One of the most popular Everscale wallets. Available on IOS, Android, Windows and MacOS. Provides the ability to create a multisig wallet and add up to 32 custodians. Download link "},{"title":"Getting started","type":0,"sectionRef":"#","url":"learn/tutorial/institutionals/tutorial","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Getting started","url":"learn/tutorial/institutionals/tutorial#introduction","content":"We are happy to see your interest in the Everscale network and want to make your entrance as smooth and straightforward as possible. To that end, on this page, we will briefly review the main cases that may be useful to you. "},{"title":"Let's begin​","type":1,"pageTitle":"Getting started","url":"learn/tutorial/institutionals/tutorial#lets-begin","content":"First, if you're not familiar with Everscale, we highly recommend that you explore the Everscale overview section. Let's move on to the cases: "},{"title":"Multisignature wallet​","type":1,"pageTitle":"Getting started","url":"learn/tutorial/institutionals/tutorial#multisignature-wallet","content":"Multisignature wallet is a very useful tool for any investor. It allows you not only to conveniently manage your corporate account, but also greatly increases the safety of your funds. Go to Multisignature Wallet page to learn more about this tool and its implementation options in Everscale. "},{"title":"Everscale DeFi Alliance​","type":1,"pageTitle":"Getting started","url":"learn/tutorial/institutionals/tutorial#everscale-defi-alliance","content":"Everscale DeFi Alliance is one of the central organizations in the network. Thanks to the Alliance, you can conduct profitable OTC transactions, as well as intelligently invest your funds directly in the development of the network, rather than in the purchase of tokens. Go to the Everscale DeFi Alliance website for more details and to apply for a partnership. "},{"title":"DAO​","type":1,"pageTitle":"Getting started","url":"learn/tutorial/institutionals/tutorial#dao","content":"DAO is a decentralized decision-making tool. Thanks to DAO, holders can make in-network decisions. DAO is a tool for those who care about the network itself (or a specific Dapp) and those who are ready to determine the value of a decision within Everscale on their own. The following projects currently have the DAO mechanism: EVER DAO - this is the primary decision-making tool relating directly to the Everscale network. Octus Bridge DAO is a decision-making tool within the main Everscale network multichain solution. EverStart (DAO mechanism not launched yet).EverLend - a DeFi platform and an Everlend-powered money market protocol that focuses on the creation of fund pools whose interest rates are based on a supply and demand algorithm of Everlend assets (DAO mechanism not launched yet). "},{"title":"Launchpad​","type":1,"pageTitle":"Getting started","url":"learn/tutorial/institutionals/tutorial#launchpad","content":"Launchpad allows you to invest in the development of certain projects just before their launch, benefiting in the long term from vesting - the gradual distribution of tokens among all investors, in proportion to the funds they have invested. At the moment, Everscale's only launchpad is Everstart. Everstart is a DAO-managed multi-chain launchpad powered entirely by smart contracts. Go to the website of the site and hurry up to get acquainted with upcoming projects. "},{"title":"Smart Investments in Everscale​","type":1,"pageTitle":"Getting started","url":"learn/tutorial/institutionals/tutorial#smart-investments-in-everscale","content":"If you're interested in classic investments and hedge funds, Warp Capital is your choice. Warp Capital is an official Everscale partner in decentralized finance. Warp Capital is one of the few decentralized finance hedge funds that provides full control over the invested funds to the investors with capital contributions of $1M+. Go to Warp Capital's website and fill out the investor questionnaire to start a reliable and profitable partnership. "},{"title":"Welcome","type":0,"sectionRef":"#","url":"learn/welcome","content":"","keywords":""},{"title":"About Everscale​","type":1,"pageTitle":"Welcome","url":"learn/welcome#about-everscale","content":"Everscale is a unique blockchain design that proposes a scalable decentralized world computer, paired with a distributed operating system — Ever OS. Ever OS is capable of processing millions of transactions per second, with Turing-complete smart contracts and decentralized user interfaces. Everscale presents some new and unique properties, such as dynamic multithreading, soft majority consensus and distributed programming, which enable it to be scalable, fast and secure at the same time. It is governed by a decentralized community founded upon meritocratic principles via Soft Majority Voting protocol. Everscale has powerful developer tools, such as compilers for Solidity and C++, API, an SDK that includes client libraries for 13 programming languages and all popular platforms, local node for DApp testing, CLI tools and a range of decentralized browsers and wallets empowering many applications in DeFi, NFT, tokenization and governance domains. If you would like to learn more about Everscale, please visit the Everscale Overview page. Comparison with other networks "},{"title":"Everscale for you​","type":1,"pageTitle":"Welcome","url":"learn/welcome#everscale-for-you","content":"Thanks to its well developed network, Everscale is able to interest several types of participants by providing them with multiple branches of activity. Users (Tutorial) - Everscale as an opportunity for storage and earnings (DeFi, NFT, etc.). Developers (Tutorial, Section) - Development of decentralised applications on Everscale. Validators (Tutorial, Section) - Validating and staking. Contributors (Tutorial, Section) - Earn with partnerships that benefit the network.. Intergators (Tutorial, Section) - Integration of Everscale technologies, listing of tokens, etc. Below, we provide tutorials as well as links to the sections of documentation designed to accommodate each particular participant in accordance with what interests you most on the Everscale network. "},{"title":"Key organizations​","type":1,"pageTitle":"Welcome","url":"learn/welcome#key-organizations","content":"There are many companies that were formed around Everscale that boosted the growth of the network. Let's take a look at some of them: Everscale DeFi Alliance - Everscale DeFi Alliance creates the necessary infrastructure to interest and maintain strong teams and projects, attract liquidity from other projects to Everscale and establish partnerships with major companies with large amounts of liquidity and/or a large number of transactions. Everscale Grants - is a campaign that aims to attract promising IT projects that can contribute to the Everscale ecosystem's growth. EVER DAO - is a platform where EVER token holders can make on-chain governance decisions for the whole Everscale Network. Ever Foundation (the website is under construction). It will become the primary entry point for all kinds of projects that want to develop and create their products and businesses on top of the Everscale. The Foundation provides grant support to projects that bring the greatest benefit to the network, and actively promotes them. "},{"title":"Users","type":0,"sectionRef":"#","url":"learn/tutorial/users","content":"","keywords":""},{"title":"Buy and store tokens​","type":1,"pageTitle":"Users","url":"learn/tutorial/users#buy-and-store-tokens","content":"Everscale has several types of tokens, the most popular of which is the TIP-3 token format. The main network token is EVER. It is used to pay fees to validators, reward stakeholders and participants in contests run by the DAO management team, and performs a number of other important functions within the network. In order to store and manage tokens on the Everscale network, you will need a wallet that supports the TIP-3 token format. There are many different ways to buy EVER: Exchange walletsExchangesDEXS Check out the Wallets section for the most popular token storage solutions. "},{"title":"Popular cases of interaction with Everscale​","type":1,"pageTitle":"Users","url":"learn/tutorial/users#popular-cases-of-interaction-with-everscale","content":"Once you have an Everscale network wallet, you can start interacting with various products (Dapps) of the network. Everscale provides many earning opportunities for regular users. You can earn on farming, NFT, staking or trading on exchanges and DEX. In the Ecosystem section, you can get acquainted with the most popular representatives of Everscale dapps in various industries: DeFi, NFT, GameFi, etc. "},{"title":"Community​","type":1,"pageTitle":"Users","url":"learn/tutorial/users#community","content":"Everscale can be proud of its community - a community of friendly newbies and experienced users: network members help each other and discuss various aspects of the network in chats and on the Everscale forum. Go to the main Everscale chats and groups to see the strength of our unity: Everscale Community Everscale News EverKit Everscale DeFi Everscale Dev "},{"title":"COPYLEFT (TIP-1.1)","type":0,"sectionRef":"#","url":"standard/TIP-1.1","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"COPYLEFT (TIP-1.1)","url":"standard/TIP-1.1#introduction","content":"Many members of our community have asked questions about Everscale code philosophy. Why we call it Free Software? What is a relationship between Everscale and Free Software? What is the difference between Free Software and Open Source? I have decided to combine this with an idea I have regarding gas payment redistribution in TON. You will see below why it is related. The concept of Free Software predates open source. Richard Stallman has started the free-software movement in 1983 with a launch of GNU Project while open-source movement has been derived from Free Software only in 1998. To clarify, the Free Software is not in conflict with Open Source. As explained below it follows all the same principles and the differences seems more ideological. Yet TON project did not have any problem with open-source nature of it software. It is all open sourced. The problem was exactly about the Freedom of people to use it. That is why Everscale is heavily influenced by Free Software movement. Declaration of Decentralisation is, in many ways, inspired by Stallman’s «The GNU Manifesto»1. In «Why Open Source misses the point of Free Software» Stallman writes among other things: «The terms «free software» and «open source» stand for almost the same range of programs. However, they say different things about those programs, based on different values. The free software movement campaigns for freedom for the users of computing; it is a movement for freedom and justice. By contrast, the open source idea values mainly practical advantage and does not campaign for principles. This is why we do not agree with open source, and do not use that term»2. It seems Everscale is in agreement with this line of thought. While all our software is open source it is the Freedom to run the software what has launched this network. Now let’s talk about Copyright and Licensing as they relate to the Free Software in general and Blockchain in particular. Before we start I need to say that blockchain may potentially provide a solution to some of the free software inherited business model problems. We all remember that free in the free software stands for freedom and not for zero price. The ability to get paid for a software should not be based on restrictions imposed by its license. But what it should be based upon then? There are several business models for free software non of which really works. What works is a business model that is not exactly related to the software itself and therefore can not be attributed to it. Such as charging for support or for portions of the software which are closed source. It all seems quite unnatural. It also prevents one of the major points of free software — an open collaboration of the community around software projects. Donald Fischer article title «Open source creators: Red Hat got $34 billion and you got $0. Here’s why»3 is self explanatory. IBM has bought a commercial company that was built on top of many developers’ contribution to its code. Those developers never got any part out of the value they have created. "},{"title":"Aligning the incentives​","type":1,"pageTitle":"COPYLEFT (TIP-1.1)","url":"standard/TIP-1.1#aligning-the-incentives","content":"Many free and open source software projects struggle to introduce a sustainable business model. This is one of the reasons why most of the open source software contributors work for large corporations. When a venture capital provides funding to a software project it expects multiple return on its capital. With commercial software it is quite straight forward — a company is charging money for its software use and if successful passes profits to its stakeholders. With free software its quite difficult. That is why there are very few (or should we say: not enough) commercially successful open source software companies. Blockchain introduces a unique opportunity for Free Software developers to align their commercial interests with those of users for the benefit of the whole ecosystem. As an Internet of Value protocol, Blockchain has built-in network incentive mechanism — network fees (or gas). To remind: Miners in Proof-Of-Work collect miner rewards and network fees to compensate them for resources spent to secure the network and process transactions. Both security computations and transaction processing are separate resources, thus requiring separate fees. In Proof-Of-Stake Validators commit funds and processing power to secure the network and process transactions (in a form of smart contract execution in TON). For this they also get separate rewards: block rewards in a form of token emission and transaction reward in a form of a fee. Please note, rewards are separated in both cases. We propose to extend the reward model to transaction facilitators. It would be logical to pay part of the fees to the smart contract developer who is initiating the transaction which pays the fee. This will attract both Developers and Users which will increase network usage and total transaction fees for all network participants. "},{"title":"On-chain licensing fees​","type":1,"pageTitle":"COPYLEFT (TIP-1.1)","url":"standard/TIP-1.1#on-chain-licensing-fees","content":"Somewhat naive mechanism but with the same underlying idea is proposed by Near blockchain. «The developerReward are allocated by per block per account, as they can be efficiently done every time the transaction or receipts is being processed by the contract»4. The problem with this approach lays in the fact that network fees not only pays for resources but also provide an important anti spam mechanism. One can use the developer kick-back to simply lower an attack costs. To mitigate that risk we propose a use of a special Payout Contract. This contract is going to pay the collected Copyleft fees to developers only after certain threshold in both amount of fees and time frame are surpassed. In this respect the Developer motivation is again aligned with the Network security model — it is not practical to break the network where one receives a long term rent. "},{"title":"Some technical details​","type":1,"pageTitle":"COPYLEFT (TIP-1.1)","url":"standard/TIP-1.1#some-technical-details","content":"Technically we introduce a TVM Opcode FB0A. Contract may include that code together with a License information and address of its developer. Collator will include a reward related to gas fees from these transactions into the block for the address indicated in the TVM instruction in the amount corresponding to the indicated License. The percentage of gas fees depends on the license type such as that the most free software compatible license provides more gas. FB0A - COPYLEFT (n x y - ), looks up for the license rule for ‘n’ in ConfigParam (for example 42) and creates output action to send part of the tokens it collected from gas fees to Payout contract indicated in ConfigParam for address x:y, where x - is 32 bit signed integer for workchain and y is 256 bit unsigned integer for contract address in this workchain. It will not throw any exceptions if n or the address are incorrect. Generally allowed licenses are those supported by Free Software Foundation as described here: https://www.gnu.org/licenses/license-list.html#SoftwareLicenses 2 License types payout GPL-Compatible Free Software Licenses 2 → 30% fees GPL-Incompatible Free Software Licenses → 20% fees To implement we add network config parameter: license fees threshold value Collator check threshold each time the instruction is executed. After threshold is reached collator sends value to Developer Account defined in contract instruction FB0A TVM creates special out action with Developer Account (last call of FB0A matters) If account is been deleted, the executor sends value to Developer Account or to ValueFlow if it is not enough (this case must be checked in Validator) Executor analyzes special out action and counts value then sends message to developer account (payment for transaction gets from value) We add fields to json objects and QServer for SDK Collator and Validator must check fees from ValueFlow with Developer correction "},{"title":"Copyright discussion​","type":1,"pageTitle":"COPYLEFT (TIP-1.1)","url":"standard/TIP-1.1#copyright-discussion","content":"«What is the proper way to decide copyright policy? If copyright is a bargain made on behalf of the public, it should serve the public interest above all. The government’s duty when selling the public’s freedom is to sell only what it must, and sell it as dearly as possible. At the very least, we should pare back the extent of copyright as much as possible while maintaining a comparable level of publication»5. One important dimension of copyright is its durationAnother dimension of copyright policy is the extent of fair use: some ways of reproducing all or part of a published work that are legally permitted even though it is copyrighted. (c) Richard Stallman Both duration and fair use of copyright is balanced in this proposal by virtue of compensating copyright holder by Payout Contract creating an ongoing reward from the network while at the same time not preventing a forking possibility by other developers who then need to improve the software in a way that will bring new users and create new intensive for the new contributor. So both improvements as well as long term rent (subscription) is provided for developers. The Copyleft spirit is fully supported here as the Fee is collected for developers who facilitates the fees creation in the first place. The freedom to fork is fully executed as well as anyone can fork the code of a smart contract. In the end it is the community of users who chooses which contract to use and the decision is usually based upon the reputation of the code represented by the hash of the code where is no single byte has been changed. Therefore the system is merit-based. Both long term developer’s incentives for original developers and forking is provided. To recap the proposed system is compatible with all four essential freedoms: The freedom to run the program as you wish, for any purpose (freedom 0).The freedom to study how the program works, and change it so it does your computing as you wish (freedom 1). Access to the source code is a precondition for this.The freedom to redistribute copies so you can help others (freedom 2).The freedom to distribute copies of your modified versions to others (freedom 3). By doing this you can give the whole community a chance to benefit from your changes. Access to the source code is a precondition for this. "},{"title":"References​","type":1,"pageTitle":"COPYLEFT (TIP-1.1)","url":"standard/TIP-1.1#references","content":"The GNU Manifesto↩Why Open Source Misses the Point of Free Software↩Open source creators: Red Hat got $34 billion and you got $0. Here's why↩Economics in a Sharded Blockchain — Section 06 — Developer Business Models↩Misinterpreting Copyright — A Series of Errors↩ "},{"title":"MYCODE (TIP-1.2)","type":0,"sectionRef":"#","url":"standard/TIP-1.2","content":"MYCODE (TIP-1.2) F82A — MYCODE (- s) — returns the Cell with the current code of the smartcontract. Equivalent to GETPARAM 10. Smartcontract has own code which cell representation can be obtained by this instruction.","keywords":""},{"title":"ReDeNS — Reverse DeCert (TIP-2.1)","type":0,"sectionRef":"#","url":"standard/TIP-2.1","content":"ReDeNS — Reverse DeCert (TIP-2.1) In TIP-2 it is stated that in order to resolve a Certificate Address from the Contract Address, that contract must have its Certificate Address explicitly stated. There is a need sometimes to resolve some certificate address from the address of a contract. Here we present an architecture and implementation of Reverse DeCert and one of its usecases: ReDeNS Reverse Decentralized Names or ReDeNS for short is a certificate that enables reverse resolving of some contracts addresses from another contract. It uses a contract Placeholder for each type of contract functionality that we want to be able to put into external (or satellite) contract of a main contract. ReDeNs enables any client to calculate the address of a satellite contract using a ReDeNs code as a certificate for each type of satellite contract it desires to resolve. In order to resolve a ReDeNS address the user may calculate an address taking a hash of a main contract and a hash of ReDeNS certificate as initial data and an owner address or PubKey in constructor parameters. After the deploy of initial ReDeNS certificate code developer will use SetCode to change the ReDeNS certificate code to desired type of satellite smart contract (with ABI, Getter or DeBot functionality, respectively and so on) For example we have identified 3 types of satellite contracts which will be default ReDeNS Certificates of any main contract in Solidity and C++ Compilers and TON OS SDK: ABI, GETTERS and DEBOT. To protect contracts without ReDeNS certificate deployed from squatters we propose to use header with bitmask: one bit for each type of ReDeNS certificates: abi-DeCert, getters-DeCert, debot-DeCert and so on. So far, we decided to have 16-bit bitmask. 3 of them already occupied. { Abi, getters, debot }. The ReDeNS certificate code is as following: How to create DeBot derived from your smart contract","keywords":""},{"title":"DeCert — Decentralized Certificates","type":0,"sectionRef":"#","url":"standard/TIP-2","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#abstract","content":"There is a clear need for unified decentralized and distributed certificate system in Everscale. As described in more details below, such system would be used in providing many services which requires a certified provable key-value store. For example a Decentralized Name Service (DeNS), a Prove of Ownership / Prove of Purchase certificate and many others. Current solutions (for example a TON DNS, proposed here) are either a large smart contracts which maintains a full list of records, or a tree-like solutions which shards the list based on some parameters. Neither of these solutions are satisfactory due to a lack of scalability, high costs of maintenance, long search time, single point of failure and so on. Here I present a completely distributed system, which does not require centralized record, nor a tree of domains or records with almost zero latency. The design relies heavily onе the principles of TIP-3 Token architecture with some notable modifications. "},{"title":"Issuance​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#issuance","content":"Root is a smart contract contains a Code of Certificate smart contract without data. The Root has methods for Certificate Issuance, Certificate Code Retrieval, Root PubKey retrieval and Version history. Each Certificate can become a Root, therefore a Root smart contract and its Certificate smart contract are the same. The Code contains an address of its Root. When a User wishes to register it is calling a Certificate Issuance method in Root, sending a Certificate Data (for example an alphanumeric string of a certificate body). Root is taking its Public Key and a Code of Certificate smart contract, inserts a Certificate Data sent by a User, calculates the address of Certificate and checks if the address already has a Certificate or any other Code deployed by sending a bounced true message calling getData method. If a contract exists it means that a Certificate with the same Certificate Data already exists. The contract then can return a registration information to the Root which will return it to a User. If a contract does not exist the message will bounce to the Root smart contract which will mean the Certificate can be registered. If Certificate does not exist the Root will Issue the Certificate by deploying the Certificate Contract with its Data. On deploy the Certificate will check that it has been deployed from the root address by comparing the address of a Root inside with the deployer address. If there is no match the deploy will fail. Of course additional business logic steps could be included between the last two steps, such as monetization or other mechanics as shown below in one of the examples. "},{"title":"Resolving​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#resolving","content":"To resolve the Name any User can now call Get method Resolve of a Root locally to obtain an Address. Root will use Certificate Code, Root PubKey, insert a name User wishes to resolve into Certificate Code and calculate the address. To resolve a Root smart contract one can take any Certificate Core and resolve for the Root name. A user application can cash the Certificate Code smart contract and Root PubKey once, after which resolving any name is achieved locally with a simple address calculation, with no need for network connection at all. The Certificate itself contains variable types of addresses of a target smart contracts to which the Certificate owner wishes the name to point. A user should choose which type of address they wish to use. "},{"title":"Reverse resolving​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#reverse-resolving","content":"In order to make a reverse resolving a smart contract need to state its certificate address. The user will check if certificate indeed has contract address. "},{"title":"Search​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#search","content":"Of course search is one of the most important features of any name system. Knowing a Certificate Code hash enables to retrieve all smart contracts having the same hash by simply querying the blockchain state. Decoding contract data will produce a full list of names under specific Root. It would be quite easy to produce a table with all the certificate records. "},{"title":"Example: Decentralized Name Service (DeNS)​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#example-decentralized-name-service-dens","content":"Let’s consider a DeNS Root is a smart contract which contains a Code of the Name Identity Certificate (NIC) smart contract. The Root has methods for Identity Registering, NIC Code Retrieval, Root PubKey retrieval, Version history. When a User wishes to register an Identity it is calling a «RegName» method in DeNS Root with the signed message of UTF-8 string (Name) together with a Registration Bid (a hash of a Bid Value in TONs with some salt) with value attached 1 TON. DeNS Root is taking its Public Key and a NIC Code inserts a Name, calculates the NIC address and checks if the address already has a NIC Code deployed by sending a bounced true message calling method «getName». Return to User a Whois Information. If it bounces or a registration period in Whois is less than 28 days DeNS Root will send the name into an Auction Smart Contract together with a Registration Bid Hash and a number of years before expiration. First bidder determines the duration of the auctioned name. Other users will be able to Bid for the same name but only for same duration with their Bids following exactly the same process. Auction duration is minimum 7 days per year of name duration but no more than 28 days. At the end of the Auction all participants will submit to the Auction contract a message signed from the address of the original bid together with their original bid price and salt. The winner of the auction will be determined by the highest bid per day and will pay the second higher price for the Name Certificate. Once DeNS Root knows the Auction result it will wait until registration period ends if the name certificate has existed before or immediately deploy the NIC smart contract into the address calculated as a NIC Contract Code with a Name inserted into initial data and PubKey of the Owner passed in its constructor. To resolve the Name any User can now call Get method «Resolve» of DeNS Root locally to obtain an Address. DeNS Root will use Code of NIC smart contract, a DeNS Root PubKey, insert any name they are wishing to resolve into NIC Code and calculate the address. Since most of the time a user application will just cash the Code of NIC smart contract and DeNS PubKey, resolving any name is achieved locally with a simple address calculation, with no need for network connection at all. "},{"title":"Example of NIC smart contract methods​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#example-of-nic-smart-contract-methods","content":"Whois — sends all certificate data: a name, date of registration, owner PubKey GetWhois is a whois getter GetAddress by Type, for example — ADNL, Wallet, RegName GetResolve ChangeAddress ChangeOwnership "},{"title":"Everscale Name Identity Certificate convention​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#everscale-name-identity-certificate-convention","content":"Format: any alfa-numeric string except for a dot (.) and slash (/) which are prohibited. Only top level names are provided by DeNS Root, but any NIC smart contract can point into a next level of hierarchy which is divided by / top-name/sub-name/ The dot (.) is specifically prohibited as to not create confusions with a current internet domain system. "},{"title":"Example: Ownership Certificate​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#example-ownership-certificate","content":"The Certificate is issued by Root for ownership of an item. Let’s call it certificate of Ownership or COW for short. COW will include a serial number of an item a User want to prove owning. Since the PubKey of an owner of certificate is presented it is easy to prove an ownership of an Item by finding the certificate with corresponding serial number calculating the address of this certificate with this number, POW Code and Root PubKey without a need to maintain any centralized ledger of said items. The transfer of ownership of an Item is easily supported as well by calling a ChangeOwnership Method in the POW signed by the owner private key. "},{"title":"Reference​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#reference","content":"Contest Proposal: Decentralized Name Service (DeNS)ReDeNS — Reverse DeCert (TIP-2.1) "},{"title":"Fungible Token","type":0,"sectionRef":"#","url":"standard/TIP-3","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Fungible Token","url":"standard/TIP-3#abstract","content":"The following standard describes the basic idea about distributed fungible token architecture. "},{"title":"Motivation​","type":1,"pageTitle":"Fungible Token","url":"standard/TIP-3#motivation","content":"The suggested standard differs considerably from Ethereum ERC20 and other smart contract token standards with single registry due to its distributed nature related to Everscale blockchain particularities. Given that Everscale has a storage fee, using an existing ERC20 standard design would cause excessive maintenance costs. Also, ERC20 is somewhat incompatible with the sharding architecture. Therefore, a Distributed Token standard is preferable. The ERC20 sharding implementation (with an idea to simply shard its registry) has drawbacks mainly related to complicated and expansive management. TIP-3 is fully distributed and implies separate storage of each user’s balance. "},{"title":"Architecture​","type":1,"pageTitle":"Fungible Token","url":"standard/TIP-3#architecture","content":"General information about token is stored in the token root contract. Each token holder has its own instance of token wallet contract. Token transfers SHOULD be implemented in P2P fashion, between sender and receiver token wallets. "},{"title":"Token root​","type":1,"pageTitle":"Fungible Token","url":"standard/TIP-3#token-root","content":"Token root contract stores the general information about the token, e.g. name, symbol, decimals, token wallet code and so on. "},{"title":"Token wallet​","type":1,"pageTitle":"Fungible Token","url":"standard/TIP-3#token-wallet","content":"Each token holder has its own instance of token wallet contract. Transfer happens in a decentralized fashion - sender token wallet SHOULD send the specific message to the receiver token wallet. Since token wallets have the same code, it's easy for receiver token wallet to check the correctness of sender token wallet. "},{"title":"References​","type":1,"pageTitle":"Fungible Token","url":"standard/TIP-3#references","content":"EIP-20: Token StandardEverscale Forum - TIP3Reference implementation by Broxus "},{"title":"Non-Fungible Token","type":0,"sectionRef":"#","url":"standard/TIP-4","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Non-Fungible Token","url":"standard/TIP-4#abstract","content":"The following standard describes the basic idea of distributed non-fungible token architecture. "},{"title":"Motivation​","type":1,"pageTitle":"Non-Fungible Token","url":"standard/TIP-4#motivation","content":"The suggested standard differs considerably from Ethereum ERC721 and other smart contract token standards with single registry because of its distributed nature related to Everscale blockchain particularities. Given that Everscale has a storage fee, TIP4 is fully distributed and implies separate storage of each NFT. "},{"title":"Architecture​","type":1,"pageTitle":"Non-Fungible Token","url":"standard/TIP-4#architecture","content":"General information about NFT collection is stored in the NFT collection contract. Each NFT deployed in separate smart contracts and links to NFT collection contract Smart contract architecture based on: Consider asynchronous type of Everscale blockchain. Use callbacks and asynchronous getters;Standardizes one NFT - one smart contract. Gas fee management practicals. Use TIP-6.1 "},{"title":"(Status:Review) Non-Fungible Token (TIP-4.1)​","type":1,"pageTitle":"Non-Fungible Token","url":"standard/TIP-4#statusreview-non-fungible-token-tip-41","content":"General information about NFT collection and NFT tokens. All NFT must implement TIP-4.1 "},{"title":"(Status:Review) Non-Fungible Token JSON Metadata (TIP-4.2)​","type":1,"pageTitle":"Non-Fungible Token","url":"standard/TIP-4#statusreview-non-fungible-token-json-metadata-tip-42","content":"General information about NFT metadata. TIP-4.2 is optional, but can be used for displaying NFT on marketplaces, wallets and web. "},{"title":"(Status:Review) On-chain indexes (TIP-4.3)​","type":1,"pageTitle":"Non-Fungible Token","url":"standard/TIP-4#statusreview-on-chain-indexes-tip-43","content":"On-chain Indexes solves easy and fast searching any data in blockchain. TIP-4.3 is optional, but can be use for find all your NFT with one dApp query. "},{"title":"(Status:Draft) On-chain storage (TIP-4.4)​","type":1,"pageTitle":"Non-Fungible Token","url":"standard/TIP-4#statusdraft-on-chain-storage-tip-44","content":"Using the Storage contract, you can store NFT-related bytes in blockchain. TIP-4.4 is optional, but can be used for fault tolerance. If off-chain services are unavailable, the user will view NFT-related bytes, because it is stored on-chain. "},{"title":"Authors​","type":1,"pageTitle":"Non-Fungible Token","url":"standard/TIP-4#authors","content":"Author\tCommandAleksand Aleksev\tgrandbazar.io Aleksandr Khramtsov\tbroxus Andrey Nedobylskiy\tsvoi.dev Anton Platonov\tcommunity member Nikita\tnumiz.org Oleg Varnov\tnumiz.org Slava Semenchuk\tscalepunks.com "},{"title":"Implementation​","type":1,"pageTitle":"Non-Fungible Token","url":"standard/TIP-4#implementation","content":"itgold implementation MIT licensed.A library of modular, reusable smart contracts.Samples and tests here "},{"title":"References​","type":1,"pageTitle":"Non-Fungible Token","url":"standard/TIP-4#references","content":"Ethereum EIP-721Solana v1.2.0TON NFT, TON DATATezos TZIP12 "},{"title":"Fungible Token Interface (TIP-3.1)","type":0,"sectionRef":"#","url":"standard/TIP-3.1","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Fungible Token Interface (TIP-3.1)","url":"standard/TIP-3.1#abstract","content":"The following standard allows for the implementation of a standard API for tokens within smart contracts. General information about token is stored in the token root contract. Each token holder has its own instance of token wallet contract. Token transfers SHOULD be implemented in P2P fashion, between sender and receiver token wallets. "},{"title":"Motivation​","type":1,"pageTitle":"Fungible Token Interface (TIP-3.1)","url":"standard/TIP-3.1#motivation","content":"A standard interface allows any tokens on Everscale to be re-used by other applications: from wallets to decentralized exchanges. "},{"title":"Specification​","type":1,"pageTitle":"Fungible Token Interface (TIP-3.1)","url":"standard/TIP-3.1#specification","content":"The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. "},{"title":"Notes​","type":1,"pageTitle":"Fungible Token Interface (TIP-3.1)","url":"standard/TIP-3.1#notes","content":"We choose Standard Interface Detection to expose the interfaces that a TIP3 smart contract supports.This standard does not define the external methods to initiate transfer, mint or burn tokens. Though it defines the methods, which MUST be called on a recipient token wallet or token root during these operations.The rules for a token wallet ownership MUST be defined in a child standards.A -1 offset is added to some function IDs derivations, so the preimage of the hash cannot be known, further reducing the chances of a possible collisions. "},{"title":"Token root​","type":1,"pageTitle":"Fungible Token Interface (TIP-3.1)","url":"standard/TIP-3.1#token-root","content":"Name​ Returns the name of the token - e.g. &quot;MyToken&quot;. function name() public view responsible returns (string);  Symbol​ Returns the symbol of the token. E.g. “HIX”. function symbol() public view responsible returns (string);  Decimals​ Returns the number of decimals the token uses - e.g. 8, means to divide the token amount by 100000000 to get its user representation. function decimals() public view responsible returns (uint8);  Total supply​ Returns the total token supply. function totalSupply() public view responsible returns (uint128);  Token wallet code​ Returns the token wallet code. function walletCode() public view responsible returns (TvmCell);  Accept tokens burn​ Does not have a standard signature, but has a standard function ID 0x192B51B1 obtained as tvm.functionId('acceptBurn(uint128)') - 1. The uint128 _value parameter MUST be first. The function name and the rest of the parameters are not fixed by this standard and can be reinvented for each substandard. Decreases token total supply by _value. The contract MUST check that the sender is a correct token wallet. Before sending this message, caller token wallet MUST decrease its own balance by _value. If the mint can't be accepted (e.g. invalid sender), this message MUST be bounced. Any function from the following snippet is a valid example: interface TIP3AcceptBurn { function acceptBurn(uint128 _value) functionID(0x192B51B1) public; function acceptBurn2(uint128 _value, uint256 _publicKey, address _owner) functionID(0x192B51B1) public; function acceptBurn3(uint128 _value, TvmCell _meta) functionID(0x192B51B1) public; }  Standard interface detection​ interface TIP3TokenRoot { function acceptBurn(uint128 _value) functionID(0x192B51B1) public view responsible; function name() public view responsible returns (string); function symbol() public view responsible returns (string); function decimals() public view responsible returns (uint8); function totalSupply() public view responsible returns (uint128); function walletCode() public view responsible returns (TvmCell); }  The token root interface ID is 0x4371D8ED. "},{"title":"Token wallet​","type":1,"pageTitle":"Fungible Token Interface (TIP-3.1)","url":"standard/TIP-3.1#token-wallet","content":"Root​ Returns the token root address. function root() public view responsible returns (address);  Balance​ Returns the token wallet balance. function balance() public view responsible returns (uint128);  Wallet code​ Returns the token wallet code. function walletCode() public view responsible returns (TvmCell);  Accept tokens transfer​ Does not have a standard signature, but has a standard function ID 0x67A0B95F obtained as tvm.functionId('acceptTransfer(uint128)') - 1. The uint128 _value parameter MUST be first. The function name and the rest of the parameters are not fixed by this standard and can be reinvented for each substandard. Increases token wallet balance by _value. The contract MUST check that the sender is a correct token wallet. Before sending this message, caller token wallet MUST decrease its own balance by _value. If the transfer can't be accepted (e.g. invalid sender), this message MUST be bounced. Any function from the following snippet is a valid example: interface TIP3AcceptTransfer { function acceptTransfer(uint128 _value) functionID(0x67A0B95F) external; function acceptTransfer2(uint128 _value, uint256 _publicKey, address _owner) functionID(0x67A0B95F) external; function acceptTransfer3(uint128 _value, TvmCell _meta) functionID(0x67A0B95F) external; }  Accept tokens mint​ Does not have a standard signature, but has a standard function ID 0x4384F298 obtained as tvm.functionId('acceptMint(uint128)') - 1. The uint128 _value parameter MUST be first. The function name and the rest of the parameters are not fixed by this standard and can be reinvented for each substandard. Increases token wallet balance by _value. The contract MUST check that the sender is a correct token root. Before sending this message, token root MUST increase the total supply by _value. If the mint can't be accepted (e.g. invalid sender), this message MUST be bounced. Any function from the following snippet is a valid example: interface TIP3AcceptMint { function acceptMint(uint128 _value) functionID(0x4384F298) external; function acceptMint2(uint128 _value, uint256 _publicKey, address _owner) functionID(0x4384F298) external; function acceptMint3(uint128 _value, TvmCell _meta) functionID(0x4384F298) external; }  On-bounce behaviour​ The acceptTransfer or acceptBurn methods can be bounced, e.g. receiver token wallet has a different code or burning disabled. The token wallet behaviour in these cases should be implemented according to the following rules. Handle acceptTransfer bounce​ Increases token wallet balance according to the value, specified in the bounce body. Handle acceptBurn bounce​ Increases token wallet balance according to the value, specified in the bounce body. Standard interface detection​ interface TIP3TokenWallet { function acceptTransfer(uint128 _value) functionID(0x67A0B95F) external; function acceptMint(uint128 _value) functionID(0x4384F298) external; function root() public view responsible returns (address); function balance() public view responsible returns (uint128); function walletCode() public view responsible returns (TvmCell); }  The token wallet interface ID is 0x4F479FA3. "},{"title":"Non-Fungible Token (TIP-4.1)","type":0,"sectionRef":"#","url":"standard/TIP-4.1","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#abstract","content":"The following standard allows for implementing a standard API for NFTs within smart contracts. General information about NFT collection is stored in the NFT collection contract. Each NFT deployed in separate smart contracts and links to NFT collection contract. This standard provides basic functionality to create, track and transfer NFTs. "},{"title":"Motivation​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#motivation","content":"A standard interface allows any NFT to be re-used by other applications: wallets, explorers, marketplaces, etc. "},{"title":"Specification​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#specification","content":"The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. "},{"title":"Collection​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#collection","content":"The contract represents shared information about NFT collection and logic for creation of NFTs and burn of NFTs. Every TIP4.1 compliant collection contract must implement the TIP4_1Collection interface and TIP-6.1 interfaces pragma ton-solidity &gt;= 0.58.0; interface TIP4_1Collection { /// @notice This event emits when NFTs are created /// @param id Unique NFT id /// @param nft Address NFT contact /// @param owner Address of NFT owner /// @param manager Address of NFT manager /// @param creator Address of creator that initialize mint NFT event NftCreated(uint256 id, address nft, address owner, address manager, address creator); /// @notice This event emits when NFTs are burned /// @param id Unique NFT id /// @param nft Address NFT contact /// @param owner Address of NFT owner when it burned /// @param manager Address of NFT manager when it burned event NftBurned(uint256 id, address nft, address owner, address manager); /// @notice Count active NFTs for this collection /// @return count A count of active NFTs minted by this contract except for burned NFTs function totalSupply() external view responsible returns (uint128 count); /// @notice Returns the NFT code /// @return code Returns the NFT code as TvmCell function nftCode() external view responsible returns (TvmCell code); /// @notice Returns the NFT code hash /// @return codeHash Returns the NFT code hash function nftCodeHash() external view responsible returns (uint256 codeHash); /// @notice Computes NFT address by unique NFT id /// @dev Return unique address for all Ids. You find nothing by address for not a valid NFT /// @param id Unique NFT id /// @return nft Returns address of NFT contract function nftAddress(uint256 id) external view responsible returns (address nft); }  NOTE The TIP-6.1 identifier for this interface is 0x1217AAAB. "},{"title":"TIP4_1Collection.totalSupply()​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#tip4_1collectiontotalsupply","content":"function totalSupply() public view responsible returns (uint128 count);  count (uint128) - A count of active NFTs The function return count of active NFTs. Value increased by one when NFT minted and decreased by one when NFT burned. "},{"title":"TIP4_1Collection.nftCode()​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#tip4_1collectionnftcode","content":"function nftCode() public view responsible returns (TvmCell code);  code (TvmCell) - NFT code NFTs is a smart contract deployed from collection smart contract use nftCode and id. "},{"title":"TIP4_1Collection.nftCodeHash()​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#tip4_1collectionnftcodehash","content":"function nftCodeHash() public view responsible returns (uint256 codeHash);  codeHash (uint256) - NFT codeHash A codeHash allows search all smart contracts using base dApp functionality. "},{"title":"TIP4_1Collection.nftAddress()​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#tip4_1collectionnftaddress","content":"function nftAddress(uint256 id) public view responsible returns (address nft);  id (uint256) - Unique NFT idnft (address) - The NFT address Computes NFT address by unique NFT id. You can check the NFT for availability using base dApp functionality. "},{"title":"Events​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#events","content":"event NftCreated(uint256 id, address nft, address owner, address manager, address creator); event NftBurned(uint256 id, address nft, address owner, address manager);  id (uint256) - Unique NFT idnft (address) - The NFT addressowner (address) - The initial\\last owner of the NFTmanager (address) - The initial\\last manager of the NFTcreator (address) - The initial address who initiate NFT deploy You must emit NftCreated event when NFT minted. You must emit NftBurned event when NFT burned. "},{"title":"Mint and burn NFT​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#mint-and-burn-nft","content":"A function's signature is not included in the specification. See the Events for your responsibilities when creating or burning NFTs. "},{"title":"NFT​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#nft","content":"The contract represents information about current NFT and control logic. Each NFT contains two roles: owner logicmanager logic The owner’s address is the address that owns this NFT. The owner can see NFT in wallets, marketplaces, apps. The owner can use the NFT for authorization, for proof in games etc. Manager address is the address that controls this NFT. Manager can burn NFT, can change the owner or change the manager (transfer the manager role). Owner address and manager address can be same usually. When an NFT is put up for sale, it means that the manager's address is the address of the smart contract with the sell logic. It's same for farming logic or custom logic for use NFT. Good practice is to set a manager address to a new owner address when owner changed. Every TIP4.1 compliant NFT contract must implement the TIP4_1NFT interface and TIP-6.1 interfaces. pragma ton-solidity &gt;= 0.58.0; interface TIP4_1NFT { struct CallbackParams { uint128 value; // ever value will be sent to address TvmCell payload; // custom payload will be proxied to address } /// @notice The event emits when NFT is created /// @dev Emit the event when NFT is ready to use /// @param id Unique NFT id /// @param owner Address of NFT owner /// @param manager Address of NFT manager /// @param collection Address of collection smart contract that mint the NFT event NftCreated(uint256 id, address owner, address manager, address collection); /// @notice The event emits when NFT owner changed /// @param oldOwner Address of NFT owner before owner changed /// @param newOwner Address of new NFT owner event OwnerChanged(address oldOwner, address newOwner); /// @notice The event emits when NFT manager changed /// @param oldManager Address of NFT manager before manager changed /// @param newManager Address of new NFT manager event ManagerChanged(address oldManager, address newManager); /// @param id Unique NFT id /// @param owner Address of NFT owner /// @param manager Address of NFT manager /// @param collection Address of collection smart contract, that mint the NFT event NftBurned(uint256 id, address owner, address manager, address collection); /// @notice NFT info /// @return id Unique NFT id /// @return owner Address of NFT owner /// @return manager Address of NFT manager /// @return collection Address of collection smart contract function getInfo() external view responsible returns(uint256 id, address owner, address manager, address collection); /// @notice Change NFT owner /// @dev Invoked from manager address only /// @dev Emit OwnerChanged /// @param newOwner New owner of NFT /// @param sendGasTo Address to send remaining gas /// @param callbacks Callbacks array to send by addresses. It can be empty function changeOwner(address newOwner, address sendGasTo, mapping(address =&gt; CallbackParams) callbacks) external; /// @notice Change NFT manager /// @dev Invoked from manager address only /// @dev Emit ManagerChanged /// @param newManager New manager of NFT /// @param sendGasTo Address to send remaining gas /// @param callbacks Callbacks array to send by addresses. It can be empty function changeManager(address newManager, address sendGasTo, mapping(address =&gt; CallbackParams) callbacks) external; /// @notice Change NFT owner and manager /// @dev Invoked from manager address only /// @dev Emit OwnerChanged /// @dev Emit ManagerChanged /// @param to New NFT owner and manager /// @param sendGasTo Address to send remaining gas /// @param callbacks Callbacks array to send by addresses. It can be empty function transfer(address to, address sendGasTo, mapping(address =&gt; CallbackParams) callbacks) external; }  NOTE The TIP-6.1 identifier for this interface is 0x78084F7E. "},{"title":"TIP4_1NFT.getInfo()​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#tip4_1nftgetinfo","content":"function getInfo() public view responsible returns(uint256 id, address owner, address manager, address collection);  id (uint256) - Unique NFT idowner (address) - The owner of the NFTmanager (address) - The manager of the NFTcollection (address) - The NFT collection address "},{"title":"TIP4_1NFT.changeOwner()​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#tip4_1nftchangeowner","content":"function changeOwner(address newOwner, address sendGasTo, mapping(address =&gt; CallbackParams) callbacks) external;  newOwner (address) - New owner of NFTsendGasTo (address) - Address to send remaining gas. It sent to all callback addresses, toocallbacks (mapping(address =&gt; CallbackParams)) - Callbacks uses for asynchronous calls to another addresses CallbackParams: Field name\ttype\tDescriptionvalue\tuint128\tEver values that send with callback payload\tTvmCell\tCustom payload will send to address Change NFT owner. You must emit OwnerChanged event when NFT owner changed. The NFT sends callbacks if callbacks not empty. "},{"title":"TIP4_1NFT.changeManager()​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#tip4_1nftchangemanager","content":"function changeManager(address newManager, address sendGasTo, mapping(address =&gt; CallbackParams) callbacks) external;  newManager (address) - New manager of NFTsendGasTo (address) - Address to send remaining gas. It sent to all callback addresses toocallbacks (mapping(address =&gt; CallbackParams)) - Callbacks uses for asynchronous calls to another addresses CallbackParams: Field name\ttype\tDescriptionvalue\tuint128\tEver values that send with callback payload\tTvmCell\tCustom payload will send to address Change NFT manager. You must emit ManagerChanged event when NFT owner changed. The NFT sends callbacks if callbacks not empty. "},{"title":"TIP4_1NFT.transfer()​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#tip4_1nfttransfer","content":"function transfer(address to, address sendGasTo, mapping(address =&gt; CallbackParams) callbacks) external;  to (address) - New NFT owner and managersendGasTo (address) - Address to send remaining gas. It sent to all callback addresses toocallbacks (mapping(address =&gt; CallbackParams)) - Callbacks uses for asynchronous calls to another addresses CallbackParams: Field name\ttype\tDescriptionvalue\tuint128\tEver values that send with callback payload\tTvmCell\tCustom payload will send to address Change NFT manager. You must emit OwnerChanged and ManagerChanged events when NFT owner changed. The NFT sends callbacks if callbacks not empty. "},{"title":"NFT events​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#nft-events","content":"event NftCreated(uint256 id, address owner, address manager, address collection); event OwnerChanged(address oldOwner, address newOwner); event ManagerChanged(address oldManager, address newManager); event NftBurned(uint256 id, address owner, address manager, address collection);  id (uint256) - Unique NFT idowner (address) - The initial\\last owner of the NFTmanager (address) - The initial\\last manager of the NFTcollection (address) - The collection address who initiate NFT deploy You must emit NftCreated event, when NFT created, initialized and ready to use. You must emit OwnerChanged event every time when owner address changed. You must emit ManagerChanged event every time when manager address changed. You must emit NftBurned event when NFT burned. Events emit when NFTs are created, burned or moved to a new owner\\manager. "},{"title":"Mint NFT​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#mint-nft","content":"A function and constructor signature is not included in the specification. The NFT must deploy from collection smart contract. The NFT must emit NftCreated event after NFT deployed and ready to use. See the [NFT events](#NFT events) for your responsibilities when creating NFT. "},{"title":"Burn NFT​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#burn-nft","content":"A function signature is not included in the specification. The NFT must emit NftBurned event before NFT burned. The NFT must send an internal message to collection contract before NFT burned. See the Events for your responsibilities when burning NFT. "},{"title":"ChangeOwner callback processing​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#changeowner-callback-processing","content":"Smart contract that processing callback message must implement. interface INftChangeOwner { struct CallbackParams { uint128 value; // ever value will send to address TvmCell payload; // custom payload will be proxied to address } /// @notice change owner callback processing /// @param id Unique NFT id /// @param manager Address of NFT manager /// @param oldOwner Address of NFT owner before owner changed /// @param newOwner Address of new NFT owner /// @param collection Address of collection smart contract, that mint the NFT /// @param sendGasTo Address to send remaining gas /// @param payload Custom payload function onNftChangeOwner( uint256 id, address manager, address oldOwner, address newOwner, address collection, address sendGasTo, TvmCell payload ) external; }  "},{"title":"ChangeManager callback processing​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#changemanager-callback-processing","content":"Smart contract that processing callback message must implement. interface INftChangeManager { struct CallbackParams { uint128 value; // ever value will send to address TvmCell payload; // custom payload will proxying to address } /// @notice change owner callback processing /// @param id Unique NFT id /// @param owner Address of NFT owner /// @param oldManager Address of NFT manager before manager changed /// @param newManager Address of new NFT manager /// @param collection Address of collection smart contract that mint the NFT /// @param sendGasTo - Address to send remaining gas /// @param payload - Custom payload function onNftChangeManager( uint256 id, address owner, address oldManager, address newManager, address collection, address sendGasTo, TvmCell payload ) external; }  "},{"title":"Transfer callback processing​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#transfer-callback-processing","content":"Smart contract that processing callback message must implement. interface INftTransfer { struct CallbackParams { uint128 value; // ever value will send to address TvmCell payload; // custom payload will proxying to address } /// @notice change owner callback processing /// @param id Unique NFT id /// @param oldOwner Address of NFT owner before transfer /// @param newOwner Address of new NFT owner /// @param oldManager Address of NFT manager before transfer /// @param newManager Address of new NFT manager /// @param collection Address of collection smart contract that mint the NFT /// @param sendGasTo Address to send remaining gas /// @param payload Custom payload function onNftTransfer( uint256 id, address oldOwner, address newOwner, address oldManager, address newManager, address collection, address sendGasTo, TvmCell payload ) external; }  "},{"title":"Visualization​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#visualization","content":""},{"title":"Legend​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#legend","content":" "},{"title":"Collection deployment​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#collection-deployment","content":" "},{"title":"Minting​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#minting","content":" "},{"title":"Burning​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#burning","content":" "},{"title":"Change owner​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#change-owner","content":" "},{"title":"Change manager​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#change-manager","content":" "},{"title":"Example how to use NFT. Put on sell using changeManager()​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#example-how-to-use-nft-put-on-sell-using-changemanager","content":" "},{"title":"Example how to use NFT. Buy using changeOwner()​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#example-how-to-use-nft-buy-using-changeowner","content":" "},{"title":"Example how to use NFT. Put on sell by TIP-3.1 tokens​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#example-how-to-use-nft-put-on-sell-by-tip-31-tokens","content":" "},{"title":"Example how to use NFT. Buy for TIP-3.1 tokens​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#example-how-to-use-nft-buy-for-tip-31-tokens","content":" "},{"title":"References​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#references","content":"Ethereum EIP-721Solana v1.2.0TON NFT, TON DATATezos TZIP12 "},{"title":"Non-Fungible Token JSON Metadata (TIP-4.2)","type":0,"sectionRef":"#","url":"standard/TIP-4.2","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Non-Fungible Token JSON Metadata (TIP-4.2)","url":"standard/TIP-4.2#abstract","content":"Token-specific metadata is stored as a string in smart contract. To facilitate an off-chain working with metadata, it is JSON object. The below metadata structure allows the marketplaces to read and display the details about the assets which your NFTs represent. This standard provides optional JSON fields and contract interface. "},{"title":"Motivation​","type":1,"pageTitle":"Non-Fungible Token JSON Metadata (TIP-4.2)","url":"standard/TIP-4.2#motivation","content":"A standard fields facilitate displaying of NFT data for: wallets, explorers, marketplaces, etc. "},{"title":"Specification​","type":1,"pageTitle":"Non-Fungible Token JSON Metadata (TIP-4.2)","url":"standard/TIP-4.2#specification","content":"The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 "},{"title":"JSON metadata​","type":1,"pageTitle":"Non-Fungible Token JSON Metadata (TIP-4.2)","url":"standard/TIP-4.2#json-metadata","content":"Return the metadata as JSON Every TIP4.2 compliant contract must implement the TIP4_2JSON_Metadata interface and TIP-6.1 interfaces pragma ton-solidity &gt;= 0.58.0; interface TIP4_2JSON_Metadata { /// @notice metadata in JSON format /// @return json The JSON string with metadata function getJson() external view responsible returns (string json); }  NOTE The TIP-6.1 identifier for this interface is 0x24D7D5F5. "},{"title":"TIP4_2JSON_Metadata.getJson()​","type":1,"pageTitle":"Non-Fungible Token JSON Metadata (TIP-4.2)","url":"standard/TIP-4.2#tip4_2json_metadatagetjson","content":"function getJson() external view responsible returns (string json);  json (string) - The JSON string with metadata The function return metadata as a JSON string. "},{"title":"Empty JSON metadata​","type":1,"pageTitle":"Non-Fungible Token JSON Metadata (TIP-4.2)","url":"standard/TIP-4.2#empty-json-metadata","content":"Empty JSON metadata is represented as a blank JSON object or an empty string. {}  "},{"title":"JSON metadata type​","type":1,"pageTitle":"Non-Fungible Token JSON Metadata (TIP-4.2)","url":"standard/TIP-4.2#json-metadata-type","content":"Not empty JSON must have &quot;type&quot; field {&quot;type&quot;:&quot;string&quot;}  Application that read JSON metadata use &quot;type&quot; field for parsing standard or custom JSON fields. "},{"title":"JSON metadata type: \"Basic NFT\"​","type":1,"pageTitle":"Non-Fungible Token JSON Metadata (TIP-4.2)","url":"standard/TIP-4.2#json-metadata-type-basic-nft","content":"The Basic NFT use for links to files stores in web. JSON fields contain information about item, files and preview info. The Basic NFT describes fields that must be in JSON Field name\ttype\tValue\tDescriptiontype\tstring\t&quot;Basic NFT&quot;\tConstant name for this type name\tstring Name of the object description\tstring Description of the object preview\tobject Object preview preview.source\tstring Link to object. Contains protocol and data source. Delimiter is : preview.mimetype\tstring Mime type of object files\tarray Array of objects. file.source\tstring Link to object. Contains protocol and data source. Delimiter is : file.mimetype\tstring Mime type of object external_url\tstring URL to website "},{"title":"Example​","type":1,"pageTitle":"Non-Fungible Token JSON Metadata (TIP-4.2)","url":"standard/TIP-4.2#example","content":"{ &quot;type&quot;: &quot;Basic NFT&quot;, &quot;name&quot;: &quot;Sample Name&quot;, &quot;description&quot;: &quot;Hello world!&quot;, &quot;preview&quot;: { &quot;source&quot;: &quot;https://everscale.network/images/Backgrounds/Main/main-hero.png&quot;, &quot;mimetype&quot;: &quot;image/png&quot; }, &quot;files&quot;: [ { &quot;source&quot;: &quot;https://everscale.network/images/Backgrounds/Main/main-hero.png&quot;, &quot;mimetype&quot;: &quot;image/png&quot; } ], &quot;external_url&quot;: &quot;https://everscale.network&quot; }  You can extend Basic NFT type for your custom fields. "},{"title":"JSON metadata type: metaverse.region​","type":1,"pageTitle":"Non-Fungible Token JSON Metadata (TIP-4.2)","url":"standard/TIP-4.2#json-metadata-type-metaverseregion","content":"The metaverse.region JSON object stores the unique reference to a specific region (bundle of regions) inside a metaverse. Field name\tType\tDescription\tValuetype\tstring\tNFT type\tmetaverse.region version\tstring\tModel version (for future compatibility)\t1.0 meta\tobject\tRegion metadata regions\tarray&lt;object&gt;\tRegion parameters (multi-component regions allowed)\t Example { &quot;type&quot;: &quot;metaverse.region&quot;, &quot;version&quot;: &quot;1.0&quot;, &quot;meta&quot;: { &quot;server&quot;: { &quot;type&quot;: &quot;minecraft&quot;, &quot;url&quot;: &quot;http://10.10.10.10:25565&quot;, &quot;pubkey&quot;: &quot;c843d424bba89625d64fb592975180023e46b499388856fa832e287484adc4aa&quot; }, &quot;signature&quot;: &quot;cc9d3377f78d33a3d2d412d173f2b6e9e6dd06af19749d95032ea7c78eb07d873ddfe0b241a190900422732207dbbdc987b1bbcfd74d56404f0ab0d65d4f930e&quot; }, &quot;regions&quot;: [ { &quot;shape&quot;: &quot;cuboid&quot;, &quot;params&quot;: { &quot;position1&quot;: { &quot;x&quot;: &quot;0&quot;, &quot;y&quot;: &quot;-50&quot;, &quot;z&quot;: &quot;0&quot; }, &quot;position2&quot;: { &quot;x&quot;: &quot;16&quot;, &quot;y&quot;: &quot;200&quot;, &quot;z&quot;: &quot;16&quot; } } } ] }  "},{"title":"Region metadata​","type":1,"pageTitle":"Non-Fungible Token JSON Metadata (TIP-4.2)","url":"standard/TIP-4.2#region-metadata","content":"This section must contain at least a minimum of the required information about the metaverse server where the region is located. Field name\tType\tDescription\tExample valueserver.type\tstring\tType of metaverse that has issued the NFT token\tminecraft server.url\turi (optional)\tAddress where the server is located. Typically, the URL, from which the server actual metadata like name, description, etc. can be extracted.\t10.10.10.10:25565 server.pubkey\tstring\tPublic key issued by the compatible NFT adapter used to sign the NFT content data signature\tstring\tHEX representation of the signature, generated using ed25519 algorithm based on the contents of regions array content (without the object name) and server private key. Before generation, the base JSON array must be compacted (i.e. all the whitespace and line breaks must be removed). In the example above, it will look as follows: [{&quot;shape&quot;:&quot;cuboid&quot;,&quot;params&quot;:{&quot;position1&quot;:{&quot;x&quot;:&quot;0&quot;,&quot;y&quot;:&quot;-50&quot;,&quot;z&quot;:&quot;0&quot;},&quot;position2&quot;:{&quot;x&quot;:&quot;16&quot;,&quot;y&quot;:&quot;200&quot;,&quot;z&quot;:&quot;16&quot;}}}]\t "},{"title":"Region shape types​","type":1,"pageTitle":"Non-Fungible Token JSON Metadata (TIP-4.2)","url":"standard/TIP-4.2#region-shape-types","content":"The reference implementation is inspired by Minecraft's Worldedit primitive region models. Type\tDescription\tReference modelcuboid\tBox-shaped region\tLink cylinder\tCylinder-shaped region\tLink sphere\tSpheric-shaped region\tLink polygon2d\t2D-polygonal-shaped region\tLink Cuboid​ Cuboid is the simplest and the most popular shape of a region typically used in most metaverses. It is defined by X, Y and Z coordinates of two points in the space (the order is insignificant), one of which is considered as the start (bottom, minimum) and the other one as the end (top, maximum) of the region. Cuboid object specification​ Field name\tType\tDescription\tValueshape\tstring\tType of shape\tcuboid params.position1\txyz\tFirst vertex of the cuboid params.position2\txyz\tSecond vertex of the cuboid\t Example usage​ { &quot;type&quot;: &quot;metaverse.region&quot;, &quot;version&quot;: &quot;1.0&quot;, &quot;meta&quot;: {}, &quot;regions&quot;: [ { &quot;shape&quot;: &quot;cuboid&quot;, &quot;params&quot;: { &quot;position1&quot;: { &quot;x&quot;: &quot;0&quot;, &quot;y&quot;: &quot;-50&quot;, &quot;z&quot;: &quot;0&quot; }, &quot;position2&quot;: { &quot;x&quot;: &quot;16&quot;, &quot;y&quot;: &quot;200&quot;, &quot;z&quot;: &quot;16&quot; } } } ] }  Cylinder​ Cylinders are commonly used in central areas of large objects (lize plazas, fountains, etc). They are defined by coordinates of basic central point, radius, and height. Cylinder object specification​ Field name\tType\tDescription\tValueshape\tstring\tType of shape\tcylinder params.center\txyz\tBasic central point of the cylinder params.radius\tstring\tRadius of the cylinder (number in string format for maximum compatibility) params.height\tstring\tHeight of the cylinder (number in string format for maximum compatibility) For the avoidance of doubt, the Y coordinate of the opposite cylinder's side is calculated as Y_basic + height\t Example usage​ { &quot;type&quot;: &quot;metaverse.region&quot;, &quot;version&quot;: &quot;1.0&quot;, &quot;meta&quot;: {}, &quot;regions&quot;: [ { &quot;shape&quot;: &quot;cylinder&quot;, &quot;params&quot;: { &quot;center&quot;: { &quot;x&quot;: &quot;0&quot;, &quot;y&quot;: &quot;-50&quot;, &quot;z&quot;: &quot;0&quot; }, &quot;radius&quot;: &quot;16&quot;, &quot;height&quot;: &quot;100&quot; } } ] }  Sphere​ Spheres are typically used as parts of complex objects like sculptures, buildings, etc. Sphere is described by coordinates of central point and radius. Spherical object specification​ Field name\tType\tDescription\tValueshape\tstring\tType of shape\tsphere params.center\txyz\tBasic central point of the sphere params.radius\tstring\tRadius of the sphere (number in string format for maximum compatibility)\t Example usage​ { &quot;type&quot;: &quot;metaverse.region&quot;, &quot;version&quot;: &quot;1.0&quot;, &quot;meta&quot;: {}, &quot;regions&quot;: [ { &quot;shape&quot;: &quot;sphere&quot;, &quot;params&quot;: { &quot;center&quot;: { &quot;x&quot;: &quot;0&quot;, &quot;y&quot;: &quot;-50&quot;, &quot;z&quot;: &quot;0&quot; }, &quot;radius&quot;: &quot;16&quot; } } ] }  2D polygon​ Polygons can represent an arbitrary set of vertices. 2D polygons assume that all vertices lay on the same plane. The whole object can be extended in height. 2D polygon object specification​ Field name\tType\tDescription\tValueshape\tstring\tType of shape\tpolygon2d params.points\tlist&lt;xyz&gt;\tCoordinates of polygon vetices params.height\tstring\tHeight of the object (number in string format for maximum compatibility). For the avoidance of doubt, the Y coordinate of the opposite object's side is calculated as Y_basic + height, where Y_basic is the Y coordinate of the first vertex in the array above.\t Shared models​ XYZ​ Field name\tType\tDescription\tDefault valuex\tstring\tX coordinate\t0 y\tstring\tY coordinate\t0 z\tstring\tZ coordinate\t0 Standard conventions​ Numbers and coordinates interpretation depends on the specific metaverse defined in the meta section of the NFT. For this standard purpose, the following convention is applied: X axis is a horizontal one pointing East;Y axis is a vertical one pointing up;Z is the orthogonal axis pointing south; Numbers are stored as strings to ensure maximum compatibility;Numbers must not use scientific notation. "},{"title":"How to add the new JSON metadata type?​","type":1,"pageTitle":"Non-Fungible Token JSON Metadata (TIP-4.2)","url":"standard/TIP-4.2#how-to-add-the-new-json-metadata-type","content":"For added new metadata type of TIP-4.2 Create product that use new JSON type.Send PR for change the docs.Explain why it will be in Standard. "},{"title":"References​","type":1,"pageTitle":"Non-Fungible Token JSON Metadata (TIP-4.2)","url":"standard/TIP-4.2#references","content":"Ethereum EIP-721Solana v1.2.0TON NFT, TON DATATezos TZIP12BNS BEP721 "},{"title":"Non-Fungible Token On-chain storage (TIP-4.4)","type":0,"sectionRef":"#","url":"standard/TIP-4.4","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#abstract","content":"Using the Storage contract, you can store NFT-related bytes in blockchain "},{"title":"Motivation​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#motivation","content":"Fault tolerance. If off-chain services are unavailable, the user will view NFT-related bytes, because it is stored on-chain. "},{"title":"Specification​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#specification","content":"The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 "},{"title":"Contracts​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#contracts","content":"Collection - TIP4.1 contract that minted token and store Storage contract codeNFT - TIP4.1 contract that store token information and Storage contract addressStorage - contract that store token byte content. Storage is independent. Storage doesn’t store NFT address because NFT contract address can be changed by burning and redeployment from another collection. "},{"title":"Collection​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#collection","content":"Every TIP-4.1 Collection contract must implement TIP4_4Collection pragma ton-solidity &gt;= 0.58.0; interface TIP4_4Collection { function storageCode() external view responsible returns (TvmCell code); function storageCodeHash() external view responsible returns (uint256 codeHash); function resolveStorage(address nft) external view responsible returns (address addr); }  NOTE The TIP-6.1 identifier for this interface is 0x6302A6F8 "},{"title":"TIP4_4Collection.storageCode()​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#tip4_4collectionstoragecode","content":"function storageCode() external view responsible returns (TvmCell code);  code (TvmCell) - storage contract code "},{"title":"TIP4_4Collection.storageCode()​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#tip4_4collectionstoragecode-1","content":"function storageCodeHash() external view responsible returns (uint256 hash);  hash (uint256) - storage contract code hash "},{"title":"TIP4_4Collection.resolveStorage()​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#tip4_4collectionresolvestorage","content":"function resolveStorage(address nft) external view responsible returns (address addr);  nft (address) - token contract addressaddr (address) - storage contract address "},{"title":"NFT​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#nft","content":"Every TIP-4.1 NFT contract must implement TIP4_4NFT pragma ton-solidity &gt;= 0.58.0; interface TIP4_4NFT { function onStorageFillComplete(address gasReceiver) external; function getStorage() external view responsible returns (address addr); }  NOTE The TIP-6.1 identifier for this interface is 0x009DC09A "},{"title":"TIP4_4NFT.onStorageFillComplete()​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#tip4_4nftonstoragefillcomplete","content":"function onStorageFillComplete(address gasReceiver) external;  gasReceiver (address) - address of contract that receive all remaining contract balance then last chunk filled Calling the Storage.fill() on storage contract that fills the last chunk should call TIP4_4NFT.onStorageFillComplete() on token contract "},{"title":"TIP4_4NFT.getStorage()​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#tip4_4nftgetstorage","content":"function getStorage() external view responsible returns (address addr);  addr (address) - storage contract address "},{"title":"Storage​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#storage","content":"Every Storage contract must implement TIP4_4Storage pragma ton-solidity &gt;= 0.58.0; interface TIP4_4Storage { function fill(uint32 id, bytes chunk, address gasReceiver) external; function getInfo() external view responsible returns ( address nft, address collection, string mimeType, mapping(uint32 =&gt; bytes) content, string contentEncoding ); }  NOTE The TIP-6.1 identifier for this interface is 0x204D6296 "},{"title":"TIP4_4Storage.fill()​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#tip4_4storagefill","content":"function fill(uint32 id, bytes chunk, address gasReceiver) external;  id (uint32) - chunk number. From 0 to 4 294 967 295bytes (chunk) - data. Max size of data is limited by external message payload size. Maximum size external message payload size is 16KB at 2022-03-18.gasReceiver (address) - address of contract that receive all remaining contract balance then last chunk filled. "},{"title":"TIP4_4Storage.getInfo()​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#tip4_4storagegetinfo","content":"function getInfo() external view responsible returns ( address nft, address collection, string mimeType, mapping(uint32 =&gt; bytes) chunks, string contentEncoding );  nft (address) - token contract addresscollection (address) - collection token contract addressmimeType (string) - MIME types are defined and standardized in IETF's RFC 6838content (mapping(uint32 =&gt; bytes)) - byte content. Maximum content size is 4 294 967 295 chunks * chunk size. Max size of data is limited by external message payload size. Maximum size external message payload size is 16KB at 2022-03-18 Maximum content size is 4 294 967 295 * 16KB ≈ 69TB at 2022-03-18.contentEncoding (string) - Was it compressed by any algorithm. If it was compressed with zstd contentEncoding need to be zstd, all other need to be like http content encoding "},{"title":"Visualization​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#visualization","content":""},{"title":"Legend​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#legend","content":" "},{"title":"NFT minting with Storage​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#nft-minting-with-storage","content":" "},{"title":"Storage filling​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#storage-filling","content":" "},{"title":"Storage with Index​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#storage-with-index","content":"How to interaction on-chain indexes and Storage contracts "},{"title":"URI scheme","type":0,"sectionRef":"#","url":"standard/TIP-5","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"URI scheme","url":"standard/TIP-5#abstract","content":"TDB "},{"title":"Motivation​","type":1,"pageTitle":"URI scheme","url":"standard/TIP-5#motivation","content":"TDB "},{"title":"Fungible token payment link (TIP-5.1)","type":0,"sectionRef":"#","url":"standard/TIP-5.1","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Fungible token payment link (TIP-5.1)","url":"standard/TIP-5.1#abstract","content":"TDB "},{"title":"Motivation​","type":1,"pageTitle":"Fungible token payment link (TIP-5.1)","url":"standard/TIP-5.1#motivation","content":"TDB "},{"title":"Non-Fungible Token on-chain indexes (TIP-4.3)","type":0,"sectionRef":"#","url":"standard/TIP-4.3","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#abstract","content":"Using the Index contract code, you can find all your NFT with one dApp query. This makes blockchain application less dependent on different off-chain parsers and indexers On-chain Indexes solves easy and fast searching any data in blockchain. This document shows standard for basic query. Any developer can get an idea of this solution and realize his own on-chain index. "},{"title":"Motivation​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#motivation","content":"A standard interface allows search all Collection and all NFT by owner using base dApp functionality "},{"title":"Specification​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#specification","content":"The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 "},{"title":"Contracts​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#contracts","content":"Collection - TIP4.1 contract that minted tokenNFT - TIP4.1 contract that store token informationIndexBasis - contract, that helps to find all collections by the code hash of whichIndex - contract, that helps to find: All user tokens in current collection using owner address and collection addressAll user tokens in all collections using owner address code of IndexBasis and Index contracts and code hash of contracts is fixed and CANNOT BE CHANGED "},{"title":"IIndexBasis​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#iindexbasis","content":"pragma ton-solidity &gt;= 0.58.0; interface IIndexBasis { function getInfo() external view responsible returns (address collection); function destruct(address gasReceiver) external; }  "},{"title":"IndexBasis​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#indexbasis","content":"pragma ton-solidity &gt;= 0.58.0; import 'IIndexBasis.sol'; /** * Errors * 101 - Method for collection only **/ contract IndexBasis is IIndexBasis { address static _collection; modifier onlyCollection() { require(msg.sender == _collection, 101, &quot;Method for collection only&quot;); tvm.accept(); _; } constructor() public onlyCollection {} function getInfo() override public view responsible returns (address collection) { return {value: 0, flag: 64} _collection; } function destruct(address gasReceiver) override public onlyCollection { selfdestruct(gasReceiver); } }  Code hash of IndexBasis compiled by TVMCompiler v0.58.2 and TVM-linker v0.14.51 without salting is 2359f897c9527073b1c95140c670089aa5ab825f5fd1bd453db803fbab47def2 "},{"title":"IIndexBasis.getInfo()​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#iindexbasisgetinfo","content":"function getInfo() external view responsible returns (address collection);  collection (address) - collection token contract address "},{"title":"IIndexBasis.destruct()​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#iindexbasisdestruct","content":"function destruct(address gasReceiver) external;  gasReceiver (address) - address of contract that receives all remaining contract balance after selfdestruct() call "},{"title":"IIndex​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#iindex","content":"pragma ton-solidity &gt;= 0.58.0; interface IIndex { function getInfo() external view responsible returns ( address collection, address owner, address nft ); function destruct(address gasReceiver) external; }  "},{"title":"Index​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#index","content":"pragma ton-solidity &gt;= 0.58.0; import 'IIndex.sol'; /** * Errors * 101 - Method for NFT only * 102 - Salt doesn't contain any value **/ contract Index is IIndex { address static _nft; address _collection; address _owner; constructor(address collection) public { optional(TvmCell) salt = tvm.codeSalt(tvm.code()); require(salt.hasValue(), 102, &quot;Salt doesn't contain any value&quot;); (, address collection_, address owner) = salt .get() .toSlice() .decode(string, address, address); require(msg.sender == _nft); tvm.accept(); _collection = collection_; _owner = owner; if (collection_.value == 0) { _collection = collection; } } function getInfo() override public view responsible returns ( address collection, address owner, address nft ) { return {value: 0, flag: 64} ( _collection, _owner, _nft ); } function destruct(address gasReceiver) override public { require(msg.sender == _nft, 101, &quot;Method for NFT only&quot;); selfdestruct(gasReceiver); } }  Code hash of Index compiled by TVMCompiler v0.58.2 and TVM-linker v0.14.51 without salting is 61e5f39a693dc133ea8faf3e80fac069250161b0bced3790c20ae234ce6fd866 "},{"title":"Index.getInfo()​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#indexgetinfo","content":"function getInfo() external view responsible returns ( address collection, address owner, address nft );  collection (address) - collection token contract addressowner (address) - token owner contract addressnft (address) - token contract address "},{"title":"IIndexBasis.destruct()​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#iindexbasisdestruct-1","content":"function destruct(address gasReceiver) external;  gasReceiver (address) - address of contract that receives all remaining contract balance after selfdestruct() call "},{"title":"Collection​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#collection","content":"TIP-4.1 Collection contract must implement the TIP4_3Collection interface and TIP-6.1 interfacesTIP-4.1 Collection contract must deploy IndexBasis contract after deployment with code saltTIP-4.1 Collection contract must destuct() IndexBasis contracts before collection destruction "},{"title":"TIP4_3Collection​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#tip4_3collection","content":"pragma ton-solidity &gt;= 0.58.0; interface TIP4_3Collection { function indexBasisCode() external view responsible returns (TvmCell code); function indexBasisCodeHash() external view responsible returns (uint256 hash); function indexCode() external view responsible returns (TvmCell code); function indexCodeHash() external view responsible returns (uint256 hash); function resolveIndexBasis() external view responsible returns (address indexBasis); }  NOTE The TIP-6.1 identifier for this interface is 0x4387BBFB TIP4_3Collection.indexBasisCode()​ function indexBasisCode() external view responsible returns (TvmCell code);  code (TvmCell) - basis index contract code TIP4_3Collection.indexBasisCodeHash()​ function indexBasisCodeHash() external view responsible returns (uint256 hash);  hash (uint256) - basis index contract code hash TIP4_3Collection.indexCode()​ function indexCode() external view responsible returns (TvmCell code);  code (TvmCell) - index contract code TIP4_3Collection.indexCodeHash()​ function indexCodeHash() external view responsible returns (uint256 hash);  hash (uint256) - index contract code hash TIP4_3Collection.indexBasis()​ function resolveIndexBasis() external view responsible returns (address indexBasis);  indexBasis (address) - basis index contract address "},{"title":"Code salt parameters​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#code-salt-parameters","content":"stamp (string) - stamp that determine type of index. stamp = &quot;nft&quot;; for all NFT indexes "},{"title":"Example of IndexBasis deployment​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#example-of-indexbasis-deployment","content":"function deployIndexBasis(TvmCell codeIndex, address collection, uint128 value) private pure { string stamp = &quot;nft&quot;; TvmBuilder salt; salt.store(stamp); TvmCell code = tvm.setCodeSalt(codeIndex, salt.toCell()); TvmCell stateInit = tvm.buildStateInit({ contr: IndexBasis, varInit: {_collection: collection}, code: code }); new IndexBasis{stateInit: stateInit, value: value}(); }  "},{"title":"NFT​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#nft","content":"TIP-4.1 Collection contract must implement the TIP4_3NFT interface and TIP-6.1 interfacesTIP-4.1 NFT contract must deploy at least two Index contract after deployment with different code salt With zero collection address collection = &quot;0:0000000000000000000000000000000000000000000000000000000000000000&quot; in code saltWith non-zero collection address collection = &quot;0:3bd8…&quot; in code salt TIP-4.1 NFT contract must destuct() Index before NFT burningTIP-4.1 NFT contract must destuct() old Index contacts and deploy new Index contracts if owner changed "},{"title":"TIP4_3NFT​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#tip4_3nft","content":"pragma ton-solidity &gt;= 0.58.0; interface TIP4_3NFT { function indexCode() external view responsible returns (TvmCell code); function indexCodeHash() external view responsible returns (uint256 hash); function resolveIndex(address collection, address owner) external view responsible returns (address index); }  NOTE The TIP-6.1 identifier for this interface is 0x4DF6250B TIP4_3NFT.indexCode()​ function indexCode() external view responsible returns (TvmCell code);  code (TvmCell) - index contract code TIP4_3NFT.indexCodeHash()​ function indexCodeHash() external view responsible returns (uint256 hash);  hash (uint256) - basis index contract code hash TIP4_3NFT.resolveIndex()​ function resolveIndex(address collection, address owner) external view responsible returns (address index);  collection (address) - collection token contract addressowner (address) - token owner contract addressindex (address) - index contract address "},{"title":"Code salt parameters​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#code-salt-parameters-1","content":"stamp (string) - stamp that determine type of index. stamp = &quot;nft&quot;; for all NFT indexescollection (address) - collection token contract addressowner (address) - token owner contract address "},{"title":"Example of Index deployment​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#example-of-index-deployment","content":"function deployIndex(TvmCell codeIndex, address nft, address collection, address owner, uint128 value) private pure { string stamp = &quot;nft&quot;; TvmBuilder salt; salt.store(stamp, collection, owner); TvmCell code = tvm.setCodeSalt(codeIndex, salt.toCell()); TvmCell stateInit = tvm.buildStateInit({ contr: Index, varInit: {_nft: nft}, code: code }); new Index{stateInit: stateInit, value: value}(); }  "},{"title":"Example of dApp query for search by index​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#example-of-dapp-query-for-search-by-index","content":"query { accounts( filter: { code_hash: { eq: &quot;207dc560c5956de1a2c1479356f8f3ee70a59767db2bf4788b1d61ad42cdad82&quot; } } ){ id } }  Part of response example { &quot;data&quot;: { &quot;accounts&quot;: [ { &quot;id&quot;: &quot;0:000001b0422f6a7069786fa9a27aa7bb8042f58e1df01dfebc51dcb2baa5eeae&quot; }, { &quot;id&quot;: &quot;0:00022772794253c1bf8cb4fa59d6161d574033c13d881f3eea14675b911e61b0&quot; } ] } }  "},{"title":"Source code​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#source-code","content":"link "},{"title":"Visualization​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#visualization","content":""},{"title":"Legend​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#legend","content":" "},{"title":"IndexBasis deployment for Collection​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#indexbasis-deployment-for-collection","content":" "},{"title":"Index contracts deployment for NFT​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#index-contracts-deployment-for-nft","content":" "},{"title":"Redeploy Index contracts after changeOwner​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#redeploy-index-contracts-after-changeowner","content":" "},{"title":"Non-fungible token payment link (TIP-5.2)","type":0,"sectionRef":"#","url":"standard/TIP-5.2","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Non-fungible token payment link (TIP-5.2)","url":"standard/TIP-5.2#abstract","content":"TDB "},{"title":"Motivation​","type":1,"pageTitle":"Non-fungible token payment link (TIP-5.2)","url":"standard/TIP-5.2#motivation","content":"TDB "},{"title":"Standard Interface Detection","type":0,"sectionRef":"#","url":"standard/TIP-6","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Standard Interface Detection","url":"standard/TIP-6#abstract","content":"Smart contracts in Everscale can implement a wide variety of functionality - wallets, tokens, exchanges and so on. We need a standard way to determine the type of smart contract without relying on knowledge of its internal structure. "},{"title":"What is TIP? (TIP-0)","type":0,"sectionRef":"#","url":"standard/workflow","content":"What is TIP? (TIP-0) TIP — Trustless Improvement Proposal (TIPs) describe standards for the Everscale blockchain. They may include anything that the community considers in need of improvement or standardization. That can be specifications for core protocol, description of interfaces, smart contract standards and so on. I propose a more relaxed structure more closely resembling Bitcoin BIPs but with quite different proccess (see below). Each TIP should have the following parts (which are heavily copy-pasted from BIP requirements): Preamble — Headers containing metadata about the TIP;Abstract — A short (~200 word) description of the technical issue being addressed;Copyright — The TIP must be explicitly licensed under acceptable copyright terms;Specification — The technical specification should describe the syntax and semantics of any new feature;The specification should be detailed enough to allow competing, interoperable implementations;Motivation — The motivation is critical for TIPs that want to change the Everscale protocol. It should clearly explain why the existing protocol is inadequate to address the problem that the TIP solves;Rationale — The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work. The rationale should provide evidence of consensus within the community and discuss important objections or concerns raised during discussion;Backwards compatibility — All TIPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The TIP must explain how the author proposes to deal with these incompatibilities; Each TIP should pass the following process of acceptance: Proposal → Discussion → Community Voting → Reference Implementations Contest → Final TIP with Reference Implementations Reference implementation — The reference implementation must be completed before any TIP is given status Final, but it need not be completed before the TIP is accepted. It is better to finish the specification and rationale first and reach consensus on it before writing code. The final implementation must include test code and documentation appropriate for the Everscale protocol.","keywords":""},{"title":"Standard Interface Detection Interface (TIP-6.1)","type":0,"sectionRef":"#","url":"standard/TIP-6.1","content":"","keywords":""},{"title":"Simple summary​","type":1,"pageTitle":"Standard Interface Detection Interface (TIP-6.1)","url":"standard/TIP-6.1#simple-summary","content":"Creates a standard method to publish and detect what interfaces a smart contract implements. "},{"title":"Abstract​","type":1,"pageTitle":"Standard Interface Detection Interface (TIP-6.1)","url":"standard/TIP-6.1#abstract","content":"Herein, we standardize the following: How interfaces are identifiedHow a contract will publish the interfaces it implements "},{"title":"Motivation​","type":1,"pageTitle":"Standard Interface Detection Interface (TIP-6.1)","url":"standard/TIP-6.1#motivation","content":"For some “standard interfaces” like the token interface, it is sometimes useful to query whether a contract supports the interface and if yes, which version of the interface, in order to adapt the way in which the contract is to be interacted with. This proposal standardizes the concept of interfaces and standardizes the identification (naming) of interfaces. "},{"title":"Specification​","type":1,"pageTitle":"Standard Interface Detection Interface (TIP-6.1)","url":"standard/TIP-6.1#specification","content":""},{"title":"How interfaces are identified​","type":1,"pageTitle":"Standard Interface Detection Interface (TIP-6.1)","url":"standard/TIP-6.1#how-interfaces-are-identified","content":"For this standard, an interface is a set of function selectors as defined by the Solidity ABI. This a subset of Solidity’s concept of interfaces and the interface keyword definition which also defines return types, mutability and events. We define the interface identifier as the XOR of all function selectors in the interface. This code example shows how to calculate an interface identifier: Solidity​ interface Solidity101 { function hello() external pure; function world(int) external pure; } contract Selector { function calculateSelector() public view returns (bytes4) { Solidity101 i; return bytes4(tvm.functionId(i.hello) ^ tvm.functionId(i.world)); } }  How a Contract will Publish the Interfaces it Implements​ A contract that is compliant with TIP6.1 shall implement the following interface: Solidity​ interface TIP6 { /// @notice Query if a contract implements an interface /// @param interfaceID The interface identifier, as specified in TIP6.1 /// @dev Interface identification is specified in TIP6.1. /// @return `true` if the contract implements `interfaceID` and /// `interfaceID` is not 0xffffffff, `false` otherwise function supportsInterface(bytes4 interfaceID) external view responsible returns (bool); }  The interface identifier for this interface is 0x3204EC29. You can calculate this by running tvm.functionId('supportsInterface(bytes4)'); or using the Selector contract above. Therefore, the implementing contract will have a supportsInterface function that returns: true when interfaceID is 0x3204EC29 (TIP6.1 interface)false when interfaceID is 0xfffffffftrue for any other interfaceID this contract implementsfalse for any other interfaceID "},{"title":"References​","type":1,"pageTitle":"Standard Interface Detection Interface (TIP-6.1)","url":"standard/TIP-6.1#references","content":"EIP-165: Standard Interface Detection "},{"title":"FAQ","type":0,"sectionRef":"#","url":"validate/depools/faq","content":"","keywords":""},{"title":"General​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#general","content":""},{"title":"What is DePool?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#what-is-depool","content":"DePool is a smart contract that allows other smart contracts to invest stakes in a common pool, which it then uses in validator elections on behalf of the validator owning the DePool, and upon successful validation pays rewards to all participants proportionally to their contribution. "},{"title":"Are there multiple versions of DePools?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#are-there-multiple-versions-of-depools","content":"Currently, only one version of the DePool is used: the current master version. "},{"title":"Are there multiple types of nodes?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#are-there-multiple-types-of-nodes","content":"At this time, available node types include the original C++ EVER node and the EverX Rust node (currently being tested on rustnet). DePool works with both versions. "},{"title":"Is DePool some special kind of wallet? How can I be sure no one’s going to misuse my funds?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#is-depool-some-special-kind-of-wallet-how-can-i-be-sure-no-ones-going-to-misuse-my-funds","content":"DePool is not a wallet with a single balance. It remembers which wallets invested which stakes. A stake cannot be withdrawn from DePool to any wallet that isn’t the owner of the stake. The DePool owner has no access to any stakes other than their own. All the owner can do is close the DePool, in which case all stakes and rewards are returned to their owners. There are, however, some risks involved: if DePool's validator node wins elections, but doesn't function correctly, it may be punished by the elector, and part or all of its stake may be lost. For this reason, the DePool owner is obliged to invest a certain amount of tokens in each validation round, all or some of which they stand to lose, and will be the first among the participants to lose, should their node perform poorly or misbehave in any way. This way, participants can be sure that the person upon whose actions their funds and rewards depend is highly motivated to perform their duties properly and ensure everyone receives their rewards. The contract code in open sourced and formally verified. See specifications and contract code for details. "},{"title":"What is validator assurance?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#what-is-validator-assurance","content":"It is the minimum amount of tokens the DePool owner is obliged to invest in each validation round. Without it, DePool would not participate in elections. DePool owner's funds will be the first lost, in case of any validator node malfunction or misbehavior. Only if they are not enough to cover the losses of the total stake, will the funds of other pool participants be affected. So, the higher the validator assurance, the more the validator owner is motivated to ensure proper operation of their node and the safer the stakes of all other participants are. This parameter of the DePool cannot be changed after the DePool is deployed, not even by its owner. "},{"title":"What is DePool fee?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#what-is-depool-fee","content":"It is the fraction of the total DePool reward that goes directly to the validator's wallet each time rewards are received. The validator needs it to cover current operational expenses of the node and the DePool. The rest of the rewards are distributed among all DePool participants, proportionally to their stakes. So, the lower the DePool fee, the more profitable the DePool is for participants. "},{"title":"Why even use DePool? What are the advantages?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#why-even-use-depool-what-are-the-advantages","content":"Becoming a validator requires a substantial cryptocurrency deposit. The required amount might far exceed an individual validator's budget. On the other hand, blockchain users with no validating system might be interested in investing in validation duty. This is where the DePool contract comes in. There are two main cases of using DePool: The user has no Validator capabilities but some free funds. User can support a third-party Validator and receive rewards.The user has Validator capabilities and but doesn't have necessary amount of funds to participate in validator elections and subsequent rewards. Thus, the usage of DePool allows us to greatly expand the number of individuals involved in the validation process and decentralize the network to a much higher degree. "},{"title":"How does DePool work?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#how-does-depool-work","content":"The DePool system has several components. The validator node, which is the same, as a regular node. It forms election requests and performs validation.The validator wallet - the wallet belonging to the validator. Normally it holds the funds to be used in stakes and sends them with election requests to the elector directly. In a DePool system however the staking funds are kept in the DePool: the validator wallet has to invest its funds into the DePool and sends its the election requests through the DePool as well.The DePool itself collects stakes from the validator and any other participants, who wish to invest in validation, receives election requests from validator wallet, attaches the collected funds, and through its proxies passes it to the elector. Whenever elector returns the stake, DePool processes it and distributes rewards among its participants.The DePool needs to be called regularly, to perform its functions. There are several methods to do it, both manually and automatically. "},{"title":"How configurable is a DePool? What settings can I define?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#how-configurable-is-a-depool-what-settings-can-i-define","content":"DePool has a number of parameters that its owner can set during deploy. Note, that these parameters cannot be changed after deploy. You’d have to close the current DePool and set up a new one, if you need to change them. The parameters are: minStake - minimum stake that DePool accepts from participants. It's recommended to set it not less than 10 everss.validatorAssurance - minimal stake for validator. If validator has stake less than validatorAssurance, DePool won't be taking part in elections.validatorWalletAddress – validator wallet address.participantRewardFraction - percentage of the total DePool reward that goes to Participants. Proxy contract code is also provided to the DePool at deploy, but has no bearing on its performance. It simply lets DePool deploy its own proxies, thus simplifying the setup. "},{"title":"How do I choose DePool deploy configuration?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#how-do-i-choose-depool-deploy-configuration","content":"The DePool configuration will influence the appeal of your DePool to potential participants and its success in competition to the other DePools out there: minStake – minimum stake that DePool accepts from participants. If set to high, some small token holders won’t be able to invest, whereas a very low minimal stake will permit participants to make small pointless stakes, where DePool fees will eat up a significant part of their reward and/or investment. 10 tokens is the recommended minimum for this parameter.validatorAssurance determines how much you take it upon yourself to invest in the DePool every election and lose in case of any validator node malfunction or misbehavior. If set too small, potential participants might decide you aren't risking enough and avoid your DePool in favor of others. Should be chosen depending on the current competition in the network.participantRewardFraction determines what percentage of the total reward all participants will receive. DePool is a complex contract that takes up a lot of computational resources to run. Depending on the setup, other contracts involved in DePool operations, such as the validator wallet, also regularly spend significant amounts on their operation. Thus DePool is programmed to reserve a part of the total rewards it receives for it’s own balance, and send a part the rewards (100% - ParticipantRewardFraction) directly to the validator wallet. Only then does it distribute ParticipantRewardFraction % of the rewards between all participants. So, if this parameter is set too small, other DePools might draw potential participants away. If it is set too big, your validator wallet might not receive enough rewards to support validation and staking. It should be chosen to balance these two concerns. "},{"title":"What are the risks of using DePool?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#what-are-the-risks-of-using-depool","content":"Validator using a DePool bears the same risks as a validator participating in elections through their own wallet and with only their own funds directly – in case of malfunction or misbehavior of their node during validation, part of the total stake or all of it may be lost. As in DePool there are usually other participants, who have no control over the node, the DePool is programmed to preserve as much of their funds as possible – the losses are deducted from the validator’s investment first, and only then from other participants. There are also some operational risks associated with the DePool specifically. If any of the contracts involved in its operation run out of funds, DePool might get up stuck and miss elections. Learn how to prevent that here. "},{"title":"Setting up​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#setting-up","content":""},{"title":"How do I set up a validator node with a DePool?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#how-do-i-set-up-a-validator-node-with-a-depool","content":"You have to follow this procedure exactly. To briefly sum up, you have to do the following: Set up a node;Set up a validator wallet. For security, we advise to have not less than three custodians in this wallet;Insert one custodian keypair for the validator wallet and its address into the node files;Deploy DePool and do not forget to set up a state update method for it;Make the necessary stakes in the DePool – ensure at least validatorAssurance is staked every round. All types of stakes count towards this value;Set up validator script;If required, confirm any transactions that the validator script or the state update method you set up generates. If all is set up correctly, DePool should participate in the next validator elections. If it doesn’t, here is some troubleshooting advice. "},{"title":"What do the validator contest winners need to do differently?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#what-do-the-validator-contest-winners-need-to-do-differently","content":"The main requirement specific to validator contest winners is their validator wallet. The vesting stake they will receive on the main net will be assigned to this specific wallet, and won’t count towards validatorAssurance, if this wallet isn’t used as validator wallet. So if you are a winner of the DePool contest: make sure to insert the address of this wallet and any one of the custodian key pairs you set up for this wallet during deploy into your node files.specify it's address as validator wallet during DePool deployment. Another important detail is the validatorAssurance parameter at DePool deployment. As the rewards for winning the contest are fixed, to make sure your DePool participates in every election, regardless of any additional stakes you make, you should set validator assurance no higher than contest reward/2. Here’s why. "},{"title":"What are the possible state update methods for the DePool?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#what-are-the-possible-state-update-methods-for-the-depool","content":"Currently there are two: Using a multisig contract to call the DePool ticktock function directly. This requires monitoring and regular replenishing of the multisig contract balance and can be automated with any task scheduler. Note, that if the multisig contract requires multiple signatures to execute transactions (for example, if it’s a contest winner’s wallet with three custodians), every such transaction has to be confirmed by the required number of custodians.Setting up a DePool helper contract and calling it with external messages. This also requires monitoring and regular replenishing of the helper contract balance and can also be automated with any task scheduler. "},{"title":"Why are two proxies necessary?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#why-are-two-proxies-necessary","content":"DePool maintains multiple rounds at once to ensure participants can make their stakes at all times. Two proxies are required to establish separate communication with the elector for odd and even rounds. This setup prevents stakes from consequent rounds getting mixed up in the event of any DePool lag, for example, if the DePool runs out of funds and sends some of its messages to the elector later than usual. Without two separate proxies for odd and even rounds, elector may combine two consequent stakes into one, and it would not be possible to accurately calculate how the rewards should be distributed between participants of the two rounds, which might have changed their stakes in-between them. "},{"title":"Stake and rounds​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#stake-and-rounds","content":""},{"title":"How do DePool rounds work?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#how-do-depool-rounds-work","content":"To make sure participants can invest their funds in the DePool at any time regardless of the current stage of the election cycle, DePool runs its operations in multiple rounds at once, and one of these rounds is always in the pooling stage (is ready to receive stakes). Whenever a new election on the network begins, the current round in the pooling stage is switched to the next stage – election - and can no longer receive stakes. Everything, that DePool accumulated during pooling is attached to validator's election request and staked in the elections. The next round then enters pooling stage, gathering stakes for the next election. In practice this comes down to alternating odd and even rounds. When a round completes its last stage and is removed from the DePool, the round after the next locks its accumulated stake (including any stakes released from the just completed round, that were reinvested) and enters elections.  So to make sure DePool participates in every election, you have to ensure sufficient stakes are invested (and set to be reinvested) in even and odd rounds both. "},{"title":"What do the parameters displayed by getRounds method mean?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#what-do-the-parameters-displayed-by-getrounds-method-mean","content":"You can find a list of getRounds parameters and their meanings here. "},{"title":"What types of stakes are there?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#what-types-of-stakes-are-there","content":"There are three types of stakes supported: Ordinary stakes​ This is the most basic type of stake. Any account (for example, any wallet) can make an ordinary stake. Its full value is invested in the DePool round that is currently in the pooling stage, and set to be continuously reinvested into every second round. The account that made the ordinary stake owns its entirety. Such a stake can increased: the value of any additional ordinary stakes from this account is simply added to the account’s ordinary stake in the current pooling round. Any rewards a participant receives in the DePool are also added to their ordinary stake. If a participant initially has no ordinary stake (e.g. is a beneficiary of a single vesting stake from which it receives rewards), and ordinary stake is created for it when the first reward is received. An ordinary stake, or a part of it can be withdrawn only to the account that owns it. An ordinary stake can also be transferred, in part or in full, to another participant of the same DePool (if this other the participant does not currently have an ordinary stake, it will be created). Vesting Stakes​ Any account can make a vesting stake and define a target participant address (beneficiary) who will own this stake. But not the whole stake is available to the beneficiary at once. Instead it is split into logical parts and the next part of stake becomes available to the participant only when next vesting period is ended. At completion step of every round DePool decides how many vesting parts should be unlocked and subtracted from vesting stake and become available to owner since last unlocking. These funds are added to beneficiary's ordinary stake. Example: address A makes a vesting stake of 120 evers for 1 year with vesting period of 1 month and defines address B as the stake beneficiary. It means that after 1 month 10 evers become available to address B and 110 evers are still locked in the pool. After 1 year vesting stake will be equal to 0 and last 10 evers will become available to owner. One Participant can be a beneficiary only of one vesting stake. When a vesting stake is created, it is split equally into two last rounds, to make sure it can be uniformly reinvested into odd and even rounds both. To receive a vesting stake, participant has to first specify the donor, that is expected to make it. Lock Stakes​ Any account can make a lock stake, in which it locks its funds in DePool for a defined period, but rewards from this stake will be payed to another target participant (beneficiary). At the end of a period the Lock Stake should be returned to the account which locked it. Example: address A makes a lock stake of 120 evers for 1 year with vesting period of 1 month and defines address B as the stake beneficiary. It means that after 1 month 10 evers become available to address A (as opposed to vesting, where these 10 evers would become available to address B, the beneficiary) and 110 evers are still locked in round. DePool will reinvest the gradually diminishing lock stake for a 1 year and pay rewards to B address. After 1 year DePool will return the remainder of the lock stake to address A. One Participant can be a beneficiary only of one lock stake. When a lock stake is created, it is split equally into two last rounds, to make sure it can be uniformly reinvested into odd and even rounds both. To receive a lock stake, participant has to first specify the donor, that is expected to make it. "},{"title":"What’s this about lock and vesting stakes split into two parts?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#whats-this-about-lock-and-vesting-stakes-split-into-two-parts","content":"The total funds of lock and vesting stakes do get split into two equal parts, and each half is invested into the current pooling round and, once it's locked, into the next pooling round. This is done, because the same stake can only be reinvested every second DePool round. The funds simply don't get unlocked in time to be reinvested into the very next one. On the other hand, one participant can be a beneficiary of only one lock and one vesting stake. So by splitting them into two parts, DePool makes it so a single lock or vesting stake is continuously reinvested into every single DePool round, and, provided it exceeds validatorAssurance *2, enough to participate in every validator election. "},{"title":"How is the validator’s stake different?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#how-is-the-validators-stake-different","content":"Validator's stake in their own DePool has certain requirements and limitations it must conform to. Most importantly, it has to always (both in odd and even rounds) exceed the validatorAssurance parameter. Otherwise DePool won't participate in elections. These are the funds validator invests in their DePool to guarantee their conscientious performance to any other participants of the pool. These funds will be the first lost, in case the node misbehaves and is punished by the elector. All three types of stakes count towards reaching this limit. Additionally, the ordinary stake of the validator wallet cannot be transferred to another participant of the DePool, nor can any other participant's ordinary stake be transferred to the validator. This rule prevents attempts to circumvent the above requirement. "},{"title":"Do lock and vesting stakes count toward validatorAssurance?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#do-lock-and-vesting-stakes-count-toward-validatorassurance","content":"Yes, if the validator wallet is the beneficiary of a lock and/or vesting stake, they count towards the validatorAssurance requirement. A single lock or vesting stake is enough to ensure your DePool participates in every election, if it is equal to or greater than validatorAssurance*2. "},{"title":"How do I make stakes?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#how-do-i-make-stakes","content":"Currently, this can be done through TONOS-CLI. It should be configured to be used with DePool. A participant needs to know the DePool address and have a suitable contract holding the funds they want to invest (e.g. a multisig wallet). Ordinary, vesting and lock stakes all have their own commands, that should be used to make a stake in the DePool, as they all have different sets of parameters, that need to be specified, when the stake is sent to the DePool. All participants' stakes have to exceed the minimum stake set for the DePool (minStake DePool parameter). Validator's stake in every round has to additionally exceed validatorAssurance. "},{"title":"I made a stake but DePool returned my funds. What's wrong?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#i-made-a-stake-but-depool-returned-my-funds-whats-wrong","content":"There can be several reasons this happened: The stake was too small. Check DePool Info to find out the minimum stake for this DePool.DePool is closed. Check DePool events to find out if it is.You are trying to make a lock or vesting stake on behalf of a wallet that did not set a donor for lock or vesting. Check Participant Info for the beneficiary.You are trying to make a lock or vesting stake on behalf of a wallet that already has this type of stake. Check Participant Info for the beneficiary.There are errors in lock or vesting period settings (withdrawalPeriod &gt; totalPeriod, totalPeriod &gt; 18 years or totalPeriod &lt;=0 seconds, or totalPeriod is not exactly divisible by withdrawalPeriod).You are using an old TONOS-CLI version (&lt;1.25). "},{"title":"Can I make a lock or vesting stake for myself?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#can-i-make-a-lock-or-vesting-stake-for-myself","content":"Starting with version 3 of the DePool, yes. "},{"title":"How are stakes reinvested and withdrawn?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#how-are-stakes-reinvested-and-withdrawn","content":"Whenever an ordinary stake is made, it is set to be continuously reinvested. The participant who made the stake may disable reinvestment at any time, and the entirety of their ordinary stake will be withdrawn to their wallet as soon as the funds are unlocked from the rounds they are invested in. A part of the ordinary stake can also be withdrawn. The remainder of the stake will keep being reinvested in this case. Lock and vesting stakes are reinvested for the full duration of their existence, which is set during their investment. "},{"title":"What are the DePool fees for staking operations?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#what-are-the-depool-fees-for-staking-operations","content":"The sender of any stake management transaction (including withdrawal and transfer) is required to cover DePool fees for this operation. These fees are normally under 0.5 tokens, so by default this value is additionally attached to any transaction to the DePool, and the change is returned to the sender. If for any reason a value of 0.5 tokens proves to be insufficient (and DePool starts running out of gas trying to execute a transaction), it can be increased in TONOS-CLI config. Additionally, when DePool receives the stake and rewards back from elector and processes the funds of participants, 0.05 evers are deducted from every participant's share of the pool, to cover the costs of executing this action. "},{"title":"How do I view my stakes in the DePool?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#how-do-i-view-my-stakes-in-the-depool","content":"It can be done with the getParticipantInfo get-method. Here's how. "},{"title":"Ensuring Regular Operations​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#ensuring-regular-operations","content":""},{"title":"How do I make sure my DePool always participates in elections?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#how-do-i-make-sure-my-depool-always-participates-in-elections","content":"Make sure that: your validator wallet has at least validatorAssurance staked in both odd and even rounds. Your own ordinary stakes, as well as Lock and vesting stakes, where you are the beneficiary, count towards validatorAssuranceyou set up the state update method to run regularlyyou have sufficient funds on the balances of all contracts (DePool, validator wallet, proxies, helper, if you use it, multisig, that updates the DePool state, if you use it)your validator script generates the election request correctly. You can find some troubleshooting advice here. "},{"title":"How do I make sure my DePool wins elections?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#how-do-i-make-sure-my-depool-wins-elections","content":"No guarantees here, just as with any elections. Configure your DePool to be competitive and appealing to participants and develop your reputation. "},{"title":"How often do I have to call the DePool state update function?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#how-often-do-i-have-to-call-the-depool-state-update-function","content":"The period for state updates should be chosen based on the duration of the validation cycle on the blockchain. At the very minimum DePool's state update function should be called three times during the validation cycle: Once after the elections begin, so DePool gets ready to receive and forward validator's election request.Once after the validation begins, to find out if it won elections or not.Once after unfreeze, to process stakes and rewards and rotate the rounds. In the current network configuration, 1 and 3 coincide, so DePool's state update function can be called twice during the validation cycle - once during elections and once during validation. "},{"title":"How do DePool and its supporting contracts receive funds for their operations?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#how-do-depool-and-its-supporting-contracts-receive-funds-for-their-operations","content":"Each of the contracts involved has its own balance from which funds are spent on any operations it performs. These balances have to be replenished regularly. For DePool this is automated. Whenever DePool receives validation rewards, it tops up its balance depending on number of participants. If it fails to do so, and the balance dips below 10 tokens, it emits an event notifying of the problem. Proxy contracts also receive the necessary funds automatically, but if for any reason their balance becomes to low to perform the necessary operations, the DePool will also emit an event notifying about it. You can replenish their balance, then call the DePool’s state update function by any available means, and resume normal operations. Helper contract, if you use it, doesn’t have built-in balance replenishing mechanisms. It has to be monitored and replenished separately. Same goes for the multisig contract you use for DePool state update, unless it’s your validator wallet. The validator wallet gets a fraction of the total DePool validation rewards each time they are received. The specific percentage is set during DePool deployment. These funds are transferred to the validator wallet directly and usually cover all its expenses related to running a DePool sufficiently well. "},{"title":"My DePool is constantly running out of funds. What do I do?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#my-depool-is-constantly-running-out-of-funds-what-do-i-do","content":"You can set up a script which will listen for the low balance DePool event and top it back up to 100 tokens, whenever the event occurs. "},{"title":"How do I monitor what’s happening to my DePool?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#how-do-i-monitor-whats-happening-to-my-depool","content":"There is a number of methods available, such as DePool events, get methods and the ever.live explorer. Read more here. "},{"title":"Rewards Distribution​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#rewards-distribution","content":"Every time DePool receives rewards for validation, DePool replenishes it's pure balance to be more than balanceThreshold and the rest is distributed according to the following rules: validatorRewardFraction% of the reward, regardless of the validator’s share in the pool, goes directly to the validator wallet. This is the reward for maintaining the node and is intended to be used on operational expenses.participantRewardFraction% of the reward is distributed among all participants (including the validator) proportionally to their share of the staking pool. By default these rewards are added to the ordinary stakes of all participants and reinvested with it. To withdraw this stake or any part of it to the participant wallet, use one of the withdrawal functions.The remaining associationRewardFraction% of the reward is transferred to the DePool Association. This is not yet implemented. "},{"title":"Troubleshooting​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#troubleshooting","content":"You can find some troubleshooting advice here. "},{"title":"FAQ","type":0,"sectionRef":"#","url":"validate/faq","content":"","keywords":""},{"title":"Getting started​","type":1,"pageTitle":"FAQ","url":"validate/faq#getting-started","content":""},{"title":"How can I become a Everscale validator?​","type":1,"pageTitle":"FAQ","url":"validate/faq#how-can-i-become-a-everscale-validator","content":"To set up a validator node you should follow the instructions in Run validator section. "},{"title":"Can I test out the node?​","type":1,"pageTitle":"FAQ","url":"validate/faq#can-i-test-out-the-node","content":"You may setup a node on the net.ton.dev test network. The procedure is similar. "},{"title":"Requirements​","type":1,"pageTitle":"FAQ","url":"validate/faq#requirements","content":""},{"title":"What kind of hardware do I need to run a node?​","type":1,"pageTitle":"FAQ","url":"validate/faq#what-kind-of-hardware-do-i-need-to-run-a-node","content":"Configuration\tCPU (cores)\tRAM (GiBs)\tStorage (GiBs)\tNetwork (Bbits/s)Minimal\t8\t16\t1000\t1 Recommended\t16\t32\t1000\t1 SSD disks are recommended for /var/ton-work/db storage "},{"title":"Does the validator node require a public IP?​","type":1,"pageTitle":"FAQ","url":"validate/faq#does-the-validator-node-require-a-public-ip","content":"Yes, the validator requires a public IP, otherwise other nodes will not be able to communicate with it. "},{"title":"What ports are needed for a node to work?​","type":1,"pageTitle":"FAQ","url":"validate/faq#what-ports-are-needed-for-a-node-to-work","content":"The UDP port set here (ADNL_PORT parameter) for the node itself.HTTPS port 443 for the TONOS-CLI utility. "},{"title":"What volumes of outgoing traffic do you need for the validator at the moment? How about in the future?​","type":1,"pageTitle":"FAQ","url":"validate/faq#what-volumes-of-outgoing-traffic-do-you-need-for-the-validator-at-the-moment-how-about-in-the-future","content":"In general, the traffic requirements are high (up to tens of TB per month), so it’s best to find a server without traffic limitations. Currently the network has 16 shards by default, and a block is issued every 2-4 seconds in each shard, even if there are no transactions and it is empty – such is the Ever architecture. On the other hand, as the number of transactions increases, traffic will not grow too fast. Furthermore, as the number of validators grows, they will be divided into groups, each to validate their own shards. This means that the number of constantly communicating neighboring validator nodes will be approximately the same. "},{"title":"Node Setup​","type":1,"pageTitle":"FAQ","url":"validate/faq#node-setup","content":""},{"title":"What network does the node work with by default?​","type":1,"pageTitle":"FAQ","url":"validate/faq#what-network-does-the-node-work-with-by-default","content":"The node is compatible with all Everscale networks, but connects to just one at a time. It is specified in the configs during node setup. "},{"title":"Why are there different initial DiffTime values? Why do some start at 40k and others at 190k?​","type":1,"pageTitle":"FAQ","url":"validate/faq#why-are-there-different-initial-difftime-values-why-do-some-start-at-40k-and-others-at-190k","content":"Nodes begin synchronization from the latest key block, which is generally issued whenever validator elections end or the validator set is changed. Thus initial DiffTime depends on when in the election cycle the node began synchronization. Synchronization speed is also very dependent on the hardware and the network throughput. "},{"title":"How can I make sure synchronization is proceeding as it should?​","type":1,"pageTitle":"FAQ","url":"validate/faq#how-can-i-make-sure-synchronization-is-proceeding-as-it-should","content":"It’s normal for synchronization to take multiple hours. However, if you have noticed that DiffTime has not been decreasing for an hour, or even started increasing, then something is wrong. Make sure you have followed the instructions exactly and that you are using an SSD, check your network status, review the logs. If no obvious reason for the lag presents itself, contact support to get help. "},{"title":"How can I correctly stop the node?​","type":1,"pageTitle":"FAQ","url":"validate/faq#how-can-i-correctly-stop-the-node","content":"pkill -f validator-engine  "},{"title":"Monitoring","type":0,"sectionRef":"#","url":"validate/monitoring","content":"Monitoring This article has TO DO status. You can contribute by submitting your own version of this page. More details on the Documentation page of the Hot streams section.","keywords":""},{"title":"Run Mainnet Node","type":0,"sectionRef":"#","url":"validate/run-validator/run-mainnet-node","content":"","keywords":""},{"title":"Getting Started​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#getting-started","content":"SSD/NVMe disks are obligatory. 1. System Requirements​ 2. Prerequisites​ 2.1 Set the Environment​ Adjust (if needed) main.ton.dev/scripts/env.sh: Set export DEPOOL_ENABLE=yes in env.sh for a depool validator (an elector request is sent to a depool from a validator multisignature wallet). Set export DEPOOL_ENABLE=no in env.sh for a direct staking validator (an elector request is sent from a multisignature wallet directly to the elector). cd main.ton.dev/scripts/ . ./env.sh  Note: Make sure to run the script as . ./env.sh, not ./env.sh 2.2 Install Dependencies​ install_deps.sh script supports Ubuntu OS only. ./install_deps.sh  Install and configure Docker according to the official documentation. Note: Make sure to add your user to the docker group, or run subsequent command as superuser: sudo usermod -a -G docker $USER  3. Deploy RUST Validator Node​ Do this step when the network is launched. Deploy the node: ./deploy.sh 2&gt;&amp;1 | tee ./deploy.log  Note: the log generated by this command will be located in the main.ton.dev/scripts/ folder and can be useful for troubleshooting. Wait until the node is synced. Depending on network throughput this step may take significant time (up to several hours). 4. Check Node synchronization​ Use the following command to check if the node is synced: docker exec -it rnode /ton-node/tools/console -C /ton-node/configs/console.json --cmd getstats  Script output example: tonlabs console 0.1.254 COMMIT_ID: BUILD_DATE: 2021-12-24 10:53:20 +0300 COMMIT_DATE: GIT_BRANCH: { &quot;sync_status&quot;: &quot;synchronization finished&quot;, &quot;masterchainblocktime&quot;: 1640343840, &quot;masterchainblocknumber&quot;: 13393489, &quot;timediff&quot;: 4, &quot;in_current_vset_p34&quot;: true, &quot;in_next_vset_p36&quot;: false, &quot;last_applied_masterchain_block_id&quot;: {&quot;shard&quot;:&quot;-1:8000000000000000&quot;,&quot;seq_no&quot;:13393489,&quot;rh&quot;:&quot;e74d505222bbe64617bbd42939cf01334b035990ae4b4e285e67ecbb1b537dd3&quot;,&quot;fh&quot;:&quot;fc0be7c22310389400a7bdbd000b3737b317ce44d92e9a5ed72086c4fa404afa&quot;}, &quot;processed_workchain&quot;: 0, &quot;validation_stats&quot;: { &quot;-1:8000000000000000&quot;: &quot;1 sec ago&quot;, &quot;0:e800000000000000&quot;: &quot;1 sec ago&quot; }, &quot;collation_stats&quot;: { &quot;-1:8000000000000000&quot;: &quot;never&quot;, &quot;0:e800000000000000&quot;: &quot;6 sec ago&quot; }, &quot;tps_10&quot;: 2, &quot;tps_300&quot;: 1 }  If the timediff parameter is less than 10 seconds, synchronization with masterchain is complete.&quot;sync_status&quot;: &quot;synchronization finished&quot; means synchronization with workchains is complete Note: The sync process may not start for up to one hour after node deployment, during which this command may result in error messages. If errors persist for more than an hour after deployment, review deployment log for errors and check the network status. 5. Configure validator multisignature wallet​ There is a small difference between direct staking and DePool validators on this step: For direct staking validator it is necessary to create and deploy a validator SafeMultisig wallet in -1 chain.For a DePool validator it is necessary to create and deploy a validator SafeMultisig wallet in 0 chain. You can use TONOS-CLI for this purpose. It should be configured to connect to the main.ton.dev network. Refer to this document for the detailed wallet creation procedure, or follow the links in the short guide below: All wallet custodians should create seed phrases and public keys for themselves. At least three custodians are recommended for validator wallet, one of which will be used by the validator node. All seed phrases should be kept secret by their owners and securely backed up.The wallet deployer (who may or may not be one of the custodians) should gather the public keys from all custodians.The wallet deployer should obtain SafeMultisig contract code from the repository.The wallet deployer should generate deployment keys.The wallet deployer should generate validator wallet address: in -1 chain for direct staking validator or in 0 chain for a DePool validator.Any user should send at least 1 token to the generated wallet address to create it in the blockchain.The wallet deployer should deploy the wallet contact to the blockchain and set all gathered public keys as its custodians. At this step the number of custodian signatures required to make transactions from the wallet is also set (&gt;=2 recommended for validator wallets). Deploy to -1 chain for direct staking validator or to 0 chain for a DePool validator.In case of direct staking, the funds for staking should be transferred to the newly created validator wallet. Once the wallet is deployed, place 2 files on the validator node: /ton-node/configs/${VALIDATOR_NAME}.addr should contain validator multisignature wallet address in form X:XXX...XXX (the folder on the host is main.ton.dev/docker-compose/ton-node/configs) /ton-node/configs/keys/msig.keys.json should contain validator multisignature custodian's keypair (the folder on the host is main.ton.dev/docker-compose/ton-node/configs/keys/) The node will use the wallet address and the keys provided to it to generate election requests each validation cycle. Note: If the validator wallet requires more than 1 custodian signature to make transactions, make sure each transaction sent by the validator node is confirmed by the required amount of custodians. 6. Configure DePool​ For a DePool validator it is necessary to deploy a DePool contract to workchain 0. You can use TONOS-CLI for this purpose. It should be configured to connect to the main.ton.dev network. Refer to this document for the detailed DePool creation procedure, or follow the links in the short guide below: Obtain contract code from the repository.Generate deployment keys.Calculate contract addresses.Send tokens to the calculated addresses.Deploy contracts. Make sure to specify your validator wallet in the DePool contract at this step.Configure DePool state update method. Once DePool is successfully deployed and configured to be regularly called to update its state, you can make stakes in it. Note that validator stakes must always exceed validator assurance, otherwise DePool will not participate in elections. Also note, that DePool and supporting contracts balance should be monitored and kept positive at all times. Once the validator wallet and the DePool are deployed, place 3 files on the validator node: /ton-node/configs/${VALIDATOR_NAME}.addr should contain validator multisignature wallet address in form 0:XXX...XXX (the folder on the host is main.ton.dev/docker-compose/ton-node/configs)/ton-node/configs/keys/msig.keys.json should contain validator multisignature custodian's keypair (the folder on the host is main.ton.dev/docker-compose/ton-node/configs/keys/)/ton-node/configs/depool.addr should contain DePool address in form 0:XXX...XXX (the folder on the host is main.ton.dev/docker-compose/ton-node/configs) The script generating validator election requests (directly through multisig wallet, or through DePool, depending on the setting selected on step 2.1) will run regularly, once the necessary addresses and keys are provided. 7. Upgrade RUST Validator Node​ Note: You may need to renew your copy of main.ton.dev scripts but do not remove any working files from the previous deployment (for example, configs folder). Adjust (specify new commit ID) main.ton.dev/scripts/env.sh: export TON_NODE_GITHUB_REPO=&quot;https://github.com/tonlabs/ton-labs-node.git&quot; export TON_NODE_GITHUB_COMMIT_ID=&quot;master&quot; export TON_NODE_TOOLS_GITHUB_REPO=&quot;https://github.com/tonlabs/ton-labs-node-tools.git&quot; export TON_NODE_TOOLS_GITHUB_COMMIT_ID=&quot;master&quot; export TONOS_CLI_GITHUB_REPO=&quot;https://github.com/tonlabs/tonos-cli.git&quot; export TONOS_CLI_GITHUB_COMMIT_ID=&quot;master&quot;  Upgrade the node: ./upgrade.sh 2&gt;&amp;1 | tee ./upgrade.log  Note: the log generated by this command will be located in the main.ton.dev/scripts/ folder and can be useful for troubleshooting. Wait until the node is synced. "},{"title":"Stopping, restarting the RUST Node​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#stopping-restarting-the-rust-node","content":"Note: call docker-compose commands from the main.ton.dev/docker-compose/ton-node folder. To stop the node use the following command: docker-compose stop  To restart a stopped node use the following command: docker-compose restart  "},{"title":"Logging​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#logging","content":"During deployment​ It is highly recommended to record the full log during node deployment: ./deploy.sh 2&gt;&amp;1 | tee ./deploy.log  The log is saved to the main.ton.dev/scripts/ folder next to the deployment script and can be useful for troubleshooting. During operation​ When operational, the node keeps a number of logs in the main.ton.dev/docker-compose/ton-node/logs folder. Logs are generated with log4rs framework. For detailed documentation on it refer to https://docs.rs/log4rs/1.0.0/log4rs/. Logging configuration is determined by the main.ton.dev/docker-compose/ton-node/configs/log_cfg.yml file. By default is contains the recommended configuration for the Rust node. refresh_rate: 30 seconds appenders: stdout: kind: console encoder: pattern: &quot;{d(%s.%f)} {l} [{h({t})}] {I}: {m}{n}&quot; stdout_ref: kind: console encoder: pattern: &quot;{f}:{L} {l} [{h({t})}] {I}: {m}{n}&quot; logfile: kind: file path: &quot;/ton-node/logs/output.log&quot; encoder: pattern: &quot;{d(%s.%f)} {l} [{h({t})}] {I}: {m}{n}&quot; rolling_logfile: kind: rolling_file encoder: pattern: &quot;{d(%Y-%m-%d %H:%M:%S.%f)} {l} [{h({t})}] {I}: {m}{n}&quot; path: /ton-node/logs/output.log policy: kind: compound trigger: kind: size limit: 50 gb roller: kind: fixed_window pattern: '/ton-node/logs/output_{}.log' base: 1 count: 1 tvm_logfile: kind: file path: &quot;target/log/tvm.log&quot; encoder: pattern: &quot;{m}{n}&quot; root: level: info appenders: - rolling_logfile loggers: ## node messages ton_node: level: trace boot: level: trace sync: level: trace ## adnl messages adnl: level: info overlay: level: info rldp: level: info dht: level: info ## block messages ton_block: level: debug ## block messages executor: level: debug ## tvm messages tvm: level: info librdkafka: level: info validator: level: debug catchain: level: debug validator_session: level: debug  The currently configured targets are the following: ton_node: node-related messages, except initial boot and sync, block exchange with other nodes boot: initial boot messages, creation of trusted key block chain, loading blockchain state sync: node synchronization - loading a certain number of most recent blocks adnl: messages of the ADNL protocol overlay: messages of the overlay protocol rldp: messages of the RLDP protocol dht: messages of the DHT protocol ton_block: messages of the block structures library, logs are turned on in debug executor: messages of the smart contract execution library, logs are turned on in debug tvm: ton virtual machine messages, logs are turned on in debug librdkafka: kafka client library messages validator: top level consensus protocol messages catchain: low level consensus protocol messages validator_session: mid level consensus protocol messages "},{"title":"Migrating from C++ node​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#migrating-from-c-node","content":"To migrate your validator from legacy C++ node to Rust node, complete the following steps: Set up a new host for the Rust node, according to steps 1-3 of this document.Wait for node to sync. Check sync according to step 4 of this document.Stop the C++ node sending election requests (by default - disable scheduling of the validator script). Do not shut down the C++ validator itself, let it finish the current round.Configure validator wallet and corresponding keys, optionally - DePool (copy them from C++ node files to Rust Node files). By default: Copy validator wallet address from ~/ton-keys/$(hostname -s).addr file on the C++ node to /ton-node/configs/${VALIDATOR_NAME}.addr on the Rust Node.Copy validator wallet keys from /ton-keys/msig.keys.json on the C++ node to /ton-node/configs/keys/msig.keys.json on the Rust Node.If you have a DePool set up, copy DePool address from ~/ton-keys/depool.addr on the C++ node to /ton-node/configs/depool.addr on the Rust Node. Once this is done, the Rust node validator script will start automatically with the next round. DO NOT shut down the C++ host. Wait for the C++ node to complete the current round until the validator set is changed.Check logs/validator.log on the Rust node, and make sure the first election request was successfully sent. There should be no errors in the log.Only once the validator set changes, the C++ node is no longer a validator and the Rust node starts validating (validation_stats and collation_stats in the console output should not be empty), shut down the C++ node. "},{"title":"Troubleshooting​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#troubleshooting","content":"Here are some solutions to frequently encountered problems. 1. Couldn’t connect to Docker daemon at http+docker://localhost​ This error occurs in two cases. Either the docker daemon isn't running, or current user doesn't have rights to access docker. You can fix the rights issue either by running relevant commands as the superuser or adding the user to the docker group: sudo usermod -a -G docker $USER  Make sure to restart the system or log out and back in, for the new group settings to take effect. 2. thread 'main' panicked error when checking node synchronization​ The following error may occur for a short time immediately after node deployment when attempting to check synchronization: thread 'main' panicked at 'Can't create client: Os { code: 111, kind: ConnectionRefused, message: &quot;Connection refused&quot; }', bin/console.rs:454:59  Currently this is expected behavior, unless it persists for more than a few minutes. If it does persist, check network status at https://ever.live, and, if the network is up and running, review deployment logs for errors. 3. Error executing command when checking node synchronization​ The following error may occur for up to an hour after node deployment when attempting to check synchronization: Error executing command: Error receiving answer: early eof bin/console.rs:296  Currently this is expected behavior, unless it persists for more than one hour. If it does persist, check network status at https://ton.live/, and, if the network is up and running, review deployment logs for errors. 4. Cannot stop/restart/remove node container​ Make sure you are running all docker-compose commands from the main.ton.dev/docker-compose/ton-node folder. 5. DePool state not updating​ It's recommended to send at least two ticktocks while the elections are open. For rust node you can use the provided ticktock script, which sends 5 ticktocks after the elections open. "},{"title":"Getting started","type":0,"sectionRef":"#","url":"validate/depools/getting-started","content":"","keywords":""},{"title":"Prerequisites​","type":1,"pageTitle":"Getting started","url":"validate/depools/getting-started#prerequisites","content":"TONOS-CLI of the latest version (0.3.0 or later) installed and configured. tvm_linker utility. Resources required to run a node available: For C++ nodeFor Rust node "},{"title":"Procedure​","type":1,"pageTitle":"Getting started","url":"validate/depools/getting-started#procedure","content":"To function correctly, the DePool contract requires an active validator node and a set of supporting smart contracts, that have to be deployed and configured alongside it: The Validator Wallet, which should be a multisignature wallet with at least three custodians and reqConfirms &gt; 1. Can be deployed to the basechain.The DePool contract itself, deployed to the basechain. DePool contract deploys two proxy smart contracts to the masterchain, which will pass messages from the DePool to the Elector smart contract. Two proxies are required to support two staking rounds running in parallel, one for odd rounds, and one for even rounds.Optionally, the DePool Helper contract, which is connected to the global Timer contract and ensures regular operation of the DePool. Also deployed to the basechain. Can be replaced with other methods of updating DePool state. Important: the only contracts requiring masterchain in this setup are the two proxy contracts, which are deployed by DePool. Everything else is designed to function on the basechain, as the contracts are rather complex and consume a lot of gas. Once all of these contracts are deployed and configured, the DePool is ready to receive stakes. Follow the steps described below to complete this procedure. "},{"title":"1. Set Up Node and Deploy Validator Wallet​","type":1,"pageTitle":"Getting started","url":"validate/depools/getting-started#1-set-up-node-and-deploy-validator-wallet","content":"When using DePool you may set up the validator wallet on the basechain, as the DePool itself operates on the basechain and will pass your stakes to the masterchain Elector contract through its proxy contracts. With that in mind, follow: For C++ node - this procedure up to step 4.4 (the validator script in step 5 will be different) For Rust node - this procedure up to step 6 and make sure to set up at least three custodians for your wallet. Make sure that in the course of the procedure: For C++ node: validator wallet address was specified in the ~/ton-keys/$(hostname -s).addr file.validator wallet keys were saved to the ~/ton-keys/msig.keys.json file. For Rust node: validator wallet address was specified in the /ton-node/configs/${VALIDATOR_NAME}.addr file.validator wallet keys were saved to the /ton-node/configs/keys/msig.keys.json file. The wallet address will also be needed on the following steps. As always, also make sure to securely backup all of your seed phrases and/or wallet keys, generated during wallet and node setup. If you lose them, you will not be able to recover access to your funds. Note: The validator wallet should have a small sum of tokens available at all times to reliably send election requests to DePool. Each election request costs ~ 1 Ton. 2. Prepare DePool and Supporting Smart Contracts​ Obtain contract code from the repository. Note: For RustCup use the DePool from RUSTCUP_DEPOOL_--_DO_NOT_DEPLOY_ON_MAINNET branch. Do not use it on any other network.The files required for DePool deployment are comprised of three pairs of compiled contract .tvc files and their corresponding ABI files: DePoolProxy.tvc DePool.tvc and DePool.abi.json DePoolHelper.tvc and DePoolHelper.abi.json "},{"title":"3. Generate Deployment Keys​","type":1,"pageTitle":"Getting started","url":"validate/depools/getting-started#3-generate-deployment-keys","content":"Use TONOS-CLI to generate seed phrases for the contracts you will be deploying: tonos-cli genphrase  Do not reuse wallet keys, or any other keys you may have used elsewhere already. Securely backup these seed phrases and keep them secret, as without them, control over the DePool contract will be lost (for example, without its key, the DePool cannot be closed). If you suspect that your keys are compromised, close the DePool and deploy it anew with new keys and a new set of supporting contracts. Generate key pair files from the seed phrases (this step is intended for the sake of convenience as nothing in the seed phrases indicates for what contract they are intended, and they are easy to mix up). tonos-cli getkeypair depool.json &quot;seed_phrase_for_depool&quot; tonos-cli getkeypair helper.json &quot;seed_phrase_for_helper&quot;  "},{"title":"4. Calculate Contract Addresses​","type":1,"pageTitle":"Getting started","url":"validate/depools/getting-started#4-calculate-contract-addresses","content":"The smart contracts you will be deploying need to be configured to know the addresses of each other. Thus, first you have to calculate and save the addresses of every contract to be deployed. 4.1. Calculate DePool address​ tonos-cli genaddr DePool.tvc DePool.abi.json --setkey depool.json --wc 0  Save the DePool address. Put it into the following files in in your validator node setup: ~/ton-keys/depool.addr file - for C++ Node /ton-node/configs/depool.addr - for Rust Node It will be required for the validator script. 4.2. (Optional) Calculate DePool Helper address​ tonos-cli genaddr DePoolHelper.tvc DePoolHelper.abi.json --setkey helper.json --wc 0  Save the DePool Helper address. "},{"title":"5. Send Coins to the Calculated Addresses​","type":1,"pageTitle":"Getting started","url":"validate/depools/getting-started#5-send-coins-to-the-calculated-addresses","content":"Send some coins to all addresses calculated on step 4 to initialize them with the following command: tonos-cli call &lt;wallet_address&gt; submitTransaction '{&quot;dest&quot;:&quot;contract_address&quot;,&quot;value&quot;:*number*,&quot;bounce&quot;:&quot;false&quot;,&quot;allBalance&quot;:&quot;false&quot;,&quot;payload&quot;:&quot;&quot;}' --abi &lt;MultisigWallet.abi.json&gt; --sign &lt;wallet_seed_or_keyfile&gt;  Where &lt;wallet_address&gt; - is the address of the wallet, from which you are making the transaction &lt;contract_address&gt; - address of one of the contracts, calculated on step 4. &quot;value&quot;:*number* - the amount of coins to be transferred (in nanotokens). &quot;bounce&quot;:&quot;false&quot; - bounce flag set to false, to allow a transaction to an account that is not yet initialized. &lt;MultisigWallet.abi.json&gt; - the ABI file of the contract, from which you are making the transaction (for validator wallets - usually SafeMultisigWallet.abi.json) &lt;wallet_seed_or_keyfile&gt; - either the seed phrase in double quotes, or the path to the keyfile for the wallet, from which you are making the transaction allBalance and payload values in this case remain default. Example: tonos-cli call 0:2bb4a0e8391e7ea8877f4825064924bd41ce110fce97e939d3323999e1efbb13 submitTransaction '{&quot;dest&quot;:&quot;0:37fbcb6e3279cbf5f783d61c213ed20fee16e0b1b94a48372d20a2596b700ace&quot;,&quot;value&quot;:200000000,&quot;bounce&quot;:&quot;false&quot;,&quot;allBalance&quot;:&quot;false&quot;,&quot;payload&quot;:&quot;&quot;}' --abi ./SafeMultisigWallet.abi.json --sign ./wallet.json  Confirm the transaction, if it is required. Such a transaction should be repeated for every address calculated on step 4: the DePool contract itself and, optionally, the DePool Helper contract. The recommended initial amounts are: 21 Evers to the DePool conrtact5 Evers to the DePool Helper10 Evers should be left on the validator wallet For the duration of the DePool existence, balance on all DePool-related contracts should be maintained: Proxies receive fees for their services automatically, but if they run out of funds for any reason, DePool might miss elections.Helper, on the other hand, should be topped up regularly, depending on the set timer period. Without funds on the Helper contract, DePool will not be able to function regularly. The DePool itself receives funds for its operations from validation rewards, but may also, if it stops receiving these rewards, run out of funds. 6. Deploy Contracts​ 6.1. Deploy DePool contract to the basechain​ tonos-cli deploy DePool.tvc '{&quot;minStake&quot;:*number*,&quot;validatorAssurance&quot;:*number*,&quot;proxyCode&quot;:&quot;&lt;ProxyContractCodeInBase64&gt;&quot;,&quot;validatorWallet&quot;:&quot;&lt;validatorWalletAddress&gt;&quot;,&quot;participantRewardFraction&quot;:*number*}' --abi DePool.abi.json --sign depool.json --wc 0  Where &quot;minStake&quot;:*number* – minimum stake (in nanoevers) that DePool accepts from participants. It's recommended to set it not less than 10 tokens. &quot;validatorAssurance&quot;:*number* - minimal stake for validator. If validator has stake less than validatorAssurance, DePool won't be taking part in elections. ProxyContractCodeInBase64 - code of the proxy contract. Can be obtained by calling tvm_linker: tvm_linker decode --tvc DePoolProxy.tvc  &lt;validatorWalletAddress&gt; – validator wallet address from step 1. &quot;participantRewardFraction&quot;:*number* - percentage of the total DePool reward (in integers, up to 99 inclusive) that goes to Participants. It's recommended to set it at 95% or more. Important: You will not be able to change all of these parameters, except participantRewardFraction, after the DePool is deployed. They will influence the appeal of your DePool to potential participants:participantRewardFraction determines what percentage of their total reward all participants will receive (too small, and other DePools might draw them away, too big, and your validator wallet might not receive enough rewards, to support validation and staking); it can be adjusted at any time by the DePool owner, but only upwards - see how below.validatorAssurance determines how much you take it upon yourself to invest in the DePool and lose in case of any validator node malfunction or misbehavior. If set too small, potential participants might decide you aren't risking enough and avoid your DePool in favor of others. Example: tonos-cli deploy DePool.tvc '{&quot;minStake&quot;:10000000000,&quot;validatorAssurance&quot;:100000000000000,&quot;proxyCode&quot;:&quot;te6ccgECIgEABdIAAib/APSkICLAAZL0oOGK7VNYMPShBwEBCvSkIPShAgIDzkAGAwIB1AUEADk7UTQ0//TP9MA0wf6QPhs+Gv4an/4Yfhm+GP4YoAA9PhCyMv/+EPPCz/4Rs8LAPhK+Ev4TF4gywfOzsntVIADTu/CC3SXgE7zRTfjAQaY/pn5mQwQh/////XUcjuDRTfbBKtFN/MBjvwQgCrqVAUNq//CW4ZGfCwGUAOeegZwD9AUaCIAAAAAAAAAAAAAAAAACHtMu6Z4sQ54Wf/CTni2S4/YBvL4HJeARvQIBIBAIAgFuDwkCASAOCgIBIA0LAZj6f40IYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABPhpIe1E0CDXScIBjhnT/9M/0wDTB/pA+Gz4a/hqf/hh+Gb4Y/hiDAG4joDi0wABn4ECANcYIPkBWPhC+RDyqN7TPwGOHvhDIbkgnzAg+COBA+iogggbd0Cgud6S+GPggDTyNNjTHyHBAyKCEP////28sZZbcfAB8AXgAfAB+EdukzDwBd4WALu0t7mSfCC3SXgE72mf6Lg0U32wSrRTfzAY78EIAq6lQFDav/wluGRnwsBlADnnoGcA/QFGgiAAAAAAAAAAAAAAAAAB8+0HGmeLEOeFn/wk54tkuP2AGEl4BG8//DPAAMe23RITPhBbpLwCd7TP9Mf0XBopvtglWim/mAx34IQBV1KgKG1f/hLcMjPhYDKAHPPQM4B+gKNBEAAAAAAAAAAAAAAAAABM+vBdM8WIs8LPyHPCx/4Sc8WyXH7AFuS8Ajef/hngAMe5zeipnwgt0l4BO9pn+mP6Lg0U32wSrRTfzAY78EIAq6lQFDav/wluGRnwsBlADnnoGcA/QFGgiAAAAAAAAAAAAAAAAABO2QLJmeLEWeFn5DnhY/8JOeLZLj9gC3JeARvP/wzwAgEgGxECASAYEgEPuotV8/+EFugTATKOgN74RvJzcfhm0fhJ+EvHBfLgZvAIf/hnFAFG7UTQINdJwgGOGdP/0z/TANMH+kD4bPhr+Gp/+GH4Zvhj+GIVAQaOgOIWAf70BXEhgED0DpPXCweRcOL4anIhgED0Do4kjQhgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE3/hrcyGAQPQOjiSNCGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATf+GxwAYBA9A7yvdcL//hicPhjFwAMcPhmf/hhAgFqGhkA8bTYWbL8ILdJeATvaZ/9IGj8JPwl44L5cDN8E7eIODRTfbBKtFN/MBjvwQgdzWUAUFq/33lwM7g0U32wSrRTfzAY78EIAq6lQFDav5DkZ8LEZwD9AUaCIAAAAAAAAAAAAAAAAAEdldCSZ4sRZ4Wf5Lj9gC34BD/8M8AApbQlaov8ILdJeATvaPwk/CZjgvlwNHwTt4gQOUEIHc1lAFRan99HERA5QQgdzWUAVFqf0Nq/kHwmZGfChGcA/QFANeegZLh9gBhvGEl4BG8//DPAAgEgHRwAn7rbxCnvhBbpLwCd7R+EuCEDuaygAiwP+OLSTQ0wH6QDAxyM+HIM6NBAAAAAAAAAAAAAAAAArbxCnozxYizxYhzws/yXH7AN5bkvAI3n/4Z4AgEgIR4BCbhxdZGQHwH6+EFukvAJ3tM/0//TH9Mf1w3/ldTR0NP/3yDXS8ABAcAAsJPU0dDe1PpBldTR0PpA39H4SfhLxwXy4Gb4J28QcGim+2CVaKb+YDHfghA7msoAoLV/vvLgZ3BopvtglWim/mAx34IQBV1KgKG1fyHIz4WIzgH6AoBqz0DPg8ggAFLPkTnN0S4ozws/J88L/ybPCx8lzwsfJM8L/yPPFM3JcfsAXwfwCH/4ZwCC3HAi0NMD+kAw+GmpOADcIccAIJwwIdMfIcAAIJJsId7f3CHBAyKCEP////28sZZbcfAB8AXgAfAB+EdukzDwBd4=&quot;,&quot;validatorWallet&quot;:&quot;0:0123012301230123012301230123012301230123012301230123012301230123&quot;,&quot;participantRewardFraction&quot;:95}' --abi DePool.abi.json --sign depool.json --wc 0  Note: For RustCup, make sure to get the proxy code from the contract file in the RUSTCUP_DEPOOL_--_DO_NOT_DEPLOY_ON_MAINNET branch. Do not use it on any other network. At the time of deployment, the variable m_balanceThreshold is set as current DePool account balance - 5 tokens. DePool will replenish its balance from validation rewards to this value every round it receives rewards. 6.2. (Optional) Deploy DePool Helper contract to the basechain​ tonos-cli deploy DePoolHelper.tvc '{&quot;pool&quot;:&quot;DePoolAddress&quot;}' --abi DePoolHelper.abi.json --sign helper.json --wc 0  Where &lt;DePoolAddress&gt; – address of the DePool contract from step 4.1. Example: tonos-cli deploy DePoolHelper.tvc '{&quot;pool&quot;:&quot;0:37fbcb6e3279cbf5f783d61c213ed20fee16e0b1b94a48372d20a2596b700ace&quot;}' --abi DePoolHelper.abi.json --sign helper.json --wc 0  "},{"title":"7. Configure DePool State Update method​","type":1,"pageTitle":"Getting started","url":"validate/depools/getting-started#7-configure-depool-state-update-method","content":"There are three different methods of setting up regular state updates of the DePool contract available. You have to set up one of them to run regularly. The period for state updates should be chosen based on the duration of the validation cycle on the blockchain. At the very minimum DePool's state update function should be called four times during the validation cycle: 1) At least twice after the elections begin, so DePool gets ready to receive and forward validator's election request. 2) Once after the validation begins, to find out if it won elections or not. 3) Once after unfreeze, to process stakes and rewards and rotate the rounds. In the current network configuration, 1 and 3 coincide, so DePool's state update should be called be called at least three times during the validation cycle - at least twice twice during elections and once during validation. For Rust node you can use the provided ticktock script, which sends 5 ticktocks after the elections open. State update through Multisig Contract​ A Multisig wallet can be used instead of Helper to call DePool's ticktock function directly. tonos-cli depool [--addr &lt;depool_address&gt;] ticktock [-w &lt;msig_address&gt;] [-s &lt;path_to_keys_or_seed_phrase&gt;]  Where --addr &lt;depool_address&gt; - the address of the DePool -w &lt;msig_address&gt; - the address of the multisig wallet used to call DePool -s &lt;path_to_keys_or_seed_phrase&gt; - either the keyfile for the wallet, or the seed phrase in quotes All these options can be skipped, if they were previously specified in the TONOS-CLI configuration file: tonos-cli config --addr &lt;address&gt; --wallet &lt;address&gt; --keys &lt;path_to_keys or seed_phrase&gt;  1 token is always attached to this call. Change will be returned. Example: tonos-cli depool --addr 0:37fbcb6e3279cbf5f783d61c213ed20fee16e0b1b94a48372d20a2596b700ace ticktock -w 0:1b91c010f35b1f5b42a05ad98eb2df80c302c37df69651e1f5ac9c69b7e90d4e -s &quot;dizzy modify exotic daring gloom rival pipe disagree again film neck fuel&quot;  State update through DePool Helper contract (temporarily unavailable)​ If you have previously deployed DePool helper, you can set it up to regularly call the DePool state update ticktock function. To do it, DePool Helper contract needs to be connected to the global Timer contract. Use the following command: tonos-cli call HelperAddress initTimer '{&quot;timer&quot;:&quot;TimerAddress&quot;,&quot;period&quot;:*number*}' --abi DePoolHelper.abi.json --sign helper.json  Where &lt;HelperAddress&gt; – is the address of the Helper contract from step 4.2 &lt;TimerAddress&gt; - is the address of the global timer contract. &quot;period&quot;:*number* - is the period for regular DePool contract calls via ticktock messages (in seconds). This period should be chosen based on the duration of the validation cycle on the blockchain. At a minimum DePool Helper contract should be set to call the DePool contract once every step of the validation cycle. Example: tonos-cli call 0:1b91c010f35b1f5b42a05ad98eb2df80c302c37df69651e1f5ac9c69b7e90d4e initTimer '{&quot;timer&quot;:&quot;0:3a10ef5d6435e82eb243b41e620f6a7737a70694884aca1c52c99088efb7643d&quot;,&quot;period&quot;:3600}' --abi DePoolHelper.abi.json --sign helper.json  Timer contract and period may be changed at any time with this command. Timer fees Timer charges a fee for its services every time the Helper calls it. The fees (in nanoevers) are calculated according to the following formula: fee = period * timerRate + fwdFee * 8 + epsilon Where timerRate = 400000 nanoevers per second fwdFee = 1000000 nanoevers epsilon = 1e9 nanoevers period = the period set in the DePool Helper contract (in seconds). Thus, the longer the period set in the DePool Helper contract is, the higher a single timer fee will be. To pay these fees reliably, sufficient positive balance (~100 Evers if the period is set to 1 hour) has to be maintained on the Helper. Without funds on the Helper contract, DePool will not be able to function regularly. State update through external call of the DePool Helper Contract​ DePool Helper can be called to send the ticktock message manually at any time with the following command: tonos-cli call &lt;HelperAddress&gt; sendTicktock {} --abi DePoolHelper.abi.json --sign helper.json  Where &lt;HelperAddress&gt; – is the address of the Helper contract from step 4.2. If needed, it can be set up to run regularly (for example, with cron utility) to supplement or replace the timer. Example: @hourly cd &lt;tonos-cli-dir&gt; &amp;&amp; tonos-cli call &lt;HelperAddress&gt; sendTicktock {} --abi DePoolHelper.abi.json --sign helper.json  Where &lt;tonos-cli-dir&gt; - directory with TONOS-CLI configuration file, DePoolHelper.abi.json file and helper.json keyfile containing DePool Helper keys. &lt;HelperAddress&gt; – address of the Helper contract from step 4.2. "},{"title":"8. Make Stakes​","type":1,"pageTitle":"Getting started","url":"validate/depools/getting-started#8-make-stakes","content":"DePool collects stakes from various participants to be pooled together and forwarded as one stake to the Elector on behalf of its validator node. Collection is continuous. Stakes can be made at any time, and will be distributed to whichever round is currently in the pooling stage. Every time an election begins on the blockchain, the accumulated pool is locked and (if all conditions are met) staked in this election, and the pooling stage of the next round begins. Note: This means, that a DePool stake for a specific election needs to be made before the election begins. To participate in elections, DePool has to accumulate, through stakes belonging to the validator wallet and, optionally, from other wallets, a staking pool, validator's share of which is not less than validatorAssurance (see section 6.1 above). TONOS-CLI allows to manage several types of stakes. DePool fees​ All staking commands are subject to an additional fee (by default 0.5 evers), that is partially spent to pay for DePool executing the command. The change is then returned to the sender. This value can be adjusted in TONOS-CLI config. Additionally, when DePool receives the stake and rewards back from elector and processes the funds of participants, it uses the rewards to top up its balance: first to m_balanceThreshold = DePool's balance at the time of deployment - 5 eversthen it takes retOrReinvFee*(N+1) tokens, where N is the number of participants.retOrReinvFee is set to 0,04 evers in the current version of DePool and can only be changed in contract code. It can be viewed through getDePoolInfo get-method. These two fees cover DePool's operational expenses and are deducted only from validation rewards. If DePool doesn't receive rewards in a round, it will not be able to top up its balance. Configure TONOS-CLI for DePool operations​ For all commands listed below, the DePool address, the wallet making the stake, the amount of fee to pay for DePool's services and the path to the keyfile/seed phrase may be specified in the TONOS-CLI config file in advance: tonos-cli config --addr &lt;address&gt; --wallet &lt;address&gt; --keys &lt;path_to_keys or seed_phrase&gt; --depool_fee &lt;depool_fee&gt;  Where --addr &lt;address&gt; - the address of the DePool --wallet &lt;address&gt; - the address of the wallet making the stake &lt;path_to_keys or seed_phrase&gt; - either the keyfile for the wallet making the stake, or the seed phrase in quotes --depool_fee &lt;depool_fee&gt; - value in evers, that is additionally attached to the message sent to the DePool to cover its fees. Change is returned to the sender. The default value, used if this option isn't configured, is 0.5 evers. It should be increased only if it proves insufficient and DePool begins to run out of gas on execution. Example: tonos-cli config --addr 0:37fbcb6e3279cbf5f783d61c213ed20fee16e0b1b94a48372d20a2596b700ace --wallet 0:1b91c010f35b1f5b42a05ad98eb2df80c302c37df69651e1f5ac9c69b7e90d4e --keys &quot;dizzy modify exotic daring gloom rival pipe disagree again film neck fuel&quot; --depool_fee 0.8  In this case all commands allow to omit --addr, --wallet and --sign options. Deposit stakes​ 1) Ordinary stake​ Ordinary stake is the most basic type of stake. It and the rewards from it belong to the wallet that made it. It is invested completely in the current pooling round, and can be reinvested every second round (as odd and even rounds are handled by DePool separately). Thus to participate in every DePool round, an ordinary stake should be invested in two consecutive rounds, so it can later be reinvested in odd and even rounds both. Ordinary stake must exceed DePool minimum stake. Check DePool Info get-method to find out the minimum stake. Use the following command to make an ordinary stake: tonos-cli depool [--addr &lt;depool_address&gt;] stake ordinary [--wallet &lt;msig_address&gt;] --value &lt;number&gt; [--sign &lt;key_file or seed_phrase&gt;]  where &lt;depool_address&gt; - address of the DePool contract. &lt;msig_address&gt; - address of the wallet making a stake. all --value parameters must be defined in evers, like this: --value 10.5, which means the value is 10,5 evers. &lt;key_file or seed_phrase&gt; - either the keyfile for the wallet making the stake, or the seed phrase in quotes. Example: tonos-cli depool --addr 0:37fbcb6e3279cbf5f783d61c213ed20fee16e0b1b94a48372d20a2596b700ace stake ordinary --wallet 0:1b91c010f35b1f5b42a05ad98eb2df80c302c37df69651e1f5ac9c69b7e90d4e --value 100.5 --sign &quot;dizzy modify exotic daring gloom rival pipe disagree again film neck fuel&quot;  2) Vesting stake​ A wallet can make a vesting stake and define a target participant address (beneficiary) who will own this stake, provided the beneficiary has previously indicated the donor as its vesting donor address. This condition prevents unauthorized vestings from blocking the beneficiary from receiving an expected vesting stake from a known address. To receive a vesting stake beneficiary must: already have an ordinary stake of any amount in the DePool (it can be made by the participant itself, or transferred from another participant) set the donor address with the following command: tonos-cli depool [--addr &lt;depool_address&gt;] donor vesting [--wallet &lt;beneficiary_address&gt;] --donor &lt;donor_address&gt; [--sign &lt;key_file or seed_phrase&gt;]  Where &lt;depool_address&gt; - address of the DePool contract. &lt;beneficiary_address&gt; - address of the beneficiary wallet . &lt;donor_address&gt; - address of the donor wallet. &lt;key_file or seed_phrase&gt; - either the keyfile for the beneficiary wallet, or the seed phrase in quotes. Example: tonos-cli depool --addr 0:3187b4d738d69776948ca8543cb7d250c042d7aad1e0aa244d247531590b9147 donor vesting --wallet 0:255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f3 --donor 0:279afdbd7b2cbf9e65a5d204635a8630aec2baec60916ffdc9c79a09d2d2893d --sign &quot;deal hazard oak major glory meat robust teach crush plastic point edge&quot;  Not the whole stake is available to the beneficiary at once. Instead it is split into parts and the next part of stake becomes available to the beneficiary (is transformed into beneficiary's ordinary stake) at the end of the round that coincides with the end of the next withdrawal period. Rewards from vesting stake are always added to the beneficiary's ordinary stake. To withdraw these funds, beneficiary should use one of the withdrawal functions. Please note, that the vesting stake is split into two equal parts by the DePool, to be used in both odd and even rounds, so to ensure DePool can participate in elections with just one vesting stake where validator wallet is beneficiary, the stake should exceed validatorAssurance2. Similarly, to ensure any vesting stake is accepted, make sure it exceeds minStake 2. Vesting for validator beneficiaries is subject to additional rules: At the end of every withdrawal period, the part of the vesting stake to be released is divided proportionally into 2 parts - for rounds in this period when DePool successfully completed validation and received a reward (without slashing) and for rounds when DePool missed elections or was slashed. The portion of the stake corresponding to the successful rounds is sent to the validator, while the portion corresponding to the failed rounds is returned to the vesting stake donor. For example, if there were 100 rounds within the withdrawal period, and DePool successfully completed 80 of them, missed elections in 5 more and was slashed in the remaining 15, the validator will receive 80% of the unlocked part of the vesting stake, and the stake donor will get back 20% of it. Donor uses the following command to make a vesting stake: tonos-cli depool [--addr &lt;depool_address&gt;] stake vesting [--wallet &lt;msig_address&gt;] --value &lt;number&gt; --total &lt;days&gt; --withdrawal &lt;days&gt; --beneficiary &lt;address&gt; [--sign &lt;key_file or seed_phrase&gt;]  Where &lt;depool_address&gt; - address of the DePool contract. &lt;msig_address&gt; - address of the wallet making a stake. all --value parameters must be defined in evers, like this: --value 10.5, which means the value is 10,5 evers. total &lt;days&gt; - total period, for which the stake is made. withdrawal &lt;days&gt; - withdrawal period (each time a withdrawal period ends, a portion of the stake is released to the beneficiary). There are limitations for period settings: withdrawalPeriod should be &lt;= totalPeriod, totalPeriod cannot exceed 18 years or be &lt;=0, totalPeriod should be exactly divisible by withdrawalPeriod.beneficiary &lt;address&gt; - address of the wallet that will receive rewards from the stake and, in parts over time, the vesting stake itself. Cannot be the same as the wallet making the stake. &lt;key_file or seed_phrase&gt; - either the keyfile for the wallet making the stake, or the seed phrase in quotes. Example: tonos-cli depool --addr 0:37fbcb6e3279cbf5f783d61c213ed20fee16e0b1b94a48372d20a2596b700ace stake vesting --wallet 0:1b91c010f35b1f5b42a05ad98eb2df80c302c37df69651e1f5ac9c69b7e90d4e --value 1000 --total 360 --withdrawal 30 --beneficiary 0:f22e02a1240dd4b5201f8740c38f2baf5afac3cedf8f97f3bd7cbaf23c7261e3 --sign &quot;dizzy modify exotic daring gloom rival pipe disagree again film neck fuel&quot;  Note: Each participant can be the beneficiary of only one vesting stake. Once the current vesting stake expires, another can be made for the participant. 3) Lock stake​ A wallet can make a lock stake, in which it locks its funds in DePool for a defined period, but rewards from this stake will be payed to another target participant (beneficiary). As with vesting, the beneficiary has to indicate the donor as its lock donor address before receiving a lock stake. This condition prevents unauthorized lock stakes from blocking the beneficiary from receiving an expected lock stake from a known address. To receive a lock stake beneficiary must: already have an ordinary stake of any amount in the DePool (it can be made by the participant itself, or transferred from another participant)set the donor address with the following command: tonos-cli depool [--addr &lt;depool_address&gt;] donor lock [--wallet &lt;beneficiary_address&gt;] --donor &lt;donor_address&gt; [--sign &lt;key_file or seed_phrase&gt;]  Where &lt;depool_address&gt; - address of the DePool contract. &lt;beneficiary_address&gt; - address of the beneficiary wallet . &lt;donor_address&gt; - address of the donor wallet. &lt;key_file or seed_phrase&gt; - either the keyfile for the beneficiary wallet, or the seed phrase in quotes. Example: tonos-cli depool --addr 0:3187b4d738d69776948ca8543cb7d250c042d7aad1e0aa244d247531590b9147 donor lock --wallet 0:255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f3 --donor 0:279afdbd7b2cbf9e65a5d204635a8630aec2baec60916ffdc9c79a09d2d2893d --sign &quot;deal hazard oak major glory meat robust teach crush plastic point edge&quot;  Like vesting stake, lock stake can be configured to be unlocked in parts at the end of each round that coincides with the end of the next withdrawal period. At the end of each period a part of the Lock Stake is returned to the wallet which locked it. The rewards of a lock stake are always added to the ordinary stake of the beneficiary. To withdraw these funds, beneficiary should use one of the withdrawal functions. Please note that the lock stake is split into two equal parts by the DePool, to be used in both odd and even rounds, so to ensure DePool can participate in elections with just one lock stake where validator wallet is beneficiary, the stake should equal validatorAssurance 2. Similarly, to ensure any vesting stake is accepted, make sure it exceeds minStake 2. Donor uses the following command to make a lock stake: tonos-cli depool [--addr &lt;depool_address&gt;] stake lock [--wallet &lt;msig_address&gt;] --value &lt;number&gt; --total &lt;days&gt; --withdrawal &lt;days&gt; --beneficiary &lt;address&gt; [--sign &lt;key_file or seed_phrase&gt;]  Where &lt;depool_address&gt; - address of the DePool contract. &lt;msig_address&gt; - address of the wallet making a stake. all --value parameters must be defined in evers, like this: --value 10.5, which means the value is 10,5 evers. total &lt;days&gt; - total period, for which the stake is made. withdrawal &lt;days&gt; - withdrawal period (each time a withdrawal period ends, a portion of the stake is returned to the wallet that made the stake). There are limitations for period settings: withdrawalPeriod should be &lt;= totalPeriod, totalPeriod cannot exceed 18 years or be &lt;=0, totalPeriod should be exactly divisible by withdrawalPeriod.beneficiary &lt;address&gt; - address of the wallet that will receive rewards from the stake. Cannot be the same as the wallet making the stake. key_file or seed_phrase - either the keyfile for the wallet making the stake, or the seed phrase in quotes. Example: tonos-cli depool --addr 0:37fbcb6e3279cbf5f783d61c213ed20fee16e0b1b94a48372d20a2596b700ace stake lock --wallet 0:1b91c010f35b1f5b42a05ad98eb2df80c302c37df69651e1f5ac9c69b7e90d4e --value 1000 --total 360 --withdrawal 30 --beneficiary 0:f22e02a1240dd4b5201f8740c38f2baf5afac3cedf8f97f3bd7cbaf23c7261e3 --sign &quot;dizzy modify exotic daring gloom rival pipe disagree again film neck fuel&quot;  Note: Each participant can be the beneficiary of only one lock stake. Once the current lock stake expires, another can be made for the participant. Remove stakes​ This command removes an ordinary stake from a pooling round (while it has not been staked in the Elector yet): tonos-cli depool [--addr &lt;depool_address&gt;] stake remove [--wallet &lt;msig_address&gt;] --value &lt;number&gt; [--sign &lt;key_file or seed_phrase&gt;]  Where &lt;depool_address&gt; - address of the DePool contract. &lt;msig_address&gt; - address of the wallet that made the stake. all --value parameters must be defined in evers, like this: --value 10.5, which means the value is 10,5 evers. &lt;key_file or seed_phrase&gt; - either the keyfile for the wallet making the stake, or the seed phrase in quotes. Example: tonos-cli depool --addr 0:37fbcb6e3279cbf5f783d61c213ed20fee16e0b1b94a48372d20a2596b700ace stake remove --wallet 0:1b91c010f35b1f5b42a05ad98eb2df80c302c37df69651e1f5ac9c69b7e90d4e --value 100 --sign &quot;dizzy modify exotic daring gloom rival pipe disagree again film neck fuel&quot;  Transfer stakes​ The following command assigns an existing ordinary stake or its part to another participant wallet. If the entirety of the stake is transferred, the transferring wallet is removed from the list of participants in the DePool. If the receiving wallet isn't listed among the participants, it will become a participant as the result of the command. tonos-cli depool [--addr &lt;depool_address&gt;] stake transfer [--wallet &lt;msig_address&gt;] --value &lt;number&gt; --dest &lt;address&gt; [--sign &lt;key_file or seed_phrase&gt;]  Where &lt;depool_address&gt; - address of the DePool contract. &lt;msig_address&gt; - address of the wallet that made the stake. all --value parameters must be defined in evers, like this: --value 10.5, which means the value is 10,5 evers. dest &lt;address&gt; - address of the new owner of the stake. &lt;key_file or seed_phrase&gt; - either the keyfile for the wallet making the stake, or the seed phrase in quotes. Example: tonos-cli depool --addr 0:37fbcb6e3279cbf5f783d61c213ed20fee16e0b1b94a48372d20a2596b700ace stake transfer --wallet 0:1b91c010f35b1f5b42a05ad98eb2df80c302c37df69651e1f5ac9c69b7e90d4e --value 1000 --dest 0:1b91c010f35b1f5b42a05ad98eb2df80c302c37df69651e1f5ac9c69b7e90d4e --sign &quot;dizzy modify exotic daring gloom rival pipe disagree again film neck fuel&quot;  Note: Stakes cannot be transferred from or to DePool's validator wallet, and between any wallets during round completion step (RoundStep = Completing = 8). Withdraw Stakes​ 1) Withdraw entire stake​ The following command allows to withdraw an ordinary stake to the wallet that owns it, as soon as the stake becomes available. Use withdraw on to receive the stake, once it's unlocked. If you then make another stake, and want to keep reinvesting it every round, run the command with withdraw off. tonos-cli depool [--addr &lt;depool_address&gt;] withdraw on | off [--wallet &lt;msig_address&gt;] [--sign &lt;key_file or seed_phrase&gt;]  Where &lt;depool_address&gt; - address of the DePool contract. &lt;msig_address&gt; - address of the wallet that made the stake. &lt;key_file or seed_phrase&gt; - either the keyfile for the wallet that made the stake, or the seed phrase in quotes. Example: tonos-cli depool --addr 0:37fbcb6e3279cbf5f783d61c213ed20fee16e0b1b94a48372d20a2596b700ace withdraw on --wallet 0:1b91c010f35b1f5b42a05ad98eb2df80c302c37df69651e1f5ac9c69b7e90d4e --sign &quot;dizzy modify exotic daring gloom rival pipe disagree again film neck fuel&quot;  2) Withdraw part of the stake​ The following command allows to withdraw part of an ordinary stake to the wallet that owns it, as soon as the stake becomes available. If, as result of this withdrawal, participant's ordinary stake becomes less than minStake, then participant's whole stake is sent to participant. tonos-cli depool [--addr &lt;depool_address&gt;] stake withdrawPart [--wallet &lt;msig_address&gt;] --value &lt;number&gt; [--sign &lt;key_file or seed_phrase&gt;]  Where &lt;depool_address&gt; - address of the DePool contract. &lt;msig_address&gt; - address of the wallet that made the stake. all --value parameters must be defined in evers, like this: --value 10.5, which means the value is 10,5 evers. &lt;key_file or seed_phrase&gt; - either the keyfile for the wallet that made the stake, or the seed phrase in quotes. Example: tonos-cli depool --addr 0:37fbcb6e3279cbf5f783d61c213ed20fee16e0b1b94a48372d20a2596b700ace stake withdrawPart --wallet 0:1b91c010f35b1f5b42a05ad98eb2df80c302c37df69651e1f5ac9c69b7e90d4e --value 1000 --sign &quot;dizzy modify exotic daring gloom rival pipe disagree again film neck fuel&quot;  Reinvest Stakes​ Ordinary stake reinvestment is controlled by the DePool reinvest flag. By default this flag is set to yes, and the the participant's available ordinary stake will be reinvested every round, no additional action required. It gets set to no when withdrawing the entire stake. After stake withdrawal it remains set to no. To re-enable ordinary stake reinvesting after withdrawing a stake, run the withdraw command with option off: tonos-cli depool [--addr &lt;depool_address&gt;] withdraw off [--wallet &lt;msig_address&gt;] [--sign &lt;key_file or seed_phrase&gt;]  Where &lt;depool_address&gt; - address of the DePool contract. &lt;msig_address&gt; - address of the wallet that made the stake. &lt;key_file or seed_phrase&gt; - either the keyfile for the wallet that made the stake, or the seed phrase in quotes. Example: tonos-cli depool --addr 0:37fbcb6e3279cbf5f783d61c213ed20fee16e0b1b94a48372d20a2596b700ace withdraw off --wallet 0:1b91c010f35b1f5b42a05ad98eb2df80c302c37df69651e1f5ac9c69b7e90d4e --sign &quot;dizzy modify exotic daring gloom rival pipe disagree again film neck fuel&quot;  Note:Withdrawing a part of the stake does not affect the reinvest flag.Lock and vesting stakes are reinvested according to their initial settings for the full duration of the staking period. There is no way to change these settings once lock and vesting stakes are made. "},{"title":"9. Check Donors and Stakes in the DePool​","type":1,"pageTitle":"Getting started","url":"validate/depools/getting-started#9-check--donors-and-stakes-in-the-depool","content":"After the stake is made, you can check its status in the DePool with the getParticipantInfo get-method: tonos-cli run &lt;depool_address&gt; getParticipantInfo '{&quot;addr&quot;:&quot;&lt;msig_address&gt;&quot;}' --abi DePool.abi.json  Where &lt;depool_address&gt; - address of the DePool contract. &lt;msig_address&gt; - address of the wallet that made the stake. Note: if you are expecting a lock or vesting stake, make sure the donor address is specified in your lockDonor or vestingDonor parameters. "},{"title":"10. Set Up Validator Script​","type":1,"pageTitle":"Getting started","url":"validate/depools/getting-started#10-set-up-validator-script","content":"Once the the validator has accumulated a stake sufficient to participate in elections, (at least validatorAssurance), this stake needs to be signed by the node. This should be done through a validator script. The main function that the validator script should regularly perform is to send signed election requests to the DePool, which will forward the accumulated stake to the Elector contract on the validator's behalf. The Election request should be generated with the proxy address for the current round as the requesting validator wallet. When participating in elections through a DePool contract, the validator script handles only the creation and sending of the node election request, as all activities regarding stakes and rewards are handled at the level of the DePool.Note, that the validator wallet should have a small sum of tokens (~20 Evers) available at all times to reliably send election requests to DePool. Each election request costs ~ 1 Ton.Note: Do not forget to confirm the election request transactions sent out by the script with the necessary amount of validator wallet custodians. For C++ node​ Working examples of such a script can be found here: for the main Everscale network, and for the devnet. Important: If you are setting up DePool validator script on top of a C++ node, that was previously functioning under a regular validator script, you should first disable the regular script (validator_msig.sh) and only set up the DePool validator script (validator_depool.sh) for the next elections. Two validator scripts should never run at the same time, as this creates unpredictable behavior. It is recommended to run the script periodically, for example with cron utility. Example: @hourly script --return --quiet --append --command &quot;cd /scripts/ &amp;&amp; ./validator_depool.sh 2&gt;&amp;1&quot; /var/ton-work/validator_depool.log  It is possible to configure the script to monitor the DePool status through the available get-methods, such as getParticipantInfo, getRounds, getDePoolInfo, getParticipants (see get-methods section for details) and through view DePool events command. For Rust Node​ For rustnet, the script is set up automatically during node deployment. Important: If you are switching a rust validator node from direct staking to DePool, make sure to delete the current node build, set the DePool validator variable and rebuild it from scratch. "},{"title":"11. Maintain Positive Balance on DePool and Supplementary Contracts​","type":1,"pageTitle":"Getting started","url":"validate/depools/getting-started#11-maintain-positive-balance-on-depool-and-supplementary-contracts","content":"DePool Balance​ Normally the DePool receives sufficient funds for its operations from validation rewards. They go to DePool's own balance, which is completely separate from the staking pool and the funds on it are never staked. However, a situation where the DePool spends its funds on regular operations, but does not receive enough rewards (for example, fails to participate in the elections or loses them), is possible. DePool balance can be viewed or through getDePoolBalance get-method in TONOS-CLI (requires DePool.abi.json file): tonos-cli run &lt;depool_address&gt; getDePoolBalance {} --abi DePool.abi.json  Additionally, DePool emits the TooLowDePoolBalance event when its balance drops too low to perform state update operations (below CRITICAL_THRESHOLD which equals 10 evers). Replenish the balance to at least 20 evers from any multisignature wallet with the following command: tonos-cli depool [--addr &lt;depool_address&gt;] replenish --value *number* [--wallet &lt;msig_address&gt;] [--sign &lt;key_file or seed_phrase&gt;]  Where &lt;depool_address&gt; - address of the DePool contract. all --value parameters must be defined in evers, like this: --value 150.5, which means the value is 150,5 evers. &lt;msig_address&gt; - address of the wallet that made the stake. &lt;key_file or seed_phrase&gt; - either the keyfile for the wallet, or the seed phrase in quotes. Example: tonos-cli depool --addr 0:37fbcb6e3279cbf5f783d61c213ed20fee16e0b1b94a48372d20a2596b700ace replenish --value 150 --wallet 0:1b91c010f35b1f5b42a05ad98eb2df80c302c37df69651e1f5ac9c69b7e90d4e --sign &quot;dizzy modify exotic daring gloom rival pipe disagree again film neck fuel&quot;  Note: These funds do not go towards any stake. They are transferred to the DePool contract itself and are spent on its operational expenses. Proxy Balance​ The balance of ~ 2 Evers on the proxies should be maintained for the full duration of DePool existence. Generally proxies receive fees for their services automatically, but if they run out of funds for any reason, DePool might miss elections. As the proxies are deployed by the DePool itself, you have to run the getDePoolInfo get-method to find out their addresses: tonos-cli run &lt;depool_address&gt; getDePoolInfo {} --abi DePool.abi.json  The balance of the proxies can be viewed on the ever.live blockchain explorer by searching the proxy addresses, or through TONOS-CLI commands: tonos-cli account &lt;proxy0_address&gt; tonos-cli account &lt;proxy1_address&gt;  If necessary, it can be topped up with a transaction from any multisignature wallet: tonos-cli call &lt;wallet_address&gt; submitTransaction '{&quot;dest&quot;:&quot;&lt;proxy_address&gt;&quot;,&quot;value&quot;:*number*,&quot;bounce&quot;:&quot;true&quot;,&quot;allBalance&quot;:&quot;false&quot;,&quot;payload&quot;:&quot;&quot;}' --abi &lt;MultisigWallet.abi.json&gt; --sign &lt;wallet_seed_or_keyfile&gt;  Where &lt;wallet_address&gt; - is the address of the wallet, from which you are making the transaction &lt;proxy_address&gt; - address of one of the proxies, calculated on step 4. &quot;value&quot;:*number* - the amount of coins to be transferred (in nanotokens). &lt;MultisigWallet.abi.json&gt; - the ABI file of the contract, from which you are making the transaction (for validator wallets - usually SafeMultisigWallet.abi.json) &lt;wallet_seed_or_keyfile&gt; - either the seed phrase in double quotes, or the path to the keyfile for the wallet, from which you are making the transaction Note: If the proxy balance dips too low to operate and it fails to deliver messages between DePool and elector, DePool will emit one of the following events: ProxyHasRejectedTheStake (if proxy cannot pass the stake on to elector) or ProxyHasRejectedRecoverRequest (if proxy cannot retrieve stake from elector). To reestablish operations you need to top up the proxy balance, and then call the DePool ticktock function by any available means. These measures should be taken as soon as possible, however, as DePool risks missing elections if it cannot communicate with elector on time. Withdrawing excess funds​ If proxy accumulates excess funds over time, they can be withdrawn using a transaction from the validator wallet with a specific payload: tonos-cli call &lt;validator_wallet&gt; submitTransaction '{&quot;dest&quot;:&quot;&lt;proxy_address&gt;&quot;,&quot;value&quot;: 500000000,&quot;bounce&quot;: true,&quot;allBalance&quot;: false, &quot;payload&quot;: &quot;te6ccgEBAQEABgAACFBK1Rc=&quot;}' --abi &lt;MultisigWallet.abi.json&gt; --sign &lt;seed_phrase_or_key_file&gt;  &lt;validator_wallet&gt; - address of the validator wallet. &lt;proxy_address&gt; - address of the proxy contract. &lt;MultisigWallet.abi.json&gt; - validator wallet ABI file (usually SafeMultisigWallet.abi.json). &lt;seed_phrase_or_key_file&gt; - either the keyfile for the validator wallet, or the seed phrase in quotes. payload contains the message calling the withdrawExcessTons() function of the proxy contract. value, bounce, allBalance and payload values should not be modified. Change from the 0.5 evers not spent on the transaction will be returned. Proxy will send all excess funds to the validator wallet, reserving only its minimal balance of 2 evers for itself. Example: tonos-cli call 0:303c1aa8110dc5c543687c6bba699add7a7faf2ed55737f494f78d1c51c6b8d4 submitTransaction '{&quot;dest&quot;:&quot;-1:d16999c37c82523d1931011471967ae9e06ee53c1cafcacc8f6d3bee34f15044&quot;,&quot;value&quot;: 500000000,&quot;bounce&quot;: true,&quot;allBalance&quot;: false, &quot;payload&quot;: &quot;te6ccgEBAQEABgAACFBK1Rc=&quot;}' --abi SafeMultisigWallet.abi.json --sign &quot;kick jewel fiber because cushion brush elegant fox bus surround pigeon divide&quot;  DePool Helper Balance​ The balance of ~ 100 Evers on the helper contract should be maintained for the full duration of DePool existence. The balance of the helper can be viewed on the ever.live blockchain explorer by searching the helper address, or through TONOS-CLI command: tonos-cli account &lt;helper_address&gt;  Helper balance should be topped up regularly. Without funds on the Helper contract, DePool will not be able to function regularly. To top up, send a transaction from any multisignature wallet: tonos-cli call &lt;wallet_address&gt; submitTransaction '{&quot;dest&quot;:&quot;&lt;helper_address&gt;&quot;,&quot;value&quot;:*number*,&quot;bounce&quot;:&quot;true&quot;,&quot;allBalance&quot;:&quot;false&quot;,&quot;payload&quot;:&quot;&quot;}' --abi &lt;MultisigWallet.abi.json&gt; --sign &lt;wallet_seed_or_keyfile&gt;  Where &lt;wallet_address&gt; - is the address of the wallet, from which you are making the transaction. &lt;helper_address&gt; - address of the helper, calculated on step 4. &quot;value&quot;:*number* - the amount of coins to be transferred (in nanotokens). &lt;MultisigWallet.abi.json&gt; - the ABI file of the contract, from which you are making the transaction (for validator wallets - usually SafeMultisigWallet.abi.json). &lt;wallet_seed_or_keyfile&gt; - either the seed phrase in double quotes, or the path to the keyfile for the wallet, from which you are making the transaction. Validator Wallet Balance​ Validator wallet will receive a fraction of any DePool round rewards directly, so with a successful DePool setup, it should receive regular income. In general, the validator wallet should have a small sum of tokens (~20 Evers) available at all times to reliably send election requests to DePool. Each election request costs ~ 1 Ton. "},{"title":"12. Check DePool Status in the Elections​","type":1,"pageTitle":"Getting started","url":"validate/depools/getting-started#12-check-depool-status-in-the-elections","content":"Once everything has been configured properly, stakes made, and election request sent by the validator script, you can monitor the operation of the DePool and its validator node through various channels. On ever.live​ Nodes currently participating in an open election are displayed on ever.live in the Next validators section until election end. When the elections end, the newly elected set of validators is posted on ever.live in the Next validators section. When the new validator set becomes active, it is moved to the Current section. At that point you will be able to see new blocks signed by the validator node on its validator page. To find the pages of your validator and DePool, you can search for the validator wallet or for the DePool address on ever.live. All validator-related pages are linked to each other. Using DePool Events​ TONOS-CLI supports DePool event monitoring. To print out all events, or, optionally, all events since a specific time use the following command: tonos-cli depool [--addr &lt;depool_address&gt;] events [--since &lt;utime&gt;]  Where &lt;depool_address&gt; - address of the DePool contract. &lt;utime&gt; - unixtime, since which the events are displayed. If -since is omitted, all DePool events are printed. To wait for a new event use the following command. tonos-cli depool [--addr &lt;depool_address&gt;] events --wait-one  Where &lt;depool_address&gt; - address of the DePool contract. TONOS-CLI waits until new event will be emitted and then prints it to the stdout. Example: tonos-cli depool --addr 0:37fbcb6e3279cbf5f783d61c213ed20fee16e0b1b94a48372d20a2596b700ace events --wait-one  List of possible events: DePoolClosed() - event emitted when DePool is closing.RoundStakeIsAccepted(uint64 queryId, uint32 comment) - event emitted when Elector accepts the stake.RoundStakeIsRejected(uint64 queryId, uint32 comment) - event emitted when Elector rejects the stake.ProxyHasRejectedTheStake(uint64 queryId) - event is emitted if stake is returned by proxy because too low balance of proxy contract.ProxyHasRejectedRecoverRequest(uint64 roundId) - event is emitted if stake cannot be returned from elector because too low balance of proxy contract.RoundCompleted(TruncatedRound round) - event emitted when the round was completed.StakeSigningRequested(uint32 electionId, address proxy) - event emitted when round switches from pooling to election indicating that DePool is waiting for signed election request from validator wallet.TooLowDePoolBalance(uint replenishment) - event emitted when DePool's own balance becomes too low to perform state update operations (below CRITICAL_THRESHOLD which equals 10 evers). replenishment indicates the minimal value required to resume operations. It's recommended to replenish the balance to 20 evers or more if this event occurs.RewardFractionsChanged(uint8 validator, uint8 participants) - event emitted when contract owner changes reward fractions. validator - validator's reward fraction. participants - participants' reward fraction.InternalError(uint16 ec) - emitted whenever an internal error occurs. Contains error code. Events command output example: event ee4f1e53997f7c5cd3a03511f8ed8e5715ead58e9645b4c99f91b56f0a4bd07b RoundStakeIsAccepted 1611665778 (2021-01-26 12:56:18.000) {&quot;queryId&quot;:&quot;1611665701&quot;,&quot;comment&quot;:&quot;0&quot;} event 14ed78bb338cc94b2e1165f71de732d092ff203941e027bfe2b5e20bdc0a90ee StakeSigningRequested 1611665471 (2021-01-26 12:51:11.000) {&quot;electionId&quot;:&quot;1611666134&quot;,&quot;proxy&quot;:&quot;-1:1ef217ee3f9aa5cd2202919c97e1b61caddcb1a80f450d82990a06b918a75d82&quot;} event c884939b93dcf846ab43f1bbc36977fabe57bf376fa3638d95b2e7127ed4f0c2 RoundCompleted 1611665471 (2021-01-26 12:51:11.000) {&quot;round&quot;:{&quot;id&quot;:&quot;159&quot;,&quot;supposedElectedAt&quot;:&quot;1611664334&quot;,&quot;unfreeze&quot;:&quot;0&quot;,&quot;stakeHeldFor&quot;:&quot;900&quot;,&quot;vsetHashInElectionPhase&quot;:&quot;0xc09caf4efff6cabff6185754d2150bc11d94098f97ea146a617e9d0d90cecc76&quot;,&quot;step&quot;:&quot;8&quot;,&quot;completionReason&quot;:&quot;3&quot;,&quot;stake&quot;:&quot;2525331200749&quot;,&quot;recoveredStake&quot;:&quot;0&quot;,&quot;unused&quot;:&quot;0&quot;,&quot;isValidatorStakeCompleted&quot;:false,&quot;rewards&quot;:&quot;0&quot;,&quot;participantQty&quot;:&quot;1&quot;,&quot;validatorStake&quot;:&quot;2525331200749&quot;,&quot;validatorRemainingStake&quot;:&quot;0&quot;,&quot;handledStakesAndRewards&quot;:&quot;0&quot;}}  Using get-methods​ DePool contract supports a number of get-methods, which can be used to monitor its status and the status of participants and stakes in the pool. getParticipantInfo(address addr)​ Returns information about a specific participant in all investment rounds. tonos-cli run &lt;depool_address&gt; getParticipantInfo '{&quot;addr&quot;:&quot;&lt;msig_address&gt;&quot;}' --abi DePool.abi.json  Where &lt;depool_address&gt; - address of the DePool contract. &lt;msig_address&gt; - address of the wallet that made the stake. Output example: Result: { &quot;total&quot;: &quot;107043197878158&quot;, &quot;withdrawValue&quot;: &quot;0&quot;, &quot;reinvest&quot;: true, &quot;reward&quot;: &quot;5837197878158&quot;, &quot;stakes&quot;: { &quot;160&quot;: &quot;104517866677409&quot;, &quot;161&quot;: &quot;2525331200749&quot; }, &quot;vestings&quot;: {}, &quot;locks&quot;: { &quot;160&quot;: { &quot;lastWithdrawalTime&quot;: &quot;1604655095&quot;, &quot;owner&quot;: &quot;0:6cde10682ab1f72f267ce4a47a439db6473be65ba87dc846556fbabdba8bfb78&quot;, &quot;remainingAmount&quot;: &quot;100000500000000&quot;, &quot;withdrawalPeriod&quot;: &quot;1728000&quot;, &quot;withdrawalValue&quot;: &quot;100000500000000&quot; }, &quot;161&quot;: { &quot;lastWithdrawalTime&quot;: &quot;1604655095&quot;, &quot;owner&quot;: &quot;0:6cde10682ab1f72f267ce4a47a439db6473be65ba87dc846556fbabdba8bfb78&quot;, &quot;remainingAmount&quot;: &quot;100000500000000&quot;, &quot;withdrawalPeriod&quot;: &quot;1728000&quot;, &quot;withdrawalValue&quot;: &quot;100000500000000&quot; }, &quot;vestingDonor&quot;: &quot;0:6cde10682ab1f72f267ce4a47a439db6473be65ba87dc846556fbabdba8bfb78&quot;, &quot;lockDonor&quot;: &quot;0:6cde10682ab1f72f267ce4a47a439db6473be65ba87dc846556fbabdba8bfb78&quot; }  The participant parameters displayed by the get-method are the following:total: participant's total stake (in nanoevers).withdrawValue: the value to be withdrawn when the funds become available.reinvest: whether the ordinary stake of the participant should be continuously reinvested.reward: The total rewards earned by participant in the current DePool (in nanoevers).stakes: the ordinary stakes in the current active rounds (in nanoevers).locks and vestings: participant's lock and vesting stake, each split into two neighboring rounds. There can be only one of each, split equally into two entries. The parameters of the lock and vesting stakes are: lastWithdrawalTime: last time a withdrawal period ended and a part of the stake was unlocked (in unixtime). owner: the address that made the lock or vesting stake on behalf of the participant. remainingAmount: the current amount staked in this round (in nanoevers).withdrawalPeriod: the period in seconds, after which the next part of the stake gets unlocked. withdrawalValue: the value that is unlocked every withdrawal period (in nanoevers).lockDonor and vestingDonor are the addresses set by the participant to be their lock and vesting donors, respectively. getDePoolInfo()​ Returns DePool configuration parameters and constants (supplementary contract addresses, minimal stake settings and fees for various actions). tonos-cli run &lt;depool_address&gt; getDePoolInfo {} --abi DePool.abi.json  Where&lt;depool_address&gt; - address of the DePool contract. Output example: Result: { &quot;poolClosed&quot;: false, &quot;minStake&quot;: &quot;10000000000&quot;, &quot;validatorAssurance&quot;: &quot;100000000000000&quot;, &quot;participantRewardFraction&quot;: &quot;50&quot;, &quot;validatorRewardFraction&quot;: &quot;50&quot;, &quot;balanceThreshold&quot;: &quot;15858929993&quot;, &quot;validatorWallet&quot;: &quot;0:303c1aa8110dc5c543687c6bba699add7a7faf2ed55737f494f78d1c51c6b8d4&quot;, &quot;proxies&quot;: [ &quot;-1:1ef217ee3f9aa5cd2202919c97e1b61caddcb1a80f450d82990a06b918a75d82&quot;, &quot;-1:d16999c37c82523d1931011471967ae9e06ee53c1cafcacc8f6d3bee34f15044&quot; ], &quot;stakeFee&quot;: &quot;500000000&quot;, &quot;retOrReinvFee&quot;: &quot;40000000&quot;, &quot;proxyFee&quot;: &quot;90000000&quot; }  The round parameters displayed by the get-method are the following:poolClosed: whether DePool was closed.minStake: the minimal stake the DePool accepts from participants (in nanoevers). Set during deployment.validatorAssurance: required validator stake (in nanoevers). Also set during deployment.participantRewardFraction: percentage of the reward that goes to all participants. Also set during deployment.validatorRewardFraction: the fraction of the total reward that goes directly to validator. Equals 100% - participantRewardFraction.validatorWallet: the address of the validator wallet. Also set during deployment.proxies: the two proxies on the masterchain that DePool uses to communicate with elector. They are deployed by the DePool itself.stakeFee: fee for staking operations (in nanoevers).retOrReinvFee: the fee deducted from every participant's stake and rewards during reward distribution at the end of the round (in nanoevers).proxyFee: the fee that proxies take for any messages passed through them (in nanoevers). getRounds()​ Returns information about all rounds (step, total stake, stakeholder count, round id). tonos-cli run &lt;depool_address&gt; getRounds {} --abi DePool.abi.json  Where&lt;depool_address&gt; - address of the DePool contract. Output example: Result: { &quot;rounds&quot;: { &quot;159&quot;: { &quot;id&quot;: &quot;159&quot;, &quot;supposedElectedAt&quot;: &quot;1611664334&quot;, &quot;unfreeze&quot;: &quot;0&quot;, &quot;stakeHeldFor&quot;: &quot;900&quot;, &quot;vsetHashInElectionPhase&quot;: &quot;0xc09caf4efff6cabff6185754d2150bc11d94098f97ea146a617e9d0d90cecc76&quot;, &quot;step&quot;: &quot;9&quot;, &quot;completionReason&quot;: &quot;3&quot;, &quot;stake&quot;: &quot;2525331200749&quot;, &quot;recoveredStake&quot;: &quot;0&quot;, &quot;unused&quot;: &quot;0&quot;, &quot;isValidatorStakeCompleted&quot;: true, &quot;rewards&quot;: &quot;0&quot;, &quot;participantQty&quot;: &quot;0&quot;, &quot;validatorStake&quot;: &quot;2525331200749&quot;, &quot;validatorRemainingStake&quot;: &quot;0&quot;, &quot;handledStakesAndRewards&quot;: &quot;2525331200749&quot; }, &quot;161&quot;: { &quot;id&quot;: &quot;161&quot;, &quot;supposedElectedAt&quot;: &quot;0&quot;, &quot;unfreeze&quot;: &quot;4294967295&quot;, &quot;stakeHeldFor&quot;: &quot;0&quot;, &quot;vsetHashInElectionPhase&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;step&quot;: &quot;1&quot;, &quot;completionReason&quot;: &quot;0&quot;, &quot;stake&quot;: &quot;2525331200749&quot;, &quot;recoveredStake&quot;: &quot;0&quot;, &quot;unused&quot;: &quot;0&quot;, &quot;isValidatorStakeCompleted&quot;: false, &quot;rewards&quot;: &quot;0&quot;, &quot;participantQty&quot;: &quot;1&quot;, &quot;validatorStake&quot;: &quot;0&quot;, &quot;validatorRemainingStake&quot;: &quot;0&quot;, &quot;handledStakesAndRewards&quot;: &quot;0&quot; }, &quot;160&quot;: { &quot;id&quot;: &quot;160&quot;, &quot;supposedElectedAt&quot;: &quot;1611666134&quot;, &quot;unfreeze&quot;: &quot;4294967295&quot;, &quot;stakeHeldFor&quot;: &quot;900&quot;, &quot;vsetHashInElectionPhase&quot;: &quot;0x7965b01da2b778404bd5b9e6dc5a5f6d1e4ce15a78284ebec78ed86a8852d5f9&quot;, &quot;step&quot;: &quot;6&quot;, &quot;completionReason&quot;: &quot;0&quot;, &quot;stake&quot;: &quot;205352016359392&quot;, &quot;recoveredStake&quot;: &quot;0&quot;, &quot;unused&quot;: &quot;0&quot;, &quot;isValidatorStakeCompleted&quot;: false, &quot;rewards&quot;: &quot;0&quot;, &quot;participantQty&quot;: &quot;2&quot;, &quot;validatorStake&quot;: &quot;104517866677409&quot;, &quot;validatorRemainingStake&quot;: &quot;0&quot;, &quot;handledStakesAndRewards&quot;: &quot;0&quot; }, &quot;162&quot;: { &quot;id&quot;: &quot;162&quot;, &quot;supposedElectedAt&quot;: &quot;0&quot;, &quot;unfreeze&quot;: &quot;4294967295&quot;, &quot;stakeHeldFor&quot;: &quot;0&quot;, &quot;vsetHashInElectionPhase&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;step&quot;: &quot;0&quot;, &quot;completionReason&quot;: &quot;0&quot;, &quot;stake&quot;: &quot;0&quot;, &quot;recoveredStake&quot;: &quot;0&quot;, &quot;unused&quot;: &quot;0&quot;, &quot;isValidatorStakeCompleted&quot;: false, &quot;rewards&quot;: &quot;0&quot;, &quot;participantQty&quot;: &quot;0&quot;, &quot;validatorStake&quot;: &quot;0&quot;, &quot;validatorRemainingStake&quot;: &quot;0&quot;, &quot;handledStakesAndRewards&quot;: &quot;0&quot; } }  id: round ID. It's also displayed above each round. At DePool deployment, the first four rounds are created: 0, 1, 2 and 3. Whenever one round completes and is removed from the DePool, a new one is created, its ID incremented by 1: when 0 is removed, 4 is created, etc.supposedElectedAt: the time the validator is scheduled to start validating, if elected (in unixtime). This value remains 0, until validator elections start and DePool enters waitingValidatorRequest step of the round. Then it is set to the time the election winners will start validating.unfreeze: the time the stake will be unfrozen by elector (in unixtime). This value remains 4294967295 until validation ends.stakeHeldFor: the period in seconds for which stake will remain frozen in elector after validation. It's set by the global configuration parameter p15 when validation completes.vsetHashInElectionPhase: this is a system variable that holds the hash of validation set (global config parameter 34) when round was in election phase. Is set during election.step: step the round is currently at. The possible steps are: 0 - PrePooling: step reserved for receiving half of vesting/lock stake from participants. Nothing else happens when round is in this step.1 - Pooling: DePool receives stakes from participants. Half of vesting/lock stakes are invested into the round in the pooling step, the other into the round in the PrePooling step. This way, the other half of these stakes is always invested into the very next round.2 - WaitingValidatorRequest: waiting for election request from validator. The elections have begun, it's no longer possible to invest stakes into this round. Once election request from validator is received, DePool can participate in elections.3 - WaitingIfStakeAccepted: stake has been sent to elector. Waiting for answer from elector.4 - WaitingValidationStart: elector has accepted round stake. Validator is candidate. Waiting for validation to start, to know if validator won elections.5 - WaitingIfValidatorWinElections: DePool has tried to recover stake in validation period to know if validator won elections. Waiting for elector answer.6 - WaitingUnfreeze: DePool received elector answer and waits for the end of unfreeze period. If at this step CompletionReason!=0, then validator did not win and DePool is waiting to return/reinvest funds after the next round. Else validator won elections.7 - WaitingReward: Unfreeze period has been ended. Request to recover stake has been sent to elector. Waiting for answer from elector.8 - Completing: Returning or reinvesting participant stakes because round is completed.9 - Completed: All stakes of the round have been returned or reinvested. At the next round rotation the round will be deleted from the DePool.completionReason: the code for the reason the round was completed. Remains &quot;0&quot;, until round actually is completed. The possible reasons are:0 - Round is not completed yet.1 - Pool was closed by owner.2 - The round was one of the first two rounds after deployment: 0 or 1. These first rounds are empty and are used only to launch the round rotation mechanism. They complete with this code without performing any additional actions.3 - Validator stake is less than validatorAssurance.4 - Stake is rejected by elector for some reason.5 - Round is completed successfully. DePool won elections, its node performed validation and it received the reward from elector.6 - DePool has participated in elections but lost the elections.7 - Validator is blamed during investigation phase.8 - Validator sent no request during election phase.stake: the total stake in the current round, that is sent to elector (in nanoevers).recoveredStake: the total stake returned by elector (in nanoevers).unused: if the stake was cut off by the elector (this can happen if there is a significant number of election candidates with much smaller stakes), this value equals the amount cut off (in nanoevers). This amount is not lost to participants - it simply isn't staked in this round and the rewards for the round will be proportionally smaller. If DePool did not receive a ticktock call during the validation period, this value will remain 0, even if some funds were cut off.isValidatorStakeCompleted: indicates whether validator's stake has been processed during Completing round step. Whenever participants receive rewards, validator's stake should be processed first, as any losses the total stake sustains due to poor node rerformance are first deducted from validator's share of the pool.rewards: the total rewards that are distributed among all participants in the current round (in nanoevers). Is calculated when the stake is returned from elector.participantQty: the quantity of participants in the round.validatorStake: this value equals the final validator stake in the current round. It is set at the and of the Pooling step.validatorRemainingStake: this value is used if validator got punished by elector for poor node performance and part of the DePool stake is lost. Then this value equals the remaining validator stake, if any (in nanoevers).handledStakesAndRewards: the total quantity of stakes and rewards that were processed by the DePool during Completing step (in nanoevers). getParticipants()​ Returns list of all participants. tonos-cli run &lt;depool_address&gt; getParticipants {} --abi DePool.abi.json  Where&lt;depool_address&gt; - address of the DePool contract. Output example: Result: { &quot;participants&quot;: [ &quot;0:9fa316f41fe4e991865b80006c9d9916b2637146e9a6f346eeb25c035206c5b7&quot;, &quot;0:a08bb1f6c64939bcbd3d950a44d88820f0102c550bfaf49f70f2d012eeec333a&quot;, &quot;-1:68384476fce1d2649484912c08541a8037c36b606aca0f8cc04c043640e8dd98&quot; ] }  getDePoolBalance()​ Returns DePool's own balance in nanotokens (without stakes). tonos-cli run &lt;depool_address&gt; getDePoolBalance {} --abi DePool.abi.json  Where&lt;depool_address&gt; - address of the DePool contract. "},{"title":"13. (Optional) Adjust validator and participant reward fraction​","type":1,"pageTitle":"Getting started","url":"validate/depools/getting-started#13-optional-adjust-validator-and-participant-reward-fraction","content":"If you want to make your DePool more attractive to potential participants, you may increase the fraction of the total reward they receive. DePool deployment keys are required for this action. Use the following command: tonos-cli call &lt;depool_address&gt; setValidatorRewardFraction '{&quot;fraction&quot;:&lt;fraction_value&gt;}' --abi DePool.abi.json --sign &lt;depool_keyfile_or_seed_phrase&gt;  Where&lt;depool_address&gt; - address of the DePool.&lt;fraction_value&gt; - new value of Validators reward fraction, which should be less than previous and should not be equal to 0.&lt;depool_keyfile_or_seed_phrase&gt; - DePool deployment keyfile or its corresponding seed phrase. Example: tonos-cli call 0:53acdc8033cc0794125038a810d4b64e24e72add52ee866b82ade42d12cd9f02 setValidatorRewardFraction '{&quot;fraction&quot;:29}' --abi DePool.abi.json --sign depool.keys.json  Current validator reward fraction value can be viewed with the getDePoolInfo get-method. "},{"title":"14. (Optional) Close DePool​","type":1,"pageTitle":"Getting started","url":"validate/depools/getting-started#14-optional-close-depool","content":"The deployer of the DePool can close the DePool at any time. DePool deployment keys are required for this action: tonos-cli call &lt;depool_address&gt; terminator {} --abi DePool.abi.json --sign &lt;depool_keyfile_or_seed_phrase&gt;  Where&lt;depool_address&gt; - address of the DePool.&lt;depool_keyfile_or_seed_phrase&gt; - DePool deployment keyfile or its corresponding seed phrase. Example: tonos-cli call 0:37fbcb6e3279cbf5f783d61c213ed20fee16e0b1b94a48372d20a2596b700ace terminator {} --abi DePool.abi.json --sign depool.json  When a DePool is closed, all the stakes invested in it are returned to their owners, as soon as they become available. dePoolClosed event is emitted. The closed DePool cannot be reactivated again. To return all stakes currently locked in rounds to their owners, make sure DePool's state update function is called once the current and the next validation cycles complete. "},{"title":"Rewards Distribution​","type":1,"pageTitle":"Getting started","url":"validate/depools/getting-started#rewards-distribution","content":"Every time DePool receives rewards for validation, DePool replenishes it's own balance and the rest is distributed according to the following rules: 1) validatorRewardFraction% of the reward, regardless of the validator’s share in the pool, goes directly to the validator wallet. This is the reward for maintaining the node and is intended to be used on operational expenses. 2) participantRewardFraction% of the reward is distributed among all participants (including the validator) proportionally to their share of the staking pool. By default these rewards are added to the ordinary stakes of all participants and reinvested with it. To withdraw this stake or any part of it to the participant wallet, use one of the withdrawal functions. "},{"title":"Troubleshooting​","type":1,"pageTitle":"Getting started","url":"validate/depools/getting-started#troubleshooting","content":""},{"title":"1. Wrong contract version​","type":1,"pageTitle":"Getting started","url":"validate/depools/getting-started#1-wrong-contract-version","content":"Issue: Wrong/outdated version of any contracts involved in DePool operations may cause various issues and hard-to-diagnose behavior. To check contract versions, search for the addresses of DePool, DePool Helper and both proxies on ever.live and review Code hash (may be hidden under More details). Click on the value to copy it to clipboard. It should match the following values: DePool:14e20e304f53e6da152eb95fffc993dbd28245a775d847eed043f7c78a503885Proxies:c05938cde3cee21141caacc9e88d3b8f2a4a4bc3968cb3d455d83cd0498d4375DePool Helper:f990434c02c2b532087782a2d615292c7c241ece4a9af33f8d090c535296401dIf only the Helper contract has wrong Code hash, deploying and configuring only a new Helper is enough. If DePool or proxies have wrong Code hash, all contracts have to be redeployed, and the node reconfigured to work with the new DePool. Note: For RustCup, contract code hash is different. Initially the following contracts were used: 891d1afd26d99ee4f9def21fbd4bccffe25143e79729669573c7d792a646f4e9 for DePool d938d7c19af7ba65342e6fc2f4c6827b7e16ce378722ce134bb461f9d62f6c76 for proxy After the August 5 update the code hashes are as follows: cef9fe9fed144e25e24aa671da1118244dfb2d1e316e9961522cd9b015bbba59 for DePool b633f0b5bc420abd8cb74b03eb0960df2a91c6c123d5cb18ed7283bb26e491bd for proxy "},{"title":"2. DePool isn't emitting events​","type":1,"pageTitle":"Getting started","url":"validate/depools/getting-started#2-depool-isnt-emitting-events","content":"Issue: DePool seems to be set up correctly, but is not emitting expected events, for example stakeSigningRequested. This can be caused by issues with the state update method.Possible solutions: Change the global timer and/or the timer call period (termporarily unavailable): tonos-cli call &lt;HelperAddress&gt; initTimer '{&quot;timer&quot;:&quot;TimerAddress&quot;,&quot;period&quot;:*number*}' --abi DePoolHelper.abi.json --sign helper.json Where&lt;HelperAddress&gt; – is the address of the Helper contract from step 4.2&lt;TimerAddress&gt; - is the address of the global timer contract.&quot;period&quot;:*number* - is the period for regular DePool contract calls via ticktock messages (in seconds).Set up external ticktock function call through TONOS-CLI: tonos-cli call &lt;HelperAddress&gt; sendTicktock {} --abi DePoolHelper.abi.json --sign helper.json Where&lt;HelperAddress&gt; – is the address of the Helper contract from step 4.2. If necessary, run it regularly, e.g. with cron: @hourly cd &lt;tonos-cli-dir&gt; &amp;&amp; tonos-cli call &lt;HelperAddress&gt; sendTicktock {} --abi DePoolHelper.abi.json --sign helper.json Where&lt;tonos-cli-dir&gt; - directory with TONOS-CLI configuration file, DePoolHelper.abi.json file and helper.json keyfile containing DePool Helper keys.&lt;HelperAddress&gt; – is the address of the Helper contract from step 4.2.Call DePool's ticktock function through multisig instead of Helper: tonos-cli depool [--addr &lt;depool_address&gt;] ticktock [-w &lt;msig_address&gt;] [-s &lt;path_to_keys_or_seed_phrase&gt;] Where--addr &lt;depool_address&gt; - the address of the DePool-w &lt;msig_address&gt; - the address of the multisig wallet used to call DePool-s &lt;path_to_keys_or_seed_phrase&gt; - either the keyfile for the wallet making the stake, or the seed phrase in quotes All these options can be skipped, if they were previously specified in the TONOS-CLI configuration file. 1 token is always attached to this call, change is returned to sender. "},{"title":"3. Validator script and election request issues​","type":1,"pageTitle":"Getting started","url":"validate/depools/getting-started#3-validator-script-and-election-request-issues","content":"Issue: DePool isn't receiving election request from validator script and/or isn't passing it on to the Elector. This can be caused by DePool setup errors, low balance on some of the contracts involved, or issues with the script or node setup.Possible solutions and diagnostic methods: If the DePool fails to accumulate a suitable stake, or malfunctions in any other manner, the election request will not pass through to the Elector. Always make sure that the full DePool setup procedure described in this document is completed, and that DePool contract itself operates correctly, i.e. enters waiting request step and emits stakeSigningRequested event, when encountering problems with election participation.Check balance of all contracts and top up if any of them have run out of funds (see section 11 for details). For C++ Node​ Check that the DePool address is specified in the in the ~/ton-keys/depool.addr file in your validator node files and matches your current DePool address.Check that the validator wallet address is specified in the ~/ton-keys/$(hostname -s).addr file according to the node setup procedure.Check that the validator wallet keys are saved to the ~/ton-keys/msig.keys.json file according to the node setup procedure.Check validator script output log (/var/ton-work/validator_depool.log file if script is set up according to the given example). They may help identify the cause of the issue.Rerun the command to send election request manually. It can be found in the validator script output log (/var/ton-work/validator_depool.log file if set up according to the given example) and used as is. Example: tonos-cli call -1:fd05bd9be4e2d3ee7789d1fbc5811e0bd85cf1d14968028fd46a9e1c7b1066cc submitTransaction '{&quot;dest&quot;:&quot;0:10fdf438953430949ca33147f792b9fd9002e7979e50c94547c771c51fb643b9&quot;,&quot;value&quot;:&quot;1000000000&quot;,&quot;bounce&quot;:true,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;te6cckEBAgEAmQABqE5zdEsAAAAAXz7BoZOzdxrAyZXWwptpyrV5ZV1EkLrRdSsfm0KFiFpOuB4XXz7FVAADAACIUt3MiEtCLfPfKEWoVz2sTA9yS/Sl8N88ZkQ8CB1c3QEAgNnX/KhAEKVKe/MO4ArCIMLXM1kgYu34Ujp9dSq2lkSo8vfj0s+yySs6Ac2ufavtXO4DLZ1afugAVwUjvKvI3Agoizgf&quot;}' --abi /validation/configs/SafeMultisigWallet.abi.json --sign /keys/msig.keys.json Run validator script with verbose logs to get more diagnostic information: bash -x ./validator_depool.sh  For Rust Node​ Check that the DePool address is specified in the in the /ton-node/configs/depool.addr file in your validator node files and matches your current DePool address.Check that the validator wallet address is specified in the /ton-node/configs/${VALIDATOR_NAME}.addr fileCheck that the validator wallet keys are saved to the /ton-node/configs/keys/msig.keys.json fileRefer to this document for Rust node troubleshooting. "},{"title":"4. DePool function terminates with error in TONOS-CLI​","type":1,"pageTitle":"Getting started","url":"validate/depools/getting-started#4-depool-function-terminates-with-error-in-tonos-cli","content":"In TONOS-CLI output it looks like this: message: Contract execution was terminated with error message_processing_state: null data: { &quot;account_address&quot;: &quot;0:3187b4d738d69776948ca8543cb7d250c042d7aad1e0aa244d247531590b9147&quot;, &quot;config_server&quot;: &quot;net.ton.dev&quot;, &quot;exit_code&quot;: 140, &quot;function_name&quot;: &quot;constructor&quot;, &quot;original_error&quot;: { &quot;code&quot;: 1006, &quot;core_version&quot;: &quot;0.27.0&quot;, &quot;data&quot;: { &quot;block_id&quot;: &quot;20c8932bc6c7baa90c2d099595b432607355b79d95293061dc6feec392675975&quot;, &quot;block_time&quot;: &quot;Thu, 19 Nov 2020 13:24:37 +0300 (1605781477)&quot;, &quot;expiration_time&quot;: &quot;Thu, 19 Nov 2020 13:24:35 +0300 (1605781475)&quot;, &quot;message_id&quot;: &quot;eae70ebcf84fd9ebcffc544908ca637d9a46a8bdffdab24db6749d003608969e&quot;, &quot;sending_time&quot;: &quot;Thu, 19 Nov 2020 13:23:35 +0300 (1605781415)&quot; }, &quot;message&quot;: &quot;Message was not delivered within the specified timeout&quot;, &quot;message_processing_state&quot;: null, &quot;source&quot;: &quot;node&quot; },  The error code is indicated in the &quot;exit_code&quot; line. Possible error codes and their meanings:101 - message sender is not owner (message public key is wrong). Please check your key file or seed phrase.108 - function cannot be called by external message.113 - message sender is not validator wallet.114 - DePool is closed.116 - participant with such address does not exist.129 - incorrectly defined stake parameters during DePool deployment (minStake &lt; 1 token or minStake &gt; validatorAssurance). Please check your parameters in deploy message.130 - DePool deployment isn't signed with public key. Please check your key file or seed phrase.133 - validator address passed to constructor is not of add_std type. Please check your parameters in deploy message.138 - Incorrect participant reward fraction during DePool deployment (participantRewardFraction ≤ 0 or ≥ 100). Please check your parameters in deploy message.141 - incorrectly specified proxy code during DePool deployment. Please check your parameters in deploy message.142 - DePool is being deployed to the wrong shardchain (workchain id ≠ 0). Please check your parameters in deploy message.143 - new validator reward fraction is greater than old.144 - new validator reward fraction is zero.146 - insufficient DePool balance.147 - validator wallet address is zero.149 - incorrectly specified minimal stake and validator assurance. Incorrect DePool function call by another contract:107 - message sender is not proxy contract.120 - message sender is not DePool (this is not a self call).125 - invalid confirmation from elector (invalid round step).126 - invalid confirmation from elector (invalid query ID).127 - invalid confirmation from elector (sender is not elector).148 - message sender is not one of the proxies. "},{"title":"Run Testnet Node","type":0,"sectionRef":"#","url":"validate/run-validator/run-testnet-node","content":"","keywords":""},{"title":"Getting Started​","type":1,"pageTitle":"Run Testnet Node","url":"validate/run-validator/run-testnet-node#getting-started","content":"SSD/NVMe disks are obligatory. 1. System Requirements​ 2. Prerequisites​ 2.1 Set the Environment​ Adjust (if needed) net.ton.dev/scripts/env.sh: Set export DEPOOL_ENABLE=yes in env.sh for a depool validator (an elector request is sent to a depool from a validator multisignature wallet). Set export DEPOOL_ENABLE=no in env.sh for a direct staking validator (an elector request is sent from a multisignature wallet directly to the elector). cd net.ton.dev/scripts/ . ./env.sh  Note: Make sure to run the script as . ./env.sh, not ./env.sh 2.2 Install Dependencies​ install_deps.sh script supports Ubuntu OS only. ./install_deps.sh  Install and configure Docker according to the official documentation. Note: Make sure to add your user to the docker group, or run subsequent command as superuser: sudo usermod -a -G docker $USER  3. Deploy RUST Validator Node​ Do this step when the network is launched. Deploy the node: ./deploy.sh 2&gt;&amp;1 | tee ./deploy.log  Note: the log generated by this command will be located in the net.ton.dev/scripts/ folder and can be useful for troubleshooting. Wait until the node is synced. Depending on network throughput this step may take significant time (up to several hours). 4. Check Node synchronization​ Use the following command to check if the node is synced: docker exec -it rnode /ton-node/tools/console -C /ton-node/configs/console.json --cmd getstats  Script output example: tonlabs console 0.1.254 COMMIT_ID: BUILD_DATE: 2021-12-24 10:53:20 +0300 COMMIT_DATE: GIT_BRANCH: { &quot;sync_status&quot;: &quot;synchronization finished&quot;, &quot;masterchainblocktime&quot;: 1640343840, &quot;masterchainblocknumber&quot;: 13393489, &quot;timediff&quot;: 4, &quot;in_current_vset_p34&quot;: true, &quot;in_next_vset_p36&quot;: false, &quot;last_applied_masterchain_block_id&quot;: {&quot;shard&quot;:&quot;-1:8000000000000000&quot;,&quot;seq_no&quot;:13393489,&quot;rh&quot;:&quot;e74d505222bbe64617bbd42939cf01334b035990ae4b4e285e67ecbb1b537dd3&quot;,&quot;fh&quot;:&quot;fc0be7c22310389400a7bdbd000b3737b317ce44d92e9a5ed72086c4fa404afa&quot;}, &quot;processed_workchain&quot;: 0, &quot;validation_stats&quot;: { &quot;-1:8000000000000000&quot;: &quot;1 sec ago&quot;, &quot;0:e800000000000000&quot;: &quot;1 sec ago&quot; }, &quot;collation_stats&quot;: { &quot;-1:8000000000000000&quot;: &quot;never&quot;, &quot;0:e800000000000000&quot;: &quot;6 sec ago&quot; }, &quot;tps_10&quot;: 2, &quot;tps_300&quot;: 1 }  If the timediff parameter is less than 10 seconds, synchronization with masterchain is complete.&quot;sync_status&quot;: &quot;synchronization finished&quot; means synchronization with workchains is complete Note: The sync process may not start for up to one hour after node deployment, during which this command may result in error messages. If errors persist for more than an hour after deployment, review deployment log for errors and check the network status. 5. Configure validator multisignature wallet​ There is a small difference between direct staking and DePool validators on this step: For direct staking validator it is necessary to create and deploy a validator SafeMultisig wallet in -1 chain.For a DePool validator it is necessary to create and deploy a validator SafeMultisig wallet in 0 chain. You can use TONOS-CLI for this purpose. It should be configured to connect to the net.ton.dev network. Refer to this document for the detailed wallet creation procedure, or follow the links in the short guide below: All wallet custodians should create seed phrases and public keys for themselves. At least three custodians are recommended for validator wallet, one of which will be used by the validator node. All seed phrases should be kept secret by their owners and securely backed up.The wallet deployer (who may or may not be one of the custodians) should gather the public keys from all custodians.The wallet deployer should obtain SafeMultisig contract code from the repository.The wallet deployer should generate deployment keys.The wallet deployer should generate validator wallet address: in -1 chain for direct staking validator or in 0 chain for a DePool validator.Any user should send at least 1 token to the generated wallet address to create it in the blockchain.The wallet deployer should deploy the wallet contact to the blockchain and set all gathered public keys as its custodians. At this step the number of custodian signatures required to make transactions from the wallet is also set (&gt;=2 recommended for validator wallets). Deploy to -1 chain for direct staking validator or to 0 chain for a DePool validator.In case of direct staking, the funds for staking should be transferred to the newly created validator wallet. Once the wallet is deployed, place 2 files on the validator node: /ton-node/configs/${VALIDATOR_NAME}.addr should contain validator multisignature wallet address in form X:XXX...XXX (the folder on the host is net.ton.dev/docker-compose/ton-node/configs) /ton-node/configs/keys/msig.keys.json should contain validator multisignature custodian's keypair (the folder on the host is net.ton.dev/docker-compose/ton-node/configs/keys/) The node will use the wallet address and the keys provided to it to generate election requests each validation cycle. Note: If the validator wallet requires more than 1 custodian signature to make transactions, make sure each transaction sent by the validator node is confirmed by the required amount of custodians. 6. Configure DePool​ For a DePool validator it is necessary to deploy a DePool contract to workchain 0. You can use TONOS-CLI for this purpose. It should be configured to connect to the net.ton.dev network. Refer to this document for the detailed DePool creation procedure, or follow the links in the short guide below: Obtain contract code from the repository.Generate deployment keys.Calculate contract addresses.Send tokens to the calculated addresses.Deploy contracts. Make sure to specify your validator wallet in the DePool contract at this step.Configure DePool state update method. Once DePool is successfully deployed and configured to be regularly called to update its state, you can make stakes in it. Note that validator stakes must always exceed validator assurance, otherwise DePool will not participate in elections. Also note, that DePool and supporting contracts balance should be monitored and kept positive at all times. Once the validator wallet and the DePool are deployed, place 3 files on the validator node: /ton-node/configs/${VALIDATOR_NAME}.addr should contain validator multisignature wallet address in form 0:XXX...XXX (the folder on the host is net.ton.dev/docker-compose/ton-node/configs)/ton-node/configs/keys/msig.keys.json should contain validator multisignature custodian's keypair (the folder on the host is net.ton.dev/docker-compose/ton-node/configs/keys/)/ton-node/configs/depool.addr should contain DePool address in form 0:XXX...XXX (the folder on the host is net.ton.dev/docker-compose/ton-node/configs) The script generating validator election requests (directly through multisig wallet, or through DePool, depending on the setting selected on step 2.1) will run regularly, once the necessary addresses and keys are provided. 7. Upgrade RUST Validator Node​ Note: You may need to renew your copy of net.ton.dev scripts but do not remove any working files from the previous deployment (for example, configs folder). Adjust (specify new commit ID) net.ton.dev/scripts/env.sh: export TON_NODE_GITHUB_REPO=&quot;https://github.com/tonlabs/ton-labs-node.git&quot; export TON_NODE_GITHUB_COMMIT_ID=&quot;master&quot; export TON_NODE_TOOLS_GITHUB_REPO=&quot;https://github.com/tonlabs/ton-labs-node-tools.git&quot; export TON_NODE_TOOLS_GITHUB_COMMIT_ID=&quot;master&quot; export TONOS_CLI_GITHUB_REPO=&quot;https://github.com/tonlabs/tonos-cli.git&quot; export TONOS_CLI_GITHUB_COMMIT_ID=&quot;master&quot;  Upgrade the node: ./upgrade.sh 2&gt;&amp;1 | tee ./upgrade.log  Note: the log generated by this command will be located in the net.ton.dev/scripts/ folder and can be useful for troubleshooting. Wait until the node is synced. "},{"title":"Stopping, restarting the RUST Node​","type":1,"pageTitle":"Run Testnet Node","url":"validate/run-validator/run-testnet-node#stopping-restarting-the-rust-node","content":"Note: call docker-compose commands from the net.ton.dev/docker-compose/ton-node folder. To stop the node use the following command: docker-compose stop  To restart a stopped node use the following command: docker-compose restart  "},{"title":"Logging​","type":1,"pageTitle":"Run Testnet Node","url":"validate/run-validator/run-testnet-node#logging","content":"During deployment​ It is highly recommended to record the full log during node deployment: ./deploy.sh 2&gt;&amp;1 | tee ./deploy.log  The log is saved to the net.ton.dev/scripts/ folder next to the deployment script and can be useful for troubleshooting. During operation​ When operational, the node keeps a number of logs in the net.ton.dev/docker-compose/ton-node/logs folder. Logs are generated with log4rs framework. For detailed documentation on it refer to https://docs.rs/log4rs/1.0.0/log4rs/. Logging configuration is determined by the net.ton.dev/docker-compose/ton-node/configs/log_cfg.yml file. By default is contains the recommended configuration for the Rust node. refresh_rate: 30 seconds appenders: stdout: kind: console encoder: pattern: &quot;{d(%s.%f)} {l} [{h({t})}] {I}: {m}{n}&quot; stdout_ref: kind: console encoder: pattern: &quot;{f}:{L} {l} [{h({t})}] {I}: {m}{n}&quot; logfile: kind: file path: &quot;/ton-node/logs/output.log&quot; encoder: pattern: &quot;{d(%s.%f)} {l} [{h({t})}] {I}: {m}{n}&quot; rolling_logfile: kind: rolling_file encoder: pattern: &quot;{d(%Y-%m-%d %H:%M:%S.%f)} {l} [{h({t})}] {I}: {m}{n}&quot; path: /ton-node/logs/output.log policy: kind: compound trigger: kind: size limit: 50 gb roller: kind: fixed_window pattern: '/ton-node/logs/output_{}.log' base: 1 count: 1 tvm_logfile: kind: file path: &quot;target/log/tvm.log&quot; encoder: pattern: &quot;{m}{n}&quot; root: level: info appenders: - rolling_logfile loggers: ## node messages ton_node: level: trace boot: level: trace sync: level: trace ## adnl messages adnl: level: info overlay: level: info rldp: level: info dht: level: info ## block messages ton_block: level: debug ## block messages executor: level: debug ## tvm messages tvm: level: info librdkafka: level: info validator: level: debug catchain: level: debug validator_session: level: debug  The currently configured targets are the following: ton_node: node-related messages, except initial boot and sync, block exchange with other nodes boot: initial boot messages, creation of trusted key block chain, loading blockchain state sync: node synchronization - loading a certain number of most recent blocks adnl: messages of the ADNL protocol overlay: messages of the overlay protocol rldp: messages of the RLDP protocol dht: messages of the DHT protocol ton_block: messages of the block structures library, logs are turned on in debug executor: messages of the smart contract execution library, logs are turned on in debug tvm: ton virtual machine messages, logs are turned on in debug librdkafka: kafka client library messages validator: top level consensus protocol messages catchain: low level consensus protocol messages validator_session: mid level consensus protocol messages "},{"title":"Migrating from C++ node​","type":1,"pageTitle":"Run Testnet Node","url":"validate/run-validator/run-testnet-node#migrating-from-c-node","content":"To migrate your validator from legacy C++ node to Rust node, complete the following steps: Set up a new host for the Rust node, according to steps 1-3 of this document.Wait for node to sync. Check sync according to step 4 of this document.Stop the C++ node sending election requests (by default - disable scheduling of the validator script). Do not shut down the C++ validator itself, let it finish the current round.Configure validator wallet and corresponding keys, optionally - DePool (copy them from C++ node files to Rust Node files). By default: Copy validator wallet address from ~/ton-keys/$(hostname -s).addr file on the C++ node to /ton-node/configs/${VALIDATOR_NAME}.addr on the Rust Node.Copy validator wallet keys from /ton-keys/msig.keys.json on the C++ node to /ton-node/configs/keys/msig.keys.json on the Rust Node.If you have a DePool set up, copy DePool address from ~/ton-keys/depool.addr on the C++ node to /ton-node/configs/depool.addr on the Rust Node. Once this is done, the Rust node validator script will start automatically with the next round. DO NOT shut down the C++ host. Wait for the C++ node to complete the current round until the validator set is changed.Check logs/validator.log on the Rust node, and make sure the first election request was successfully sent. There should be no errors in the log.Only once the validator set changes, the C++ node is no longer a validator and the Rust node starts validating (validation_stats and collation_stats in the console output should not be empty), shut down the C++ node. "},{"title":"Troubleshooting​","type":1,"pageTitle":"Run Testnet Node","url":"validate/run-validator/run-testnet-node#troubleshooting","content":"Here are some solutions to frequently encountered problems. 1. Couldn’t connect to Docker daemon at http+docker://localhost​ This error occurs in two cases. Either the docker daemon isn't running, or current user doesn't have rights to access docker. You can fix the rights issue either by running relevant commands as the superuser or adding the user to the docker group: sudo usermod -a -G docker $USER  Make sure to restart the system or log out and back in, for the new group settings to take effect. 2. thread 'main' panicked error when checking node synchronization​ The following error may occur for a short time immediately after node deployment when attempting to check synchronization: thread 'main' panicked at 'Can't create client: Os { code: 111, kind: ConnectionRefused, message: &quot;Connection refused&quot; }', bin/console.rs:454:59  Currently this is expected behavior, unless it persists for more than a few minutes. If it does persist, check network status at https://net.ton.live/, and, if the network is up and running, review deployment logs for errors. 3. Error executing command when checking node synchronization​ The following error may occur for up to an hour after node deployment when attempting to check synchronization: Error executing command: Error receiving answer: early eof bin/console.rs:296  Currently this is expected behavior, unless it persists for more than one hour. If it does persist, check network status at https://net.ton.live/, and, if the network is up and running, review deployment logs for errors. 4. Cannot stop/restart/remove node container​ Make sure you are running all docker-compose commands from the net.ton.dev/docker-compose/ton-node folder. 5. DePool state not updating​ It's recommended to send at least two ticktocks while the elections are open. For rust node you can use the provided ticktock script, which sends 5 ticktocks after the elections open. "},{"title":"System Requirements","type":0,"sectionRef":"#","url":"validate/run-validator/system-requirements","content":"","keywords":""},{"title":"EverX Testnet Node​","type":1,"pageTitle":"System Requirements","url":"validate/run-validator/system-requirements#everx-testnet-node","content":"Configuration\tCPU (threads)\tRAM (GiB)\tStorage (GiB)\tNetwork (Gbit/s)Minimum\t48\t128\t1000\t1 "},{"title":"EverX Mainnet Node​","type":1,"pageTitle":"System Requirements","url":"validate/run-validator/system-requirements#everx-mainnet-node","content":"Configuration\tCPU (threads)\tRAM (GiB)\tStorage (GiB)\tNetwork (Gbit/s)Minimum\t48\t128\t1000\t1 "},{"title":"Update Validator","type":0,"sectionRef":"#","url":"validate/run-validator/update-validator","content":"Update Validator Note: You may need to renew your copy of main.ton.dev scripts but do not remove any working files from the previous deployment (for example, configs folder). Adjust (specify new commit ID) main.ton.dev/scripts/env.sh: export TON_NODE_GITHUB_REPO=&quot;https://github.com/tonlabs/ton-labs-node.git&quot; export TON_NODE_GITHUB_COMMIT_ID=&quot;master&quot; export TON_NODE_TOOLS_GITHUB_REPO=&quot;https://github.com/tonlabs/ton-labs-node-tools.git&quot; export TON_NODE_TOOLS_GITHUB_COMMIT_ID=&quot;master&quot; export TONOS_CLI_GITHUB_REPO=&quot;https://github.com/tonlabs/tonos-cli.git&quot; export TONOS_CLI_GITHUB_COMMIT_ID=&quot;master&quot; Upgrade the node: ./upgrade.sh 2&gt;&amp;1 | tee ./upgrade.log Note: the log generated by this command will be located in the main.ton.dev/scripts/ folder and can be useful for troubleshooting. Wait until the node is synced.","keywords":""},{"title":"Validator Elections","type":0,"sectionRef":"#","url":"validate/run-validator/validator-elections","content":"Validator Elections After having studied how to run a validator node, please follow the description below in order to understand how a validator is elected. It explains in detail the election process using an electoral contract. The election mechanism works as follows: Firstly, it should be noted that elections of validators take place every 18 hours in respect to the current network configuration. Each period consists of 3 phases: The election is open, the elector's smart contract accepts new stakes, and previous validators can return their stakes from the elector's smart contract. The election is over and the smart contract determines the group of validators for the next phase. A new group of validators starts working. The stakes of the former group of validators are temporarily frozen. The electoral smart contract operates according to the following rules: The following parameters are taken from the network configuration: a) Min and Max number of validators; b) Min and Max stake size; c) Maximum difference between the first (maximum) and last (minimum) validator stakes. The maximum group of validators is selected, starting from the largest stake (and moving further in the stake descending order. In the case that the amounts of stakes coincide, then the time of the validator serving in the network is considered), which has a difference between the largest and smallest stakes no more than max_factor. For the next stake, the sum of all the stakes is calculated in such a way as to comply with the max_factor rule. For this, the largest stake (or stakes) is trimmed in order to meet the max_factor rules. If the resulting sum of all the stakes has become larger, then the elector's smart contract tries to select the next stakes, in the descending stakes order, according to the max_factor rule. As soon as the total stake calculated according to the above mentioned procedure stops growing, that is, the maximum amount of stakes is found, then this stake is considered to have passed the elections - then, all past elections, and validators will begin to validate for the next election period, and the trimmed parts of the stakes (if any) are immediately returned to wallets from which they were sent. Please follow this page in order to find out how a Validator is Updated.","keywords":""},{"title":"Staking","type":0,"sectionRef":"#","url":"validate/staking","content":"","keywords":""},{"title":"Glossary​","type":1,"pageTitle":"Staking","url":"validate/staking#glossary","content":"Validator - the entity performing validation of new blocks on the blockchain through a Proof-of-Stake system. Requires a multisignature wallet for staking. Deployer - person who generates the public key for multisignature wallet, collects custodian public keys and deploys the wallet. DevOps - IT Engineer who sets up validator node and scripts, generates Validator Custodian key Custodians - Multisignature wallet owners who submit and confirm transactions from multisignature wallet. Deployer may be one of the custodians. Deployer seed phrase - the seed phrase, generated by Deployer, used to deploy the wallet. Validator Custodian Key - public key generated by DevOps during Node setup. "},{"title":"Prerequisites​","type":1,"pageTitle":"Staking","url":"validate/staking#prerequisites","content":"Synced validator node with initialized wallet - all responsible persons have completed all steps up to and including step 4.4 of Run Validator page.TONOS-CLI installed and configured with the correct network for all wallet custodians, including the Deployer - refer to Multisignature Wallet page.Elections have started - election_id parameter of the elector contract != 0~/ton-keys/msig.keys.json - file with validator custodian keypair.~/ton-keys/$(hostname -s).addr - file wallet address. "},{"title":"1. Validator script submits staking transaction​","type":1,"pageTitle":"Staking","url":"validate/staking#1-validator-script-submits-staking-transaction","content":"Synced validator node should be continuously running validator script (see step 5 of Run Validator page): ./validator_msig.sh &lt;STAKE&gt; &gt;&gt; ./validator.log 2&gt;&amp;1  Once election begins, validator script attempts to create a staking transaction, pledging &lt;STAKE&gt; amount of tokens to the elections contract. Note: to continuously participate in elections validator should have at least 2x &lt;STAKE&gt; on its balance. When the transaction is successfully created, script extracts transactionId and prints it in terminal. Note: if the multisignature wallet has only one custodian the transaction is confirmed automatically and steps 2 and 3 of this guide can be skipped. Go to step 4. "},{"title":"2. Custodians identify Transaction ID​","type":1,"pageTitle":"Staking","url":"validate/staking#2-custodians-identify-transaction-id","content":"Note: Custodians should know the address of their multisignature wallet. A number of custodian signatures are required for a transaction to be executed. Custodians can request the list of transactions awaiting confirmation with the following command: ./tonos-cli run &lt;multisig_address&gt; getTransactions {} --abi SafeMultisigWallet.abi.json  multisig_address – address of the validator wallet. If there are some transactions requiring confirmation, they will be displayed:  Identify the transaction ID of the transaction where the &quot;dest&quot; parameter equals 1:333333....3333333. This is the transaction to the elector contract. Alternatively DevOps may send transactionId to other custodians directly. "},{"title":"3. Wallet custodians confirm staking transaction​","type":1,"pageTitle":"Staking","url":"validate/staking#3-wallet-custodians-confirm-staking-transaction","content":"The required number of validator wallet custodians confirm the transaction through TONOS-CLI with their seed phrases. To create a confirmation message use the following command: ./tonos-cli call &lt;multisig_address&gt; confirmTransaction '{&quot;transactionId&quot;:&quot;&lt;id&gt;&quot;}' --abi SafeMultisigWallet.abi.json --sign &quot;&lt;seed_phrase&gt;&quot;  multisig_address – address of the validator wallet. transactionId – the ID of the transaction identified on the previous step. seed_phrase – custodian seed phrase. "},{"title":"4. Custodians check that the staking transaction was executed​","type":1,"pageTitle":"Staking","url":"validate/staking#4-custodians-check-that-the-staking-transaction-was-executed","content":"To confirm the transaction has been executed, use the getTransactions command again: ./tonos-cli run &lt;multisig_address&gt; getTransactions {} --abi SafeMultisigWallet.abi.json  The staking transaction will no longer be displayed in the list of transactions awaiting confirmation. You can also visit the ever.live explorer and find the message from your address to the 1:333333....3333333 address in the message list. "},{"title":"5. After the elections cycle completes, script checks the size of validator stake to be returned​","type":1,"pageTitle":"Staking","url":"validate/staking#5-after-the-elections-cycle-completes-script-checks-the-size-of-validator-stake-to-be-returned","content":"If election_id == 0 (that means no validator elections at the moment): script requests size of validator stake that can be returned from elector. Returned value will not be 0 if validator won previous elections and was a validator;if this value != 0, script submits new transaction from wallet to Elector contract with 1 token and recover-stake payload, extracts transactionId and prints it in terminal and then exits.  "},{"title":"6. Wallet custodians confirm the recover transaction​","type":1,"pageTitle":"Staking","url":"validate/staking#6-wallet-custodians-confirm-the-recover-transaction","content":"If the number of custodian confirmations required to execute a transaction is &gt; 1, repeat step 2 and 3 for this guide for the recover transaction. Otherwise the transaction will be confirmed automatically and the stake will be returned from elector. Note: It is recommended to run validator_msig.sh periodically, for example with cron utility. validator_misg.sh will automatically make a stake and request it (stake + reward) back when it is available. Only custodian confirmations will have to be done manually in this case. "},{"title":"Mainnet EverX Node Troubleshooting","type":0,"sectionRef":"#","url":"validate/troubleshooting/mainnet-node-troubleshooting","content":"","keywords":""},{"title":"1. Couldn’t connect to Docker daemon at http+docker://localhost​","type":1,"pageTitle":"Mainnet EverX Node Troubleshooting","url":"validate/troubleshooting/mainnet-node-troubleshooting#1-couldnt-connect-to-docker-daemon-at-httpdockerlocalhost","content":"This error occurs in two cases. Either the docker daemon isn't running, or current user doesn't have rights to access docker. You can fix the rights issue either by running relevant commands as the superuser or adding the user to the docker group: sudo usermod -a -G docker $USER  Make sure to restart the system or log out and back in, for the new group settings to take effect. "},{"title":"2. thread 'main' panicked error when checking node synchronization​","type":1,"pageTitle":"Mainnet EverX Node Troubleshooting","url":"validate/troubleshooting/mainnet-node-troubleshooting#2-thread-main-panicked-error-when-checking-node-synchronization","content":"The following error may occur for a short time immediately after node deployment when attempting to check synchronization: thread 'main' panicked at 'Can't create client: Os { code: 111, kind: ConnectionRefused, message: &quot;Connection refused&quot; }', bin/console.rs:454:59  Currently this is expected behavior, unless it persists for more than a few minutes. If it does persist, check network status at https://ton.live/, and, if the network is up and running, review deployment logs for errors. "},{"title":"3. Error executing command when checking node synchronization​","type":1,"pageTitle":"Mainnet EverX Node Troubleshooting","url":"validate/troubleshooting/mainnet-node-troubleshooting#3-error-executing-command-when-checking-node-synchronization","content":"The following error may occur for up to an hour after node deployment when attempting to check synchronization: Error executing command: Error receiving answer: early eof bin/console.rs:296  Currently this is expected behavior, unless it persists for more than one hour. If it does persist, check network status at https://ton.live/, and, if the network is up and running, review deployment logs for errors. "},{"title":"4. Cannot stop/restart/remove node container​","type":1,"pageTitle":"Mainnet EverX Node Troubleshooting","url":"validate/troubleshooting/mainnet-node-troubleshooting#4-cannot-stoprestartremove-node-container","content":"Make sure you are running all docker-compose commands from the main.ton.dev/docker-compose/ton-node folder. "},{"title":"5. DePool state not updating​","type":1,"pageTitle":"Mainnet EverX Node Troubleshooting","url":"validate/troubleshooting/mainnet-node-troubleshooting#5-depool-state-not-updating","content":"It's recommended to send at least two ticktocks while the elections are open. For rust node you can use the provided ticktock script, which sends 5 ticktocks after the elections open. "},{"title":"Node upgrades","type":0,"sectionRef":"#","url":"validate/troubleshooting/node-upgrades","content":"Node upgrades This article has TO DO status. You can contribute by submitting your own version of this page. More details on the Documentation page of the Hot streams section.","keywords":""},{"title":"Testnet EverX Node Troubleshooting","type":0,"sectionRef":"#","url":"validate/troubleshooting/testnet-node-troubleshooting","content":"","keywords":""},{"title":"1. Couldn’t connect to Docker daemon at http+docker://localhost​","type":1,"pageTitle":"Testnet EverX Node Troubleshooting","url":"validate/troubleshooting/testnet-node-troubleshooting#1-couldnt-connect-to-docker-daemon-at-httpdockerlocalhost","content":"This error occurs in two cases. Either the docker daemon isn't running, or current user doesn't have rights to access docker. You can fix the rights issue either by running relevant commands as the superuser or adding the user to the docker group: sudo usermod -a -G docker $USER  Make sure to restart the system or log out and back in, for the new group settings to take effect. "},{"title":"2. thread 'main' panicked error when checking node synchronization​","type":1,"pageTitle":"Testnet EverX Node Troubleshooting","url":"validate/troubleshooting/testnet-node-troubleshooting#2-thread-main-panicked-error-when-checking-node-synchronization","content":"The following error may occur for a short time immediately after node deployment when attempting to check synchronization: thread 'main' panicked at 'Can't create client: Os { code: 111, kind: ConnectionRefused, message: &quot;Connection refused&quot; }', bin/console.rs:454:59  Currently this is expected behavior, unless it persists for more than a few minutes. If it does persist, check network status at https://net.ton.live/, and, if the network is up and running, review deployment logs for errors. "},{"title":"3. Error executing command when checking node synchronization​","type":1,"pageTitle":"Testnet EverX Node Troubleshooting","url":"validate/troubleshooting/testnet-node-troubleshooting#3-error-executing-command-when-checking-node-synchronization","content":"The following error may occur for up to an hour after node deployment when attempting to check synchronization: Error executing command: Error receiving answer: early eof bin/console.rs:296  Currently this is expected behavior, unless it persists for more than one hour. If it does persist, check network status at https://net.ton.live/, and, if the network is up and running, review deployment logs for errors. "},{"title":"4. Cannot stop/restart/remove node container​","type":1,"pageTitle":"Testnet EverX Node Troubleshooting","url":"validate/troubleshooting/testnet-node-troubleshooting#4-cannot-stoprestartremove-node-container","content":"Make sure you are running all docker-compose commands from the net.ton.dev/docker-compose/ton-node folder. "},{"title":"5. DePool state not updating​","type":1,"pageTitle":"Testnet EverX Node Troubleshooting","url":"validate/troubleshooting/testnet-node-troubleshooting#5-depool-state-not-updating","content":"It's recommended to send at least two ticktocks while the elections are open. Here are some solutions to frequently encountered problems. "},{"title":"Getting started","type":0,"sectionRef":"#","url":"validate/tutorial/getting-started","content":"","keywords":""},{"title":"Before we start​","type":1,"pageTitle":"Getting started","url":"validate/tutorial/getting-started#before-we-start","content":"Before proceeding with the material explaining what it means to be a validator of Everscale, firstly consult with Everscale overview page, in order to get familiar with Everscale blockchain essentials. "},{"title":"Overview​","type":1,"pageTitle":"Getting started","url":"validate/tutorial/getting-started#overview","content":"A validator on the Everscale network is basically a server tasked with confirmation of new blocks generated in the blockchain. In order for a new block to be confirmed, it has to be signed by several validators (or nodes). This way, a consensus in the network is reached, which is needed to ensure its reliability. Practically, this mechanism secures resistance to failures of individual nodes and protects the network from deliberate attacks. To become a validator on the Everscale network, a stake (deposit) is required. It allows the participation in the election of validators and subsequent validation of the Proof-of-Stake consensus algorithm. Right now, the stake required amounts to 350 000 Ever. For their work, validators receive remuneration at the end of each validation cycle, consisting of two parts: Processing fees - 1,7 EVER for a new block on the masterchain, and 1 EVER for a new block on the shardchain. Fees from the emission of new tokens distributed to validators, which is currently fixed in the network at the level of ~0.5% per year. Based on the current network configuration, validator elections take place every 18 hours. Each period consists of 3 phases: The election is open, the elector's smart contract accepts new stakes, and previous validators can return their stakes from the elector's smart contract;The election is over and the smart contract determines the group of validators for the next phase;A new group of validators starts working. The stakes of the former group of validators are temporarily frozen. Check out the validator elections page to get better understanding the elections mechanism. To accomodate participants with stakes lower than those required, as mentioned above, DePool smart contracts are designed. They permit any validator, irrespective of the stake size, to participate in staking and receive their part of the reward. DePool smart contracts guarantee that the validator cannot use the participants' funds in any other way, thereby guaranteeing the security of their funds from the validator's dishonesty. "},{"title":"Let’s get started​","type":1,"pageTitle":"Getting started","url":"validate/tutorial/getting-started#lets-get-started","content":"Run Validator - here you can find information explaining how to launch a validation node in prod or testnet, as well as learn all additional information regarding this topic. Depools - in this section you can find information on interaction with DePools. More on this, you can read in the Learn section. "},{"title":"Help and News​","type":1,"pageTitle":"Getting started","url":"validate/tutorial/getting-started#help-and-news","content":"Everscale validator's Telegram chat Everscale validator's Telegram group "}]
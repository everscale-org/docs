[{"title":"Accounts","type":0,"sectionRef":"#","url":"arch/accounts","content":"","keywords":""},{"title":"Account (contract)​","type":1,"pageTitle":"Accounts","url":"arch/accounts#account-contract","content":"Account (contract) is identified by its full address consisting of workchain and ID. Full information about Account is stored in its state. Account can have some balance, a place for its code, place for its data and many other fields. It can have 1 owner, many owners and no owners at all. Account ID is calculated during deploy from its initial code and data. "},{"title":"Basics of Everscale Blockchain","type":0,"sectionRef":"#","url":"arch/basics","content":"","keywords":""},{"title":"Blockchain structure​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#blockchain-structure","content":"At the moment blockchain consists of 2 workchains. One of them (-1), so-called masterchain, is needed for service contracts and validator contracts, another one (0) is for simple users. In the future, it is possible to add more simple workchains (1, 2, etc) to the blockchain. In turn, workchain is splitted into shards (so-called shardchains). When the load is low there are 16 shards, when it increases shards split and when decreases they merge. Blockchain is validated by validators. Part of them validate masterchain, others are splitted into groups and validate shardchains. Periodically global set of validators changes with elections. Within one election cycle shardchain validators rotate as well. "},{"title":"Account (contract)​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#account-contract","content":"Account (contract) is identified by its full address consisting of workchain and ID. Full information about Account is stored in its state. Account can have some balance, a place for its code, place for its data and many other fields. It can have 1 owner, many owners and no owners at all. Account ID is calculated during deploy from its initial code and data. "},{"title":"About deploy​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#about-deploy","content":"Deploy — placing code of the account into blockchain. You can not deploy account's code if its balance is empty because deploy is paid out of that money. This is why any deploy operation must begin with sponsoring the account with some tokens. Because account's ID is unequivocally calculated from code and data, this calculation can be done before actual deploy. "},{"title":"About address​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#about-address","content":"Address is calculated from initial contract's code and data, that is attached to the deploy message. When contract performs SETCODE operation, its address does not change. To calculate the contract address, you need to know its code and its initial data (public key of the owner is also stored in data). "},{"title":"About money transfer​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#about-money-transfer","content":"Money can be transferred from one account to another only by execution of the account's code. Do not transfer money to the addresses where you can not deploy code because they will stay there forever. "},{"title":"About commissions​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#about-commissions","content":"There are several types of fees for operations with contracts. For example, commission for storage, for execution, for message delivery. Read more about them here Fee calculation details. "},{"title":"About get methods​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#about-get-methods","content":"Get method is a method of the contract which doesn't change contract state, thus can be executed locally on the client's machine for free. What shard my account is in right now? Account shard is defined by the first bits of its address and the current list of shards. Encode hex shard prefix to binary format, discard the most right 1. You just got the shard mask. Put this mask on top of account address, if the bits are equal — the account is in this shard. Account can change its shard depending on the load of the network. So before calculating account's shard check the current list of shards. "},{"title":"Message​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#message","content":"All interactions in Free TON are performed via messages. External inbound messages help deploy and call contracts from outside. Internal messages allow contracts to communicate with each other. External outbound messages are the events the contracts produce for the outside world. Use them to implement some off-chain logic — subscribe for these messages and perform some off-chain actions whenever you receive them. For example, simple value transfer can be initiated with an external inbound message (by a human or some service) or with internal message from another contract. This message will produce a transaction (read below) and an internal message with value transfer. "},{"title":"Transaction​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#transaction","content":"Transaction is the result of contract execution. In general transaction is generated with one incoming message (external or internal) and can generate several outcoming messages (external or internal) as a result. Transaction can be successful or aborted. For example, simple value transfer consists of 2 transactions — Sender's transaction which generated an internal message with value transfer, and Recipient's transaction where it received the message with value and updated its balance. "},{"title":"BOC (Bag of cells)​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#boc-bag-of-cells","content":"Is a universal format for data packaging in Free TON. Every object — account, transaction, message, block are stored in blockchain database as bocs. By the way, boc of the block includes bocs of all messages and transactions that were executed in this block inside of it. "},{"title":"TVM​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#tvm","content":"Ton Virtual Machine. Turing complete virtual machine for contract code execution. It works with data represented in boc format. TVM itself does not calculate any commissions and can be used on client side for running get methods of the contracts. TVM is used for debot engine execution on client side as well. Also, TVM is used on validators together with higher level protocols, such as Transaction Executor, to additionally calculate commissions and perform other necessary checks "},{"title":"Transaction Executor​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#transaction-executor","content":"Take results of TVM, calculate fees, checks balance and other things. Used by validators to validate blocks. Can also be used on the client side to debug contract execution. "},{"title":"Contract composition","type":0,"sectionRef":"#","url":"arch/contract-composition","content":"Contract composition","keywords":""},{"title":"What is Ever OS","type":0,"sectionRef":"#","url":"arch/ever-os","content":"","keywords":""},{"title":"Why we call it Ever OS?​","type":1,"pageTitle":"What is Ever OS","url":"arch/ever-os#why-we-call-it-ever-os","content":"A modern blockchain like Everscale is not just an immutable ledger. Bitcoin and other earlier blockchains were mostly ledgers, yet even Bitcoin supports a non-Turing complete script that provides some transaction execution instructions. In fact, the Bitcoin script is a Forth-like instruction set, which makes it somewhat similar in origin to TON Virtual Machine assembly language, but more on that later. Most blockchains after Ethereum are, in large part, distributed computing engines that execute and verify Turing-complete programs called smart contracts. In simpler words they are a special breed of network processors working in orchestration (called &quot;consensus&quot;) to perform common operations and in that way verify correctness of their execution. In Everscale this paradigm is taken to the extreme. The immutable ledger is quite a small part of Everscale. Of course it is an immutable ledger and a chain of blocks — that is how the data is written and transmitted from one network processor to another — yet there are at least two aspects which make Everscale uniquely more so a computing engine than a simple ledger. Almost everything in Everscale is smart contracts. Every account in Everscale must be associated with a smart contract code (or initialized) in order for a user to be able to perform any operation with it. Smart contracts are Everscale Assembly programs executed in the Everscale Virtual machine much like any assembly code is executed by hardware or by a virtual processor in a regular computer. Between a regular computer and a user (which may be a developer who would like to write programs for that computer or a regular user who would like to execute and interact with these programs) there is something called an operating system. That is how GNU defines operating system: Linux is an operating system: a series of programs that let you interact with your computer and run other programs. An operating system consists of various fundamental programs which are needed by your computer so that it can communicate and receive instructions from users; read and write data to hard disks, tapes, and printers; control the use of memory; and run other software. It is quite obvious why computers need an operating system. Before operating systems existed, interaction with computers looked something like this:  I still think the &quot;world computer&quot; is a good analogy. The idea that you have a shared computing environment that anybody can build and run stuff on is still a totally legitimate and valuable thing to emphasize. — Vitalik Buterin Any way you look at it, blockchain is quite a good candidate to be called a decentralized computer. At least some of the blockchains are. Everscale most definitely is. And just as with any computer, a blockchain needs an intermediate layer (or layers) that manages its resources and provides services to the programs the user runs or interacts with. Of course blockchain, in terms of architecture, cannot perhaps be compared directly 1:1 with a regular PC. But in logical terms, whenever we think about a software stack needed to enable interaction with a user — to call it an operating system is quite compelling. Let's run some arguments. For reasons of practicality we will not talk only about Free Everscale blockchain, but most of the arguments could be applied to some other modern blockchains as well. A classical operating system is expected to provide: Memory Management Processor Managing Device Managing File handling Security Handling System performance control Job accounting and handling Error detecting and handling Synchronization with other software and users Let's compare with Ever OS and the services it provides: "},{"title":"Memory Management​","type":1,"pageTitle":"What is Ever OS","url":"arch/ever-os#memory-management","content":"Individual blocks containing data are created, validated and finalized under governance by the consensus blockchain software. Nodes participating in processing blocks are chosen dynamically without requiring interference from the blockchain user. "},{"title":"Processor Managing​","type":1,"pageTitle":"What is Ever OS","url":"arch/ever-os#processor-managing","content":"Smart contracts are blockchain programs that are executed by the Everscale Virtual Machine across many network devices and locally (if we consider how a user is accessing the blockchain). A user does not think about how a smart contract is executed. Following some deployment instructions, a developer can deploy and run smart contracts without thinking about which virtual machine it is executed on or how this execution has been synchronized across the network and verified. In this respect it is safe to say that Ever OS provides processor management capabilities. "},{"title":"Device Managing​","type":1,"pageTitle":"What is Ever OS","url":"arch/ever-os#device-managing","content":"Blockchain software, including full node implementation, allows users to control, handle, configure and diagnose individual blockchain nodes. "},{"title":"File handling​","type":1,"pageTitle":"What is Ever OS","url":"arch/ever-os#file-handling","content":"Via a smart contract users can store and access persistent data on the blockchain. "},{"title":"Security Handling​","type":1,"pageTitle":"What is Ever OS","url":"arch/ever-os#security-handling","content":"Access to restricted areas of the system is authorized through extensive use of specialized smart contracts. Cases of unauthorized access attempts are recorded and monitored using security smart contracts. "},{"title":"System performance control​","type":1,"pageTitle":"What is Ever OS","url":"arch/ever-os#system-performance-control","content":"System-wide smart contracts deployed to the blockchain are in charge of monitoring system performance and receiving events which pinpoint various cases of system malfunction. "},{"title":"Job accounting and handling​","type":1,"pageTitle":"What is Ever OS","url":"arch/ever-os#job-accounting-and-handling","content":"Smart contracts execution inside the blockchain is governed by specialized software modules. Details of the execution are available for view and analysis through the blockchain explorer. "},{"title":"Error detecting and handling​","type":1,"pageTitle":"What is Ever OS","url":"arch/ever-os#error-detecting-and-handling","content":"Cases of misbehavior and inconsistency of smart contracts and blockchain software are monitored, collected and stored for subsequent analysis by specialized smart contracts. "},{"title":"Synchronization with other software and users​","type":1,"pageTitle":"What is Ever OS","url":"arch/ever-os#synchronization-with-other-software-and-users","content":"System smart contracts form an interconnected decentralized network by exchanging addresses, interfaces and specifications with each other to provide users and other smart contracts with the information required to properly utilize their functionality. "},{"title":"Managing gas","type":0,"sectionRef":"#","url":"arch/managing-gas","content":"","keywords":""},{"title":"Gas calculation basics​","type":1,"pageTitle":"Managing gas","url":"arch/managing-gas#gas-calculation-basics","content":""},{"title":"Specification Overview​","type":1,"pageTitle":"Managing gas","url":"arch/managing-gas#specification-overview","content":"The entire state of TVM consists of the five components: StackControl registersCurrent continuationCurrent codepageGas limits Collectively these are called SCCCG. Check out section 1.4 of the TVM specification. The Gas component limits gas usage and сontains four signed 64-bit integers: the remaining gas: grthe current gas limit: glthe maximal gas limit: gmthe gas credit: gc The following is always true: 0≤gl≤gm,gc≥0,andgr≤gl+gc0 ≤ gl ≤ gm, gc ≥ 0, and gr ≤ gl + gc0≤gl≤gm,gc≥0,andgr≤gl+gc gc is initialized by zero for internal messages, gr is initialized by gl + gc and gradually decreases, as the TVM runs. When gr becomes negative or if contract terminates with gc &gt; 0, an out of gas exception is triggered. "},{"title":"Gas prices​","type":1,"pageTitle":"Managing gas","url":"arch/managing-gas#gas-prices","content":"As stated in A.1 of the TVM specification. According to the original TON, for most primitives gas is calculated according to the following formula: Pb:=10+bPb := 10 + bPb:=10+b where b is the instruction length in bits. The same is true for EverX implementation. For example: the gas required for A0 (ADD) instruction is 10 + 8 = 18 gas, while the gas for A6cc (ADDCONST cc) instruction is 10 + 16 = 26 gas. For some instructions this rule does not apply. TVM specification lists either total gas prices, or prices in addition to the basic Pb for them explicitly. Instruction list with additional information may be obtained in A.2 through A.13 of the TVM specification. Apart from integer constants, the following expressions may appear: The total price of loading cells. Currently it is 100 gas units per cell. Reloading a cell again now costs 25 gas units.The total price of creating new Cells from Builders. Currently it is 500 gas units.Exception throwing. 50 gas units per exception.Exiting the block costs 5 gas units per implicit RET. Jumping to the first link costs 10 gas units - implicit JUMP.Moving to a new continuation with transferring parameters costs gas if there are more then 32 parameters. It costs N-32 gas, where N is the number of parameters.Tuple gas price. 1 gas unit for every tuple element. Note: that the most expensive operations are dictionary read/write operations. Dictionaries are stored in the form of trees of cells, where each cell can only be linked to four others. As result, these trees can grow quite large, depending on the data that needs to be stored. To read data in any cell, all its parent cells need to be read first, at the price of 100 gas per cell, and to write data in a cell, similarly all its parent cells need to be (re)created at the price of 500 gas per cell. "},{"title":"Global gas limits​","type":1,"pageTitle":"Managing gas","url":"arch/managing-gas#global-gas-limits","content":"Global gas limits are values stored in the masterchain configuration contract. Global values are standard and do not change at contract deployment. Only validator consensus can modify them. The values currently used can always be reviewed on ever.live in the latest key block details (example FIXME broken link). p20 config parameter values are used for masterchain and p21 values are used for workchain. "},{"title":"Gas-related TVM primitives​","type":1,"pageTitle":"Managing gas","url":"arch/managing-gas#gas-related-tvm-primitives","content":"These is the list of official TVM primitives used for gas-related operations: F800 — ACCEPT, sets current gas limit gl to its maximal allowed value gm, and resets the gas credit gc to zero, decreasing the value of gr by gc in the process. In other words, the current smart contract agrees to buy some gas to finish the current transaction. This action is required to process external messages, which bring no value (hence no gas) with themselves.F801 — SETGASLIMIT (g – ), sets current gas limit gl to the minimum of g and gm, and resets the gas credit gc to zero. If the gas consumed so far (including the present instruction) exceeds the resulting value of gl, an (unhandled) out of gas exception is thrown before setting new gas limits. Notice that SETGASLIMIT with an argument g ≥ 2 63 − 1 is equivalent to ACCEPT.F802 — BUYGAS (x – ), computes the amount of gas that can be bought for x nanotokens, and sets gl accordingly in the same way as SETGASLIMIT.F804 — GRAMTOGAS (x – g), computes the amount of gas that can be bought for x nanotokens. If x is negative, returns 0. If g exceeds 2 63−1, it is replaced with this value.F805 — GASTOGRAM (g – x), computes the price of g gas in nanotokens.F806–F80F — Reserved for gas-related primitives. These are yet to be released. Note: F802, F804, F805 are not implemented in Telegram TON node. In Evernode, the general gas formula is the same as specified by TON specifications. Overall, Evernode operate in compliance with the specification. For every executed primitive, the amount of gas is added to the virtual machine according to the specification formula. Gas value for every primitive is based on gr. "},{"title":"Gas initialization types​","type":1,"pageTitle":"Managing gas","url":"arch/managing-gas#gas-initialization-types","content":""},{"title":"1. Calling contract from another contract​","type":1,"pageTitle":"Managing gas","url":"arch/managing-gas#1-calling-contract-from-another-contract","content":"An internal message with a balance value is received. In this case, the following formulas are applied to determine limits: gm = MIN(account balance / gas price, global_gas_limit) gl = MIN(message value / gas price, global_gas_limit) gc = 0 gr = gc + gl  By default, gas costs are allocated to the caller contract that triggers the transaction with a message. Accepting is also available for internal contracts. If ACCEPT is not called, gas is taken from the caller contract according to the message value. In other words, the message value defines the current limit. The message value determines the starting TVM gas limit. So, to put it plain, if ACCEPT is not called, the message pays, if ACCEPT is used, additional gas can be bought by the target contract. This approach enables flexible contract design where either total gas is paid by the caller contract (but in this case it has to have enough gas at any moment of time) or the target contract also incurs costs. "},{"title":"2. Offchain contract call​","type":1,"pageTitle":"Managing gas","url":"arch/managing-gas#2-offchain-contract-call","content":"External messages do not carry balance values. In this case, the values are calculated according to the following formulas: gm = MIN(account balance / gas price, global_gas_limit) gl = 0 gc = MIN(gm, global_gas_credit) gr = gc + gl  As external messages have no gas value, gas is credited to execute it. Target contracts have to cover costs by calling Accept to buy gas. If a contract returns an exception before the credit is given, no gas fee applies. As the public code for node has just been released this documentation is likely to be updated. Managing Gas in Solidity Some Theory Anyone can send external message to your contract. When a message arrives, the contract initial gas limit is equal to 10,000 units of credit gas that should be bought later by the ACCEPT TVM primitive. Otherwise when credit gas falls to zero, the TVM throws the out of gas exception. The contract is supposed to spend these 10,000 units of 'free' gas to check the body of an inbound message tp make sure that it is valid and can be processed by contract successfully. The idea of credit gas allowance is that as long as it is beyond zero, any exception thrown by contract prevents all further gas charges. But once the contract accepts a message, all gas consumed by contract is converted to gas fees regardless of whether a transaction is aborted or not. ACCEPT is useful in internal messages too. When another contract sends an internal message to your contract, initial gas limit is equal to an inbound message value divided by the gas_price or global gas limit, if it is smaller. If this value is not enough to finish execution, the contract then can increase its gas limit by calling ACCEPT or SETGASLIMIT primitive. The ACCEPT primitive increases the limit to the value of its balance divided by the gas_price, and the SETGASLIMIT primitive sets the current gas limit to the value popped from the TVM stack (the value cannot be bigger than the gm limit). With the ACCEPT command a contract can choose whether gas for its execution is paid by the caller contract or by the contract itself. Implementation In EverX the ACCEPT primitive is implemented in Solidity as a private function called by public functions. Find below actual usage examples. All can be compiled using EverX Solidity compiler. Accept gas inside function To avoid gas payment when the foo function is called by another contract, we can use the following code: Remember that the caller contract should attach enough tokens to its message to cover all gas that will be spend by foo function. Accept gas inside modifier contract AcceptExample2 { uint _sum = 0; modifier AlwaysAccept() { tvm.accept(); _; } function foo(uint a, uint b) AlwaysAccept() public { _sum = a + b; } }  Important: modifier is called before arguments are deserialized from inbound message body. In the example above AlwaysAccept() will be called before a and b are decoded. "},{"title":"Fee calculation","type":0,"sectionRef":"#","url":"arch/fee-calculation","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Fee calculation","url":"arch/fee-calculation#introduction","content":"Transaction fees consist of a few types of different fees connected to the execution of a single transaction. Transactions itself are complex processes, and fees are paid relative to different stages of executing them. In this document, we explain how the fees are calculated. We shall define transaction_fee as a sum of all fees for a single transaction. transaction_fee = inbound_external_message_fee + storage_fees + gas_fees + total_action_fees + outbound_internal_messages_fee  Where: inbound_external_message_fee — is deducted, if an inbound external message is imported in the transaction. storage_fees — storage costs since the moment of the last transaction. gas_fees — include all gas fees associated with the transaction. You can find more info in the Gas calculation basics section. total_action_fees — fees for performing send message actions. outbound_internal_messages_fee — is calculated as a sum of fees for all outbound internal messages generated by the transaction. Depending on the nature of the transaction, all of these except storage fees may not be applicable. Below we examine these types of fees in detail. Note: Block creation fee is not to be confused with the fees discussed in this document. Block creation fee is the new coins minted by the elector contract and distributed among validators as reward for creating blocks. It is not part of transaction fees. "},{"title":"Storage fees​","type":1,"pageTitle":"Fee calculation","url":"arch/fee-calculation#storage-fees","content":"Every transaction in TON has a storage phase that implies a certain storage fee charged on an account balance. This fee is charged for the period between transactions and is calculated according to the following formula: storage_fees = CEIL( ( account.bits * global_bit_price + account.cells * global_cell_price ) * period / 2 ^ 16 )  Where: account.bits and account.cells — stand for a number of bits and cells in the Account structure represented as tree of cells (including code and data). global_bit_price — is a global configuration parameter (p18 for both masterchain and workchains), price for storing one bit. global_cell_price — another global configuration parameter (p18 for both masterchain and workchains), price for storing one cell. period — number of seconds since previous storage fee payment. Note: While account.bits are generally easy to estimate, the account.cells value can vary greatly for different types of data. A cell can contain no more than 1023 bits and 4 references to other cells. Contract code and numerical variables tend to be packed into cells effectively, resulting in mostly full cells, and thus a minimal number of cells needed to store the data. More complex data structures can be packed into cells less efficiently, taking up more cells to store the same amount of data. Example: Let's calculate a minimal fee for storing 1KB of data for the duration of one day on a workchain: global_bit_price = 1 global_cell_price = 500 period = 86400 seconds account.bits = 8192 The minimal account.cells value for 8192 bits of data is 9 (rounding 8192/1023 up to the nearest integer). Thus the minimum storage fee would be calculated as follows: storage_fees = CEIL( ( 8192 * 1 + 9 * 500 ) * 86400 / 65536 ) = 16733 nanotokens = 0.000016733 tokens  Real storage fees for 1KB account can be higher, depending on the specific features of the contract. If the account balance is less than the due storage fee, the account is frozen and its balance is subtracted from storage fee and reduced to zero. Remaining storage fee is stored in account as debt. Note: Current global configuration can be always reviewed on [ever.live]( https:/ /ever.live/) in the master config section of the latest key block details (example) FIXME broken link. It can only be changed by a vote of validators. "},{"title":"Message fees​","type":1,"pageTitle":"Fee calculation","url":"arch/fee-calculation#message-fees","content":"Every message is subject to a forwarding fee, which is calculated according to the following formula: msg_fwd_fee = ( lump_price + CEIL( ( bit_price * msg.bits + cell_price * msg.cells ) / 2 ^ 16 ) )  msg.bits and msg.cells are calculated from message represented as a tree of cells. Root cell is not counted. lump_price, bit_price, cell_price are contained in global config parameters p24 and p25, and can and can only be changed by a vote of validators. Note: Like in storage fees, msg.bits are generally easy to estimate, while the msg.cells value can vary for different types of messages. Example: Let's calculate a minimal forward fee for sending a 1KB message on a workchain: lump_price = 10000000 bit_price = 655360000 cell_price = 65536000000 To calculate msg.bits we subtract the root cell bits from the total message bits. For this example we'll assume that the root cell is filled completely (usually this is not the case, and the subtracted value is smaller, which results in a higher fee): msg.bits = 8192 - 1023 = 7169  To calculate msg.cells we subtract the root cell from the total umber of cells. The minimal number of cells in a 1 KB message is 9 (rounding 8192/1023 up to the nearest integer). Thus msg.cells is calculated as follows: msg.bits = 9 - 1 = 8  The minimum forward fee for a 1KB message would be calculated as follows: msg_fwd_fee = ( 10000000 + CEIL( ( 655360000 * 7169 + 65536000000 * 8 ) / 65536 ) ) = 89690000 nanotokens = 0.08969 tokens  Real forward fees for 1 KB messages may be higher, depending on the type and contents of the message. Note: Current global configuration can be always reviewed on ever.live in the master config section of the latest key block details (example) FIXME broken link. "},{"title":"Outbound messages​","type":1,"pageTitle":"Fee calculation","url":"arch/fee-calculation#outbound-messages","content":"outbound_internal_messages_fee is calculated as a sum of outbound internal message fees for every message generated as result of transaction execution: outbound_internal_messages_fee = SUM( out_int_msg.header.fwd_fee + out_int_msg.header.ihr_fee )  Where out_int_msg.header.fwd_fee is a part of the standard forward fee for the outbound internal message. out_int_msg.header.ihr_fee is currently disabled. Routing​ The forward fee for outbound internal message is split into int_msg_mine_fee and int_msg_remain_fee: msg_forward_fee = int_msg_mine_fee + int_msg_remain_fee  Where: int_msg_mine_fee = msg_forward_fee * first_frac / 2 ^ 16  first_frac — is contained in global config parameters p24 and p25, and determines the fraction of the fee, that the current set of validators receive. Note: Current global configuration can be always reviewed on ever.live in the master config section of the latest key block details (example) FIXME broken link. int_msg_mine_fee then becomes part of transaction action fees (see below). The remaining int_msg_remain_fee is placed in the header of outbound internal message (becoming out_int_msg.header.fwd_fee) and will go to validators who will process the message. If, while being forwarded to the destination address, the message passes through additional validator sets (i.e. if the validator set changes more than once while the message is being forwarded), a part of out_int_msg.header.fwd_fee is payed to the relevant validator set every time and the remaining fee in the message header is reduced by this amount: intermediate_fee = out_int_msg.header.fwd_fee * next_frac / 2 ^ 16  next_frac — is contained in global config parameters p24 and p25, and determines the fraction of the remaining forward fee, that intermediary validators receive. Note: Current global configuration can be always reviewed on ever.live in the master config section of the latest key block details (example) FIXME broken link. Note: Length of route does not affect the initial calculation of the forward fee. The fee is simply split between all involved validators according to global config parameters. Note: If an exception is thrown, and a bounce message is generated, it is subject to fees, just like a single regular outbound message. "},{"title":"Inbound external messages​","type":1,"pageTitle":"Fee calculation","url":"arch/fee-calculation#inbound-external-messages","content":"Whenever an inbound external message needs to be imported for transaction execution, the for this action fee is calculated according to the standard forwarding fee formula, and paid to the current validators. "},{"title":"Action fees​","type":1,"pageTitle":"Fee calculation","url":"arch/fee-calculation#action-fees","content":"Action fees pay for performing 'send message' actions. They consist of all fees for external outbound messages, and the first fraction of internal outbound message fees. They are calculated as follows: total_action_fees = total_out_ext_msg_fwd_fee + total_int_msg_mine_fee  where: total_out_ext_msg_fwd_fee — sum of implicit forward fee for all generated outbound external messages.total_int_msg_mine_fee — sum of 'mine' parts of message forward fees for outbound internal messages.total_fwd_fees — is a separate way to calculate total forwarding fees. total_fwd_fees = total_action_fees + SUM( int_msg_remain_fee + out_int_msg.header.ihr_fee )  out_int_msg.header.ihr_fee — this fee is currently zero. The action fee might be absent if no actions are performed during the transaction. "},{"title":"Gas fees​","type":1,"pageTitle":"Fee calculation","url":"arch/fee-calculation#gas-fees","content":"trans.gas_fees include all gas fees associated with the transaction. You can find more information in the Gas calculation basics section. Same as action fees, gas fees are not always present. They can be skipped if the TVM compute phase is not initialized in a transaction. "},{"title":"Message","type":0,"sectionRef":"#","url":"arch/message","content":"Message","keywords":""},{"title":"Querying","type":0,"sectionRef":"#","url":"arch/querying","content":"Querying","keywords":""},{"title":"Runtime","type":0,"sectionRef":"#","url":"arch/runtime","content":"Runtime","keywords":""},{"title":"Serialization","type":0,"sectionRef":"#","url":"arch/serialization","content":"Serialization","keywords":""},{"title":"Smart Contract Security","type":0,"sectionRef":"#","url":"arch/security","content":"","keywords":""},{"title":"Replay Attack Protection​","type":1,"pageTitle":"Smart Contract Security","url":"arch/security#replay-attack-protection","content":"All external messages must be protected against replay attacks. Otherwise, a malicious party can resend an external message obtained from blockchain and repeat a transaction for a smart contract. For example, a hacker can repeat a Token transfer and bring an account balance to zero. For internal messages the risk of replay attacks is irrelevant, as they only can be generated inside blockchain by other contracts. "},{"title":"Implementation Options​","type":1,"pageTitle":"Smart Contract Security","url":"arch/security#implementation-options","content":"Different approaches to implementing replay attack protection exist. None of them is a silver bullet, but there are several indicators applied to compare and evaluate them: Gas consumptionStorage feesRace conditionUsability "},{"title":"Sequence number​","type":1,"pageTitle":"Smart Contract Security","url":"arch/security#sequence-number","content":"This is a very simple protection option. It implies that each protected contract stores a counter (i.e. 32bit integer) that is initially set to zero. An external message is then accepted by the contract only under condition that it contains a number equal to the current contract counter value. Each time a new message is accepted, the contract counter value is incremented by one. Pros: simple implementation in contractslow gas and storage fees Cons: To get the right sequence number off-chain, a client must request the contract state from blockchain before sending an external message. If the state is large, it can cause a network traffic overheadRace condition issue that arises when there are multiple contract owners who can simultaneously call it. One owner can increment the contract counter value before this counter becomes available to the next ownerLess sensitive issue of a potential counter overflow in the future. In this case the TVM will throw an exception causing the owner to lose access to the contract "},{"title":"Timestamp​","type":1,"pageTitle":"Smart Contract Security","url":"arch/security#timestamp","content":"Another simple protection option is adding a timestamp to every external message. It can be a 64-bit value in unixtime format. The contract must store the timestamp of the last accepted external message. When a new external message comes, the contract verifies the message timestamp. It must to be bigger than the previous message timestamp and less then now + interval. The interval value is necessary, because now does not stand for the current time, but indicates creation time of the relevant block. The interval can be equal the block generation period or bigger. Pros: Very simple implementationNo need to request account state before sending external messages Cons: Race condition issues remains unresolved as in case of sequence number implementationClient time must be synchronized with blockchain time "},{"title":"Set of accepted messages​","type":1,"pageTitle":"Smart Contract Security","url":"arch/security#set-of-accepted-messages","content":"Dictionary of randoms This option implies that every external message contains a random value, for example, a 32bit integer. A protected contract, in turn, stores previously used randoms in a dictionary, compares message randoms with it and rejects a message if there is a match detected. Pros: No need to request account state before sending an external messageNo race condition; simultaneous access to contract of multiple parties is supported. Collisions are still possible when multiple clients have the same random, but chances can be minimized. Cons: Consumes a lot of gas for dictionary write/read operations. Note that the gas fee will increase in the futureHigh storage fees for storing dictionary Dictionary of messages with garbage collection This option implies that every external message contains an expire-at integer that defines the time when the message becomes invalid (i.e. expires). The contract, in turn, must store a dictionary with all recently accepted and not expired external messages. The key is a message hash, the value is the relevant expire-at integer. The contract then rejects all messages that are already present in its dictionary. To avoid persistent data increase, a protected contract can delete messages with the expire-at value less than now from its dictionary. Pros: No need to request the account state before sending an external messageNo race condition issues Cons: Harder to implement compared to the above option with a dictionary of randomsHigh gas fees caused by the need to access a dictionaryHigh storage fees, yet these can be reduced by deleting expired messages from the dictionaryGarbage collecting also involves some gas costs "},{"title":"Sessions​","type":1,"pageTitle":"Smart Contract Security","url":"arch/security#sessions","content":"Before sending requests to contract, a user creates a session with a contract by sending a create_session external message. The message contains a new session ID, its expired-at time and a starting sequence number. The contract stores a session dictionary. After a session is created, the user adds the session_id and the next session sequence number to every external message. For every external message (not create_session) the contract checks that: The message session ID exists in dictionary The message sequence number is equal to the stored session number, and The now value is less then the expired-at value for session If all checks are passed successfully, the contract increments the stored sequence number for the session. In case of failure, the message is rejected. Also, expired sessions require some garbage collection. Pros: No need to request the account state before sending an external messageNo race condition issuesNo collisions Cons: Harder to implement compared to all the options covered aboveHigh gas feesHigh storage feesNeed to use garbage collectingUnsuitable for simple single-user contracts "},{"title":"Conclusion​","type":1,"pageTitle":"Smart Contract Security","url":"arch/security#conclusion","content":"In EverX, we selected a lightweight and simple replay protection option, it will be implemented in the compiler by default and based on the timestamp approach. It is supposed to work well for single-user contracts, as well as for contracts without heavy race conditions. It is easy to use given that EverX SDK enables inserting a timestamp automatically on the client side. Also, there will be an option to redefine the default protection method by overloading a special contract function. This is how contract developers will be able to implement any protection option they seem fit. "},{"title":"Transaction","type":0,"sectionRef":"#","url":"arch/transaction","content":"Transaction","keywords":""},{"title":"Bug bounty program","type":0,"sectionRef":"#","url":"contribute/bug-bounty-program","content":"Bug bounty program","keywords":""},{"title":"Community maintainers","type":0,"sectionRef":"#","url":"contribute/community-maintainers","content":"Community maintainers","keywords":""},{"title":"Hot topics for contributors","type":0,"sectionRef":"#","url":"contribute/hot-topics-for-contributors","content":"Hot topics for contributors","keywords":""},{"title":"Rewards","type":0,"sectionRef":"#","url":"contribute/rewards","content":"Rewards","keywords":""},{"title":"Getting started","type":0,"sectionRef":"#","url":"contribute/tutorial/getting-started","content":"Getting started","keywords":""},{"title":"How to","type":0,"sectionRef":"#","url":"contribute/tutorial/how-to","content":"How to","keywords":""},{"title":"How to contribute code","type":0,"sectionRef":"#","url":"contribute/tutorial/how-to-contribute-code","content":"How to contribute code","keywords":""},{"title":"How to contribute to docs","type":0,"sectionRef":"#","url":"contribute/tutorial/how-to-contribute-to-docs","content":"How to contribute to docs","keywords":""},{"title":"How to contribute to website","type":0,"sectionRef":"#","url":"contribute/tutorial/how-to-contribute-to-website","content":"How to contribute to website","keywords":""},{"title":"Comparison with Ethereum","type":0,"sectionRef":"#","url":"develop/from-another-platform/comparison-with-ethereum","content":"Comparison with Ethereum","keywords":""},{"title":"Comparison with Bitcoin","type":0,"sectionRef":"#","url":"develop/from-another-platform/comparison-with-bitcoin","content":"Comparison with Bitcoin","keywords":""},{"title":"Comparison with Solana","type":0,"sectionRef":"#","url":"develop/from-another-platform/comparison-with-solana","content":"Comparison with Solana","keywords":""},{"title":"Hackathons & Grants","type":0,"sectionRef":"#","url":"develop/hackathons-grants","content":"Hackathons &amp; Grants","keywords":""},{"title":"Comparison with EVM Solidity Contracts","type":0,"sectionRef":"#","url":"develop/smart-contract/comparison-with-evm-solidity","content":"Comparison with EVM Solidity Contracts","keywords":""},{"title":"Components","type":0,"sectionRef":"#","url":"develop/smart-contract/components","content":"Components","keywords":""},{"title":"Debugging","type":0,"sectionRef":"#","url":"develop/smart-contract/debugging","content":"Debugging","keywords":""},{"title":"Developing with C++","type":0,"sectionRef":"#","url":"develop/smart-contract/developing-with-c++","content":"Developing with C++","keywords":""},{"title":"Examples","type":0,"sectionRef":"#","url":"develop/smart-contract/examples","content":"Examples","keywords":""},{"title":"Developing with TVM Solidity","type":0,"sectionRef":"#","url":"develop/smart-contract/developing-with-tvm-solidity","content":"Developing with TVM Solidity","keywords":""},{"title":"Frontend App","type":0,"sectionRef":"#","url":"develop/smart-contract/frontend-app","content":"Frontend App","keywords":""},{"title":"FAQ","type":0,"sectionRef":"#","url":"develop/smart-contract/faq","content":"FAQ","keywords":""},{"title":"Lifecycle","type":0,"sectionRef":"#","url":"develop/smart-contract/lifecycle","content":"Lifecycle","keywords":""},{"title":"Math","type":0,"sectionRef":"#","url":"develop/smart-contract/math","content":"Math","keywords":""},{"title":"Getting started","type":0,"sectionRef":"#","url":"develop/smart-contract/getting-started","content":"","keywords":""},{"title":"Prerequisite​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/getting-started#prerequisite","content":"Node.js &gt;= 14.x installed Node Version Manager (NVM)NVM-windows Docker &gt;= 19.x installed and running "},{"title":"Generate a new project​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/getting-started#generate-a-new-project","content":"mkdir my-project &amp;&amp; cd $_ npm init --force npm install --save everdev  "},{"title":"Setup local environment​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/getting-started#setup-local-environment","content":"Set Local Blockchain SE (Startup Edition) as the default network: Startup SE at this step, you may have to wait until the docker image is downloaded: npx everdev se start  A local network explorer is available at localhost check it. Setting SE as default network: npx everdev network default se  "},{"title":"Configure Giver​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/getting-started#configure-giver","content":"Configure Giver wallet that will sponsor EVER for deploy operation: npx everdev signer add giver 172af540e43a524763dd53b26a066d472a97c4de37d5498170564510608250c3 npx everdev network giver se 0:b5e9240fc2d2f1ff8cbb1d1dee7fb7cae155e5f6320e585fcc685698994a19a5 --signer giver npx everdev network giver dev 0:b5e9240fc2d2f1ff8cbb1d1dee7fb7cae155e5f6320e585fcc685698994a19a5 --signer giver  "},{"title":"Generate the key pair for contract ownership​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/getting-started#generate-the-key-pair-for-contract-ownership","content":"Key pair file — used in contracts with implemented authorization. It is the file containing private and public keys authorized to access the contract. In --sign parameter the corresponding seed phrase may be used instead of it. npx everdev signer generate coder npx everdev signer default coder npx everdev signer list  "},{"title":"Generate a new smart-contract​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/getting-started#generate-a-new-smart-contract","content":"npx everdev sol create App  You are got App.sol: pragma ton-solidity &gt;= 0.35.0; pragma AbiHeader expire; // This is class that describes you smart contract. contract App { // Contract can have an instance variables. // In this example instance variable `timestamp` // is used to store the time of `constructor` // or `touch` function call. uint32 public timestamp; // Contract can have a `constructor`. // The function that will be called when contract will be deployed to the blockchain. // In this example constructor adds current time to the instance variable. // All contracts need call `tvm.accept()` for succeeded deploy. constructor() public { // Check that contract's public key is set require(tvm.pubkey() != 0, 101); // Check that message has signature (msg.pubkey() is not zero) and // message is signed with the owner's private key require(msg.pubkey() == tvm.pubkey(), 102); // The current smart contract agrees to buy some gas to finish the // current transaction. This actions required to process external // messages, which bring no value (hence no gas) with themselves. tvm.accept(); timestamp = now; } function renderHelloWorld () public pure returns (string) { return 'helloWorld'; } // Updates variable `timestamp` with current blockchain time. function touch() external { // Each function that accepts external message must check that // message is correctly signed. require(msg.pubkey() == tvm.pubkey(), 102); // Tells to the TVM that we accept this message. tvm.accept(); // Update timestamp timestamp = now; } function sendValue(address dest, uint128 amount, bool bounce) public view { require(msg.pubkey() == tvm.pubkey(), 102); tvm.accept(); // It allows to make a transfer with arbitrary settings dest.transfer(amount, bounce, 0); } }  For more about Solidity and specific of Everscale Solidity "},{"title":"Compile smart-contract​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/getting-started#compile-smart-contract","content":"npx everdev sol compile App.sol  You are got: App.abi.json — ABI *.abi.json file — a file that describes the contract interface, the methods and parameters used to interact with it, for detail see ABI Specification V2.App.tvc — TVC *.tvc file — the compiled smart contract file. Used only when generating contract address and deploying contract code to the blockchain. "},{"title":"Deploy smart-contract​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/getting-started#deploy-smart-contract","content":"The 1 EVER is 1000000000 nano EVER Local network: npx everdev contract deploy --network se --value 1000000000 App  Developer network: npx everdev contract deploy --network dev --value 1000000000 App  "},{"title":"Address smart-contract​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/getting-started#address-smart-contract","content":"Address of smart-contract is calculated from TVC and signer (coder) public: npx everdev contract info --network se --signer coder App  Getting only address: appAddress=$(npx everdev contract info --network se --signer coder App | grep Address | cut -d ' ' -f 4) echo $appAddress  "},{"title":"Interact with smart-contract​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/getting-started#interact-with-smart-contract","content":"Read: npx everdev contract run-local --network se App renderHelloWorld npx everdev contract run-local --network se App timestamp  Write: npx everdev contract run --network se --signer coder App touch  For more details see: Get started with Development Tools. "},{"title":"Migration Guide","type":0,"sectionRef":"#","url":"develop/smart-contract/migration-guide","content":"Migration Guide","keywords":""},{"title":"Verifying Smart Contract","type":0,"sectionRef":"#","url":"develop/smart-contract/verifying-smart-contract","content":"Verifying Smart Contract","keywords":""},{"title":"Issue a Fungible Token","type":0,"sectionRef":"#","url":"develop/smart-digital-assets/issue-ft","content":"","keywords":""},{"title":"Reference​","type":1,"pageTitle":"Issue a Fungible Token","url":"develop/smart-digital-assets/issue-ft#reference","content":"TIP-3 Core description "},{"title":"Mint a Non-Fungible Token","type":0,"sectionRef":"#","url":"develop/smart-digital-assets/mint-nft","content":"","keywords":""},{"title":"Reference​","type":1,"pageTitle":"Mint a Non-Fungible Token","url":"develop/smart-digital-assets/mint-nft#reference","content":"TIP-4 Core description "},{"title":"API","type":0,"sectionRef":"#","url":"develop/software/api","content":"API","keywords":""},{"title":"Ever OS CLI","type":0,"sectionRef":"#","url":"develop/software/everos-cli","content":"Ever OS CLI","keywords":""},{"title":"SDK","type":0,"sectionRef":"#","url":"develop/software/sdk","content":"SDK","keywords":""},{"title":"Multisignature Wallet","type":0,"sectionRef":"#","url":"develop/smart-contract/multisignature-wallet","content":"","keywords":""},{"title":"Glossary​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#glossary","content":"Multisignature wallet - crypto wallet on the blockchain, which supports multiple owners (custodians), who are authorized to manage the wallet. Wallet address - unique address of the wallet on the blockchain. It explicitly identifies the wallet and is required for any actions with the wallet to be performed. It does not, on its own, provide anyone access to wallet funds. Wallet custodian - authorized owner of the wallet. Owns the private key and corresponding seed phrase, which are required to make any changes to the wallet or wallet funds. Wallet may have more than one custodian. Custodian private key - the unique cryptographic key belonging to the wallet custodian, which authorizes access to the wallet. Should be kept secret. Custodian seed phrase - unique mnemonic phrase exactly corresponding to the custodian private key. Can be used to restore the private key, or to sign transactions in TONOS-CLI instead of it. Should be kept secret and securely backed up. Custodian public key - public key forming a cryptographic key pair with the custodian private key. It is not secret and may be freely shared with anyone. Validator - the entity performing validation of new blocks on the blockchain through a Proof-of-Stake system. Requires a multisignature wallet for staking. 2. Install TONOS-CLI "},{"title":"2.1. Install TONOS-CLI utility​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#21-install-tonos-cli-utility","content":""},{"title":"Install compiled executable​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#install-compiled-executable","content":"Create a folder. Download the .zip file from the latest release from here: https://github.com/tonlabs/tonos-cli/releases to this folder. Extract it. "},{"title":"Install through TONDEV​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#install-through-tondev","content":"You can use TONDEV to install the latest version of TONOS-CLI. tondev tonos-cli install  The installer requires NPM to be installed, so it can install packages globally without using sudo. In case of error, manually set environment variable PATH=$PATH:$HOME./tondev/solidity This command updates TONOS-CLI installed through TONDEV to the latest version: tondev tonos-cli update  This command specifies TONOS-CLI version to use and downloads it if needed: tondev tonos-cli set --version 0.8.0  "},{"title":"Build from source​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#build-from-source","content":"Refer to the TONOS-CLI readme for build from source procedure. "},{"title":"Tails OS secure environment​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#tails-os-secure-environment","content":"For maximum security while working with offline TONOS-CLI features (such as cryptographic commands or encrypted message generation), you can use the Tails OS. You can perform the following actions entirely offline: Generate seed phrases and custodian keysPepare deployment message offlinePrepare new transaction offlinePrepare transaction confirmation offline "},{"title":"A note on Windows syntax​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#a-note-on-windows-syntax","content":"When using Windows command line, the following syntax should be used for all TONOS-CLI commands: Never use the ./ symbols before tonos-cli: &gt; tonos-cli &lt;command_name&gt; &lt;options&gt;  For all commands with nested quotes, the outer single quotes should be changed to double quotes, and the inner double quotes should be shielded by a preceding \\. Example: &gt; tonos-cli deploy SafeMultisigWallet.tvc &quot;{\\&quot;owners\\&quot;:[\\&quot;0x723b2f0fa217cd10fe21326634e66106678f15d5a584babe4f576dffe9dcbb1b\\&quot;,\\&quot;0x127e3ca223ad429ddaa053a39fecd21131df173bb459a4438592493245b695a3\\&quot;,\\&quot;0xc2dd3682ffa9df97a968bef90b63da90fc92b22163f558b63cb7e52bfcd51bbb\\&quot;],\\&quot;reqConfirms\\&quot;:2}&quot; --abi SafeMultisigWallet.abi.json --sign deploy.keys.json  "},{"title":"2.2. Download contract files​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#22-download-contract-files","content":"Download compiled .abi.json and .tvc multisignature contract files from https://github.com/tonlabs/ton-labs-contracts/tree/master/solidity Choose a contract version: SafeMultisig - basic multisignature wallet, does not permit contract code modification. Is required if you use validator scripts. SafeMultisigWallet.abi.json direct link: https://raw.githubusercontent.com/tonlabs/ton-labs-contracts/master/solidity/safemultisig/SafeMultisigWallet.abi.json SafeMultisigWallet.tvc direct link: https://github.com/tonlabs/ton-labs-contracts/raw/master/solidity/safemultisig/SafeMultisigWallet.tvc SetcodeMultisig - more advanced multisignature wallet. SetcodeMultisigWallet.abi.json direct link: https://raw.githubusercontent.com/tonlabs/ton-labs-contracts/master/solidity/setcodemultisig/SetcodeMultisigWallet.abi.json SetcodeMultisigWallet.tvc direct link: https://github.com/tonlabs/ton-labs-contracts/raw/master/solidity/setcodemultisig/SetcodeMultisigWallet.tvc Place both files into the folder containing the tonos-cli executable. Note: Make sure you have downloaded the raw versions of the files. A common error when downloading from the github project page manually is to save the redirection page instead of the raw file.Note: TON Surf uses a specialized version of the SetcodeMultisig contract. It will not be possible to manage a standard Setcode wallet in TON Surf. "},{"title":"2.3. Configure TONOS-CLI environment​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#23-configure-tonos-cli-environment","content":"(Optional, Linux/Mac OS, if you didn't install through tondev) Put tonos-cli into system environment: export PATH=&quot;&lt;tonos_folder_path&gt;:$PATH&quot;  If you skip this step and didn't install through tondev, make sure you run the utility from the utility folder: ./tonos-cli &lt;command&gt; &lt;options&gt;  Use the following command to set the network: tonos-cli config --url &lt;https://network_url&gt;  Some of the frequently used networks: https://net.ton.dev - developer sandbox for testing. https://main.ton.dev - main Free TON network. https://rustnet.ton.dev - test network running on Rust nodes. You need to do it only once before using the utility. tonos-cli.conf.json configuration file will be created in the current folder. The URL of the current network will be specified there. All subsequent calls of the utility will use this file to select the network to connect to. Note: By default tonos-cli connects to net.ton.dev network.Note: Always run tonos-cli utility only from the folder where tonos-cli.conf.json is placed, unless you have configured a different path for the file. Refer to the TONOS-CLI document for additional information. 3. Use the following command to check the set network:  tonos-cli config --list  For additional configuration options, refer to the TONOS-CLI readme. 3. Create Wallet The following actions should be performed to create a wallet: Create wallet seed phraseGenerate deployment key pair file with wallet private/public keys based on the wallet seed phraseGenerate wallet address based on the wallet seed phraseSend some tokens to the wallet addressDeploy wallet (set custodians) All of these steps are detailed in this section. "},{"title":"3.1. Create seed phrases and public keys for all custodians​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#31-create-seed-phrases-and-public-keys-for-all-custodians","content":""},{"title":"3.1.1. Create wallet seed phrase​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#311-create-wallet-seed-phrase","content":"To generate your seed phrase enter the following command: tonos-cli genphrase  Terminal displays the generated seed phrase. Example: $ tonos-cli genphrase Config: /home/user/tonos-cli.conf.json Succeeded. Seed phrase: &quot;rule script joy unveil chaos replace fox recipe hedgehog heavy surge online&quot;  Note: Seed phrases should be created for every custodian of the multisignature wallet. The seed phrase ensures access to the multisignature wallet. If lost, the custodian will no longer be able to manage the wallet. The seed phrase is unique for every custodian and should be kept secret and securely backed up (word order matters). 3.1.2. Generate public key​ To generate your public key enter the following command with your previously generated seed phrase in quotes: tonos-cli genpubkey &quot;&lt;seed_phrase&gt;&quot;  Example: $ tonos-cli genpubkey &quot;rule script joy unveil chaos replace fox recipe hedgehog heavy surge online&quot; Config: /home/user/tonos-cli.conf.json Succeeded. Public key: 88c541e9a1c173069c89bcbcc21fa2a073158c1bd21ca56b3eb264bba12d9340 &lt;QR code with key&gt;  Copy the generated code from Terminal or scan the QR code containing the code with your phone and send it to whichever custodian is responsible for deploying the multisignature wallet. Note: The public key should also be generated for every custodian. The public key is not secret and can be freely transmitted to anyone. 3.2. Generate deployment key pair file​ Any custodian who has received the public keys of all other custodians can deploy the multisignature wallet to the blockchain. To create the key pair file from the seed phrase generated at step 3.1.1 use the following command: tonos-cli getkeypair &lt;deploy.keys.json&gt; &quot;&lt;seed_phrase&gt;&quot;  &lt;deploy.keys.json&gt; - the file the key pair will be written to. The utility generates the file that contains the key pair produced from seed phrase. $ tonos-cli getkeypair key.json &quot;rule script joy unveil chaos replace fox recipe hedgehog heavy surge online&quot; Config: /home/user/tonos-cli.conf.json Input arguments: key_file: key.json phrase: rule script joy unveil chaos replace fox recipe hedgehog heavy surge online Succeeded.  "},{"title":"3.3. Generate wallet address​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#33-generate-wallet-address","content":"Use deployment key pair file to generate your address: tonos-cli genaddr &lt;MultisigWallet.tvc&gt; &lt;MultisigWallet.abi.json&gt; --setkey &lt;deploy.keys.json&gt; --wc &lt;workchain_id&gt;  &lt;MultisigWallet.tvc&gt; - either SafeMultisigWallet.tvc or SetcodeMultisigWallet.tvc depending on the contract you have selected at step 2.2. &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2. &lt;deploy.keys.json&gt; - the file the key pair is read from. --wc &lt;workchain_id&gt; - (optional) ID of the workchain the wallet will be deployed to (-1 for masterchain, 0 for basechain). By default this value is set to 0. Note: Masterchain fees are significantly higher, but masterchain is required for direct staking validator wallets. Make sure to set workchain ID to -1 for any direct staking validator wallets you are deploying: --wc -1. Basechain, on the other hand, is best suited for user wallets and validator wallets that are staking through a DePool. The utility displays the new multisignature wallet address (Raw_address). Example: $ tonos-cli genaddr --genkey key.json --wc -1 SafeMultisigWallet.tvc SafeMultisigWallet.abi.json Config: /home/user/tonos-cli.conf.json Input arguments: tvc: SafeMultisigWallet.tvc wc: -1 keys: key.json init_data: None is_update_tvc: None Seed phrase: &quot;chimney nice diet engage hen sing vocal upgrade column address consider word&quot; Raw address: -1:a021414a79539001ed35d615a646dc8b89df29ccccf143c30df15c7fbcaff086 testnet: Non-bounceable address (for init): 0f-gIUFKeVOQAe011hWmRtyLid8pzMzxQ8MN8Vx_vK_whkeM Bounceable address (for later access): kf-gIUFKeVOQAe011hWmRtyLid8pzMzxQ8MN8Vx_vK_whhpJ mainnet: Non-bounceable address (for init): Uf-gIUFKeVOQAe011hWmRtyLid8pzMzxQ8MN8Vx_vK_whvwG Bounceable address (for later access): Ef-gIUFKeVOQAe011hWmRtyLid8pzMzxQ8MN8Vx_vK_whqHD Succeeded  Note: The wallet address is required for any interactions with the wallet. It should be shared with all wallet custodians. "},{"title":"3.4. Send tokens to the new address from another wallet​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#34-send-tokens-to-the-new-address-from-another-wallet","content":"Use the following command to create a new transaction from another existing wallet: tonos-cli call &lt;source_address&gt; submitTransaction '{&quot;dest&quot;:&quot;&lt;raw_address&gt;&quot;,&quot;value&quot;:&lt;nanotokens&gt;,&quot;bounce&quot;:false,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;}' --abi &lt;MultisigWallet.abi.json&gt; --sign &quot;&lt;source_seed_or_keyfile&gt;&quot;  &lt;source_address&gt; - address of the wallet the funds are sent from. &quot;dest&quot;:&lt;raw_address&gt; - new wallet address generated at step 3.3. Example: &quot;0:f22e02a1240dd4b5201f8740c38f2baf5afac3cedf8f97f3bd7cbaf23c7261e3&quot; &quot;value&quot;: - amount of tokens to transfer in nanotokens (Example: &quot;value&quot;:10000000000 sets up a transfer of 10 tokens). &quot;bounce&quot; - use false to transfer funds to a non-existing contract to create it. &quot;payload&quot; - use &quot;&quot; for simple transfer. Otherwise payload is used as a body of outbound internal message. &quot;allBalance&quot; - used to transfer all funds in the wallet. Use false for a simple transfer. Note: Due to a bug setting allBalance to true currently causes errors. Single-custodian multisig wallets may use sendTransaction method with flag 130 and value 0 instead: tonos-cli call &lt;multisig_address&gt; sendTransaction '{&quot;dest&quot;:&quot;raw_address&quot;,&quot;value&quot;:0,&quot;bounce&quot;:true,&quot;flags&quot;:130,&quot;payload&quot;:&quot;&quot;}' --abi &lt;MultisigWallet.abi.json&gt; --sign &lt;seed_or_keyfile&gt; &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2. &quot;&lt;source_seed_or_keyfile&gt;&quot; - seed phrase in quotes or path to keyfile of the source wallet. Example: $ tonos-cli call 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc submitTransaction '{&quot;dest&quot;:&quot;-1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;,&quot;value&quot;:234000000,&quot;bounce&quot;:false,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;}' --abi SetcodeMultisigWallet.abi.json --sign k1.keys.json Config: /home/user/tonos-cli.conf.json Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: submitTransaction params: {&quot;dest&quot;:&quot;-1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;,&quot;value&quot;:234000000,&quot;bounce&quot;:false,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;} abi: SetcodeMultisigWallet.abi.json keys: k1.keys.json lifetime: None output: None Connecting to net.ton.dev Generating external inbound message... MessageId: c6baac843fefe6b9e8dc3609487a63ef21207e4fdde9ec253b9a47f7f5a88d01 Expire at: Sat, 08 May 2021 14:52:23 +0300 Processing... Succeeded. Result: { &quot;transId&quot;: &quot;6959885776551137793&quot; }  If the sponsoring wallet has multiple custodians, the transaction may require confirmation from its other custodians. To confirm the transaction use the following command: tonos-cli call &lt;source_address&gt; confirmTransaction '{&quot;transactionId&quot;:&quot;&lt;id&gt;&quot;}' --abi &lt;MultisigWallet.abi.json&gt; --sign &quot;&lt;source_seed_or_keyfile&gt;&quot;  &lt;source_address&gt; - address of the wallet to funds are sent from. &quot;&lt;source_seed_or_keyfile&gt;&quot; - seed phrase in quotes or path to keyfile of the source wallet. transactionId – the ID of the transaction transferring tokens to the new wallet. &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2. Example: $ tonos-cli call 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc confirmTransaction '{&quot;transactionId&quot;:&quot;6981478983724354305&quot;}' --abi SetcodeMultisigWallet.abi.json --sign k2.keys.json Config: default Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: confirmTransaction params: {&quot;transactionId&quot;:&quot;6981478983724354305&quot;} abi: SetcodeMultisigWallet.abi.json keys: k2.keys.json lifetime: None output: None Connecting to https://net.ton.dev Generating external inbound message... MessageId: 322e1efffedf73c8009b84a103dd3fdc205796eb4d88a912fa13d931ce9e7c9c Expire at: Mon, 05 Jul 2021 19:28:08 +0300 Processing... Succeeded. Result: {}  Ensure that the new wallet has been created in the blockchain and has Uninit status: tonos-cli account &lt;multisig_address&gt;  &lt;multisig_address&gt; - new wallet address generated at step 3.3. "},{"title":"3.5. Deploy wallet (set custodians)​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#35-deploy-wallet-set-custodians","content":""},{"title":"3.5.1. Deploy the wallet to blockchain​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#351-deploy-the-wallet-to-blockchain","content":"Use the following command: tonos-cli deploy &lt;MultisigWallet.tvc&gt; '{&quot;owners&quot;:[&quot;0x...&quot;, ...],&quot;reqConfirms&quot;:N}' --abi &lt;MultisigWallet.abi.json&gt; --sign &lt;deploy_seed_or_keyfile&gt; --wc &lt;workchain_id&gt;  Configuration parameters: &lt;MultisigWallet.tvc&gt; - either SafeMultisigWallet.tvc or SetcodeMultisigWallet.tvc depending on the contract you have selected at step 2.2. &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2. owners - array of custodian public keys generated by all wallet custodians at step 3.1.2 as uint256 numbers. Make sure all public keys are enclosed in quotes and start with 0x.... Example: &quot;owners&quot;:[&quot;0x8868adbf012ebc349ced852fdcf5b9d55d1873a68250fae1be609286ddb962582&quot;, &quot;0xa0e16ccff0c7bf4f29422b33ec1c9187200e9bd949bb2dd4c7841f5009d50778a&quot;] reqConfirms - number of signatures needed to confirm a transaction ( 0 &lt; N ≤ custodian count). --wc &lt;workchain_id&gt; - (optional) ID of the workchain the wallet will be deployed to (-1 for masterchain, 0 for basechain). By default this value is set to 0. Note: Masterchain fees are significantly higher, but masterchain is required for validator wallets. Make sure to set workchain ID to -1 for any validator wallets you are deploying: --wc -1. Basechain, on the other hand, is best suited for user wallets.&lt;deploy_seed_or_keyfile&gt; - can either be the seed phrase used in step 3.2 to generate the deployment key pair file or the deploy.keys.json file itself. If seed phrase is used, enclose it in double quotes. Example: --sign &quot;flip uncover dish sense hazard smile gun mom vehicle chapter order enact&quot; or --sign deploy.keys.json Deploying a wallet without at least one custodian is not possible, since every transaction from a wallet has to be signed by one or more custodians (depending on wallet configuration) with their private key or equivalent seed phrase. It is a basic security requirement of the system. Example: $ tonos-cli deploy --sign key.json --wc -1 --abi SafeMultisigWallet.abi.json SafeMultisigWallet.tvc '{&quot;owners&quot;:[&quot;0x88c541e9a1c173069c89bcbcc21fa2a073158c1bd21ca56b3eb264bba12d9340&quot;],&quot;reqConfirms&quot;:1}' Config: /home/user/tonos-cli.conf.json Input arguments: tvc: SafeMultisigWallet.tvc params: {&quot;owners&quot;:[&quot;0x88c541e9a1c173069c89bcbcc21fa2a073158c1bd21ca56b3eb264bba12d9340&quot;],&quot;reqConfirms&quot;:1} abi: SafeMultisigWallet.abi.json keys: key.json wc: -1 Connecting to net.ton.dev Deploying... Transaction succeeded. Contract deployed at address: -1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6  Note: After a SafeMultisig wallet is deployed, for reasons of security you cannot add or remove custodians from it. If you want to change the custodian list, you have to create a new wallet, transfer all funds there, and set the new list of custodians. 3.5.2. Check that the wallet is active​ Check the new wallet status again. Now it should be Active. tonos-cli account &lt;multisig_address&gt;  "},{"title":"3.5.3. Request the list of custodian public keys from the blockchain​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#353-request-the-list-of-custodian-public-keys-from-the-blockchain","content":"Verify that they match the keys you have loaded during deploy. tonos-cli run &lt;multisig_address&gt; getCustodians {} --abi SafeMultisigWallet.abi.json  The wallet is deployed and the owners of the listed public keys have access to it. Example: $ tonos-cli run 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc getCustodians {} --abi SetcodeMultisigWallet.abi.json Config: default Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: getCustodians params: {} abi: SetcodeMultisigWallet.abi.json keys: None lifetime: None output: None Connecting to https://net.ton.dev Generating external inbound message... MessageId: 6c3daeeea601ef6c81a516079a3cec2210fea278a06cc7bb118b4529f154e5d7 Expire at: Mon, 05 Jul 2021 19:31:47 +0300 Running get-method... Succeeded. Result: { &quot;custodians&quot;: [ { &quot;index&quot;: &quot;1&quot;, &quot;pubkey&quot;: &quot;0x154bc7ed3088294e4e767e2e7183f43d62bcec820c58a30e2ec730f0bb8792a3&quot; }, { &quot;index&quot;: &quot;4&quot;, &quot;pubkey&quot;: &quot;0x18331765f53c6a50aa3a348fa4536e6f632798d81ff59281aae21d9b5f86a21c&quot; }, { &quot;index&quot;: &quot;3&quot;, &quot;pubkey&quot;: &quot;0x6ee6539d0d8a3800d7525922c25b64874e0645340f2b43a2cb277db458b42fa4&quot; }, { &quot;index&quot;: &quot;0&quot;, &quot;pubkey&quot;: &quot;0x849ee401fde65ad8cda6d937bdc81e2beba0f36ba2f87115f4a2d24a15568203&quot; }, { &quot;index&quot;: &quot;2&quot;, &quot;pubkey&quot;: &quot;0x9ef666feaacf1d65c78af3b1c099c5096aa2e26afc21346fd66b8e7d5d9d6224&quot; } ] }  4. Manage Wallet "},{"title":"4.1. Select blockchain network​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#41-select-blockchain-network","content":"There are two networks currently available: Some of the frequently used networks: https://net.ton.dev - developer sandbox for testing. https://main.ton.dev - main Free TON network. https://rustnet.ton.dev - test network running on Rust nodes. Use the following command to switch to any of these networks: tonos-cli config --url &lt;https://network_url&gt;  You need to do it only once before using the utility. A .json configuration file will be created in the current folder. The URL of the current network will be specified there. All subsequent calls of the utility will use this file to select the network to connect to. "},{"title":"4.2. Convert tokens to nanotokens​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#42-convert-tokens-to-nanotokens","content":"Amounts in most multisig wallet commands are indicated in nanotokens. To convert tokens to nanotokens use the following command: tonos-cli convert tokens &lt;amount&gt;  Example: $ tonos-cli convert tokens 125.8 Config: /home/user/tonos-cli.conf.json 125800000000  "},{"title":"4.3. Check wallet balance and status​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#43-check-wallet-balance-and-status","content":""},{"title":"4.3.1. Check wallet balance and status with TONOS-CLI​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#431-check-wallet-balance-and-status-with-tonos-cli","content":"You may use the following command to check the current status and balance of your wallet: tonos-cli account &lt;multisig_address&gt;  It displays the wallet status: Not found – if the wallet does not existUninit – wallet was created, but contract code wasn’t deployedActive – wallet exists and has the contract code and data It also displays the wallet balance, time of the most recent transaction, contract data block, data in boc format and code hash (which is unique for every contract type). Example: $ tonos-cli account 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc Config: default Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc Connecting to https://net.ton.dev Processing... Succeeded. acc_type: Active balance: 236565978364 nanoton last_paid: 1625502429 last_trans_lt: 0x9274fd9102 data(boc): b5ee9c7201020d010001b10003df849ee401fde65ad8cda6d937bdc81e2beba0f36ba2f87115f4a2d24a155682030000017a777eac3bc24f7200fef32d6c66d36c9bdee40f15f5d079b5d17c388afa5169250aab4101800000000000000000000000000000000000000000000000000000000000000082800000000182700c0a01020120050202016204030043bf3bd99bfaab3c75971e2bcec702671425aa8b89abf084d1bf59ae39f5767588900a0043bf127b9007f7996b63369b64def72078afae83cdae8be1c457d28b4928555a080c0202012007060044bfaee6539d0d8a3800d7525922c25b64874e0645340f2b43a2cb277db458b42fa40302016609080043bec198bb2fa9e3528551d1a47d229b737b193cc6c0ffac940d5710ecdafc3510e0240043beea5e3f6984414a7273b3f1738c1fa1eb15e7641062c5187176398785dc3c95180c01d7a030719912b7df6580b0719912b7df6580800000018201424f7200fef32d6c66d36c9bdee40f15f5d079b5d17c388afa5169250aab410180400255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f30000000000000000000000000df28e800003c0b0000000140 code_hash: e2b60b6b602c10ced7ea8ede4bdf96342c97570a3798066f3fb50a4b2b27a208  SafeMultisig code hash is 80d6c47c4a25543c9b397b71716f3fae1e2c5d247174c52e2c19bd896442b105 SetcodeMultisig code hash is e2b60b6b602c10ced7ea8ede4bdf96342c97570a3798066f3fb50a4b2b27a208 "},{"title":"4.3.2. Check wallet balance and status in the blockchain explorer​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#432-check-wallet-balance-and-status-in-the-blockchain-explorer","content":"The detailed status of the account can also be viewed in the ton.live blockchain explorer. Select the network the wallet is deployed to and enter the raw address of the wallet into the main search field. Account status, balance, message and transaction history for the account will be displayed. "},{"title":"4.4. List custodian public keys​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#44-list-custodian-public-keys","content":"The following command displays the list of public keys, the owners of which have rights to manage the wallet: tonos-cli run &lt;multisig_address&gt; getCustodians {} --abi &lt;MultisigWallet.abi.json&gt;  Example: $ tonos-cli run 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc getCustodians {} --abi SetcodeMultisigWallet.abi.json Config: default Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: getCustodians params: {} abi: SetcodeMultisigWallet.abi.json keys: None lifetime: None output: None Connecting to https://net.ton.dev Generating external inbound message... MessageId: 6c3daeeea601ef6c81a516079a3cec2210fea278a06cc7bb118b4529f154e5d7 Expire at: Mon, 05 Jul 2021 19:31:47 +0300 Running get-method... Succeeded. Result: { &quot;custodians&quot;: [ { &quot;index&quot;: &quot;1&quot;, &quot;pubkey&quot;: &quot;0x154bc7ed3088294e4e767e2e7183f43d62bcec820c58a30e2ec730f0bb8792a3&quot; }, { &quot;index&quot;: &quot;4&quot;, &quot;pubkey&quot;: &quot;0x18331765f53c6a50aa3a348fa4536e6f632798d81ff59281aae21d9b5f86a21c&quot; }, { &quot;index&quot;: &quot;3&quot;, &quot;pubkey&quot;: &quot;0x6ee6539d0d8a3800d7525922c25b64874e0645340f2b43a2cb277db458b42fa4&quot; }, { &quot;index&quot;: &quot;0&quot;, &quot;pubkey&quot;: &quot;0x849ee401fde65ad8cda6d937bdc81e2beba0f36ba2f87115f4a2d24a15568203&quot; }, { &quot;index&quot;: &quot;2&quot;, &quot;pubkey&quot;: &quot;0x9ef666feaacf1d65c78af3b1c099c5096aa2e26afc21346fd66b8e7d5d9d6224&quot; } ] }  "},{"title":"4.5. List transactions awaiting confirmation​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#45-list-transactions-awaiting-confirmation","content":"Use the following command to list the transactions currently awaiting custodian confirmation: tonos-cli run &lt;multisig_address&gt; getTransactions {} --abi &lt;MultisigWallet.abi.json&gt;  If there are some transactions requiring confirmation, they will be displayed. Example: $ tonos-cli run 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc getTransactions {} --abi SafeMultisigWallet.abi.json Config: /home/user/tonos-cli.conf.json Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: getTransactions params: {} abi: SafeMultisigWallet.abi.json keys: None lifetime: None output: None Connecting to net.ton.dev Generating external inbound message... MessageId: ff8b8a73b1a7803a735eb4f620cade78ed45fd1530992fd3bedb91f3c66eacc5 Expire at: Sat, 08 May 2021 15:16:59 +0300 Running get-method... Succeeded. Result: { &quot;transactions&quot;: [ { &quot;id&quot;: &quot;6959890394123980993&quot;, &quot;confirmationsMask&quot;: &quot;1&quot;, &quot;signsRequired&quot;: &quot;4&quot;, &quot;signsReceived&quot;: &quot;1&quot;, &quot;creator&quot;: &quot;0x849ee401fde65ad8cda6d937bdc81e2beba0f36ba2f87115f4a2d24a15568203&quot;, &quot;index&quot;: &quot;0&quot;, &quot;dest&quot;: &quot;-1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;, &quot;value&quot;: &quot;234000000&quot;, &quot;sendFlags&quot;: &quot;3&quot;, &quot;payload&quot;: &quot;te6ccgEBAQEAAgAAAA==&quot;, &quot;bounce&quot;: false } ] }  "},{"title":"4.6. Create transaction online​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#46-create-transaction-online","content":"Use the following command to create a new transaction: tonos-cli call &lt;multisig_address&gt; submitTransaction '{&quot;dest&quot;:&quot;raw_address&quot;,&quot;value&quot;:&lt;nanotokens&gt;,&quot;bounce&quot;:true,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;}' --abi &lt;MultisigWallet.abi.json&gt; --sign &lt;seed__or_keyfile&gt;  &quot;dest&quot; - raw address of a destination smart contract. Example: &quot;0:f22e02a1240dd4b5201f8740c38f2baf5afac3cedf8f97f3bd7cbaf23c7261e3&quot; &quot;value&quot;: - amount of tokens to transfer in nanotokens (Example: &quot;value&quot;:10000000000 sets up a transfer of 10 tokens). &quot;bounce&quot; - use false to transfer funds to a non-existing contract to create it. Use true to transfer funds to an Active contract. Note: at step [3.4]](#34-send-tokens-to-the-new-address-from-another-wallet) of the wallet deployment procedure use false.&quot;payload&quot; - use &quot;&quot; for simple transfer. Otherwise payload is used as a body of outbound internal message. &quot;allBalance&quot; - used to transfer all funds in the wallet. Use false for a simple transfer. Note: Due to a bug setting allBalance to true currently causes errors. Single-custodian multisig wallets may use sendTransaction method with flag 130 and value 0 instead: tonos-cli call &lt;multisig_address&gt; sendTransaction '{&quot;dest&quot;:&quot;raw_address&quot;,&quot;value&quot;:0,&quot;bounce&quot;:true,&quot;flags&quot;:130,&quot;payload&quot;:&quot;&quot;}' --abi &lt;MultisigWallet.abi.json&gt; --sign &lt;seed_or_keyfile&gt; &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2. &lt;seed_or_keyfile&gt; - can either be the custodian seed phrase or the corresponding custodian key pair file. If seed phrase is used, enclose it in double quotes. Example: --sign &quot;flip uncover dish sense hazard smile gun mom vehicle chapter order enact&quot; or --sign keyfile.json If the wallet has multiple custodians and more than one custodian signature is required to execute a transaction, the new transaction is queued in the wallet and waits for the necessary amount of confirmations. Otherwise it is executed immediately. Example: $ tonos-cli call 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc submitTransaction '{&quot;dest&quot;:&quot;-1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;,&quot;value&quot;:234000000,&quot;bounce&quot;:true,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;}' --abi SetcodeMultisigWallet.abi.json --sign k1.keys.json Config: /home/user/tonos-cli.conf.json Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: submitTransaction params: {&quot;dest&quot;:&quot;-1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;,&quot;value&quot;:234000000,&quot;bounce&quot;:true,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;} abi: SetcodeMultisigWallet.abi.json keys: k1.keys.json lifetime: None output: None Connecting to net.ton.dev Generating external inbound message... MessageId: c6baac843fefe6b9e8dc3609487a63ef21207e4fdde9ec253b9a47f7f5a88d01 Expire at: Sat, 08 May 2021 14:52:23 +0300 Processing... Succeeded. Result: { &quot;transId&quot;: &quot;6959885776551137793&quot; }  Note: For maximum security you may also create a transaction message on a machine without internet connection in offline mode. See section 4.8. "},{"title":"4.6.1. Alternative command to create transaction online​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#461-alternative-command-to-create-transaction-online","content":"TONOS-CLI supports alterbative syntax for this command, which does not use quotes and brackets to list parameters and may be more convenient: tonos-cli callex submitTransaction &lt;multisig_address&gt; &lt;MultisigWallet.abi.json&gt; &lt;seed_or_keyfile&gt; --dest &lt;raw_address&gt; --value &lt;tokens&gt;T --bounce &lt;true|false&gt; --allBalance &lt;true|false&gt; --payload &quot;&quot;  &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2. &lt;seed_or_keyfile&gt; - can either be the custodian seed phrase or the corresponding custodian key pair file. If seed phrase is used, enclose it in double quotes. Example: &quot;flip uncover dish sense hazard smile gun mom vehicle chapter order enact&quot; or keyfile.json &lt;raw_address&gt; - raw address of a destination smart contract. Example: 0:f22e02a1240dd4b5201f8740c38f2baf5afac3cedf8f97f3bd7cbaf23c7261e3 value - amount of tokens to transfer: in nanotokens, if specified without the T suffix, or in tokens, if specified with it (Example: --value 10500000000 and --value 10.5T are the same value of 10.5 tokens). bounce - use false to transfer funds to a non-existing contract to create it. Use true to transfer funds to an Active contract. Note: at step 3.4 of the wallet deployment procedure use false.payload - use &quot;&quot; for simple transfer. Otherwise payload is used as a body of outbound internal message. allBalance - used to transfer all funds in the wallet. Use false for a simple transfer. Note: Due to a bug setting allBalance to true currently causes errors. Single-custodian multisig wallets may use sendTransaction method with flag 130 and value 0 instead: tonos-cli callex sendTransaction &lt;multisig_address&gt; &lt;MultisigWallet.abi.json&gt; &lt;seed_or_keyfile&gt; --dest &lt;raw_address&gt; --value 0 --bounce &lt;true|false&gt; --flags 130 --payload &quot;&quot; Example: $ tonos-cli callex submitTransaction 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc SetcodeMultisigWallet.abi.json k1.keys.json --dest -1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6 --value 0.234T --bounce false --allBalance false --payload &quot;&quot; Config: /home/user/tonos-cli.conf.json Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: submitTransaction params: {&quot;dest&quot;:&quot;-1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;,&quot;value&quot;:&quot;0234000000&quot;,&quot;bounce&quot;:&quot;false&quot;,&quot;allBalance&quot;:&quot;false&quot;,&quot;payload&quot;:&quot;&quot;} abi: SetcodeMultisigWallet.abi.json keys: k1.keys.json Connecting to net.ton.dev Generating external inbound message... MessageId: a38f37bfbe3c7427c869b3ee97c3b2d7f4421ca1427ace4e7a92f1a61d7ef234 Expire at: Sat, 08 May 2021 15:10:15 +0300 Processing... Succeeded. Result: { &quot;transId&quot;: &quot;6959890394123980993&quot; }  "},{"title":"4.7. Create transaction confirmation online​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#47-create-transaction-confirmation-online","content":"Once one of the custodians creates a new transaction on the blockchain, it has to get the required number of confirmations from other custodians. To confirm a transaction, use the following command: tonos-cli call &lt;multisig_address&gt; confirmTransaction '{&quot;transactionId&quot;:&quot;&lt;id&gt;&quot;}' --abi &lt;MultisigWallet.abi.json&gt; --sign &lt;seed_or_keyfile&gt;  transactionId – the ID of the transaction can be acquired from the custodian who created it, or by requesting the list of transactions awaiting confirmation from the multisignature wallet. &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2. &lt;seed_or_keyfile&gt; - can either be the custodian seed phrase or the corresponding custodian key pair file. If seed phrase is used, enclose it in double quotes. Example: --sign &quot;flip uncover dish sense hazard smile gun mom vehicle chapter order enact&quot; or --sign keyfile.json Note: If the wallet has only one custodian, or if the number of confirmations required to perform a transaction was set to 1, this action won't be necessary. The transaction will be confirmed automatically. Example: $ tonos-cli call 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc confirmTransaction '{&quot;transactionId&quot;:&quot;6981478983724354305&quot;}' --abi SetcodeMultisigWallet.abi.json --sign k2.keys.json Config: default Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: confirmTransaction params: {&quot;transactionId&quot;:&quot;6981478983724354305&quot;} abi: SetcodeMultisigWallet.abi.json keys: k2.keys.json lifetime: None output: None Connecting to https://net.ton.dev Generating external inbound message... MessageId: 322e1efffedf73c8009b84a103dd3fdc205796eb4d88a912fa13d931ce9e7c9c Expire at: Mon, 05 Jul 2021 19:28:08 +0300 Processing... Succeeded. Result: {}  Note: For maximum security you may also create a transaction confirmation message on a machine without internet connection in offline mode. See section 4.9 4.7.1. Alternative command to confirm transaction online​ TONOS-CLI supports alterbative syntax for this command, which does not use quotes and brackets to list parameters and may be more convenient: tonos-cli callex confirmTransaction &lt;multisig_address&gt; &lt;MultisigWallet.abi.json&gt; &lt;seed_or_keyfile&gt; --transactionId &lt;id&gt;  &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2. &lt;seed_or_keyfile&gt; - can either be the custodian seed phrase or the corresponding custodian key pair file. If seed phrase is used, enclose it in double quotes. Example: &quot;flip uncover dish sense hazard smile gun mom vehicle chapter order enact&quot; or keyfile.json &lt;id&gt; - ID of the transaction that should be confirmed. Example: $ tonos-cli callex confirmTransaction 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc SetcodeMultisigWallet.abi.json k2.keys.json --transactionId 6982528395137505473 Config: default Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: confirmTransaction params: {&quot;transactionId&quot;:&quot;6982528395137505473&quot;} abi: SetcodeMultisigWallet.abi.json keys: k2.keys.json Connecting to https://net.ton.dev Generating external inbound message... MessageId: 00048660c32d95313eeee7e09d89679e0c68f9a7660794736ba399c4c5fab011 Expire at: Thu, 08 Jul 2021 15:26:26 +0300 Processing... Succeeded. Result: {}  "},{"title":"4.8. Create new transaction offline​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#48-create-new-transaction-offline","content":"An internet connection is not required to create a signed transaction message. Use the following command to do it: tonos-cli message &lt;multisig_address&gt; submitTransaction '{&quot;dest&quot;:&quot;raw_address&quot;,&quot;value&quot;:&lt;nanotokens&gt;,&quot;bounce&quot;:true,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;}' --abi &lt;MultisigWallet.abi.json&gt; --sign &lt;seed_or_keyfile&gt; --lifetime 3600  &quot;dest&quot; - raw address of a destination smart contract. Example: &quot;0:f22e02a1240dd4b5201f8740c38f2baf5afac3cedf8f97f3bd7cbaf23c7261e3&quot;. &quot;value&quot;: - amount of tokens to transfer in nanotokens (Example: &quot;value&quot;:10000000000 sets up a transfer of 10 tokens). &quot;bounce&quot; - use false to transfer funds to a non-existing contract to create it. Use true to transfer funds to an Active contract. &quot;payload&quot; - use &quot;&quot; for simple transfer. Otherwise payload is used as a body of outbound internal message. &quot;allBalance&quot; - used to transfer all funds in the wallet. Use false for a simple transfer. Note: Due to a bug setting allBalance to true currently causes errors. Single-custodian multisig wallets may use sendTransaction method with flag 130 and value 0 instead: tonos-cli message &lt;multisig_address&gt; sendTransaction '{&quot;dest&quot;:&quot;raw_address&quot;,&quot;value&quot;:0,&quot;bounce&quot;:true,&quot;flags&quot;:130,&quot;payload&quot;:&quot;&quot;}' --abi &lt;MultisigWallet.abi.json&gt; --sign &lt;seed_or_keyfile&gt; --lifetime 3600 &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2. &lt;seed_or_keyfile&gt; - can either be the custodian seed phrase or the corresponding custodian key pair file. If seed phrase is used, enclose it in double quotes. Example: --sign &quot;flip uncover dish sense hazard smile gun mom vehicle chapter order enact&quot; or --sign keyfile.json lifetime – message lifetime in seconds. Once this time elapses, the message will not be accepted by the contract. The TONOS-CLI utility displays encrypted message text and a QR code that contains the submitTransaction message. Example: $ tonos-cli message 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc submitTransaction '{&quot;dest&quot;:&quot;0:255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f3&quot;,&quot;value&quot;:567000000,&quot;bounce&quot;:true,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;}' --abi SetcodeMultisigWallet.abi.json --sign k1.keys.json --lifetime 3600 Config: default Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: submitTransaction params: {&quot;dest&quot;:&quot;0:255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f3&quot;,&quot;value&quot;:567000000,&quot;bounce&quot;:true,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;} abi: SetcodeMultisigWallet.abi.json keys: k1.keys.json lifetime: 3600 output: None Generating external inbound message... MessageId: 649e36ac7d656d1ce99f3e8b235074ff2483e115596a0233caacdf0c4ccf78a1 Expire at: Thu, 08 Jul 2021 16:32:45 +0300 Message: 7b226d7367223a7b226d6573736167655f6964223a2236343965333661633764363536643163653939663365386232333530373466663234383365313135353936613032333363616163646630633463636637386131222c226d657373616765223a227465366363674542424145413051414252596742534d553677767679593746624464704a365a5748706b4c7846304545726f4b4a36775165555369536633674d415148686d4733712f3553464e2f79317a703749337433586243796874586a51734b48763437654e657479504f6e46524b3939487a444c7974644754307a4e784a50314e3964544a4c444f6766496a2b556f57784c366571686d456e7551422f655a61324d326d32546539794234723636447a61364c34635258306f744a4b46566143417741414158714747793062594f622b66524d64677332414341574f41424b7448577a763146556e6d6b44437456666a36382b6a366f45436a495871734b4f4a77364230324c763567414141414141414141414141414141454f58643446414d4141413d3d222c22657870697265223a313632353735313136352c2261646472657373223a22303a61343632396436313764663933316438616438366564323466346361633364333231373838626130383235373431343466353832306632383934343933666263227d2c226d6574686f64223a227375626d69745472616e73616374696f6e227d &lt;Message QR code&gt;  Copy the message text or scan the QR code and broadcast the message online. "},{"title":"4.9. Create transaction confirmation offline​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#49-create-transaction-confirmation-offline","content":"Once one of the custodians creates a new transaction on the blockchain, it has to get the required number of confirmations from other custodians. To create a confirmation message offline use the following command: tonos-cli message &lt;multisig_address&gt; confirmTransaction '{&quot;transactionId&quot;:&quot;&lt;id&gt;&quot;}' --abi &lt;MultisigWallet.abi.json&gt; --sign &quot;&lt;seed_or_keyfile&gt;&quot; --lifetime 600  transactionId – the ID of the transaction can be acquired from the custodian who created it, or by requesting the list of transactions awaiting confirmation from the multisignature wallet. &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2. &lt;seed_or_keyfile&gt; - can either be the custodian seed phrase or the corresponding custodian key pair file. If seed phrase is used, enclose it in double quotes. Example: --sign &quot;flip uncover dish sense hazard smile gun mom vehicle chapter order enact&quot; or --sign keyfile.json lifetime – message lifetime in seconds. Once this time elapses, the message will not be accepted by the contract. The TONOS-CLI utility displays encrypted transaction text and a QR code that contains the confirmTransaction message. Example: $ tonos-cli message 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc confirmTransaction '{&quot;transactionId&quot;:&quot;6982528395137505473&quot;}' --abi SetcodeMultisigWallet.abi.json --sign k3.keys.json --lifetime 600 Config: default Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: confirmTransaction params: {&quot;transactionId&quot;:&quot;6982528395137505473&quot;} abi: SetcodeMultisigWallet.abi.json keys: k3.keys.json lifetime: 600 output: None Generating external inbound message... MessageId: 1751be3063638271c2590ede75d71bfaa48b0dc76180443f1158ffc3d178148d Expire at: Thu, 08 Jul 2021 15:59:47 +0300 Message: 7b226d7367223a7b226d6573736167655f6964223a2231373531626533303633363338323731633235393065646537356437316266616134386230646337363138303434336631313538666663336431373831343864222c226d657373616765223a227465366363674542416745416f51414252596742534d553677767679593746624464704a365a5748706b4c7846304545726f4b4a36775165555369536633674d41514478394d2b686c7a4a523034444370564d6c586e775954466344495532424a304d51304966654971476f36712b6646526f717545664c326b792f6c766873667133707a77704c4463504a48566b663472412b6a6f5870676565396d622b717338645a63654b383748416d63554a61714c69617677684e472f5761343539585a31694a414141415871474b734b6f594f62327778716e514f3167357579556b6a2f597759413d3d222c22657870697265223a313632353734393138372c2261646472657373223a22303a61343632396436313764663933316438616438366564323466346361633364333231373838626130383235373431343466353832306632383934343933666263227d2c226d6574686f64223a22636f6e6669726d5472616e73616374696f6e227d &lt;QR code&gt;  Copy the message text or scan the QR code and broadcast the message online. "},{"title":"4.10. Generate deploy message offline​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#410-generate-deploy-message-offline","content":"If needed, signed deploy message can be generated without immediately broadcasting it to the blockchain. Generated message can be broadcasted later. tonos-cli deploy_message [--raw] [--output &lt;path_to_file&gt;] [--sign &lt;deploy_seed_or_keyfile&gt;] [--wc &lt;int8&gt;] [--abi &lt;contract.abi.json&gt;] &lt;contract.tvc&gt; &lt;params&gt;  --raw - use to create raw message boc. --output &lt;path_to_file&gt; - specify path to file where the raw message should be written to, instead of printing it to terminal. &lt;deploy_seed_or_keyfile&gt; - can either be the seed phrase used to generate the deployment key pair file or the key pair file itself. If seed phrase is used, enclose it in double quotes. Example: --sign &quot;flip uncover dish sense hazard smile gun mom vehicle chapter order enact&quot; or --sign deploy.keys.json--wc &lt;int8&gt; ID of the workchain the wallet will be deployed to (-1 for masterchain, 0 for basechain). By default this value is set to 0. &lt;contract.abi.json&gt; - contract interface file. &lt;contract.tvc&gt; - compiled smart contract file. &lt;params&gt; - deploy command parameters, depend on the contract. Example (saving to a file contract deployment message to the masterchain): $ tonos-cli deploy_message --raw --output deploy.boc --sign key.json --wc -1 --abi SafeMultisigWallet.abi.json SafeMultisigWallet.tvc '{&quot;owners&quot;:[&quot;0x88c541e9a1c173069c89bcbcc21fa2a073158c1bd21ca56b3eb264bba12d9340&quot;],&quot;reqConfirms&quot;:1}' Config: /home/user/tonos-cli.conf.json Input arguments: tvc: SafeMultisigWallet.tvc params: {&quot;owners&quot;:[&quot;0x88c541e9a1c173069c89bcbcc21fa2a073158c1bd21ca56b3eb264bba12d9340&quot;],&quot;reqConfirms&quot;:1} abi: SafeMultisigWallet.abi.json keys: key.json wc: -1 MessageId: 51da1b8840bd12f9ef5152639bd1fe9062d77ed91829301043bb85b4a4d610ea Expire at: unknown Message saved to file deploy.boc Contract's address: -1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6 Succeeded.  "},{"title":"4.11. Broadcast previously generated message​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#411-broadcast-previously-generated-message","content":"Use the following command to broadcast any previously generated message (transaction message, confirmation message, deploy message): tonos-cli send --abi &lt;MultisigWallet.abi.json&gt; &quot;message&quot;  &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2.message – the content of the message generated by the TONOS-CLI utility during message creation. It should be enclosed in double quotes. Example: $ tonos-cli send --abi SafeMultisigWallet.abi.json &quot;7b226d7367223a7b226d6573736167655f6964223a2266363364666332623030373065626264386365643265333865373832386630343837326465643036303735376665373430376534393037646266663338626261222c226d657373616765223a227465366363674542424145413051414252596742534d553677767679593746624464704a365a5748706b4c7846304545726f4b4a36775165555369536633674d41514868757856507a324c5376534e663344454a2f374866653165562f5a78324d644e6b4b727770323865397a7538376a4d6e7275374c48685965367642523141756c48784b44446e4e62344f47686768386e6b6b7a48386775456e7551422f655a61324d326d32546539794234723636447a61364c34635258306f744a4b465661434177414141586c4d464e7077594a61616b524d64677332414341574f663459757151715976325233654e776d49655834517048686e37537a75624c76524838657931425a6a617a6a414141414141414141414141414141414a4d61735142414d4141413d3d222c22657870697265223a313632303438323730352c2261646472657373223a22303a61343632396436313764663933316438616438366564323466346361633364333231373838626130383235373431343466353832306632383934343933666263227d2c226d6574686f64223a227375626d69745472616e73616374696f6e227d&quot; Config: /home/user/tonos-cli.conf.json Input arguments: message: 7b226d7367223a7b226d6573736167655f6964223a2266363364666332623030373065626264386365643265333865373832386630343837326465643036303735376665373430376534393037646266663338626261222c226d657373616765223a227465366363674542424145413051414252596742534d553677767679593746624464704a365a5748706b4c7846304545726f4b4a36775165555369536633674d41514868757856507a324c5376534e663344454a2f374866653165562f5a78324d644e6b4b727770323865397a7538376a4d6e7275374c48685965367642523141756c48784b44446e4e62344f47686768386e6b6b7a48386775456e7551422f655a61324d326d32546539794234723636447a61364c34635258306f744a4b465661434177414141586c4d464e7077594a61616b524d64677332414341574f663459757151715976325233654e776d49655834517048686e37537a75624c76524838657931425a6a617a6a414141414141414141414141414141414a4d61735142414d4141413d3d222c22657870697265223a313632303438323730352c2261646472657373223a22303a61343632396436313764663933316438616438366564323466346361633364333231373838626130383235373431343466353832306632383934343933666263227d2c226d6574686f64223a227375626d69745472616e73616374696f6e227d abi: SafeMultisigWallet.abi.json Connecting to net.ton.dev MessageId: f63dfc2b0070ebbd8ced2e38e7828f04872ded060757fe7407e4907dbff38bba Expire at: Sat, 08 May 2021 17:05:05 +0300 Calling method submitTransaction with parameters: { &quot;dest&quot;: &quot;-1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;, &quot;value&quot;: &quot;1234000000&quot;, &quot;bounce&quot;: false, &quot;allBalance&quot;: false, &quot;payload&quot;: &quot;te6ccgEBAQEAAgAAAA==&quot; } Processing... Processing... Succeded. Result: { &quot;transId&quot;: &quot;6959904904053506881&quot; }  If transaction requires multiple confirmations, the terminal displays the transaction ID, which should be sent to other wallet custodians. 5. Error codes Errors related to the operation of multisig contracts typically are displayed like this: { &quot;code&quot;: 507, &quot;message&quot;: &quot;Message expired. Contract was not executed on chain. Possible reason: Contract execution was terminated with error: Contract did not accept message, exit code: 103. For more information about exit code check the contract source code or ask the contract developer&quot;, &quot;data&quot;: { &quot;message_id&quot;: &quot;029502efa1f4d5701713de772947de0c9447746abfb1c1191e403220698cf8cb&quot;, &quot;shard_block_id&quot;: &quot;baf38272f69eca4291e58958813d82cbc3e2107f0dc63ed261c2017232e3b714&quot;, &quot;core_version&quot;: &quot;1.14.1&quot;, &quot;waiting_expiration_time&quot;: &quot;Thu, 20 May 2021 18:23:37 +0300 (1621524217)&quot;, &quot;block_time&quot;: &quot;Thu, 20 May 2021 18:23:40 +0300 (1621524220)&quot;, &quot;account_address&quot;: &quot;0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc&quot;, &quot;local_error&quot;: { &quot;code&quot;: 414, &quot;message&quot;: &quot;Contract execution was terminated with error: Contract did not accept message, exit code: 103. For more information about exit code check the contract source code or ask the contract developer&quot;, &quot;data&quot;: { &quot;core_version&quot;: &quot;1.14.1&quot;, &quot;phase&quot;: &quot;computeVm&quot;, &quot;exit_code&quot;: 103, &quot;exit_arg&quot;: &quot;0&quot;, &quot;account_address&quot;: &quot;0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc&quot; } }, &quot;config_servers&quot;: [ &quot;net1.ton.dev&quot;, &quot;net5.ton.dev&quot; ], &quot;query_url&quot;: &quot;https://net5.ton.dev/graphql&quot; } } Error: All attempts have failed Error: 1  Multisig error codes, corresponding to the event that caused the error are specified in the exit_code parameter. The list of possible exit codes and what they mean is as follows:100 - message sender is not a custodian - sendTransaction, submitTransaction or confirmTransaction method was called by someone who is not a wallet custodian.102 - transaction does not exist - ID of the transaction that custodian attempted to confirm is not present in multisig.103 - operation is already confirmed by this custodian - custodian attempted to confirm transaction twice.107 - input value is too low - transaction amount is less than the minimum amount (1000000 nanotons).108 - wallet should have only one custodian - wallet custodian attempted to call sendTransaction in a wallet with more than one custodian.113 - Too many requests for one custodian - the maximum amount of queued submitTransaction and submitUpdate calls was reached (currently, this amount is set to 5). Custodian has to wait until the calls are executed, before queuing any more.117 - invalid number of custodians - the number of custodians specified during multisig deploy exceeds the maximum amount (currently, this amount is set to 32).121 - payload size is too big; submitTransaction payload exceeds the maximum limit.SetcodeMultisig-specific errors115 - update request does not exist - Setcode request with the specified ID is not present in the multisig.116 - update request already confirmed by this custodian - Setcode request with the specified ID is already confirmed by the current custodian.119 - stored code hash and calculated code hash are not equal - the code hash submitted in executeUpdate is not equal to the code previously submitted in submitUpdate .120 - update request is not confirmed; cannot perform executeUpdate as the setcode request was not confirmed by the required number of custodians yet.Currently unused error codes110 - too many custodians - not currently used. 122 - object is expired - not currently used. "},{"title":"Getting started","type":0,"sectionRef":"#","url":"develop/tutorial/getting-started","content":"Getting started","keywords":""},{"title":"Tutorial 2","type":0,"sectionRef":"#","url":"develop/tutorial/tutorial-2","content":"Tutorial 2","keywords":""},{"title":"Tutorial 1","type":0,"sectionRef":"#","url":"develop/tutorial/tutorial-1","content":"Tutorial 1","keywords":""},{"title":"Bridge integration","type":0,"sectionRef":"#","url":"integrate/bridge-integration","content":"Bridge integration","keywords":""},{"title":"API","type":0,"sectionRef":"#","url":"integrate/client/api","content":"API","keywords":""},{"title":"SDK","type":0,"sectionRef":"#","url":"integrate/client/sdk","content":"SDK","keywords":""},{"title":"Add Everscale to your Exchange","type":0,"sectionRef":"#","url":"integrate/tutorial/add-everscale-to-your-exchange","content":"Add Everscale to your Exchange","keywords":""},{"title":"Getting started","type":0,"sectionRef":"#","url":"integrate/tutorial/getting-started","content":"Getting started","keywords":""},{"title":"How to read Network details","type":0,"sectionRef":"#","url":"integrate/tutorial/how-to-read-network-details","content":"How to read Network details","keywords":""},{"title":"Blockchain basis","type":0,"sectionRef":"#","url":"learn/blockchain-basis","content":"Blockchain basis","keywords":""},{"title":"DeBot Consortium","type":0,"sectionRef":"#","url":"learn/decentralization/debot-consortium","content":"","keywords":""},{"title":"DeBot-IS-consortium​","type":1,"pageTitle":"DeBot Consortium","url":"learn/decentralization/debot-consortium#debot-is-consortium","content":"DeBot Interface Specifications (IS) Consortium. IS a place where community defines interfaces every DeBot browser should support. DeBot-IS-consortium repository "},{"title":"Application Rules:​","type":1,"pageTitle":"DeBot Consortium","url":"learn/decentralization/debot-consortium#application-rules","content":"Each new interface must create a folder, which has a readme.md desciption of an interface, example of its implementaion in both Solidity and C++ placed in an &quot;examples&quot; sub folder. "},{"title":"Interface submission proccess:​","type":1,"pageTitle":"DeBot Consortium","url":"learn/decentralization/debot-consortium#interface-submission-proccess","content":"You should create a specifications proposal, discuss it.After the discussion is over and proposal is accepted you should submit examples in both Solidity and C++.Only proposals with examples will be published. "},{"title":"Supported browsers:​","type":1,"pageTitle":"DeBot Consortium","url":"learn/decentralization/debot-consortium#supported-browsers","content":"If you implemented a DeBot browser we will be happy to list it. Please let us know.Your browser should clearly state interfaces which it supports (by version number as stated in repository). "},{"title":"DePool Specifications","type":0,"sectionRef":"#","url":"learn/decentralization/depool-specifications","content":"","keywords":""},{"title":"Background​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#background","content":"It is quite evident that to achieve high-performance properties, a network needs powerful, reliable servers with fast connectivity. At the same time, to achieve sufficient decentralization, these servers have to belong to as many owners as possible. There seems to be a contradiction between these goals. In Proof-of-Work networks, performance is often sacrificed for decentralization. Yet, claims arise that the centralization of Bitcoin, Ethereum etc. mining power is not entirely prevented. Mining Pools centralization remains an issue, as these pools are controlled by particular entities distributing rewards. For example, almost 60% of Bitcoin mining power is concentrated in just 4 pools and around 80% of all mining power originates in China. Just 2 mining pools control 52% of Ethereum hashrate, more than 50% of which originates in China. In Proof-of-Stake, the correlation between network performance and concentration of power (money in this case) is even more apparent, as one does not need to buy, set up, and manage complicated mining farms. It can ultimately be claimed that POS is trading performance for decentralization (look no further than EOS centralization, Steemit network overtaking etc.). It seems that enabling small token holders to participate in network governance is a very important decentralization property. "},{"title":"Motivation​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#motivation","content":"Everscale blockchain needs all newly created blocks to be validated in order to run correctly. For this it relies on special designated nodes called &quot;Validators&quot;, and offers substantial reward for their work. However, becoming a validator requires a substantial cryptocurrency deposit. The required amount might far exceed an individual validator budget. On the other hand, blockchain users with no validating system might be interested in investing in validation duty. This is where the Decentralized Pool (DePool) smart contract comes in. There are two main use cases of DePool: User has no Validator capabilities but some free funds. User can support a third-party Validator and receive rewards.User has Validator capabilities and but doesn't have necessary amount of funds to participate in validator elections and subsequent rewards. "},{"title":"Basic terms​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#basic-terms","content":"DePool — a smart contract that allows other smart contracts to invest stakes into a common pool of funds and after some period of time to receive it back with interest.Elector — a system level smart contract, deployed to masterchain from zero state. Runs validator elections periodically.DePool Proxy (proxy) — a smart contract that delivers messages between DePool and Elector.Participant — a smart contract that invests funds into DePool.Validator — software running blockchain node. Each DePool works with one node only. This node must be a DePool participant.Validator wallet — a smart contract that is used by Validator to send election requests to DePool and receive the Validator reward. Validator wallet should be a Multisig contract with 3 custodians.DePool Helper — a smart contract that stores the address of the actual DePool and works with the Timer contract.Global Validators Set (GVS) — current set of validators chosen in the latest elections.Validation period — period of time for which GVS is elected.Investment round — period of time between Participant investing a stake in DePool and receiving it back (with or without interest).Timer — a smart contract that can call other smart contracts periodically. "},{"title":"Architecture​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#architecture","content":" DePool is designed to receive investment stakes from Participants, allocate the pool funds to a validator in order to participate in elections of the GVS and, after the end of the validation cycle, distribute stakes with certain rewards back to the Participants.DePool is deployed to basechain. But it cannot communicate with Elector directly, because Elector rejects messages from non-masterchain contracts. Thus there are DePool proxies that are deployed to masterchain and deliver messages from DePool to Elector and back. This is done, because DePool is a large and complex contract, and gas and storage fees are 10 times lower in basechain compared to masterchain. Keeping DePool on masterchain would be unreasonably expensive.DePool is open for Participants’ stakes at all times, however, there is a deadline for participation in the upcoming elections. The deadline depends on the timer of the Elector. After the deadline, the incoming stakes will be accumulated for participation in the next elections.DePool distinguishes stakes received before the deadline and after the deadline, therefore it stores information on Participant stakes in separate investment rounds (or rounds), one for every elections, to facilitate subsequent distribution of stakes and rewards. To separate Elector communication, DePool uses 2 proxies: one for even rounds, one for odd.In order to be time-aware, the DePool should be called from time to time. For this purpose the Timer contract is used. DePool Helper asks Timer to call it periodically and transmits every call from Timer to DePool. Interval between calls is chosen according to the elections interval.DePool must be linked to a validator wallet to participate in elections on behalf of the latter. This validator wallet address is specified during DePool deployment and cannot be changed afterwards. When elections start, DePool waits for signed election requests from linked wallet, then attaches round stake to request and transmits it to Elector.Validator can validate many DePools with 1 Validator wallet. Reputation of Validator wallet therefore is available and can be analyzed over time.To ensure that the validator will perform its functions correctly (be always online and not &quot;lie&quot; to other validators), the validator wallet must itself become a Participant and invest in every investment round at least m_validatorAssurance, which is initialized in DePool constructor. This can be achieved with any of the three available types of stakes.When Elector unfreezes validator stakes, DePool returns its stake back with round rewards. Part of the total reward is used to top up the DePool's own balance to a certain value. The rest is distributed as follows: m_validatorRewardFraction% goes to Validator wallet balance. m_participantRewardFraction% is distributed among all Participants in investment round (validator is also participant). m_associationRewardFraction% (can be equal to zero) goes to m_association address.DePool keeps a balance for each Participant and can automatically reinvest Participant's stake into the next investment round if appropriate flag is enabled.Participant can transfer part of its total stake to another Participant's stake inside DePool storage. This function allows for collateralization of the stake to provide liquidity to stake holders. "},{"title":"Special kinds of stakes​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#special-kinds-of-stakes","content":"Along with the basic ordinary stake, that functions according to the rules detailed above, there are 2 types of special stakes: vesting and lock stake. While the entire ordinary stake is invested into the current pooling round (and will thus be reinvested every second round), lock and vesting stakes are split into two equal parts upon reception, which are invested into the current pooling round, and the next round. This way they can be continuously reinvested into both odd and even rounds. "},{"title":"Vesting Stake​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#vesting-stake","content":"Any address can make a vesting stake and define a target participant address (beneficiary) who will own this stake. But not the whole stake is available to the beneficiary at once. Instead it is split into logical parts and the next part of stake becomes available to the participant only when next vesting period is ended. At completion step of every round DePool decides how many vesting parts should be unlocked and subtracted from vesting stake and become available to owner since last unlocking. These funds are added to beneficiary's ordinary stake. Example: address A makes a vesting stake of 120 tons for 1 year with vesting period of 1 month and defines address B as the stake beneficiary. It means that after 1 month 10 tons become available to address B and 110 tons are still locked in the pool. After 1 year vesting stake will be equal to 0 and last 10 tons will become available to owner. Vesting for validator beneficiaries is subject to additional rules: At the end of every withdrawal period, the part of the vesting stake to be released is divided proportionally into 2 parts — for rounds in this period when DePool successfully completed validation and received a reward (without slashing) and for rounds when DePool missed elections or was slashed. The portion of the stake corresponding to the successful rounds is sent to the validator, while the portion corresponding to the failed rounds is returned to the vesting stake owner. For example, if there were 100 rounds within the withdrawal period, and DePool successfully completed 80 of them, missed elections in 5 more and was slashed in the remaining 15, the validator will receive 80% of the unlocked part of the vesting stake, and the stake owner will get back 20% of it. "},{"title":"Lock Stake​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#lock-stake","content":"Any address can make a lock stake, in which it locks its funds in DePool for a defined period, but rewards from this stake will be payed to another target participant (beneficiary). At the end of a period the Lock Stake should be returned to the address which locked it. Example: address A makes a lock stake of 120 tons for 1 year with vesting period of 1 month and defines address B as the stake beneficiary. It means that after 1 month 10 tons become available to address A (as opposed to vesting, where these 10 tons would become available to address B, the beneficiary) and 110 tons are still locked in round. DePool will reinvest the gradually diminishing lock stake for a 1 year and pay rewards to B address. After 1 year DePool will return the remainder of the lock stake to address A. One Participant can be a beneficiary only of one lock and one vesting stake. Once current lock or vesting stake of the participant expires, it can be repeated. When a stake of either of these types is created, it is split equally into two last rounds, which means that the minimal value for such stake is 2 * minStake + fee. "},{"title":"Specification​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#specification","content":""},{"title":"Data Structures​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#data-structures","content":"DePool contract uses library and inheritance from several simple base contacts to separate functionality and facilitate development and debugging of the contract. The core data set stored by DePool is the following: DePoolLib.sol // Describes contract who deposit stakes in DePool pool struct Participant { // Count of rounds in which participant takes a part uint8 roundQty; // Sum of all rewards from completed rounds (for logging) uint64 reward; // count of parts of vesting stakes in the rounds uint8 vestingParts; // count of parts of lock stakes in the rounds uint8 lockParts; // Flag whether to reinvest ordinary stakes and rewards bool reinvest; // Target tons that will be transferred to participant after rounds are completed // After each round this value is decreased uint64 withdrawValue; } // Request for elections from validator wallet. struct Request { // Random query id. uint64 queryId; // Validator's public key that will be used as validator key if validator will win elections. uint256 validatorKey; // current election id. uint32 stakeAt; // Validator's stake factor. uint32 maxFactor; // Validator's address in adnl overlay network. uint256 adnlAddr; // Ed25519 signature of above values. bytes signature; }  DePoolRounds.sol // roundPre0 = m_rounds[m_roundQty - 1] — pre-pooling. Helper round for adding vesting and lock // stakes. When vesting/lock stake is added than stake is // split into two part. And first part invested into pooling // round and second part — pre-pooling. // // round0 = m_rounds[m_roundQty - 2] — pooling // round1 = m_rounds[m_roundQty - 3] — election or validation // round2 = m_rounds[m_roundQty - 4] — validation or investigation // Algo of round rotation: // delete round2 // round1 -&gt; round2 // round0 -&gt; round1 // roundPre0 -&gt; round0 // createNewRound -&gt; roundPre0 mapping(uint64 =&gt; Round) m_rounds; // count of created rounds uint64 m_roundQty = 0;  DePoolBase.sol // Dictionary of participants for rounds mapping (address =&gt; Participant) m_participants; // Address of the validator wallet address m_validatorWallet; // Array of proxies addresses. address[] m_proxies;  DePool.sol // Indicates that pool is closed. Closed pool doesn't accept stakes from other contracts. bool m_poolClosed; // Min stake accepted to the pool in nTon (for gas efficiency reasons): 10 tons is recommended. uint64 m_minStake; // Minimum validator stake in each round uint64 m_validatorAssurance; // % of participant rewards uint8 m_participantRewardFraction; // % of validator rewards uint8 m_validatorRewardFraction; // % of dePool association rewards uint8 m_associationRewardFraction; // Association address address m_association; // Minimum balance uint64 m_minimumBalance;  "},{"title":"DePool Initialization​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#depool-initialization","content":"When deployed, the DePool constructor is called with the following parameters: /// @dev DePool's constructor. /// @param minStake Min stake that participant may have in one round. /// @param validatorAssurance Min validator stake. /// @param proxyCode Code of proxy contract. /// @param validatorWallet Address of validator wallet. /// @param participantRewardFraction % of reward that distributed among participants. constructor( uint64 minStake, uint64 validatorAssurance, TvmCell proxyCode, address validatorWallet, uint8 participantRewardFraction, )  At initialization the variable m_balanceThreshold is set as current DePool account balance — 5 tokens. DePool will replenish its balance from validation rewards to this value every round it receives rewards. "},{"title":"Participant functions​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#participant-functions","content":"DePool stores some participant information in a dictionary (m_participants) where key — Participant's address and value — Participant structure. Functions used by participants perform checks and send receiveAnswer message back to the caller with an error code and a comment in case of failure. If all conditions are met, DePool sends a confirmation message (receiveAnswer with status 0) back to the caller. All functions can be called by internal messages only. addOrdinaryStake(uint64 stake) — allows to make an ordinary stake in the current pooling round. The source address of the message is taken as Participant's address. The Participant's total stake is increased by stake amount. Parameters: stake — value of participant's stake in nanotons. Function checks that: inbound message value is at least (stake + ADD_STAKE_FEE);stake is at least min stake;pool is not closed. Function returns change (part of unused ADD_STAKE_FEE). addVestingStake(uint64 stake, address beneficiary, uint32 withdrawalPeriod, uint32 totalPeriod) — allows to add a vesting stake for another participant (beneficiary). The source address of the message is saved as the vesting stake owner. Parameters: stake — value of participant's stake in nanotons (Note: this value is divided into 2 parts and is added to 2 rounds).beneficiary — address of target participant (beneficiary);withdrawalPeriod — the period in seconds after which the part of the vesting becomes available for beneficiary;totalPeriod — total period of vesting in seconds after which beneficiary becomes owner of the whole stake. Function checks that: DePool is not closed (m_poolClosed ≠ true);beneficiary is an addr_std. It's not zero address. It's not the message sender (not self vesting);inbound msg.value ≥ (m_minStake + ADD_STAKE_FEE);Message value is at least stake + STAKE_FEE;stake / 2 is at least min stake;withdrawalPeriod ≤ totalPeriod;totalPeriod &lt; 18 years;withdrawalPeriod ≠ 0;totalPeriod % withdrawalPeriod = 0;beneficiary doesn't have a vesting stake. addLockStake(uint64 stake, address beneficiary, uint32 withdrawalPeriod, uint32 totalPeriod) — allows to add a stake that will bring rewards to another participant (beneficiary). The source address of the message is saved as the lock stake owner. It has the same parameters and checks as addVestingStake, but it checks that participant doesn't have a lock stake instead of a vesting stake. withdrawFromPoolingRound(uint64 withdrawValue) — allows to remove Participant's stake from the current pooling round. Parameters: withdrawValue — desired amount of stake to be removed. Function checks that: inbound msg.sender address is address of an existing participant. If real ordinary stake is less than withdrawValue, then DePool returns the whole stake from pooling round. If the remaining stake in the pooling round is less than m_minStake, then the whole stake is transferred to Participant. If the remaining total stake of Participant is 0, then it is removed from the m_stakeholders dictionary. withdrawPart(uint64 withdrawValue) — Allows a participant to withdraw some value from DePool. This function withdraws withdrawValue nanotons when rounds are completed. If participant stake becomes less than minStake, then the whole stake is sent to participant. Parameters: withdrawValue — desired amount of stake to be removed. Function checks that: pool is not closed (m_poolClosed ≠ true);inbound msg.sender address is address of an existing participant. If the remaining stake in the round is less than m_minStake, then the whole stake will be transferred to Participant (after completing round). If the remaining total stake of Participant is 0, then it is removed from the m_stakeholders dictionary. 6. withdrawAll() — Set global flag for the participant that indicates to return participant's ordinary stake after completing rounds. Function checks that: pool is not closed (m_poolClosed ≠ true);inbound msg.sender address is address of an existing participant. After transferring all Participant's stake, the Participant will be removed from the m_stakeholders dictionary. cancelWithdrawal() — Cancel effect of calls of functions withdrawAll and withdrawPart. transferStake(address dest, uint64 amount) — allows to move amount of stake from msg.sender Participant to dest Participant inside DePool storage. Parameters: dest — stake beneficiary;amount — stake value transferred to dest in nanotons. Function checks that: pool is not closed (m_poolClosed ≠ true);destination is a non-zero addr_std;msg.sender ≠ dest;neither destination nor msg.sender is the validator wallet;inbound msg.sender address is address of an existing participant;desired amount can be transferred and transfer doesn't leave stake less than m_minStake in any round. In case of success DePool sends back a notification via onTransfer function calling to beneficiary. "},{"title":"Functions of interface DePoolInfoGetter:​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#functions-of-interface-depoolinfogetter","content":"function getLastRoundInfo() public If there is no completed round yet, call callback function receiveDePoolInfo with struct containing default values, else send call with struct containing info about last completed round. // Represent info about last completed round struct LastRoundInfo { uint32 supposedElectedAt; uint8 participantRewardFraction; uint8 validatorRewardFraction; uint32 participantQty; uint64 roundStake; address validatorWallet; uint256 validatorPubkey; uint64 validatorAssurance; }  "},{"title":"Participant callback functions:​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#participant-callback-functions","content":"These functions are called by DePool to send notifications to Participant. receiveAnswer(uint32 errcode, uint64 comment) — function, which is called as an answer from DePool to Participant. Arguments: errcode — error code. List of codes: uint8 constant STATUS_SUCCESS = 0; uint8 constant STATUS_STAKE_TOO_SMALL = 1; uint8 constant STATUS_DEPOOL_CLOSED = 3; uint8 constant STATUS_NO_PARTICIPANT = 6; uint8 constant STATUS_PARTICIPANT_HAVE_ALREADY_VESTING = 9; uint8 constant STATUS_WITHDRAWAL_PERIOD_GREATER_TOTAL_PERIOD = 10; uint8 constant STATUS_TOTAL_PERIOD_MORE_18YEARS = 11; uint8 constant STATUS_WITHDRAWAL_PERIOD_IS_ZERO = 12; uint8 constant STATUS_TOTAL_PERIOD_IS_NOT_DIVED_BY_WITHDRAWAL_PERIOD = 13; uint8 constant STATUS_PERIOD_PAYMENT_IS_ZERO = 14; uint8 constant STATUS_REMAINING_STAKE_LESS_THAN_MINIMAL = 16; uint8 constant STATUS_PARTICIPANT_HAVE_ALREADY_LOCK = 17; uint8 constant STATUS_TRANSFER_AMOUNT_IS_TOO_BIG = 18; uint8 constant STATUS_TRANSFER_SELF = 19; uint8 constant STATUS_TRANSFER_TO_OR_FROM_VALIDATOR = 20; uint8 constant STATUS_FEE_TOO_SMALL = 21; uint8 constant STATUS_INVALID_ADDRESS = 22; uint8 constant STATUS_INVALID_BENEFICIARY = 23; uint8 constant STATUS_NO_ELECTION_ROUND = 24; uint8 constant STATUS_INVALID_ELECTION_ID = 25;  comment — some value attached to error code. onTransfer(address source, uint128 amount) — function, which is called after successful transferStake to inform beneficiary. Arguments: source — address of Participant who made transfer;amount — funds that were transferred. onRoundComplete(uint64 roundId, uint64 reward, uint64 ordinaryStake, uint64 vestingStake, uint64 lockStake, bool reinvest, uint8 reason) — send a notification from DePool to Participant when round is completed: roundId — Id of completed round;reward — Participant's reward in completed round in nanotons;ordinaryStake — ordinary stake in completed round;vestingStake — vesting stake in completed round;lockStake — lock stake in completed round;reinvest — are ordinary stakes automatically reinvested (prolonged)?reason — reason why round is completed (See enum CompletionReason). "},{"title":"DePool owner functions:​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#depool-owner-functions","content":"These functions can be called only by the DePool owner, as they have to be signed with the deploy keypair. terminator() [external msg only] — a method to close DePool. All stakes from all rounds are returned in several phases: a. first of all, stakes from pooling round are returned immediately. b.m_poolClosed = true; c. All other rounds will return stakes after their &quot;completed&quot; step. Important: remaining parts of vesting/lock stakes will be sent to owners of those stakes (not to beneficiaries) setValidatorRewardFraction(uint8 fraction) [external msg only] Sets new validator's reward fraction and calculates new participants' reward fraction. New validator's reward fraction must be less than current one and be not zero. fraction — new validator's reward fraction. "},{"title":"Events​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#events","content":"DePoolClosed() — event emitted when pool is closed by terminator() function.RoundStakeIsAccepted(uint64 queryId, uint32 comment) — event is emitted on accepting stake by elector.RoundStakeIsRejected(uint64 queryId, uint32 comment) — event is emitted on rejecting stake by elector.ProxyHasRejectedTheStake(uint64 queryId) — event is emitted if stake is returned by proxy (IProxy.process_new_stake) because too low balance of proxy contract.ProxyHasRejectedRecoverRequest(uint64 roundId) — event is emitted if stake cannot be returned from elector (IProxy.recover_stake) because too low balance of proxy contract.RoundCompleted(TruncatedRound round) — event is emitted on completing round.StakeSigningRequested(uint32 electionId, address proxy) — Event emitted when round is switched from pooling to election. DePool is waiting for signed election request from validator wallet.TooLowDePoolBalance(uint replenishment) — event emitted when pure DePool's balance becomes too low. replenishment minimal value that must be sent to DePool via receiveFunds function.RewardFractionsChanged(uint8 validator, uint8 participants) — event emitted when contract owner changes reward fractions. validator — validator's reward fraction. participants — participants' reward fraction. "},{"title":"Get-methods​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#get-methods","content":"These get-methods are used for local run. getParticipantInfo(address addr) — returns participant's information about stakes in every rounds;getDePoolInfo() — returns DePool configuration parameters and constants;getParticipants() — return list of all participants;getRounds() — returns information about all rounds.getDePoolBalance() — returns DePool's own balance in nanotokens. The DePool does not store validator public keys or ADNL address, because, according to the official Everscale guide, the Validator generates a new keypair and ADNL for every elections. The contract stores only Validator wallet address. "},{"title":"State update function​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#state-update-function","content":"ticktock() — this function is the &quot;engine&quot; of DePool. This function rotates rounds: creates a new round if necessary and removes an old one. Switches steps of rounds and calls various internal functions if certain conditions are satisfied and so on. ticktock() — does not accept external inbound messages and can be called only from other contracts ticktock returns unspent message value (change) back to caller. "},{"title":"Multi-Round elections​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#multi-round-elections","content":" Every round goes through several steps: &quot;PrePooling&quot; step (RoundStep.PrePooling) — it's an imaginary round introduced to store half of vesting/lock stake from participants. See addVestingStake/addLockStake functions.&quot;Pooling&quot; step (RoundStep.Pooling) — round is ready to accept stakes from Participants. This round receives ordinary, vesting and lock stakes.&quot;waiting for election requests&quot; step (RoundStep.WaitingValidatorRequest) — round is switched to this step when validator elections begin. DePool is waiting for signed election request from validator wallet. See process_new_stake function of Elector to properly generate election request. Important: Validator wallet must also be a Participant and invest at least m_validatorAssurance stake in the round. If it doesn't, round is completed and stakes are reinvested in another round or are returned to participants. &quot;Waiting if stake is accepted by elector&quot; (RoundStep.WaitingIfStakeAccepted) — DePool has received the validator signed election request. DePool has sent the whole round stake to elector through one of its proxies. Now DePool is waiting for elector answer. Note: elector will call DePool's onStakeAccept function if election request is accepted successfully or onStakeReject in case of an error.&quot;waiting for validation start&quot; (RoundStep.WaitingValidationStart) — round stake was accepted by elector. Validator is a candidate. DePool now is waiting for the start of the validation to find out if validator won the elections.&quot;waiting for election result&quot; (RoundStep.WaitingIfValidatorWinElections) — DePool has tried to recover stake in validation period to find out if validator won elections. Waiting for elector answer. Note: If validator won the elections, elector returns no stake. If Validator lost the elections, elector returns the whole stake.&quot;waiting stake unfreeze&quot; (RoundStep.WaitingUnfreeze) — If CompletionReason != Undefined, the round is waiting round rotation to return/reinvest funds because elections were lost. Else validator won elections. DePool is waiting for ending of unfreeze period to recover funds from elector.&quot;waiting for a reward&quot; (RoundStep.WaitingReward) — Unfreeze period has been ended. Request to recover stake has been sent to elector. DePool is waiting for answer from elector.&quot;completing&quot; step (RoundStep.Completing) — DePool receives reward and replenishes its balance from it. Then it returns or reinvests participant's stakes. Also on this step DePool recounts vesting and lock stakes and modifies them if necessary.&quot;completed&quot; (RoundStep.Completed) — round switches to this step after processing all the Participants in the round. In next ticktock this round will be deleted. "},{"title":"Round completion​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#round-completion","content":"When a round switches to &quot;completing&quot; step (completeRound function), the DePool replenishes its balance from received rewards and then starts to cycle through all stakes in the round. If Participant's reinvestment flag is false, DePool sends it back to the Participant, otherwise — adds it to the pooling round. Also DePool sends notification message (onRoundComplete) to Participant. DePool goes through all vesting and lock stakes of the completing round and checks whether a withdrawal period has finished for the current stake. If it has, DePool modifies the stake via transferring part of it to Participants ordinary stake (in case of Vesting) and/or transferring part of the stake back to the owner (in case of Lock or in case of Vesting for validator which was slashed or lost elections over the course of the completed withdrawal period). Remark: if there are 15000 stakes in round, then the contract should split completion to 375 transactions sending 375 completePendingRound messages to itself. All these transactions can fit in 1-2 blocks and the whole operation will take about 5-20 seconds. "},{"title":"DePool decentralization​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#depool-decentralization","content":"No inherent way to replace the contract code (no SETCODE);No inherent way to transfer an arbitrary amount of currency from the DePool;Any contract can call the ticktock() function to update the state of the DePool;No one has special privileges, except for deployer of DePool who can only close DePool and start a procedure of returning all stakes back to Participants;Fees cannot be changed after the contract is deployed;Validator wallet must be a Participant as well to share risks with other Participants. "},{"title":"DePool contract fee​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#depool-contract-fee","content":"Caller of DePool's ticktock function must pay for consumed gas. Unused message value is returned back when ticktock is finished. At the beginning of completing step DePool first takes from the total reward an amount of tokens to replenish it's balance to m_balanceThreshold, and then additionally RET_OR_REINV_FEE * (N + 1), where N is the number of participants, to cover the costs of stake processing. "},{"title":"Links​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#links","content":"DePool contract is available on github. DePool deployment instructions can be found here. "},{"title":"DeBot Specifications","type":0,"sectionRef":"#","url":"learn/decentralization/debot-specifications","content":"","keywords":""},{"title":"Objective​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#objective","content":"Provide a secure and convenient environment to work with smart-contracts emulate calling smart-contract functions locally on the client;debug blockchain transactions;interact with smart-contracts deployed in the blockchain. "},{"title":"Basic terms​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#basic-terms","content":"DeBot — a smart contract facilitating conversation-like flow communication with a target smart contract;Target smart contract — a smart contract for which DeBot is created. DeBot is an interface to this smart contract;DeBot protocol — a set of rules describing the communication between browser and DeBot: how to call DeBot functions and how to interpret its answers;DeBot engine (DEngine) — a program component that executes DeBot and parses its answer using DeBot protocol;DeBot browser — a program, which creates instances of DEngine for executed DeBot and renders the user interface. "},{"title":"Architecture​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#architecture","content":" DeBot platform consists of the following elements: DeBot smart contract;DeBot browser;Target smart contract(s). One target smart contract can have several DeBot and vise versa. DeBot is deployed to the blockchain. DeBot browser runs on client. It downloads DeBot code and runs it inside the DEngine. "},{"title":"Proof of State​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#proof-of-state","content":"Transactions can be verified by running DeBot locally and comparing the result of execution to the account state in the blockchain. "},{"title":"DeBot Interfaces​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#debot-interfaces","content":""},{"title":"Motivation​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#motivation","content":"DeBot is a smart contract and smart contracts are isolated from each other and from the blockchain, their capabilities are limited by the commands of the virtual machine on which they are executed. But DeBot must have more possibilities. DeBot need to: receive input from users;query info about other smart contracts;query transactions and messages;receive data from external subsystems (like file system) and external devices (like NFC, camera and so on);call external function libraries that allow to do operations that are not supported by VM. For example, work with json, convert numbers to string and vice versa, encrypt/decrypt/sign data. To cover all these needs we should design different DeBot Interfaces (DInterfaces) which can be used in DeBot and which must be supported in DeBot Browsers. These interfaces should match the requirements: comprehensive — interfaces should describe all types of communication accessible on modern devices;universal — interfaces should be abstract from certain OS and hardware;atomic — every communication channel should be separately described in the interface for further flexible resource access management;convenient — even low-skilled developers should be able to use this interface in their DeBot. In this model DeBot Engine should act like a proxy between DeBot Browser and DeBot. But it can have builtin implementation of very basic DInterfaces (e.g. working with json). Also, we need to describe the manifest for DeBot. DeBot developer will describe all needed interfaces in this manifest and the DeBot Browser will check it before running DeBot. We need this manifest to keep users secure and private when using DeBot. "},{"title":"Description​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#description","content":"Every DeBot must declare which DInterfaces it will use. For this purpose it must have getRequiredInterfaces() function which returns array of required interfaces. Every interface must have an id which is an unsigned 256-bit integer and an address which is used in DeBot as a destination address of internal messages. Address must be a standard Everscale address consisting of DEBOT_WC (equal to 0xDB) as a workchain_id part and interface id as address part (see &quot;Telegram Open Network Blockchain&quot;specification, section 3.1.2 for details about TL-B scheme for address). For example, in solidity getRequiredInterfaces can be implemented like this: // Base contract for all DeBot abstract contract Debot { i32 constant DEBOT_WC = - 31; function getRequiredInterfaces() virtual returns (uint256[] interfaces); } contract DebotA is Debot { function getRequiredInterfaces() override returns (uint256[] interfaces) { return [ID_TERMINAL, ID_MENU, ...]; } }  "},{"title":"How to use DInterface in DeBot​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#how-to-use-dinterface-in-debot","content":"To use an interface DeBot should import source file with DInterface declaration and call its methods as any other smart contract methods in Everscale — by sending internal messages to interface address. Before running the DeBot, DeBot Browser should provide callbacks for DEngine to receive all requests to DInterfaces. Requests are packed into internal messages. When Browser receives a message from DEngine it should unpack the message, decode its body, call DInterface function, pack results to internal message and return it to DEngine using Dengine.send(msg). interface BrowserCallbacks { // Message from Debot to Browser with encoded DInterface call send(message: string): Promise&lt;void&gt; // Request from DEngine to approve some action (for example, send mesage to blockchain) approve(action: {}): boolean // Request from DeBot to call another DeBot invoke(debotAddress: string, message: string): Promise&lt;void&gt; }  "},{"title":"DeBot Start​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#debot-start","content":"Befor starting DeBot should also provide metadata, which includes its name, version, authorship information, description, language and ABI. This is accomplished through the getDebotInfo() mandatory function. Along with getRequiredInterfaces() this function is defined in the base contract Debot.sol. // Base contract for all DeBots abstract contract Debot { /// @notice ACTION structure struct Action { // String that describes action step, should be printed to user string desc; // Name of debot function that runs this action string name; // Action type uint8 actionType; // Action attributes. // Syntax: &quot;attr1,attr2,attr3=value,...&quot;. // Example: &quot;instant,fargs=fooFunc,sign=by-user,func=foo&quot; string attrs; // Context to transit to uint8 to; // Action internal data TvmCell misc; } struct Context { uint8 id; // Context ordinal string desc; // message to be printed to the user Action[] actions; // list of actions } string s_dabi; /* * Public debot interface */ /// @notice Returns list of interfaces used by DeBot. function getRequiredInterfaces() public view virtual returns (uint256[] interfaces); /// @notice Used for error handling for external messages if error code &gt;= 400 (TVM) and &lt; 500 (PROCESSING) function getErrorDescription(uint32 error) public pure virtual returns (string desc); /// @notice Invoked by DeBot Browser at debot startup. Returns array of debot contexts. function fetch() public virtual returns (Context[] contexts); /// @notice DeBot entry point. function start() public virtual; /// @notice Returns DeBot metadata. /// @return name String with name of debot, e.g. &quot;DePool&quot;. /// @return version Semver version of debot, that will be converted to string like &quot;x.y.z&quot;. /// @return publisher String with info about who has deployed debot to blokchain, e.g. &quot;TON Labs&quot;. /// @return caption (10-20 ch.) String with short description, e.g. &quot;Work with Smthg&quot;. /// @return author String with name of author of DeBot, e.g. &quot;Ivan Ivanov&quot;. /// @return support Free TON address of author for questions and donations. /// @return hello String with first messsage with DeBot description. /// @return language (ISO-639) String with debot interface language, e.g. &quot;en&quot;. /// @return dabi String with debot ABI. function getDebotInfo() public functionID(0xDEB) view virtual returns( string name, string version, string publisher, string caption, string author, address support, string hello, string language, string dabi, bytes icon ); /// @notice Allow to set debot ABI. Do it before using debot. function setABI(string dabi) public { require(tvm.pubkey() == msg.pubkey(), 100); tvm.accept(); s_dabi = dabi; } /// @notice Returns DeBot ABI. /// @dev Deprecated. Remove later. https://github.com/tonlabs/TON-SDK/blob/dc0631a726295c4e7190361c417214c301ec4e01/ton_client/src/debot/dengine.rs#L175 function getDebotOptions() public view returns ( uint8 options, string debotAbi, string targetAbi, address targetAddr ) { debotAbi = s_dabi; targetAbi = &quot;&quot;; targetAddr = address(0); options = 1; } } contract MyDeBot is Debot { function getErrorDescription(uint32 error) public pure override returns (string desc) { tvm.log(format(&quot;getErrorDescription: {}&quot;, error)); desc = format(&quot;some description about code {}&quot;, error); // TODO description error codes } function fetch() public override returns (Context[] contexts) { tvm.log(&quot;fetch&quot;); // TODO fetch Context } function start() public override { tvm.log(&quot;start&quot;); // TODO start } function getDebotInfo() public functionID(0xDEB) view override returns( string name, string version, string publisher, string caption, string author, address support, string hello, string language, string dabi, bytes icon ) { tvm.log(&quot;getDebotInfo&quot;); name = &quot;MyDeBot&quot;; version = &quot;1.0.0-alpha.0&quot;; publisher = &quot;Everscale&quot;; caption = &quot;My first DeBot&quot;; author = &quot;Everscale&quot;; support = address.makeAddrStd(0, 0x0); hello = &quot;Hello first user!&quot;; language = &quot;en&quot;; dabi = s_dabi; icon = &quot;&quot;; } function getRequiredInterfaces() public view override returns (uint256[] interfaces) { tvm.log(&quot;getRequiredInterfaces&quot;); // TODO add dependency interfaces } }  Run debug log: npx tonos-cli debot --debug fetch &lt;ADDRESS&gt; 19:43:58 [DEBUG] (1) ton_client::debot::dengine: running getRequiredInterfaces, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:43:58 [INFO] getRequiredInterfaces 19:43:58 [DEBUG] (1) ton_client::debot::dengine: running getDebotInfo, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:43:58 [INFO] getDebotInfo 19:43:58 [DEBUG] (1) ton_client::debot::dengine: run_debot_external getDebotOptions, args: {} 19:43:58 [DEBUG] (1) ton_client::debot::dengine: running getDebotOptions, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:43:58 [DEBUG] (1) ton_client::debot::dengine: run_debot_external fetch, args: {} 19:43:58 [DEBUG] (1) ton_client::debot::dengine: running fetch, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:43:58 [INFO] fetch DeBot Info: Name : MyDeBot Version: 1.0.0-alpha.0 Author : Everscale Publisher: Everscale Support: 0:0000000000000000000000000000000000000000000000000000000000000000 Description: My first DeBot Hello first user! Run the DeBot (y/n)? y 19:44:02 [DEBUG] (1) ton_client::debot::dengine: running getRequiredInterfaces, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:44:02 [INFO] getRequiredInterfaces 19:44:02 [DEBUG] (1) ton_client::debot::dengine: running getDebotInfo, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:44:02 [INFO] getDebotInfo 19:44:02 [DEBUG] (1) ton_client::debot::dengine: run_debot_external getDebotOptions, args: {} 19:44:02 [DEBUG] (1) ton_client::debot::dengine: running getDebotOptions, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:44:02 [DEBUG] (1) ton_client::debot::dengine: run_debot_external fetch, args: {} 19:44:02 [DEBUG] (1) ton_client::debot::dengine: running fetch, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:44:02 [INFO] fetch 19:44:02 [DEBUG] (1) ton_client::debot::dengine: switching to 0 19:44:02 [DEBUG] (1) tonos_cli::debot::callbacks: switched to ctx 0 19:44:02 [DEBUG] (1) ton_client::debot::dengine: run_action: start 19:44:02 [DEBUG] (1) ton_client::debot::dengine: run_debot_external start, args: {} 19:44:02 [DEBUG] (1) ton_client::debot::dengine: running start, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:44:02 [INFO] start 19:44:02 [DEBUG] (1) ton_client::debot::dengine: instant_switch = false, state_to = 0 19:44:02 [DEBUG] (1) tonos_cli::debot::callbacks: no more actions, exit loop  Before starting the DeBot, DeBot Browser creates new instance of DEngine with address of DeBot;DEngine downloads DeBot state, queries metadata and list of DInterfaces required by DeBot and returns the list to Browser;Browser must check that it supports all required DInterfaces. If one of interfaces is not supported, Browser must report error to the user (application) and not start the DeBot otherwise Browser must list requested interfaces to user (application);All required interfaces should be approved by user (application);After the list of interfaces is approved, the DeBot Browser starts DeBot using Dengine.start(callback). On every interface call Browser should check permission for DeBot and on success execute it according to isolation requirement if needed. Below you can see DeBot start sequence:  "},{"title":"DInterface specification​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#dinterface-specification","content":"Every DInterface must be discussed and accepted by DeBot Interface Specifications (DIS) Consortium before it can be used in DeBot. All accepted interfaces are published in repo: https://github.com/tonlabs/DeBot-IS-consortium Everybody can suggest new DInterface. Go to repo and follow the instructions. "},{"title":"DInterfaces support in DeBot Browser​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#dinterfaces-support-in-debot-browser","content":"DeBot Browser can support and implement any or all DInterfaces published in DIS repo depending on browser's capabilities. For example, console browser cannot support external devices like camera, NFC, microphone and so on. Some interfaces required for basic DeBot operation are built into the DEngine itself (SDK, Hex, JsonDeserialize). They are marked as such in their respective readme files in the IS consortium repository. "},{"title":"DEngine versioning​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#dengine-versioning","content":"DEngine as a SDK module should have a version of SDK itself. DIS statuses: Proposed, Accepted, Published. "},{"title":"Example of DInterface​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#example-of-dinterface","content":"Name\tIDRawInput\t8796536366ee21852db56dccb60bc564598b618c865fc50c8b1ab740bba128e3 "},{"title":"Description​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#description-1","content":"Allows to get string from user "},{"title":"Functions​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#functions","content":"Function input arguments: answerId: uint32 — function id of result callbackprompt: bytes — string printed to the user and describing what to enter returns: text: bytes — string entered by user "},{"title":"Declaration in Solidity​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#declaration-in-solidity","content":"interface IRawInput { function input(uint32 answerId, string prompt) external returns (string value); } Library RawInput { uint256 constant ID_RAWINPUT = 0x8796536366ee21852db56dccb60bc564598b618c865fc50c8b1ab740bba128e3 // Callback Function Prototype function inputResult(uint32 answerId, string prompt) public { address addr = address.makeAddrStd(DEBOT_WC, ID_RAWINPUT); IRawInput(addr).input(answerId, prompt); } }  "},{"title":"Declaration in C++​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#declaration-in-c","content":"namespace tvm { namespace schema { __interface IRawInput { [[internal, answer_id]] string input(string prompt); };  "},{"title":"Code Example​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#code-example","content":"Solidity​ pragma solidity &gt;=0.6.0; import &quot;Debot.sol&quot;; import &quot;RawInput.sol&quot;; contract ExampleDebot is Debot, RawInput { function start() public { RawInput.input(tvm.functionId(inputResult), &quot;enter your name:&quot;); RawInput.input(tvm.functionId(inputResult), &quot;enter your wallet address:&quot;); } function inputResult(string text) public override { require(text == &quot;Debot&quot;); } }  Note: C++ DeBot are currently in the state of early development, and not all features all completely defined for them yet. "},{"title":"DeBot Special Features​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#debot-special-features","content":"DeBot have 3 special features: calling — get-methods of target smart contracts;calling — external functions of target smart contracts onchain;invoking — other DeBot in a local environment. Ordinary Everscale smart contracts cannot use 1st and 2nd features because they cannot produce external inbound messages. But DeBot can, due to the fact that they are executed in DEngine, that allows DeBot to generate these kinds of messages, send them to blockchain and return results to DeBot. In terms of DeBot, all these features are implemented without DInterfaces but in a native way, like two smart contracts communicating with each other — by sending messages directly to target address. But with only one difference — to call a get-method or call a function onchain DeBot must generate external inbound message, while to invoke another DeBot, it should generate an internal message to the invoked DeBot address. DEngine distinguishes between get-methods and onchain calls by examining the sign header of the message. Signed messages (sign: true) are considered onchain calls, while unsigned messages (sign: false) are considered to be get-method calls. "},{"title":"Get-methods​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#get-methods","content":"Developer Example​ Solidity function showTasks(uint32 index) public view { index = index; optional(uint256) none; ITodo(m_address).getTasks{ abiVer: 2, extMsg: true, sign: false, pubkey: none, time: uint64(now), expire: 0, callbackId: tvm.functionId(showTasks_), onErrorId: tvm.functionId(onError) }(); }  Support in DEngine​ DEngine executes DeBot and checks if it produces external inbound messages. If yes, then DEngine analyzes each message by scanning signature and public key bits in message body to understand if message is for get-method call. If bits are zero DEngine downloads target contract and runs its get-method, then returns results to DeBot by calling its function set in the callbackId or onErrorId (in case of errors) headers of message body. "},{"title":"Onchain function call​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#onchain-function-call","content":"Developer example​ Solidity IMsig(m_msigAddress).sendTransaction{ abiVer: 2, extMsg: true, sign: true, pubkey: pubkey, time: uint64(now), expire: 0, callbackId: tvm.functionId(waitBeforeDeploy), onErrorId: tvm.functionId(onErrorRepeatCredit) }(m_address, INITIAL_BALANCE, false, 3, empty); }  Support in DEngine​ DEngine executes DeBot and checks if it produces external inbound messages. If there is one, DEngine analyzes if it is onchain call by scanning signature and public key bits in message body. If signature bit is 1 then DEngine does the following things. Downloads target smart contract, signs the message and emulates its transaction locally;Checks if transaction produces outbound internal messages with funds;Requests permission from DeBot Browser to send this message onchain. Request contains information about funds that will be spent if message will be executed onchain and message itself;If DeBot Browser allows to send message, DEngine sends message to blockchain. "},{"title":"Invoking DeBot​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#invoking-debot","content":"DeBot can call another DeBot by simply sending internal message to it. After DeBot execution DEngine filters all internal messages produced by DeBot with destination addresses with workchain 0. This filter allows to separate DInterface calls (which have 0xDB workchain id) from DeBot invokes. If there are invoke messages, DEngine sends them to Browser through BrowserCallbacks interface. Browser (or user) has to approve the invoke of a new DeBot, at which point Browser creates a new DEngine instance, downloads target DeBot and transfers the message to it. Browsers should generally support a common queue for messages from several DeBot. "},{"title":"Security notes​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#security-notes","content":"At start browser creates a DEngine instance, and receives DeBot metadata and list of required DInterfaces through DEngine, and checks them for compatibility and security. When DeBot is running, DEngine proxies all DInterface calls (except calls to builtin interfaces supported by engine itself like SDK calls) directly to Browser which must decide to execute or reject them. Get-method calls are always allowed. Executed by DEngine. External function calls must be approved by Browser. Executed by DEngine. Other DeBot calls are always allowed. But executed by Browser which can block invoke if needed. "},{"title":"End-to-end Decentralization","type":0,"sectionRef":"#","url":"learn/decentralization/end-to-end-decentralization","content":"","keywords":""},{"title":"Background​","type":1,"pageTitle":"End-to-end Decentralization","url":"learn/decentralization/end-to-end-decentralization#background","content":"Decentralization is an important property of public blockchain technology 1. Despite its claims of decentralization, blockchain keeps on fighting to achieve it through improvements and optimizations mainly related to consensus mechanisms and data exchange protocols. Proof-of-Work and Proof-of-Stake consensus protocols (and their derivatives) have issues related to centralization at both mining/staking and at the front-end levels. Considerable amounts of centralization exist in development ecosystems of some blockchains as well. Decentralization claims can only be made when the whole system is decentralized, and therefore, should be judged by its weakest (or rather most centralized) link. In the current invention we present an end-to-end Decentralization framework (E2ED). In today's blockchains that support smart contracts (or in other words the ability to perform and validate arbitrary computations), user interaction with results of such computations is performed using some front end library (such as Web3 in Ethereum blockchain). The Web3 library takes care of performing blockchain related tasks with blockchain data presented to a user. The IPFS is used to store data in a decentralized manner. Yet as shown below neither is enough to preserve full decentralization of end user interactions with a blockchain system to ensure censorship resistance and security. "},{"title":"Web3​","type":1,"pageTitle":"End-to-end Decentralization","url":"learn/decentralization/end-to-end-decentralization#web3","content":"Web3.0 js is a collection of libraries which allow you to interact with a local or remote Ethereum node, using a HTTP or IPC connection2. Web3.0 is a collection of JavaScript libraries that allow users to interact with a local or remote Ethereum node using an HTTP or IPC connection. In other words, it’s a kind of SDK which gives users the ability to work with blockchain in the browser. That’s why it actually has a Web in the name and not something else. Web3.0 is numbered 3.0 quite obviously because 2.0 and 1.0 versions of Web already exist, referring to the World Wide Web's evolution where the 2.0 version unlike the 1.0 version, for instance, allows for display of user-generated content, dynamically making websites more sophisticated. Web 3.0 on the other hand is seen as part of the World Wide Web’s evolution due to the fact that it can be considered as a first attempt to access decentralized (blockchain) applications on the web. The purpose of Web3 is to give the ability to create decentralized apps on the web connecting sites to the world of blockchain, in particular Ethereum blockchain. The main problem with this approach is that a user does not really interact with the blockchain when using Web3 based applications, because most of the time the user interacts with many elements of information outside of the blockchain, presented to them by the application user interface. This presents quite a significant problem as all such information and user interface elements are not decentralized, which means they are not immutable, not censorship resistant, and not fault tolerant. Moreover, blockchain related elements that are supposedly temper proofed lose their properties once they are part of this centralized model. "},{"title":"IPFS​","type":1,"pageTitle":"End-to-end Decentralization","url":"learn/decentralization/end-to-end-decentralization#ipfs","content":"Enters IPFS. The InterPlanetary File System (IPFS) is a protocol and peer-to-peer network for storing and sharing data in a distributed file system. IPFS uses content-addressing to uniquely identify each file in a global namespace connecting all computing devices3. An IPFS developer or user can store the content somewhere that’s always online and accessible and make sure that when the user comes online they know where to find the content. This way we theoretically could use IPFS to store all user interfaces somewhere, save a hash and an address of said content on the blockchain and therefore prove to the user that whatever is displayed in their browser is true and correct by way of verifying it using Web3 library. Yet even an IPFS and Web3 combination does not guarantee end-to-end decentralization as described below in more detail. "},{"title":"User interaction (DeBot)​","type":1,"pageTitle":"End-to-end Decentralization","url":"learn/decentralization/end-to-end-decentralization#user-interaction-debot","content":"A system is needed to create a comprehensive user experience without relying on trusted infrastructure. To achieve this, we introduced technology for writing the user interface inside the smart contract itself. Decentralized Bot (DeBot) is a technology enabling end-to-end Decentralization at a user interaction level. Using E2ED, any front-end application (be it in a web browser or a purposely built software) can draw an entire user experience without relying on a server. Comparing Web 2.0, Web 3.0 and E2ED based systems (which for the purpose of the diagram below we named Web3.11 as a reminiscent to the famous Windows 3.11), E2ED is not a contradiction to Web3.0 but rather a continuation that closes some centralization loopholes to achieve end-to-end decentralization. Web3.0 itself is not a monolithic system. It has many components such as an IPFS database for storage and others for address discovery and storage query on top. The Web3.0 approach is fragmented. A smart contract is executed in one place and the data it manipulates is stored in another. The data meets the business logic only on an end user device, therefore, the computation performed on such data can not be verified by a blockchain. For that reason we have verifiable business logic (smart contract) operating with the data it can not verify. The only limited verification available is the hash of data stored somewhere else. The interaction with said data is static. If a man-in-the-middle attack is performed on the user device level, the security of Web3 can be compromised. In practice today what happens in almost 100% of cases is shown in the middle column of the diagram below. A user interface is provided by a web server. An application is running on the server and displayed in the user browser (or on a mobile device). The user performs many usual operations with the website content on the server and only when needed to interact with the blockchain does the Web3.0.js get called, which then interacts with the blockchain calling it from the end user device and signed with the user private key. Even if Web3.0 is really advanced and stores the application data (say a website), in the IPFS database the Web3.0.js will be called to perform operations with a blockchain and again not the library nor the smart contract it interacts with, and will not be able to verify what has actually happened to the data that was stored and received from the IPFS on the user device.  In E2ED the smart contract contains the actual user interface in a form of DeBot. The DeBot system described herein is just one way of performing user interface functions by a smart contract. The whole graphical user interface could be drawn if needed. In DeBot the sequence of user actions is performed by calling DeBot smart contract functions using the local virtual machine of any particular blockchain. The result of those actions could at any time be transmitted to the remote smart contract together with the sequence of user performed actions and the whole interface interaction could be verified remotely by the blockchain, including the resulting transaction. In terms of addressing the user, it just needs to know the address of a smart contract DeBot, which is a blockchain address that in turn can be abstracted further using a blockchain based DNS service. "},{"title":"References​","type":1,"pageTitle":"End-to-end Decentralization","url":"learn/decentralization/end-to-end-decentralization#references","content":"The Meaning of Decentralization↩web3.js - Ethereum JavaScript API↩InterPlanetary File System↩ "},{"title":"Bridges","type":0,"sectionRef":"#","url":"learn/everscale-overview/bridges","content":"","keywords":""},{"title":"What is a cross-chain bridge?​","type":1,"pageTitle":"Bridges","url":"learn/everscale-overview/bridges#what-is-a-cross-chain-bridge","content":"Cross-chain bridges was made for transferring assets between chains. Their locks assets in the source chain and creates an equivalent number of wrapped assets in the destination blockchain. When you initiate an asset transfer from one blockchain to another using a bridge, assets are not actually moved or sent anywhere. Instead, the transfer functionality is used in a two-step process and handled by a smart contract. In simple terms - Let's say you want to move tokens from chain A to chain B. What the bridge does is it temporarily locks or freezes your asset in chain A. They then create an equivalent number of new tokens that will be unlocked for you in chain B. When you want to redeem the tokens, that is, when you want to move the original assets back from chain B to the original chain (chain A), the tokens created in chain B will be burned and the original assets will be unlocked. The concept of interchain communication and token transfer is done using a two-way binding system; where the value of a token in either blockchain is the same, as it remains tied to the value of the initial ones. "},{"title":"Everscale Bridges​","type":1,"pageTitle":"Bridges","url":"learn/everscale-overview/bridges#everscale-bridges","content":""},{"title":"Octus Bridge​","type":1,"pageTitle":"Bridges","url":"learn/everscale-overview/bridges#octus-bridge","content":"Octus Bridge is a platform built by the Broxus team that enables cross-chain asset transfers between Everscale and other networks such as Ethereum, BNB Chain, Fantom and Polygon. The platform also implements the Governance interface or DAO, which provides a level of decentralization unprecedented for bridges due to the ability to make decisions directly by network participants, as well as a staking interface. "},{"title":"Adaever​","type":1,"pageTitle":"Bridges","url":"learn/everscale-overview/bridges#adaever","content":"Cross-chain bridge between Cardano and Everscale built by the Broxus team. "},{"title":"Wallets/Exchanges","type":0,"sectionRef":"#","url":"learn/everscale-overview/exchangewallets","content":"","keywords":""},{"title":"Non-custodial wallets​","type":1,"pageTitle":"Wallets/Exchanges","url":"learn/everscale-overview/exchangewallets#non-custodial-wallets","content":"Non-custodial - the user has full control over the keys and their funds. If the private key and the password to recover it are lost, the funds will be irretrievably lost. EVER Wallet (IOS, Android, Web) Ever Surf (IOS, Android, Windows, Linux, MacOS) Everspace (IOS, Android, Telegram) ScaleWallet (Web) Lumi (Android, Web) "},{"title":"Custodial wallets​","type":1,"pageTitle":"Wallets/Exchanges","url":"learn/everscale-overview/exchangewallets#custodial-wallets","content":"Custodial wallets are similar to bank instruments. The user does not have full control over their funds because an operator (custodian) has access to the private key. Pros: having lost passwords or keys, the user has the opportunity to gain access to the funds again. Combot (Web, Telegram) Koshelek (Android, IOS) Crypterium (IOS, Android) FreeWallet (IOS, Android, Web) Kilox (IOS, Android) "},{"title":"Exchange Wallets​","type":1,"pageTitle":"Wallets/Exchanges","url":"learn/everscale-overview/exchangewallets#exchange-wallets","content":"Crypterium (IOS, Android) Koshelek (Android, IOS) "},{"title":"Ecosystem","type":0,"sectionRef":"#","url":"learn/everscale-overview/ecosystem","content":"","keywords":""},{"title":"Wallets​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#wallets","content":"Go to the Wallets section to get acquainted with the Everscale network's wallets. "},{"title":"Exchanges​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#exchanges","content":""},{"title":"Gate.io (EVER/USDT)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#gateio-everusdt","content":""},{"title":"MEXC (EVER/USDT)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#mexc-everusdt","content":""},{"title":"Bitrue (EVER/USDT)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#bitrue-everusdt","content":""},{"title":"Digifinex (EVER/USDT)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#digifinex-everusdt","content":""},{"title":"HitBTC (EVER/USDT, EVER/BTC)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#hitbtc-everusdt-everbtc","content":""},{"title":"KUNA (EVER/USDT)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#kuna-everusdt","content":""},{"title":"Changelly PRO (EVER/BTC)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#changelly-pro-everbtc","content":""},{"title":"CEX.io (EVER/USDT, EVER/USD)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#cexio-everusdt-everusd","content":""},{"title":"FMFW.io (EVER/BTC)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#fmfwio-everbtc","content":""},{"title":"GameFi​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#gamefi","content":""},{"title":"Pokerton​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#pokerton","content":"Telegram Poker – Win EVER by participating in free daily tournaments. "},{"title":"EverBall.io​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#everballio","content":"The world's first game where you mine EVER by absorbing opponents. "},{"title":"Everscale Gaming​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#everscale-gaming","content":"Esports tournaments with prize pools in EVER. "},{"title":"EverCraft​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#evercraft","content":"A plugin to connect Everscale with Minecraft. "},{"title":"Galaxy Online​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#galaxy-online","content":"A great MMO with playable blockchain-based races. "},{"title":"Bridges​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#bridges","content":"Go to the Bridges to get acquainted with the Everscale network's bridges. "},{"title":"NFT​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#nft","content":""},{"title":"GrandBaraz​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#grandbaraz","content":"Everscale's first NFT marketplace. Buy, sell, and craft rare digital items. "},{"title":"ChessNFT​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#chessnft","content":"An NFT platform from the FIDE Chess Federation. "},{"title":"Third Place NFT​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#third-place-nft","content":"An NFT platform from the St. Petersburg creative space Third Place. "},{"title":"Most Expensive​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#most-expensive","content":"Real expensive NFT items! "},{"title":"ScalePunks.com​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#scalepunkscom","content":"A collection of 10,000 unique punks. "},{"title":"DeFi​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#defi","content":""},{"title":"FlatQube​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#flatqube","content":"DEX solution. Easy and fast exchange of tokens and participation in liquidity pools for farming income. "},{"title":"Surf Staking​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#surf-staking","content":"A staking service from the popular Ever Surf. "},{"title":"Surf Depooler​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#surf-depooler","content":"Top depooler rating, performance analysis and depooler selection for more income. "},{"title":"Surf Payments​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#surf-payments","content":"Payments framework built on low-fees Everscale blockchain. "},{"title":"EVER DAO​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#ever-dao","content":"Everscale decentralized project management platform. "},{"title":"EverStart​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#everstart","content":"DAO-controlled multi-chain launchpad to connect with curated projects "},{"title":"EverLand​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#everland","content":"A P2P secured lending platform with interest on funds. "},{"title":"EverKit Coin​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#everkit-coin","content":"Everscale Coin Information (EVER): stats, wallets, and resources to buy: Exchanges, DEX, and P2P. "},{"title":"KWPC​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#kwpc","content":"The Killer Whale Pod Cast is a launch pad for young blockchain projects developed on the Everscale network. "},{"title":"EVER Pools​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#ever-pools","content":"Depool analysis by Broxus – the developer of FlatQube and Octus Bridge. "},{"title":"Ever Live​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#ever-live","content":"Everscale Blockchain Explorer by EverX. "},{"title":"EVER Scan​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#ever-scan","content":"Everscale Blockchain Explorer by Broxus. "},{"title":"Wrapped EVER​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#wrapped-ever","content":"WEVER is Wrapped EVER. Similar to Wrapped Ether but for Everscale. "},{"title":"FAQ","type":0,"sectionRef":"#","url":"learn/faq","content":"FAQ","keywords":""},{"title":"Governance","type":0,"sectionRef":"#","url":"learn/governance","content":"Governance","keywords":""},{"title":"History","type":0,"sectionRef":"#","url":"learn/history","content":"","keywords":""},{"title":"History behind TON blockchain​","type":1,"pageTitle":"History","url":"learn/history#history-behind-ton-blockchain","content":"The Telegram messenger project was created by brothers Nikolay and Pavel Durov in 2013. Nikolay Durov invented the MTProto encryption scheme, which formed the basis of the project. The main concept of Telegram messenger was privacy and secure communication of users. The messenger existed on Pavel Durov's personal funds until 2017. In 2017, Pavel Durov develops the concept of TON - Telegram Open Network. The Telegram Open Network project is inextricably linked with the Telegram Messenger, with plans to integrate the Gram cryptocurrency [1]. In December 2018 TON virtual machine delivired. In February 2018, Pavel Durov is raising $850 million in investments in the first round of ICO for the development of blockchain platform TON (price of the Gram token was $0.38). The ICO notification is officially registered by the US Securities and Exchange Commission (SEC). From the business plan of Pavel Durov, it follows that Telegram as a messenger is the first phase of a more global project, and was created mainly to form a huge customer base. As TON develops, the messenger itself will become just one of its applications, so in 2021 it is planned to rebrand Telegram Open Network into The Open Network, and the Telegram brand will remain with the messenger. The real goal of the project is the Telegram Open Network platform, which offers Gram cryptocurrency with fast transaction speeds, as well as various services from Proxy for bypassing censorship to bots and file storage that can be paid for with Gram cryptocurrency. In the second round of ICO, an additional $850 million are raised(price of the Gram is up to $1.33)[2]. At the same time, Pavel Durov rejected about half of the applications for investment until the third round of placement - investors wanted to invest more than $3.7 billion in the project. Pavel Durov's refusal to receive new investments is justified by the fact that his plan to raise money exceeded his expectations many times. The cost of establishing the Telegram Open Network is estimated at $400 million. At the same time, the total amount of raised investments amounted to $1.7 billion for both rounds. The whole amount was received from private investors who got Gram tokens in return for their investments. The list of investors includes quite famous personalities: Roman Arkadievich Abramovich (entrepreneur, included in the list of Forbes, invested $10 million through the fund Norma Investments Limited), David Mikhailovich Yakobashvili (founder of the company Wimm-Bill-Dann, invested $10 million), Sergey Alexandrovich Solonin (founder of the platform Qiwi, invested $ 17 million), Mikhail Safarbekovich Gutseriev (main shareholder of the group Safmar, the owner of the company M.Video and Eldorado, invested $15 million through Larnabel Ventures) [3]. TON blockchain platform was launched in autumn 2018. The developers then said that the network is 70% ready and most of the components have already been finalized. The launch of testnet should have taken place in January 2019, however, was postponed. Ferbuary 2019: TON Labs launches the first EVER blockchain with proof of authority (PoA). July 2019: TON Labs Launch of the alpha version of TON OS. On September 6, 2019, TON test portal for developers with official project specifications was opened - https://test.ton.org/, and on https://test.ton.org/testnet/ TON network explorer was available, displaying the first hundreds of working nodes of the network. The New York Times, commenting on these events, noted that the project produces test tokens ahead of schedule, which should satisfy investors. Observers, referring to experts in crypto, also note that Durov's strategy to keep the development of TON in relative secrecy has given rise to some skepticism in the cryptographic society about the competing Libra cryptocurrency project from Facebook, but in the end, it turned out to be correct, because Facebook, after making the development of Libra transparent, immediately incurred the anger of regulators. At the same time, crypto experts such as David Gerard note that despite the TON team's efforts to meet the KYC-AML principles, the project's central risk is similar to Libra - government regulators may be afraid of losing control of the financial system [4]. TON OS startup edition goes public. In October 2019, the U.S. Securities and Exchange Commission (SEC) demanded a ban on the issuance of Gram. The SEC, in its report, recognized Gram as security (not a commodity or utility token) and the Gram issue itself violated securities laws. On November 2019 TON Labs launches its own TON testnet. On January 7 and 8, 2020, the SEC interrogated Pavel Durov about TON ICO. The interrogation took place in Dubai, UAE. The American regulator was trying to find out why Durov launched the ICO, how much money he spent on Telegram and TON, and why Gram token is not a security. Durov replied that the money was needed to buy equipment and maintain the blockchain platform, and Gram was a utility token, not a security. On March 25, Telegram challenged the U.S. court ban on transferring Gram tokens to investors. The court of the Southern District of New York State in a preliminary decision agreed with the SEC's opinion that the project's cryptocurrency is a security. The U.S. authorities claim that investors purchased coins to sell on the secondary market to earn money. On May 12, 2020, Pavel Durov announced in his Telegram channel that he has closed the TON blockchain project. According to Pavel Durov, Telegram's participation in TON development is over. He urged users not to trust money or data to projects that use the name of the messenger or platform. No one from the company team participates in any of these projects, Durov said. He added that networks that use TON's developments may appear, but Telegram has nothing to do with them and is unlikely to ever support them. TON Labs participates in the community launch of the Free TON blockchain as the core developer On Thursday, May 7th, the Free TON Community (consisting of developers and potential TON users) launched the Free TON blockchain platform. Instead of Gram participants will get tokens called TON Crystal. To become a community member you need to sign Free TON Declaration of Decentralization. On August 2021 Everscale achieves world record high throughput. In 8 November, 2021, Free TON has announced an ecosystem rebrand to Everscale. The new brand identity comes as the network prepares to migrate from C++ to Rust programming language implementation, enabling unmatched scalability and throughput capable of bringing the world on-chain. December 2021: Free TON rebrands to Everscale Source: Everscale Wiki "},{"title":"Support","type":0,"sectionRef":"#","url":"learn/support","content":"Support","keywords":""},{"title":"Terminology","type":0,"sectionRef":"#","url":"learn/terminology","content":"Terminology","keywords":""},{"title":"Contributors","type":0,"sectionRef":"#","url":"learn/tutorial/contributors","content":"Contributors","keywords":""},{"title":"Developers","type":0,"sectionRef":"#","url":"learn/tutorial/developers","content":"Developers","keywords":""},{"title":"Multisig","type":0,"sectionRef":"#","url":"learn/tutorial/institutionals/multisig","content":"","keywords":""},{"title":"What is multisignature wallet?​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#what-is-multisignature-wallet","content":"As a simple analogy, we can imagine a secure deposit box that has two locks and two keys. One key is held by Alice and the other one is held by Bob. The only way they can open the box is by providing their both keys at the same time, so one cannot open the box without the consent of the other. Basically speaking, the funds stored on a multi-signature address can only be accessed by using 2 or more signatures. Therefore, the use of a multisig wallet enables users to create an additional layer of security to their funds. "},{"title":"Use cases for a multisignature wallet​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#use-cases-for-a-multisignature-wallet","content":""},{"title":"Increasing security​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#increasing-security","content":"By using a multisig wallet, users are able to prevent the problems caused by the loss or theft of a private key. So even if one of the keys is compromised, the funds are still safe. Imagine that Alice creates a 2-of-3 multisig address and then stores each private key into a different place or device (e.g. mobile phone, laptop, and tablet). Even if her mobile device is stolen, the thief won’t be able to access her funds using only 1 of the 3 keys. Similarly, phishing attacks and malware infections are less likely to succeed because the hacker would most likely have access to a single device and key. Malicious attacks aside, if Alice loses one of her private keys, she can still access her funds using the other 2 keys. "},{"title":"Two-factor authentication​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#two-factor-authentication","content":"By creating a multisig wallet that requires two keys, Alice is able to create a two-factor authentication mechanism to access her funds. For instance, she could have one private key stored in her laptop and the other one in her mobile device (or even on a piece of paper). This would ensure that only someone who has access to both keys is able to make a transaction. Keep in mind, however, that using multisig technology as two-factor authentication can be dangerous – especially if it is set as a 2-of-2 multisig address. If one of the keys are lost, you won’t be able to access your funds. "},{"title":"Escrow transactions​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#escrow-transactions","content":"Creating a 2-of-3 multisig wallet can allow for an escrow transaction between two parties (Alice and Bob) that includes a third party (Charlie) as a mutually trusted arbiter in case anything goes wrong. Charlie, the arbiter, would only need to step in if there was a dispute, at which point he could use his key to create a signature that would be provided to either Alice or Bob, according to Charlie’s judgment. "},{"title":"Decision making​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#decision-making","content":"A board of directors might use a multisig wallet to control access to a company’s funds. For example, by setting up a 4-of-6 wallet where each board member holds one key, no individual board member is able to misuse the funds. Therefore, only decisions that are agreed upon by the majority can be executed. "},{"title":"Everscale multisignature wallets​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#everscale-multisignature-wallets","content":"Let's move on to choosing a multi-signature wallet. "},{"title":"EVER Wallet​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#ever-wallet","content":"Everscale native wallet created by the Broxus team. Access on IOS, Android and as a Google Chrome browser extension. It has several types of multisignature wallets, including those with the ability to add new custodians. A distinctive feature of the wallet is the ability to connect it with Everscale's most popular DeFi products: FlatQube (DEX), Octus Bridge, Everstart (launchpad), etc. Download link "},{"title":"Ever Sufr​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#ever-sufr","content":"One of the most popular Everscale wallets. Available on IOS, Android, Windows and MacOS. Provides the ability to create a multisig wallet and add up to 32 custodians. Download link "},{"title":"Users","type":0,"sectionRef":"#","url":"learn/tutorial/users","content":"","keywords":""},{"title":"Buy and store tokens​","type":1,"pageTitle":"Users","url":"learn/tutorial/users#buy-and-store-tokens","content":"Everscale has several types of tokens, the most popular of which is the TIP-3 token format. The main network token is EVER. It is used to pay fees to validators, reward stakeholders and participants in contests run by the DAO management team, and performs a number of other important functions within the network. In order to store and manage tokens on the Everscale network, you will need a wallet that supports the TIP-3 token format. There are many different ways to buy EVER: Exchange walletsExchangesDEXS Check out the Wallets section for the most popular token storage solutions. "},{"title":"Popular cases of interaction with Everscale​","type":1,"pageTitle":"Users","url":"learn/tutorial/users#popular-cases-of-interaction-with-everscale","content":"Once you have an Everscale network wallet, you can start interacting with various products (Dapps) of the network. Everscale provides many earning opportunities for regular users. You can earn on farming, NFT, staking or trading on exchanges and DEX. In the Ecosystem section, you can get acquainted with the most popular representatives of Everscale dapps in various industries: DeFi, NFT, GameFi, etc. "},{"title":"Community​","type":1,"pageTitle":"Users","url":"learn/tutorial/users#community","content":"Everscale can be proud of its community - a community of friendly newbies and experienced users: network members help each other and discuss various aspects of the network in chats and on the Everscale forum. Go to the main Everscale chats and groups to see the strength of our unity: Everscale Community Everscale News EverKit Everscale DeFi Everscale Dev "},{"title":"Validators","type":0,"sectionRef":"#","url":"learn/tutorial/validators","content":"Validators","keywords":""},{"title":"TVM","type":0,"sectionRef":"#","url":"learn/tvm","content":"","keywords":""},{"title":"About TVM​","type":1,"pageTitle":"TVM","url":"learn/tvm#about-tvm","content":"The TVM , is the virtual machine used to execute smart-contract code in the masterchain and in the basic workchain. Other workchains may use other virtual machines alongside or instead of the TVM. Here we list some of its features. TVM represents all data as a collection of (TVM) cells. Each cell contains up to 128 data bytes and up to 4 references to other cells. As a consequence of the “everything is a bag of cells” philosophy, this enables TVM to work with all data related to the Everscale Blockchain, including blocks and blockchain global state if necessary. TVM can work with values of arbitrary algebraic data types, represented as trees or directed acyclic graphs of TVM cells. However, it is agnostic towards the existence of algebraic data types; it just works with cells. TVM has built-in support for hashmaps.TVM is a stack machine. Its stack keeps either 64-bit integers or cell references. 64-bit, 128-bit and 256-bit arithmetic is supported. All n-bit arithmetic operations come in three flavors: for unsigned integers, for signed integers and for integers modulo 2^n (no automatic overflow checks in the latter case). TVM has unsigned and signed integer conversion from n-bit to m-bit, for all 0 ≤ m, n ≤ 256, with overflow checks. All arithmetic operations perform overflow checks by default, greatly simplifying the development of smart contracts. TVM has “multiply-then-shift” and “shift-then-divide” arithmetic operations with intermediate values computed in a larger integer type; this simplifies implementing fixed-point arithmetic. TVM offers support for bit strings and byte strings. Support for 256-bit Elliptic Curve Cryptography (ECC) for some predefined curves, including Curve25519, is present. Support for Weil pairings on some elliptic curves, useful for fast implementation of zk-SNARKs, is also present. Support for popular hash functions, including sha256, is present. TVM can work with Merkle proofs.TVM offers support for “large” or “global” smart contracts. Such smart contracts must be aware of sharding. Usual (local) smart contracts can be sharding-agnostic. TVM supports closures. A “spineless tagless G-machine” can be easily implemented inside TVM.  Several high-level languages can be designed for TVM, in addition to the “TVM assembly”. All these languages will have static types and will support algebraic data types. We envision the following possibilities: A Java-like imperative language, with each smart contract resembling a separate class. A lazy functional language (think of Haskell). An eager functional language (think of ML).  "},{"title":"Peculiarities of TVM.​","type":1,"pageTitle":"TVM","url":"learn/tvm#peculiarities-of-tvm","content":"The TVM, used to run smart contracts in the masterchain and Workchain Zero, is considerably different from customary designs inspired by the EVM (Ethereum Virtual Machine): it works not just with 256-bit integers, but actually with (almost) arbitrary “records”, “structures”, or “sum-product types”, making it more suitable to execute code written in high-level (especially functional) languages. Essentially, TVM uses tagged data types, not unlike those used in implementations of Prolog or Erlang. \\ One might imagine first that the state of a TVM smart contract is not just a hashmap 2^256 → 2^256, or Hashmap(256, 2^256), but (as a first step) Hashmap(256, X), where X is a type with several constructors, enabling it to store, apart from 256-bit integers, other data structures, including other hashmaps Hashmap(256, X) in particular. This would mean that a cell of TVM (persistent or temporary) storage—or a variable or an element of an array in a TVM smart-contract code—may contain not only an integer, but a whole new hashmap. Of course, this would mean that a cell contains not just 256 bits, but also, say, an 8-bit tag, describing how these 256 bits should be interpreted. In fact, values do not need to be precisely 256-bit. The value format used by TVM consists of a sequence of raw bytes and references to other structures, mixed in arbitrary order, with some descriptor bytes inserted in suitable locations to be able to distinguish pointers from raw data (e.g., strings or integers); This raw value format may be used to implement arbitrary sum-product algebraic types. In this case, the value would contain a raw byte first, describing the “constructor” being used (from the perspective of a high-level language), and then other “fields” or “constructor arguments”, consisting of raw bytes and references to other structures depending on the constructor chosen. However, TVM does not know anything about the correspondence between constructors and their arguments; the mixture of bytes and references is explicitly described by certain descriptor bytes.* The Merkle tree hashing is extended to arbitrary such structures: to compute the hash of such a structure, all references are recursively replaced by hashes of objects referred to, and then the hash of the resulting byte string (descriptor bytes included) is computed. In this way, the Merkle tree hashing for hashmaps, described in 2.3.8, is just a special case of hashing for arbitrary (dependent) algebraic data types, applied to type Hashmap(n, X) with two constructors.** *These two descriptor bytes, present in any TVM cell, describe only the total number of references and the total number of raw bytes; references are kept together either before or after all raw bytes. **Actually, Leaf and Node are constructors of an auxiliary type, HashmapAux(n, X). Type Hashmap(n, X) has constructors Root and EmptyRoot, with Root containing a value of type HashmapAux(n, X). "},{"title":"TVM Cells​","type":1,"pageTitle":"TVM","url":"learn/tvm#tvm-cells","content":"Ultimately, the TVM keeps all data in a collection of (TVM) cells. Each cell contains two descriptor bytes first, indicating how many bytes of raw data are present in this cell (up to 128) and how many references to other cells are present (up to four). Then these raw data bytes and references follow. Each cell is referenced exactly once, so we might have included in each cell a reference to its “parent” (the only cell referencing this one). However, this reference need not be explicit. In this way, the persistent data storage cells of a Everscale smart contract are organized into a tree,* with a reference to the root of this tree kept in the smart-contract description. If necessary, a Merkle tree hash of this entire persistent storage is recursively computed, starting from the leaves and then simply replacing all references in a cell with the recursively computed hashes of the referenced cells, and subsequently computing the hash of the byte string thus obtained. *Logically; the “bag of cells” representation described in 2.5.5 identifies all duplicate cells, transforming this tree into a directed acyclic graph (dag) when serialized. "},{"title":"Additionally​","type":1,"pageTitle":"TVM","url":"learn/tvm#additionally","content":"You can learn more about TVM and how it works from several sources: Legacy TON WhitepaperTVM WhitepaperTVM Extended Instructions "},{"title":"Welcome","type":0,"sectionRef":"#","url":"learn/welcome","content":"","keywords":""},{"title":"About Everscale​","type":1,"pageTitle":"Welcome","url":"learn/welcome#about-everscale","content":"Everscale is a unique blockchain design that proposes a scalable decentralized world computer, paired with a distributed operating system — Ever OS. Ever OS is capable of processing millions of transactions per second, with Turing-complete smart contracts and decentralized user interfaces. Everscale presents some new and unique properties, such as dynamic multithreading, soft majority consensus and distributed programming, which enable it to be scalable, fast and secure at the same time. It is governed by a decentralized community founded upon meritocratic principles via Soft Majority Voting protocol. Everscale has powerful developer tools, such as compilers for Solidity and C++, API, SDK that includes client libraries for 13 programming languages and all popular platforms, local node for DApp testing, CLI tools and a range of decentralized browsers and wallets empowering many applications in DeFi, NFT, tokenization and governance domains. If you would like to learn more about Everscale, please visit the Everscale Overview page. Comparison with other networks "},{"title":"Everscale for you​","type":1,"pageTitle":"Welcome","url":"learn/welcome#everscale-for-you","content":"Everscale is able to interest several types of users with their own interests by providing them with different features. In this documentation we have created sections and tutorials for each type of user, so you can find key information for getting to know and immerse yourself in any part of Everscale: Users (Tutorial) - Everscale as an opportunity for storage and earnings (DeFi, NFT, etc.). Developers (Tutorial, Section) - Development on Everscale and technical details. Validators (Tutorial, Section) - Validating and staking. Contributors (Tutorial, Section) - Earning on partnership and benefiting the network. Intergators (Tutorial, Section) - Integration of Everscale technologies, listing of tokens, etc. "},{"title":"Key organizations​","type":1,"pageTitle":"Welcome","url":"learn/welcome#key-organizations","content":"Many organizations have formed around Everscale to grow the network: recruiting new teams, DAOs, grants, etc. Let's take a look at some of them: Everscale DeFi Alliance - Everscale DeFi Alliance creates the necessary infrastructure to attract and maintain strong teams and projects, attract liquidity from another projects to Everscale and establish a partnerships with major companies with large amounts of liquidity and/or a large number of transactions. Everscale Grants - Everscale Grants is a campaign that aims to attract promising IT projects that can contribute to the Everscale ecosystem's growth. EVER DAO - EVER DAO is a platform where EVER token holders can make on-chain governance decisions for the whole Everscale Network. Ever Foundation (the website is under construction) - The Ever Foundation shall become the primary entry point for all kinds of projects that want to develop and create their products and businesses on top of the Everscale. The Foundation provides grant support to projects that bring the greatest benefit to the network, and is also actively promoting them. "},{"title":"DeCert — Decentralized Certificates","type":0,"sectionRef":"#","url":"standard/TIP-2","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#abstract","content":"There is a clear need for unified decentralized and distributed certificate system in Free TON. As described in more details below, such system would be used in providing many services which requires a certified provable key-value store. For example a Decentralized Name Service (DeNS), a Prove of Ownership / Prove of Purchase certificate and many others. Current solutions (for example a TON DNS, proposed here) are either a large smart contracts which maintains a full list of records, or a tree-like solutions which shards the list based on some parameters. Neither of these solutions are satisfactory due to a lack of scalability, high costs of maintenance, long search time, single point of failure and so on. Here I present a completely distributed system, which does not require centralized record, nor a tree of domains or records with almost zero latency. The design relies heavily onе the principles of TIP-3 Token architecture with some notable modifications. "},{"title":"Issuance​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#issuance","content":"Root is a smart contract contains a Code of Certificate smart contract without data. The Root has methods for Certificate Issuance, Certificate Code Retrieval, Root PubKey retrieval and Version history. Each Certificate can become a Root, therefore a Root smart contract and its Certificate smart contract are the same. The Code contains an address of its Root. When a User wishes to register it is calling a Certificate Issuance method in Root, sending a Certificate Data (for example an alphanumeric string of a certificate body). Root is taking its Public Key and a Code of Certificate smart contract, inserts a Certificate Data sent by a User, calculates the address of Certificate and checks if the address already has a Certificate or any other Code deployed by sending a bounced true message calling getData method. If a contract exists it means that a Certificate with the same Certificate Data already exists. The contract then can return a registration information to the Root which will return it to a User. If a contract does not exist the message will bounce to the Root smart contract which will mean the Certificate can be registered. If Certificate does not exist the Root will Issue the Certificate by deploying the Certificate Contract with its Data. On deploy the Certificate will check that it has been deployed from the root address by comparing the address of a Root inside with the deployer address. If there is no match the deploy will fail. Of course additional business logic steps could be included between the last two steps, such as monetization or other mechanics as shown below in one of the examples. "},{"title":"Resolving​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#resolving","content":"To resolve the Name any User can now call Get method Resolve of a Root locally to obtain an Address. Root will use Certificate Code, Root PubKey, insert a name User wishes to resolve into Certificate Code and calculate the address. To resolve a Root smart contract one can take any Certificate Core and resolve for the Root name. A user application can cash the Certificate Code smart contract and Root PubKey once, after which resolving any name is achieved locally with a simple address calculation, with no need for network connection at all. The Certificate itself contains variable types of addresses of a target smart contracts to which the Certificate owner wishes the name to point. A user should choose which type of address they wish to use. "},{"title":"Reverse resolving​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#reverse-resolving","content":"In order to make a reverse resolving a smart contract need to state its certificate address. The user will check if certificate indeed has contract address. "},{"title":"Search​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#search","content":"Of course search is one of the most important features of any name system. Knowing a Certificate Code hash enables to retrieve all smart contracts having the same hash by simply querying the blockchain state. Decoding contract data will produce a full list of names under specific Root. It would be quite easy to produce a table with all the certificate records. "},{"title":"Example: Decentralized Name Service (DeNS)​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#example-decentralized-name-service-dens","content":"Let’s consider a DeNS Root is a smart contract which contains a Code of the Name Identity Certificate (NIC) smart contract. The Root has methods for Identity Registering, NIC Code Retrieval, Root PubKey retrieval, Version history. When a User wishes to register an Identity it is calling a «RegName» method in DeNS Root with the signed message of UTF-8 string (Name) together with a Registration Bid (a hash of a Bid Value in TONs with some salt) with value attached 1 TON. DeNS Root is taking its Public Key and a NIC Code inserts a Name, calculates the NIC address and checks if the address already has a NIC Code deployed by sending a bounced true message calling method «getName». Return to User a Whois Information. If it bounces or a registration period in Whois is less than 28 days DeNS Root will send the name into an Auction Smart Contract together with a Registration Bid Hash and a number of years before expiration. First bidder determines the duration of the auctioned name. Other users will be able to Bid for the same name but only for same duration with their Bids following exactly the same process. Auction duration is minimum 7 days per year of name duration but no more than 28 days. At the end of the Auction all participants will submit to the Auction contract a message signed from the address of the original bid together with their original bid price and salt. The winner of the auction will be determined by the highest bid per day and will pay the second higher price for the Name Certificate. Once DeNS Root knows the Auction result it will wait until registration period ends if the name certificate has existed before or immediately deploy the NIC smart contract into the address calculated as a NIC Contract Code with a Name inserted into initial data and PubKey of the Owner passed in its constructor. To resolve the Name any User can now call Get method «Resolve» of DeNS Root locally to obtain an Address. DeNS Root will use Code of NIC smart contract, a DeNS Root PubKey, insert any name they are wishing to resolve into NIC Code and calculate the address. Since most of the time a user application will just cash the Code of NIC smart contract and DeNS PubKey, resolving any name is achieved locally with a simple address calculation, with no need for network connection at all. "},{"title":"Example of NIC smart contract methods​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#example-of-nic-smart-contract-methods","content":"Whois — sends all certificate data: a name, date of registration, owner PubKey GetWhois is a whois getter GetAddress by Type, for example — ADNL, Wallet, RegName GetResolve ChangeAddress ChangeOwnership "},{"title":"Free TON Name Identity Certificate convention​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#free-ton-name-identity-certificate-convention","content":"Format: any alfa-numeric string except for a dot (.) and slash (/) which are prohibited. Only top level names are provided by DeNS Root, but any NIC smart contract can point into a next level of hierarchy which is divided by / top-name/sub-name/ The dot (.) is specifically prohibited as to not create confusions with a current internet domain system. "},{"title":"Example: Ownership Certificate​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#example-ownership-certificate","content":"The Certificate is issued by Root for ownership of an item. Let’s call it certificate of Ownership or COW for short. COW will include a serial number of an item a User want to prove owning. Since the PubKey of an owner of certificate is presented it is easy to prove an ownership of an Item by finding the certificate with corresponding serial number calculating the address of this certificate with this number, POW Code and Root PubKey without a need to maintain any centralized ledger of said items. The transfer of ownership of an Item is easily supported as well by calling a ChangeOwnership Method in the POW signed by the owner private key. "},{"title":"Reference​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#reference","content":"Contest Proposal: Decentralized Name Service (DeNS)ReDeNS — Reverse DeCert (TIP-2.1) "},{"title":"Free Software License (TIP-1.1)","type":0,"sectionRef":"#","url":"standard/TIP-1.1","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Free Software License (TIP-1.1)","url":"standard/TIP-1.1#introduction","content":"Many members of our community have asked questions about Free TON code philosophy. Why we call it Free Software? What is a relationship between Free TON and Free Software? What is the difference between Free Software and Open Source? I have decided to combine this with an idea I have regarding gas payment redistribution in TON. You will see below why it is related. The concept of Free Software predates open source. Richard Stallman has started the free-software movement in 1983 with a launch of GNU Project while open-source movement has been derived from Free Software only in 1998. To clarify, the Free Software is not in conflict with Open Source. As explained below it follows all the same principles and the differences seems more ideological. Yet TON project did not have any problem with open-source nature of it software. It is all open sourced. The problem was exactly about the Freedom of people to use it. That is why Free TON is heavily influenced by Free Software movement. Declaration of Decentralisation is, in many ways, inspired by Stallman’s «The GNU Manifesto»1. In «Why Open Source misses the point of Free Software» Stallman writes among other things: «The terms «free software» and «open source» stand for almost the same range of programs. However, they say different things about those programs, based on different values. The free software movement campaigns for freedom for the users of computing; it is a movement for freedom and justice. By contrast, the open source idea values mainly practical advantage and does not campaign for principles. This is why we do not agree with open source, and do not use that term»2. It seems Free TON is in agreement with this line of thought. While all our software is open source it is the Freedom to run the software what has launched this network. Now let’s talk about Copyright and Licensing as they relate to the Free Software in general and Blockchain in particular. Before we start I need to say that blockchain may potentially provide a solution to some of the free software inherited business model problems. We all remember that free in the free software stands for freedom and not for zero price. The ability to get paid for a software should not be based on restrictions imposed by its license. But what it should be based upon then? There are several business models for free software non of which really works. What works is a business model that is not exactly related to the software itself and therefore can not be attributed to it. Such as charging for support or for portions of the software which are closed source. It all seems quite unnatural. It also prevents one of the major points of free software — an open collaboration of the community around software projects. Donald Fischer article title «Open source creators: Red Hat got $34 billion and you got $0. Here’s why»3 is self explanatory. IBM has bought a commercial company that was built on top of many developers’ contribution to its code. Those developers never got any part out of the value they have created. "},{"title":"Aligning the incentives​","type":1,"pageTitle":"Free Software License (TIP-1.1)","url":"standard/TIP-1.1#aligning-the-incentives","content":"Many free and open source software projects struggle to introduce a sustainable business model. This is one of the reasons why most of the open source software contributors work for large corporations. When a venture capital provides funding to a software project it expects multiple return on its capital. With commercial software it is quite straight forward — a company is charging money for its software use and if successful passes profits to its stakeholders. With free software its quite difficult. That is why there are very few (or should we say: not enough) commercially successful open source software companies. Blockchain introduces a unique opportunity for Free Software developers to align their commercial interests with those of users for the benefit of the whole ecosystem. As an Internet of Value protocol, Blockchain has built-in network incentive mechanism — network fees (or gas). To remind: Miners in Proof-Of-Work collect miner rewards and network fees to compensate them for resources spent to secure the network and process transactions. Both security computations and transaction processing are separate resources, thus requiring separate fees. In Proof-Of-Stake Validators commit funds and processing power to secure the network and process transactions (in a form of smart contract execution in TON). For this they also get separate rewards: block rewards in a form of token emission and transaction reward in a form of a fee. Please note, rewards are separated in both cases. We propose to extend the reward model to transaction facilitators. It would be logical to pay part of the fees to the smart contract developer who is initiating the transaction which pays the fee. This will attract both Developers and Users which will increase network usage and total transaction fees for all network participants. "},{"title":"On-chain licensing fees​","type":1,"pageTitle":"Free Software License (TIP-1.1)","url":"standard/TIP-1.1#on-chain-licensing-fees","content":"Somewhat naive mechanism but with the same underlying idea is proposed by Near blockchain. «The developerReward are allocated by per block per account, as they can be efficiently done every time the transaction or receipts is being processed by the contract»4. The problem with this approach lays in the fact that network fees not only pays for resources but also provide an important anti spam mechanism. One can use the developer kick-back to simply lower an attack costs. To mitigate that risk we propose a use of a special Payout Contract. This contract is going to pay the collected Copyleft fees to developers only after certain threshold in both amount of fees and time frame are surpassed. In this respect the Developer motivation is again aligned with the Network security model — it is not practical to break the network where one receives a long term rent. "},{"title":"Some technical details​","type":1,"pageTitle":"Free Software License (TIP-1.1)","url":"standard/TIP-1.1#some-technical-details","content":"Technically we introduce a TVM Opcode FB0A. Contract may include that code together with a License information and address of its developer. Collator will include a reward related to gas fees from these transactions into the block for the address indicated in the TVM instruction in the amount corresponding to the indicated License. The percentage of gas fees depends on the license type such as that the most free software compatible license provides more gas. FB0A - COPYLEFT (n x y - ), looks up for the license rule for ‘n’ in ConfigParam (for example 42) and creates output action to send part of the tokens it collected from gas fees to Payout contract indicated in ConfigParam for address x:y, where x - is 32 bit signed integer for workchain and y is 256 bit unsigned integer for contract address in this workchain. It will not throw any exceptions if n or the address are incorrect. Generally allowed licenses are those supported by Free Software Foundation as described here: https://www.gnu.org/licenses/license-list.html#SoftwareLicenses 2 License types payout GPL-Compatible Free Software Licenses 2 → 30% fees GPL-Incompatible Free Software Licenses → 20% fees To implement we add network config parameter: license fees threshold value Collator check threshold each time the instruction is executed. After threshold is reached collator sends value to Developer Account defined in contract instruction FB0A TVM creates special out action with Developer Account (last call of FB0A matters) If account is been deleted, the executor sends value to Developer Account or to ValueFlow if it is not enough (this case must be checked in Validator) Executor analyzes special out action and counts value then sends message to developer account (payment for transaction gets from value) We add fields to json objects and QServer for SDK Collator and Validator must check fees from ValueFlow with Developer correction "},{"title":"Copyright discussion​","type":1,"pageTitle":"Free Software License (TIP-1.1)","url":"standard/TIP-1.1#copyright-discussion","content":"«What is the proper way to decide copyright policy? If copyright is a bargain made on behalf of the public, it should serve the public interest above all. The government’s duty when selling the public’s freedom is to sell only what it must, and sell it as dearly as possible. At the very least, we should pare back the extent of copyright as much as possible while maintaining a comparable level of publication»5. One important dimension of copyright is its durationAnother dimension of copyright policy is the extent of fair use: some ways of reproducing all or part of a published work that are legally permitted even though it is copyrighted. (c) Richard Stallman Both duration and fair use of copyright is balanced in this proposal by virtue of compensating copyright holder by Payout Contract creating an ongoing reward from the network while at the same time not preventing a forking possibility by other developers who then need to improve the software in a way that will bring new users and create new intensive for the new contributor. So both improvements as well as long term rent (subscription) is provided for developers. The Copyleft spirit is fully supported here as the Fee is collected for developers who facilitates the fees creation in the first place. The freedom to fork is fully executed as well as anyone can fork the code of a smart contract. In the end it is the community of users who chooses which contract to use and the decision is usually based upon the reputation of the code represented by the hash of the code where is no single byte has been changed. Therefore the system is merit-based. Both long term developer’s incentives for original developers and forking is provided. To recap the proposed system is compatible with all four essential freedoms: The freedom to run the program as you wish, for any purpose (freedom 0).The freedom to study how the program works, and change it so it does your computing as you wish (freedom 1). Access to the source code is a precondition for this.The freedom to redistribute copies so you can help others (freedom 2).The freedom to distribute copies of your modified versions to others (freedom 3). By doing this you can give the whole community a chance to benefit from your changes. Access to the source code is a precondition for this. "},{"title":"References​","type":1,"pageTitle":"Free Software License (TIP-1.1)","url":"standard/TIP-1.1#references","content":"The GNU Manifesto↩Why Open Source Misses the Point of Free Software↩Open source creators: Red Hat got $34 billion and you got $0. Here's why↩Economics in a Sharded Blockchain — Section 06 — Developer Business Models↩Misinterpreting Copyright — A Series of Errors↩ "},{"title":"ReDeNS — Reverse DeCert (TIP-2.1)","type":0,"sectionRef":"#","url":"standard/TIP-2.1","content":"ReDeNS — Reverse DeCert (TIP-2.1) In TIP-2 it is stated that in order to resolve a Certificate Address from the Contract Address, that contract must have its Certificate Address explicitly stated. There is a need sometimes to resolve some certificate address from the address of a contract. Here we present an architecture and implementation of Reverse DeCert and one of its usecases: ReDeNS Reverse Decentralized Names or ReDeNS for short is a certificate that enables reverse resolving of some contracts addresses from another contract. It uses a contract Placeholder for each type of contract functionality that we want to be able to put into external (or satellite) contract of a main contract. ReDeNs enables any client to calculate the address of a satellite contract using a ReDeNs code as a certificate for each type of satellite contract it desires to resolve. In order to resolve a ReDeNS address the user may calculate an address taking a hash of a main contract and a hash of ReDeNS certificate as initial data and an owner address or PubKey in constructor parameters. After the deploy of initial ReDeNS certificate code developer will use SetCode to change the ReDeNS certificate code to desired type of satellite smart contract (with ABI, Getter or DeBot functionality, respectively and so on) For example we have identified 3 types of satellite contracts which will be default ReDeNS Certificates of any main contract in Solidity and C++ Compilers and TON OS SDK: ABI, GETTERS and DEBOT. To protect contracts without ReDeNS certificate deployed from squatters we propose to use header with bitmask: one bit for each type of ReDeNS certificates: abi-DeCert, getters-DeCert, debot-DeCert and so on. So far, we decided to have 16-bit bitmask. 3 of them already occupied. { Abi, getters, debot }. The ReDeNS certificate code is as following: How to create DeBot derived from your smart contract","keywords":""},{"title":"Fungible Token","type":0,"sectionRef":"#","url":"standard/TIP-3","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Fungible Token","url":"standard/TIP-3#abstract","content":"The following standard describes the basic idea about distributed fungible token architecture. "},{"title":"Motivation​","type":1,"pageTitle":"Fungible Token","url":"standard/TIP-3#motivation","content":"The suggested standard differs considerably from Ethereum ERC20 and other smart contract token standards with single registry due to its distributed nature related to Everscale blockchain particularities. Given that Everscale has a storage fee, using an existing ERC20 standard design would cause excessive maintenance costs. Also, ERC20 is somewhat incompatible with the sharding architecture. Therefore, a Distributed Token standard is preferable. The ERC20 sharding implementation (with an idea to simply shard its registry) has drawbacks mainly related to complicated and expansive management. TIP-3 is fully distributed and implies separate storage of each user’s balance. "},{"title":"Architecture​","type":1,"pageTitle":"Fungible Token","url":"standard/TIP-3#architecture","content":"General information about token is stored in the token root contract. Each token holder has its own instance of token wallet contract. Token transfers SHOULD be implemented in P2P fashion, between sender and receiver token wallets. "},{"title":"Token root​","type":1,"pageTitle":"Fungible Token","url":"standard/TIP-3#token-root","content":"Token root contract stores the general information about the token, e.g. name, symbol, decimals, token wallet code and so on. "},{"title":"Token wallet​","type":1,"pageTitle":"Fungible Token","url":"standard/TIP-3#token-wallet","content":"Each token holder has its own instance of token wallet contract. Transfer happens in a decentralized fashion - sender token wallet SHOULD send the specific message to the receiver token wallet. Since token wallets have the same code, it's easy for receiver token wallet to check the correctness of sender token wallet. "},{"title":"References​","type":1,"pageTitle":"Fungible Token","url":"standard/TIP-3#references","content":"EIP-20: Token StandardForum FreeTON - TIP3Reference implementation by Broxus "},{"title":"Non-Fungible Token","type":0,"sectionRef":"#","url":"standard/TIP-4","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Non-Fungible Token","url":"standard/TIP-4#abstract","content":"TDB "},{"title":"Motivation​","type":1,"pageTitle":"Non-Fungible Token","url":"standard/TIP-4#motivation","content":"TDB "},{"title":"Non-Fungible Token (TIP-4.1)","type":0,"sectionRef":"#","url":"standard/TIP-4.1","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#abstract","content":"TDB "},{"title":"Motivation​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#motivation","content":"TDB "},{"title":"Fungible Token Interface (TIP-3.1)","type":0,"sectionRef":"#","url":"standard/TIP-3.1","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Fungible Token Interface (TIP-3.1)","url":"standard/TIP-3.1#abstract","content":"The following standard allows for the implementation of a standard API for tokens within smart contracts. General information about token is stored in the token root contract. Each token holder has its own instance of token wallet contract. Token transfers SHOULD be implemented in P2P fashion, between sender and receiver token wallets. "},{"title":"Motivation​","type":1,"pageTitle":"Fungible Token Interface (TIP-3.1)","url":"standard/TIP-3.1#motivation","content":"A standard interface allows any tokens on Everscale to be re-used by other applications: from wallets to decentralized exchanges. "},{"title":"Specification​","type":1,"pageTitle":"Fungible Token Interface (TIP-3.1)","url":"standard/TIP-3.1#specification","content":"The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. "},{"title":"Notes​","type":1,"pageTitle":"Fungible Token Interface (TIP-3.1)","url":"standard/TIP-3.1#notes","content":"We choose Standard Interface Detection to expose the interfaces that a TIP3 smart contract supports.This standard does not define the external methods to initiate transfer, mint or burn tokens. Though it defines the methods, which MUST be called on a recipient token wallet or token root during these operations.The rules for a token wallet ownership MUST be defined in a child standards.A -1 offset is added to some function IDs derivations, so the preimage of the hash cannot be known, further reducing the chances of a possible collisions. "},{"title":"Token root​","type":1,"pageTitle":"Fungible Token Interface (TIP-3.1)","url":"standard/TIP-3.1#token-root","content":"Name​ Returns the name of the token - e.g. &quot;MyToken&quot;. function name() public view responsible returns (string);  Symbol​ Returns the symbol of the token. E.g. “HIX”. function symbol() public view responsible returns (string);  Decimals​ Returns the number of decimals the token uses - e.g. 8, means to divide the token amount by 100000000 to get its user representation. function decimals() public view responsible returns (uint8);  Total supply​ Returns the total token supply. function totalSupply() public view responsible returns (uint128);  Token wallet code​ Returns the token wallet code. function walletCode() public view responsible returns (TvmCell);  Accept tokens burn​ Does not have a standard signature, but has a standard function ID 0x192B51B1 obtained as tvm.functionId('acceptBurn(uint128)') - 1. The uint128 _value parameter MUST be first. The function name and the rest of the parameters are not fixed by this standard and can be reinvented for each substandard. Decreases token total supply by _value. The contract MUST check that the sender is a correct token wallet. Before sending this message, caller token wallet MUST decrease its own balance by _value. If the mint can't be accepted (e.g. invalid sender), this message MUST be bounced. Any function from the following snippet is a valid example: interface TIP3AcceptBurn { function acceptBurn(uint128 _value) functionID(0x192B51B1) public; function acceptBurn2(uint128 _value, uint256 _publicKey, address _owner) functionID(0x192B51B1) public; function acceptBurn3(uint128 _value, TvmCell _meta) functionID(0x192B51B1) public; }  Standard interface detection​ interface TIP3TokenRoot { function acceptBurn(uint128 _value) functionID(0x192B51B1) public view responsible; function name() public view responsible returns (string); function symbol() public view responsible returns (string); function decimals() public view responsible returns (uint8); function totalSupply() public view responsible returns (uint128); function walletCode() public view responsible returns (TvmCell); }  The token root interface ID is 0x4371D8ED. "},{"title":"Token wallet​","type":1,"pageTitle":"Fungible Token Interface (TIP-3.1)","url":"standard/TIP-3.1#token-wallet","content":"Root​ Returns the token root address. function root() public view responsible returns (address);  Balance​ Returns the token wallet balance. function balance() public view responsible returns (uint128);  Wallet code​ Returns the token wallet code. function walletCode() public view responsible returns (TvmCell);  Accept tokens transfer​ Does not have a standard signature, but has a standard function ID 0x67A0B95F obtained as tvm.functionId('acceptTransfer(uint128)') - 1. The uint128 _value parameter MUST be first. The function name and the rest of the parameters are not fixed by this standard and can be reinvented for each substandard. Increases token wallet balance by _value. The contract MUST check that the sender is a correct token wallet. Before sending this message, caller token wallet MUST decrease its own balance by _value. If the transfer can't be accepted (e.g. invalid sender), this message MUST be bounced. Any function from the following snippet is a valid example: interface TIP3AcceptTransfer { function acceptTransfer(uint128 _value) functionID(0x67A0B95F) external; function acceptTransfer2(uint128 _value, uint256 _publicKey, address _owner) functionID(0x67A0B95F) external; function acceptTransfer3(uint128 _value, TvmCell _meta) functionID(0x67A0B95F) external; }  Accept tokens mint​ Does not have a standard signature, but has a standard function ID 0x4384F298 obtained as tvm.functionId('acceptMint(uint128)') - 1. The uint128 _value parameter MUST be first. The function name and the rest of the parameters are not fixed by this standard and can be reinvented for each substandard. Increases token wallet balance by _value. The contract MUST check that the sender is a correct token root. Before sending this message, token root MUST increase the total supply by _value. If the mint can't be accepted (e.g. invalid sender), this message MUST be bounced. Any function from the following snippet is a valid example: interface TIP3AcceptMint { function acceptMint(uint128 _value) functionID(0x4384F298) external; function acceptMint2(uint128 _value, uint256 _publicKey, address _owner) functionID(0x4384F298) external; function acceptMint3(uint128 _value, TvmCell _meta) functionID(0x4384F298) external; }  On-bounce behaviour​ The acceptTransfer or acceptBurn methods can be bounced, e.g. receiver token wallet has a different code or burning disabled. The token wallet behaviour in these cases should be implemented according to the following rules. Handle acceptTransfer bounce​ Increases token wallet balance according to the value, specified in the bounce body. Handle acceptBurn bounce​ Increases token wallet balance according to the value, specified in the bounce body. Standard interface detection​ interface TIP3TokenWallet { function acceptTransfer(uint128 _value) functionID(0x67A0B95F) external; function acceptMint(uint128 _value) functionID(0x4384F298) external; function root() public view responsible returns (address); function balance() public view responsible returns (uint128); function walletCode() public view responsible returns (TvmCell); }  The token wallet interface ID is 0x4F479FA3. "},{"title":"Fungible token payment link (TIP-5.1)","type":0,"sectionRef":"#","url":"standard/TIP-5.1","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Fungible token payment link (TIP-5.1)","url":"standard/TIP-5.1#abstract","content":"TDB "},{"title":"Motivation​","type":1,"pageTitle":"Fungible token payment link (TIP-5.1)","url":"standard/TIP-5.1#motivation","content":"TDB "},{"title":"URI scheme","type":0,"sectionRef":"#","url":"standard/TIP-5","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"URI scheme","url":"standard/TIP-5#abstract","content":"TDB "},{"title":"Motivation​","type":1,"pageTitle":"URI scheme","url":"standard/TIP-5#motivation","content":"TDB "},{"title":"Standard Interface Detection","type":0,"sectionRef":"#","url":"standard/TIP-6","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Standard Interface Detection","url":"standard/TIP-6#abstract","content":"Smart contracts in Everscale can implement a wide variety of functionality - wallets, tokens, exchanges and so on. We need a standard way to determine the type of smart contract without relying on knowledge of its internal structure. "},{"title":"Non-fungible token payment link (TIP-5.2)","type":0,"sectionRef":"#","url":"standard/TIP-5.2","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Non-fungible token payment link (TIP-5.2)","url":"standard/TIP-5.2#abstract","content":"TDB "},{"title":"Motivation​","type":1,"pageTitle":"Non-fungible token payment link (TIP-5.2)","url":"standard/TIP-5.2#motivation","content":"TDB "},{"title":"What is TIP? (TIP-0)","type":0,"sectionRef":"#","url":"standard/workflow","content":"What is TIP? (TIP-0) TIP — Trustless Improvement Proposal (TIPs) describe standards for the Everscale blockchain. They may include anything that the community considers in need of improvement or standardization. That can be specifications for core protocol, description of interfaces, smart contract standards and so on. I propose a more relaxed structure more closely resembling Bitcoin BIPs but with quite different proccess (see below). Each TIP should have the following parts (which are heavily copy-pasted from BIP requirements): Preamble — Headers containing metadata about the TIP;Abstract — A short (~200 word) description of the technical issue being addressed;Copyright — The TIP must be explicitly licensed under acceptable copyright terms;Specification — The technical specification should describe the syntax and semantics of any new feature;The specification should be detailed enough to allow competing, interoperable implementations;Motivation — The motivation is critical for TIPs that want to change the Everscale protocol. It should clearly explain why the existing protocol is inadequate to address the problem that the TIP solves;Rationale — The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work. The rationale should provide evidence of consensus within the community and discuss important objections or concerns raised during discussion;Backwards compatibility — All TIPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The TIP must explain how the author proposes to deal with these incompatibilities; Each TIP should pass the following process of acceptance: Proposal → Discussion → Community Voting → Reference Implementations Contest → Final TIP with Reference Implementations Reference implementation — The reference implementation must be completed before any TIP is given status Final, but it need not be completed before the TIP is accepted. It is better to finish the specification and rationale first and reach consensus on it before writing code. The final implementation must include test code and documentation appropriate for the Everscale protocol.","keywords":""},{"title":"Standard Interface Detection Interface (TIP-6.1)","type":0,"sectionRef":"#","url":"standard/TIP-6.1","content":"","keywords":""},{"title":"Simple summary​","type":1,"pageTitle":"Standard Interface Detection Interface (TIP-6.1)","url":"standard/TIP-6.1#simple-summary","content":"Creates a standard method to publish and detect what interfaces a smart contract implements. "},{"title":"Abstract​","type":1,"pageTitle":"Standard Interface Detection Interface (TIP-6.1)","url":"standard/TIP-6.1#abstract","content":"Herein, we standardize the following: How interfaces are identifiedHow a contract will publish the interfaces it implements "},{"title":"Motivation​","type":1,"pageTitle":"Standard Interface Detection Interface (TIP-6.1)","url":"standard/TIP-6.1#motivation","content":"For some “standard interfaces” like the token interface, it is sometimes useful to query whether a contract supports the interface and if yes, which version of the interface, in order to adapt the way in which the contract is to be interacted with. This proposal standardizes the concept of interfaces and standardizes the identification (naming) of interfaces. "},{"title":"Specification​","type":1,"pageTitle":"Standard Interface Detection Interface (TIP-6.1)","url":"standard/TIP-6.1#specification","content":""},{"title":"How interfaces are identified​","type":1,"pageTitle":"Standard Interface Detection Interface (TIP-6.1)","url":"standard/TIP-6.1#how-interfaces-are-identified","content":"For this standard, an interface is a set of function selectors as defined by the Solidity ABI. This a subset of Solidity’s concept of interfaces and the interface keyword definition which also defines return types, mutability and events. We define the interface identifier as the XOR of all function selectors in the interface. This code example shows how to calculate an interface identifier: Solidity​ interface Solidity101 { function hello() external pure; function world(int) external pure; } contract Selector { function calculateSelector() public view returns (bytes4) { Solidity101 i; return bytes4(tvm.functionId(i.hello) ^ tvm.functionId(i.world)); } }  How a Contract will Publish the Interfaces it Implements​ A contract that is compliant with TIP6.1 shall implement the following interface: Solidity​ interface TIP6 { /// @notice Query if a contract implements an interface /// @param interfaceID The interface identifier, as specified in TIP6.1 /// @dev Interface identification is specified in TIP6.1. /// @return `true` if the contract implements `interfaceID` and /// `interfaceID` is not 0xffffffff, `false` otherwise function supportsInterface(bytes4 interfaceID) external view responsible returns (bool); }  The interface identifier for this interface is 0x3204EC29. You can calculate this by running tvm.functionId('supportsInterface(bytes4)'); or using the Selector contract above. Therefore, the implementing contract will have a supportsInterface function that returns: true when interfaceID is 0x3204EC29 (TIP6.1 interface)false when interfaceID is 0xfffffffftrue for any other interfaceID this contract implementsfalse for any other interfaceID "},{"title":"References​","type":1,"pageTitle":"Standard Interface Detection Interface (TIP-6.1)","url":"standard/TIP-6.1#references","content":"EIP-165: Standard Interface Detection "},{"title":"Delegate","type":0,"sectionRef":"#","url":"validate/delegate","content":"Delegate","keywords":""},{"title":"Contributing","type":0,"sectionRef":"#","url":"validate/contributing","content":"Contributing","keywords":""},{"title":"Economics","type":0,"sectionRef":"#","url":"validate/economics","content":"Economics","keywords":""},{"title":"Monitoring","type":0,"sectionRef":"#","url":"validate/monitoring","content":"Monitoring","keywords":""},{"title":"Run Mainnet Node","type":0,"sectionRef":"#","url":"validate/run-validator/run-mainnet-node","content":"","keywords":""},{"title":"1. System Requirements​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#1-system-requirements","content":""},{"title":"2. Prerequisites​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#2-prerequisites","content":""},{"title":"2.1 Set the Environment​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#21-set-the-environment","content":"Adjust (if needed) main.ton.dev/scripts/env.sh: Set export DEPOOL_ENABLE=yes in env.sh for a depool validator (an elector request is sent to a depool from a validator multisignature wallet). Set export DEPOOL_ENABLE=no in env.sh for a direct staking validator (an elector request is sent from a multisignature wallet directly to the elector). cd main.ton.dev/scripts/ . ./env.sh  Note: Make sure to run the script as . ./env.sh, not ./env.sh 2.2 Install Dependencies​ install_deps.sh script supports Ubuntu OS only. ./install_deps.sh  Install and configure Docker according to the official documentation. Note: Make sure to add your user to the docker group, or run subsequent command as superuser: sudo usermod -a -G docker $USER  "},{"title":"3. Deploy RUST Validator Node​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#3-deploy-rust-validator-node","content":"Do this step when the network is launched. Deploy the node: ./deploy.sh 2&gt;&amp;1 | tee ./deploy.log  Note: the log generated by this command will be located in the main.ton.dev/scripts/ folder and can be useful for troubleshooting. Wait until the node is synced. Depending on network throughput this step may take significant time (up to several hours). "},{"title":"4. Check Node synchronization​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#4-check-node-synchronization","content":"Use the following command to check if the node is synced: docker exec -it rnode /ton-node/tools/console -C /ton-node/configs/console.json --cmd getstats  Script output example: tonlabs console 0.1.254 COMMIT_ID: BUILD_DATE: 2021-12-24 10:53:20 +0300 COMMIT_DATE: GIT_BRANCH: { &quot;sync_status&quot;: &quot;synchronization finished&quot;, &quot;masterchainblocktime&quot;: 1640343840, &quot;masterchainblocknumber&quot;: 13393489, &quot;timediff&quot;: 4, &quot;in_current_vset_p34&quot;: true, &quot;in_next_vset_p36&quot;: false, &quot;last_applied_masterchain_block_id&quot;: {&quot;shard&quot;:&quot;-1:8000000000000000&quot;,&quot;seq_no&quot;:13393489,&quot;rh&quot;:&quot;e74d505222bbe64617bbd42939cf01334b035990ae4b4e285e67ecbb1b537dd3&quot;,&quot;fh&quot;:&quot;fc0be7c22310389400a7bdbd000b3737b317ce44d92e9a5ed72086c4fa404afa&quot;}, &quot;processed_workchain&quot;: 0, &quot;validation_stats&quot;: { &quot;-1:8000000000000000&quot;: &quot;1 sec ago&quot;, &quot;0:e800000000000000&quot;: &quot;1 sec ago&quot; }, &quot;collation_stats&quot;: { &quot;-1:8000000000000000&quot;: &quot;never&quot;, &quot;0:e800000000000000&quot;: &quot;6 sec ago&quot; }, &quot;tps_10&quot;: 2, &quot;tps_300&quot;: 1 }  If the timediff parameter is less than 10 seconds, synchronization with masterchain is complete.&quot;sync_status&quot;: &quot;synchronization finished&quot; means synchronization with workchains is complete Note: The sync process may not start for up to one hour after node deployment, during which this command may result in error messages. If errors persist for more than an hour after deployment, review deployment log for errors and check the network status. "},{"title":"5. Configure validator multisignature wallet​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#5-configure-validator-multisignature-wallet","content":"There is a small difference between direct staking and DePool validators on this step: For direct staking validator it is necessary to create and deploy a validator SafeMultisig wallet in -1 chain.For a DePool validator it is necessary to create and deploy a validator SafeMultisig wallet in 0 chain. You can use TONOS-CLI for this purpose. It should be configured to connect to the main.ton.dev network. Refer to this document for the detailed wallet creation procedure, or follow the links in the short guide below: All wallet custodians should create seed phrases and public keys for themselves. At least three custodians are recommended for validator wallet, one of which will be used by the validator node. All seed phrases should be kept secret by their owners and securely backed up.The wallet deployer (who may or may not be one of the custodians) should gather the public keys from all custodians.The wallet deployer should obtain SafeMultisig contract code from the repository.The wallet deployer should generate deployment keys.The wallet deployer should generate validator wallet address: in -1 chain for direct staking validator or in 0 chain for a DePool validator.Any user should send at least 1 token to the generated wallet address to create it in the blockchain.The wallet deployer should deploy the wallet contact to the blockchain and set all gathered public keys as its custodians. At this step the number of custodian signatures required to make transactions from the wallet is also set (&gt;=2 recommended for validator wallets). Deploy to -1 chain for direct staking validator or to 0 chain for a DePool validator.In case of direct staking, the funds for staking should be transferred to the newly created validator wallet. Once the wallet is deployed, place 2 files on the validator node: /ton-node/configs/${VALIDATOR_NAME}.addr should contain validator multisignature wallet address in form X:XXX...XXX (the folder on the host is main.ton.dev/docker-compose/ton-node/configs) /ton-node/configs/keys/msig.keys.json should contain validator multisignature custodian's keypair (the folder on the host is main.ton.dev/docker-compose/ton-node/configs/keys/) The node will use the wallet address and the keys provided to it to generate election requests each validation cycle. Note: If the validator wallet requires more than 1 custodian signature to make transactions, make sure each transaction sent by the validator node is confirmed by the required amount of custodians. "},{"title":"6. Configure DePool​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#6-configure-depool","content":"For a DePool validator it is necessary to deploy a DePool contract to workchain 0. You can use TONOS-CLI for this purpose. It should be configured to connect to the main.ton.dev network. Refer to this document for the detailed DePool creation procedure, or follow the links in the short guide below: Obtain contract code from the repository.Generate deployment keys.Calculate contract addresses.Send tokens to the calculated addresses.Deploy contracts. Make sure to specify your validator wallet in the DePool contract at this step.Configure DePool state update method. Once DePool is successfully deployed and configured to be regularly called to update its state, you can make stakes in it. Note that validator stakes must always exceed validator assurance, otherwise DePool will not participate in elections. Also note, that DePool and supporting contracts balance should be monitored and kept positive at all times. Once the validator wallet and the DePool are deployed, place 3 files on the validator node: /ton-node/configs/${VALIDATOR_NAME}.addr should contain validator multisignature wallet address in form 0:XXX...XXX (the folder on the host is main.ton.dev/docker-compose/ton-node/configs)/ton-node/configs/keys/msig.keys.json should contain validator multisignature custodian's keypair (the folder on the host is main.ton.dev/docker-compose/ton-node/configs/keys/)/ton-node/configs/depool.addr should contain DePool address in form 0:XXX...XXX (the folder on the host is main.ton.dev/docker-compose/ton-node/configs) The script generating validator election requests (directly through multisig wallet, or through DePool, depending on the setting selected on step 2.1) will run regularly, once the necessary addresses and keys are provided. "},{"title":"7. Upgrade RUST Validator Node​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#7-upgrade-rust-validator-node","content":"Note: You may need to renew your copy of main.ton.dev scripts but do not remove any working files from the previous deployment (for example, configs folder). Adjust (specify new commit ID) main.ton.dev/scripts/env.sh: export TON_NODE_GITHUB_REPO=&quot;https://github.com/tonlabs/ton-labs-node.git&quot; export TON_NODE_GITHUB_COMMIT_ID=&quot;master&quot; export TON_NODE_TOOLS_GITHUB_REPO=&quot;https://github.com/tonlabs/ton-labs-node-tools.git&quot; export TON_NODE_TOOLS_GITHUB_COMMIT_ID=&quot;master&quot; export TONOS_CLI_GITHUB_REPO=&quot;https://github.com/tonlabs/tonos-cli.git&quot; export TONOS_CLI_GITHUB_COMMIT_ID=&quot;master&quot;  Upgrade the node: ./upgrade.sh 2&gt;&amp;1 | tee ./upgrade.log  Note: the log generated by this command will be located in the main.ton.dev/scripts/ folder and can be useful for troubleshooting. Wait until the node is synced. Stopping, restarting the RUST Node Note: call docker-compose commands from the main.ton.dev/docker-compose/ton-node folder. To stop the node use the following command: docker-compose stop  To restart a stopped node use the following command: docker-compose restart  Logging "},{"title":"During deployment​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#during-deployment","content":"It is highly recommended to record the full log during node deployment: ./deploy.sh 2&gt;&amp;1 | tee ./deploy.log  The log is saved to the main.ton.dev/scripts/ folder next to the deployment script and can be useful for troubleshooting. "},{"title":"During operation​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#during-operation","content":"When operational, the node keeps a number of logs in the main.ton.dev/docker-compose/ton-node/logs folder. Logs are generated with log4rs framework. For detailed documentation on it refer to https://docs.rs/log4rs/1.0.0/log4rs/. Logging configuration is determined by the main.ton.dev/docker-compose/ton-node/configs/log_cfg.yml file. By default is contains the recommended configuration for the Rust node. refresh_rate: 30 seconds appenders: stdout: kind: console encoder: pattern: &quot;{d(%s.%f)} {l} [{h({t})}] {I}: {m}{n}&quot; stdout_ref: kind: console encoder: pattern: &quot;{f}:{L} {l} [{h({t})}] {I}: {m}{n}&quot; logfile: kind: file path: &quot;/ton-node/logs/output.log&quot; encoder: pattern: &quot;{d(%s.%f)} {l} [{h({t})}] {I}: {m}{n}&quot; rolling_logfile: kind: rolling_file encoder: pattern: &quot;{d(%Y-%m-%d %H:%M:%S.%f)} {l} [{h({t})}] {I}: {m}{n}&quot; path: /ton-node/logs/output.log policy: kind: compound trigger: kind: size limit: 50 gb roller: kind: fixed_window pattern: '/ton-node/logs/output_{}.log' base: 1 count: 1 tvm_logfile: kind: file path: &quot;target/log/tvm.log&quot; encoder: pattern: &quot;{m}{n}&quot; root: level: info appenders: - rolling_logfile loggers: # node messages ton_node: level: trace boot: level: trace sync: level: trace # adnl messages adnl: level: info overlay: level: info rldp: level: info dht: level: info # block messages ton_block: level: debug # block messages executor: level: debug # tvm messages tvm: level: info librdkafka: level: info validator: level: debug catchain: level: debug validator_session: level: debug  The currently configured targets are the following: ton_node: node-related messages, except initial boot and sync, block exchange with other nodes boot: initial boot messages, creation of trusted key block chain, loading blockchain state sync: node synchronization - loading a certain number of most recent blocks adnl: messages of the ADNL protocol overlay: messages of the overlay protocol rldp: messages of the RLDP protocol dht: messages of the DHT protocol ton_block: messages of the block structures library, logs are turned on in debug executor: messages of the smart contract execution library, logs are turned on in debug tvm: ton virtual machine messages, logs are turned on in debug librdkafka: kafka client library messages validator: top level consensus protocol messages catchain: low level consensus protocol messages validator_session: mid level consensus protocol messages Migrating from C++ node To migrate your validator from legacy C++ node to Rust node, complete the following steps: Set up a new host for the Rust node, according to steps 1-3 of this document.Wait for node to sync. Check sync according to step 4 of this document.Stop the C++ node sending election requests (by default - disable scheduling of the validator script). Do not shut down the C++ validator itself, let it finish the current round.Configure validator wallet and corresponding keys, optionally - DePool (copy them from C++ node files to Rust Node files). By default: Copy validator wallet address from ~/ton-keys/$(hostname -s).addr file on the C++ node to /ton-node/configs/${VALIDATOR_NAME}.addr on the Rust Node.Copy validator wallet keys from /ton-keys/msig.keys.json on the C++ node to /ton-node/configs/keys/msig.keys.json on the Rust Node.If you have a DePool set up, copy DePool address from ~/ton-keys/depool.addr on the C++ node to /ton-node/configs/depool.addr on the Rust Node. Once this is done, the Rust node validator script will start automatically with the next round. DO NOT shut down the C++ host. Wait for the C++ node to complete the current round until the validator set is changed.Check logs/validator.log on the Rust node, and make sure the first election request was successfully sent. There should be no errors in the log.Only once the validator set changes, the C++ node is no longer a validator and the Rust node starts validating (validation_stats and collation_stats in the console output should not be empty), shut down the C++ node. Troubleshooting Here are some solutions to frequently encountered problems. "},{"title":"1. Couldn’t connect to Docker daemon at http+docker://localhost​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#1-couldnt-connect-to-docker-daemon-at-httpdockerlocalhost","content":"This error occurs in two cases. Either the docker daemon isn't running, or current user doesn't have rights to access docker. You can fix the rights issue either by running relevant commands as the superuser or adding the user to the docker group: sudo usermod -a -G docker $USER  Make sure to restart the system or log out and back in, for the new group settings to take effect. "},{"title":"2. thread 'main' panicked error when checking node synchronization​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#2-thread-main-panicked-error-when-checking-node-synchronization","content":"The following error may occur for a short time immediately after node deployment when attempting to check synchronization: thread 'main' panicked at 'Can't create client: Os { code: 111, kind: ConnectionRefused, message: &quot;Connection refused&quot; }', bin/console.rs:454:59  Currently this is expected behavior, unless it persists for more than a few minutes. If it does persist, check network status at https://ever.live, and, if the network is up and running, review deployment logs for errors. "},{"title":"3. Error executing command when checking node synchronization​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#3-error-executing-command-when-checking-node-synchronization","content":"The following error may occur for up to an hour after node deployment when attempting to check synchronization: Error executing command: Error receiving answer: early eof bin/console.rs:296  Currently this is expected behavior, unless it persists for more than one hour. If it does persist, check network status at https://ton.live/, and, if the network is up and running, review deployment logs for errors. "},{"title":"4. Cannot stop/restart/remove node container​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#4-cannot-stoprestartremove-node-container","content":"Make sure you are running all docker-compose commands from the main.ton.dev/docker-compose/ton-node folder. "},{"title":"5. DePool state not updating​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#5-depool-state-not-updating","content":"It's recommended to send at least two ticktocks while the elections are open. For rust node you can use the provided ticktock script, which sends 5 ticktocks after the elections open. "},{"title":"Run testnet node","type":0,"sectionRef":"#","url":"validate/run-validator/run-testnet-node","content":"","keywords":""},{"title":"1. System Requirements​","type":1,"pageTitle":"Run testnet node","url":"validate/run-validator/run-testnet-node#1-system-requirements","content":""},{"title":"2. Prerequisites​","type":1,"pageTitle":"Run testnet node","url":"validate/run-validator/run-testnet-node#2-prerequisites","content":""},{"title":"2.1 Set the Environment​","type":1,"pageTitle":"Run testnet node","url":"validate/run-validator/run-testnet-node#21-set-the-environment","content":"Adjust (if needed) net.ton.dev/scripts/env.sh: Set export DEPOOL_ENABLE=yes in env.sh for a depool validator (an elector request is sent to a depool from a validator multisignature wallet). Set export DEPOOL_ENABLE=no in env.sh for a direct staking validator (an elector request is sent from a multisignature wallet directly to the elector). cd net.ton.dev/scripts/ . ./env.sh  Note: Make sure to run the script as . ./env.sh, not ./env.sh 2.2 Install Dependencies​ install_deps.sh script supports Ubuntu OS only. ./install_deps.sh  Install and configure Docker according to the official documentation. Note: Make sure to add your user to the docker group, or run subsequent command as superuser: sudo usermod -a -G docker $USER  "},{"title":"3. Deploy RUST Validator Node​","type":1,"pageTitle":"Run testnet node","url":"validate/run-validator/run-testnet-node#3-deploy-rust-validator-node","content":"Do this step when the network is launched. Deploy the node: ./deploy.sh 2&gt;&amp;1 | tee ./deploy.log  Note: the log generated by this command will be located in the net.ton.dev/scripts/ folder and can be useful for troubleshooting. Wait until the node is synced. Depending on network throughput this step may take significant time (up to several hours). "},{"title":"4. Check Node synchronization​","type":1,"pageTitle":"Run testnet node","url":"validate/run-validator/run-testnet-node#4-check-node-synchronization","content":"Use the following command to check if the node is synced: docker exec -it rnode /ton-node/tools/console -C /ton-node/configs/console.json --cmd getstats  Script output example: tonlabs console 0.1.254 COMMIT_ID: BUILD_DATE: 2021-12-24 10:53:20 +0300 COMMIT_DATE: GIT_BRANCH: { &quot;sync_status&quot;: &quot;synchronization finished&quot;, &quot;masterchainblocktime&quot;: 1640343840, &quot;masterchainblocknumber&quot;: 13393489, &quot;timediff&quot;: 4, &quot;in_current_vset_p34&quot;: true, &quot;in_next_vset_p36&quot;: false, &quot;last_applied_masterchain_block_id&quot;: {&quot;shard&quot;:&quot;-1:8000000000000000&quot;,&quot;seq_no&quot;:13393489,&quot;rh&quot;:&quot;e74d505222bbe64617bbd42939cf01334b035990ae4b4e285e67ecbb1b537dd3&quot;,&quot;fh&quot;:&quot;fc0be7c22310389400a7bdbd000b3737b317ce44d92e9a5ed72086c4fa404afa&quot;}, &quot;processed_workchain&quot;: 0, &quot;validation_stats&quot;: { &quot;-1:8000000000000000&quot;: &quot;1 sec ago&quot;, &quot;0:e800000000000000&quot;: &quot;1 sec ago&quot; }, &quot;collation_stats&quot;: { &quot;-1:8000000000000000&quot;: &quot;never&quot;, &quot;0:e800000000000000&quot;: &quot;6 sec ago&quot; }, &quot;tps_10&quot;: 2, &quot;tps_300&quot;: 1 }  If the timediff parameter is less than 10 seconds, synchronization with masterchain is complete.&quot;sync_status&quot;: &quot;synchronization finished&quot; means synchronization with workchains is complete Note: The sync process may not start for up to one hour after node deployment, during which this command may result in error messages. If errors persist for more than an hour after deployment, review deployment log for errors and check the network status. "},{"title":"5. Configure validator multisignature wallet​","type":1,"pageTitle":"Run testnet node","url":"validate/run-validator/run-testnet-node#5-configure-validator-multisignature-wallet","content":"There is a small difference between direct staking and DePool validators on this step: For direct staking validator it is necessary to create and deploy a validator SafeMultisig wallet in -1 chain.For a DePool validator it is necessary to create and deploy a validator SafeMultisig wallet in 0 chain. You can use TONOS-CLI for this purpose. It should be configured to connect to the net.ton.dev network. Refer to this document for the detailed wallet creation procedure, or follow the links in the short guide below: All wallet custodians should create seed phrases and public keys for themselves. At least three custodians are recommended for validator wallet, one of which will be used by the validator node. All seed phrases should be kept secret by their owners and securely backed up.The wallet deployer (who may or may not be one of the custodians) should gather the public keys from all custodians.The wallet deployer should obtain SafeMultisig contract code from the repository.The wallet deployer should generate deployment keys.The wallet deployer should generate validator wallet address: in -1 chain for direct staking validator or in 0 chain for a DePool validator.Any user should send at least 1 token to the generated wallet address to create it in the blockchain.The wallet deployer should deploy the wallet contact to the blockchain and set all gathered public keys as its custodians. At this step the number of custodian signatures required to make transactions from the wallet is also set (&gt;=2 recommended for validator wallets). Deploy to -1 chain for direct staking validator or to 0 chain for a DePool validator.In case of direct staking, the funds for staking should be transferred to the newly created validator wallet. Once the wallet is deployed, place 2 files on the validator node: /ton-node/configs/${VALIDATOR_NAME}.addr should contain validator multisignature wallet address in form X:XXX...XXX (the folder on the host is net.ton.dev/docker-compose/ton-node/configs) /ton-node/configs/keys/msig.keys.json should contain validator multisignature custodian's keypair (the folder on the host is net.ton.dev/docker-compose/ton-node/configs/keys/) The node will use the wallet address and the keys provided to it to generate election requests each validation cycle. Note: If the validator wallet requires more than 1 custodian signature to make transactions, make sure each transaction sent by the validator node is confirmed by the required amount of custodians. "},{"title":"6. Configure DePool​","type":1,"pageTitle":"Run testnet node","url":"validate/run-validator/run-testnet-node#6-configure-depool","content":"For a DePool validator it is necessary to deploy a DePool contract to workchain 0. You can use TONOS-CLI for this purpose. It should be configured to connect to the net.ton.dev network. Refer to this document for the detailed DePool creation procedure, or follow the links in the short guide below: Obtain contract code from the repository.Generate deployment keys.Calculate contract addresses.Send tokens to the calculated addresses.Deploy contracts. Make sure to specify your validator wallet in the DePool contract at this step.Configure DePool state update method. Once DePool is successfully deployed and configured to be regularly called to update its state, you can make stakes in it. Note that validator stakes must always exceed validator assurance, otherwise DePool will not participate in elections. Also note, that DePool and supporting contracts balance should be monitored and kept positive at all times. Once the validator wallet and the DePool are deployed, place 3 files on the validator node: /ton-node/configs/${VALIDATOR_NAME}.addr should contain validator multisignature wallet address in form 0:XXX...XXX (the folder on the host is net.ton.dev/docker-compose/ton-node/configs)/ton-node/configs/keys/msig.keys.json should contain validator multisignature custodian's keypair (the folder on the host is net.ton.dev/docker-compose/ton-node/configs/keys/)/ton-node/configs/depool.addr should contain DePool address in form 0:XXX...XXX (the folder on the host is net.ton.dev/docker-compose/ton-node/configs) The script generating validator election requests (directly through multisig wallet, or through DePool, depending on the setting selected on step 2.1) will run regularly, once the necessary addresses and keys are provided. "},{"title":"7. Upgrade RUST Validator Node​","type":1,"pageTitle":"Run testnet node","url":"validate/run-validator/run-testnet-node#7-upgrade-rust-validator-node","content":"Note: You may need to renew your copy of net.ton.dev scripts but do not remove any working files from the previous deployment (for example, configs folder). Adjust (specify new commit ID) net.ton.dev/scripts/env.sh: export TON_NODE_GITHUB_REPO=&quot;https://github.com/tonlabs/ton-labs-node.git&quot; export TON_NODE_GITHUB_COMMIT_ID=&quot;master&quot; export TON_NODE_TOOLS_GITHUB_REPO=&quot;https://github.com/tonlabs/ton-labs-node-tools.git&quot; export TON_NODE_TOOLS_GITHUB_COMMIT_ID=&quot;master&quot; export TONOS_CLI_GITHUB_REPO=&quot;https://github.com/tonlabs/tonos-cli.git&quot; export TONOS_CLI_GITHUB_COMMIT_ID=&quot;master&quot;  Upgrade the node: ./upgrade.sh 2&gt;&amp;1 | tee ./upgrade.log  Note: the log generated by this command will be located in the net.ton.dev/scripts/ folder and can be useful for troubleshooting. Wait until the node is synced. Stopping, restarting the RUST Node Note: call docker-compose commands from the net.ton.dev/docker-compose/ton-node folder. To stop the node use the following command: docker-compose stop  To restart a stopped node use the following command: docker-compose restart  Logging "},{"title":"During deployment​","type":1,"pageTitle":"Run testnet node","url":"validate/run-validator/run-testnet-node#during-deployment","content":"It is highly recommended to record the full log during node deployment: ./deploy.sh 2&gt;&amp;1 | tee ./deploy.log  The log is saved to the net.ton.dev/scripts/ folder next to the deployment script and can be useful for troubleshooting. "},{"title":"During operation​","type":1,"pageTitle":"Run testnet node","url":"validate/run-validator/run-testnet-node#during-operation","content":"When operational, the node keeps a number of logs in the net.ton.dev/docker-compose/ton-node/logs folder. Logs are generated with log4rs framework. For detailed documentation on it refer to https://docs.rs/log4rs/1.0.0/log4rs/. Logging configuration is determined by the net.ton.dev/docker-compose/ton-node/configs/log_cfg.yml file. By default is contains the recommended configuration for the Rust node. refresh_rate: 30 seconds appenders: stdout: kind: console encoder: pattern: &quot;{d(%s.%f)} {l} [{h({t})}] {I}: {m}{n}&quot; stdout_ref: kind: console encoder: pattern: &quot;{f}:{L} {l} [{h({t})}] {I}: {m}{n}&quot; logfile: kind: file path: &quot;/ton-node/logs/output.log&quot; encoder: pattern: &quot;{d(%s.%f)} {l} [{h({t})}] {I}: {m}{n}&quot; rolling_logfile: kind: rolling_file encoder: pattern: &quot;{d(%Y-%m-%d %H:%M:%S.%f)} {l} [{h({t})}] {I}: {m}{n}&quot; path: /ton-node/logs/output.log policy: kind: compound trigger: kind: size limit: 50 gb roller: kind: fixed_window pattern: '/ton-node/logs/output_{}.log' base: 1 count: 1 tvm_logfile: kind: file path: &quot;target/log/tvm.log&quot; encoder: pattern: &quot;{m}{n}&quot; root: level: info appenders: - rolling_logfile loggers: # node messages ton_node: level: trace boot: level: trace sync: level: trace # adnl messages adnl: level: info overlay: level: info rldp: level: info dht: level: info # block messages ton_block: level: debug # block messages executor: level: debug # tvm messages tvm: level: info librdkafka: level: info validator: level: debug catchain: level: debug validator_session: level: debug  The currently configured targets are the following: ton_node: node-related messages, except initial boot and sync, block exchange with other nodes boot: initial boot messages, creation of trusted key block chain, loading blockchain state sync: node synchronization - loading a certain number of most recent blocks adnl: messages of the ADNL protocol overlay: messages of the overlay protocol rldp: messages of the RLDP protocol dht: messages of the DHT protocol ton_block: messages of the block structures library, logs are turned on in debug executor: messages of the smart contract execution library, logs are turned on in debug tvm: ton virtual machine messages, logs are turned on in debug librdkafka: kafka client library messages validator: top level consensus protocol messages catchain: low level consensus protocol messages validator_session: mid level consensus protocol messages Migrating from C++ node To migrate your validator from legacy C++ node to Rust node, complete the following steps: Set up a new host for the Rust node, according to steps 1-3 of this document.Wait for node to sync. Check sync according to step 4 of this document.Stop the C++ node sending election requests (by default - disable scheduling of the validator script). Do not shut down the C++ validator itself, let it finish the current round.Configure validator wallet and corresponding keys, optionally - DePool (copy them from C++ node files to Rust Node files). By default: Copy validator wallet address from ~/ton-keys/$(hostname -s).addr file on the C++ node to /ton-node/configs/${VALIDATOR_NAME}.addr on the Rust Node.Copy validator wallet keys from /ton-keys/msig.keys.json on the C++ node to /ton-node/configs/keys/msig.keys.json on the Rust Node.If you have a DePool set up, copy DePool address from ~/ton-keys/depool.addr on the C++ node to /ton-node/configs/depool.addr on the Rust Node. Once this is done, the Rust node validator script will start automatically with the next round. DO NOT shut down the C++ host. Wait for the C++ node to complete the current round until the validator set is changed.Check logs/validator.log on the Rust node, and make sure the first election request was successfully sent. There should be no errors in the log.Only once the validator set changes, the C++ node is no longer a validator and the Rust node starts validating (validation_stats and collation_stats in the console output should not be empty), shut down the C++ node. Troubleshooting Here are some solutions to frequently encountered problems. "},{"title":"1. Couldn’t connect to Docker daemon at http+docker://localhost​","type":1,"pageTitle":"Run testnet node","url":"validate/run-validator/run-testnet-node#1-couldnt-connect-to-docker-daemon-at-httpdockerlocalhost","content":"This error occurs in two cases. Either the docker daemon isn't running, or current user doesn't have rights to access docker. You can fix the rights issue either by running relevant commands as the superuser or adding the user to the docker group: sudo usermod -a -G docker $USER  Make sure to restart the system or log out and back in, for the new group settings to take effect. "},{"title":"2. thread 'main' panicked error when checking node synchronization​","type":1,"pageTitle":"Run testnet node","url":"validate/run-validator/run-testnet-node#2-thread-main-panicked-error-when-checking-node-synchronization","content":"The following error may occur for a short time immediately after node deployment when attempting to check synchronization: thread 'main' panicked at 'Can't create client: Os { code: 111, kind: ConnectionRefused, message: &quot;Connection refused&quot; }', bin/console.rs:454:59  Currently this is expected behavior, unless it persists for more than a few minutes. If it does persist, check network status at https://net.ton.live/, and, if the network is up and running, review deployment logs for errors. "},{"title":"3. Error executing command when checking node synchronization​","type":1,"pageTitle":"Run testnet node","url":"validate/run-validator/run-testnet-node#3-error-executing-command-when-checking-node-synchronization","content":"The following error may occur for up to an hour after node deployment when attempting to check synchronization: Error executing command: Error receiving answer: early eof bin/console.rs:296  Currently this is expected behavior, unless it persists for more than one hour. If it does persist, check network status at https://net.ton.live/, and, if the network is up and running, review deployment logs for errors. "},{"title":"4. Cannot stop/restart/remove node container​","type":1,"pageTitle":"Run testnet node","url":"validate/run-validator/run-testnet-node#4-cannot-stoprestartremove-node-container","content":"Make sure you are running all docker-compose commands from the net.ton.dev/docker-compose/ton-node folder. "},{"title":"5. DePool state not updating​","type":1,"pageTitle":"Run testnet node","url":"validate/run-validator/run-testnet-node#5-depool-state-not-updating","content":"It's recommended to send at least two ticktocks while the elections are open. For rust node you can use the provided ticktock script, which sends 5 ticktocks after the elections open. "},{"title":"System requirements","type":0,"sectionRef":"#","url":"validate/run-validator/system-requirements","content":"","keywords":""},{"title":"EverX Testnet Node​","type":1,"pageTitle":"System requirements","url":"validate/run-validator/system-requirements#everx-testnet-node","content":"Configuration\tCPU (threads)\tRAM (GiB)\tStorage (GiB)\tNetwork (Gbit/s)Minimum\t48\t128\t1000\t1 "},{"title":"EverX Mainnet Node​","type":1,"pageTitle":"System requirements","url":"validate/run-validator/system-requirements#everx-mainnet-node","content":"Configuration\tCPU (threads)\tRAM (GiB)\tStorage (GiB)\tNetwork (Gbit/s)Minimum\t48\t128\t1000\t1 "},{"title":"Validator elections","type":0,"sectionRef":"#","url":"validate/run-validator/validator-elections","content":"Validator elections","keywords":""},{"title":"Update Validator","type":0,"sectionRef":"#","url":"validate/run-validator/update-validator","content":"Update Validator","keywords":""},{"title":"Staking","type":0,"sectionRef":"#","url":"validate/staking","content":"Staking","keywords":""},{"title":"FAQ","type":0,"sectionRef":"#","url":"validate/troubleshooting/faq","content":"FAQ","keywords":""},{"title":"Node upgrades","type":0,"sectionRef":"#","url":"validate/troubleshooting/node-upgrades","content":"Node upgrades","keywords":""},{"title":"Mainnet EverX Node Troubleshooting","type":0,"sectionRef":"#","url":"validate/troubleshooting/mainnet-node-troubleshooting","content":"","keywords":""},{"title":"1. Couldn’t connect to Docker daemon at http+docker://localhost​","type":1,"pageTitle":"Mainnet EverX Node Troubleshooting","url":"validate/troubleshooting/mainnet-node-troubleshooting#1-couldnt-connect-to-docker-daemon-at-httpdockerlocalhost","content":"This error occurs in two cases. Either the docker daemon isn't running, or current user doesn't have rights to access docker. You can fix the rights issue either by running relevant commands as the superuser or adding the user to the docker group: sudo usermod -a -G docker $USER  Make sure to restart the system or log out and back in, for the new group settings to take effect. "},{"title":"2. thread 'main' panicked error when checking node synchronization​","type":1,"pageTitle":"Mainnet EverX Node Troubleshooting","url":"validate/troubleshooting/mainnet-node-troubleshooting#2-thread-main-panicked-error-when-checking-node-synchronization","content":"The following error may occur for a short time immediately after node deployment when attempting to check synchronization: thread 'main' panicked at 'Can't create client: Os { code: 111, kind: ConnectionRefused, message: &quot;Connection refused&quot; }', bin/console.rs:454:59  Currently this is expected behavior, unless it persists for more than a few minutes. If it does persist, check network status at https://ton.live/, and, if the network is up and running, review deployment logs for errors. "},{"title":"3. Error executing command when checking node synchronization​","type":1,"pageTitle":"Mainnet EverX Node Troubleshooting","url":"validate/troubleshooting/mainnet-node-troubleshooting#3-error-executing-command-when-checking-node-synchronization","content":"The following error may occur for up to an hour after node deployment when attempting to check synchronization: Error executing command: Error receiving answer: early eof bin/console.rs:296  Currently this is expected behavior, unless it persists for more than one hour. If it does persist, check network status at https://ton.live/, and, if the network is up and running, review deployment logs for errors. "},{"title":"4. Cannot stop/restart/remove node container​","type":1,"pageTitle":"Mainnet EverX Node Troubleshooting","url":"validate/troubleshooting/mainnet-node-troubleshooting#4-cannot-stoprestartremove-node-container","content":"Make sure you are running all docker-compose commands from the main.ton.dev/docker-compose/ton-node folder. "},{"title":"5. DePool state not updating​","type":1,"pageTitle":"Mainnet EverX Node Troubleshooting","url":"validate/troubleshooting/mainnet-node-troubleshooting#5-depool-state-not-updating","content":"It's recommended to send at least two ticktocks while the elections are open. For rust node you can use the provided ticktock script, which sends 5 ticktocks after the elections open. "},{"title":"Testnet EverX Node Troubleshooting","type":0,"sectionRef":"#","url":"validate/troubleshooting/testnet-node-troubleshooting","content":"","keywords":""},{"title":"1. Couldn’t connect to Docker daemon at http+docker://localhost​","type":1,"pageTitle":"Testnet EverX Node Troubleshooting","url":"validate/troubleshooting/testnet-node-troubleshooting#1-couldnt-connect-to-docker-daemon-at-httpdockerlocalhost","content":"This error occurs in two cases. Either the docker daemon isn't running, or current user doesn't have rights to access docker. You can fix the rights issue either by running relevant commands as the superuser or adding the user to the docker group: sudo usermod -a -G docker $USER  Make sure to restart the system or log out and back in, for the new group settings to take effect. "},{"title":"2. thread 'main' panicked error when checking node synchronization​","type":1,"pageTitle":"Testnet EverX Node Troubleshooting","url":"validate/troubleshooting/testnet-node-troubleshooting#2-thread-main-panicked-error-when-checking-node-synchronization","content":"The following error may occur for a short time immediately after node deployment when attempting to check synchronization: thread 'main' panicked at 'Can't create client: Os { code: 111, kind: ConnectionRefused, message: &quot;Connection refused&quot; }', bin/console.rs:454:59  Currently this is expected behavior, unless it persists for more than a few minutes. If it does persist, check network status at https://net.ton.live/, and, if the network is up and running, review deployment logs for errors. "},{"title":"3. Error executing command when checking node synchronization​","type":1,"pageTitle":"Testnet EverX Node Troubleshooting","url":"validate/troubleshooting/testnet-node-troubleshooting#3-error-executing-command-when-checking-node-synchronization","content":"The following error may occur for up to an hour after node deployment when attempting to check synchronization: Error executing command: Error receiving answer: early eof bin/console.rs:296  Currently this is expected behavior, unless it persists for more than one hour. If it does persist, check network status at https://net.ton.live/, and, if the network is up and running, review deployment logs for errors. "},{"title":"4. Cannot stop/restart/remove node container​","type":1,"pageTitle":"Testnet EverX Node Troubleshooting","url":"validate/troubleshooting/testnet-node-troubleshooting#4-cannot-stoprestartremove-node-container","content":"Make sure you are running all docker-compose commands from the net.ton.dev/docker-compose/ton-node folder. "},{"title":"5. DePool state not updating​","type":1,"pageTitle":"Testnet EverX Node Troubleshooting","url":"validate/troubleshooting/testnet-node-troubleshooting#5-depool-state-not-updating","content":"It's recommended to send at least two ticktocks while the elections are open. Here are some solutions to frequently encountered problems. "},{"title":"Getting started","type":0,"sectionRef":"#","url":"validate/tutorial/getting-started","content":"Getting started","keywords":""},{"title":"How to stake","type":0,"sectionRef":"#","url":"validate/tutorial/how-to-stake","content":"How to stake","keywords":""},{"title":"How to vote","type":0,"sectionRef":"#","url":"validate/tutorial/how-to-vote","content":"How to vote","keywords":""}]
"use strict";(self.webpackChunkeverscale_docs_website=self.webpackChunkeverscale_docs_website||[]).push([[8920],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return k}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=d(n),k=o,m=u["".concat(s,".").concat(k)]||u[k]||p[k]||i;return n?a.createElement(m,r(r({ref:t},c),{},{components:n})):a.createElement(m,r({ref:t},c))}));function k(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var d=2;d<i;d++)r[d]=n[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5593:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return s},default:function(){return k},frontMatter:function(){return l},metadata:function(){return d},toc:function(){return p}});var a=n(3117),o=n(102),i=(n(7294),n(3905)),r=["components"],l={sidebar_position:2},s="DePool Specifications",d={unversionedId:"learn/decentralization/depool-specifications",id:"learn/decentralization/depool-specifications",title:"DePool Specifications",description:"Background",source:"@site/../../src/learn/decentralization/depool-specifications.md",sourceDirName:"learn/decentralization",slug:"/learn/decentralization/depool-specifications",permalink:"/learn/decentralization/depool-specifications",draft:!1,editUrl:"https://github.com/everscale-org/docs/edit/main/.build/website/../../src/learn/decentralization/depool-specifications.md",tags:[],version:"current",lastUpdatedAt:1663045150,formattedLastUpdatedAt:"Sep 13, 2022",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"End-to-end Decentralization",permalink:"/learn/decentralization/end-to-end-decentralization"},next:{title:"DeBot Specifications",permalink:"/learn/decentralization/debot-specifications"}},c={},p=[{value:"Background",id:"background",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Basic terms",id:"basic-terms",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Special kinds of stakes",id:"special-kinds-of-stakes",level:2},{value:"Vesting Stake",id:"vesting-stake",level:3},{value:"Lock Stake",id:"lock-stake",level:3},{value:"Specification",id:"specification",level:2},{value:"Data Structures",id:"data-structures",level:3},{value:"DePool Initialization",id:"depool-initialization",level:3},{value:"Participant functions",id:"participant-functions",level:2},{value:"Functions of interface DePoolInfoGetter:",id:"functions-of-interface-depoolinfogetter",level:3},{value:"Participant callback functions:",id:"participant-callback-functions",level:3},{value:"DePool owner functions:",id:"depool-owner-functions",level:2},{value:"Events",id:"events",level:3},{value:"Get-methods",id:"get-methods",level:2},{value:"State update function",id:"state-update-function",level:2},{value:"Multi-Round elections",id:"multi-round-elections",level:2},{value:"Round completion",id:"round-completion",level:2},{value:"DePool decentralization",id:"depool-decentralization",level:2},{value:"DePool contract fee",id:"depool-contract-fee",level:2},{value:"Links",id:"links",level:2}],u={toc:p};function k(e){var t=e.components,l=(0,o.Z)(e,r);return(0,i.kt)("wrapper",(0,a.Z)({},u,l,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"depool-specifications"},"DePool Specifications"),(0,i.kt)("h2",{id:"background"},"Background"),(0,i.kt)("p",null,"It is quite evident that to achieve high-performance properties, a network needs powerful, reliable servers with fast connectivity. At the same time, to achieve sufficient decentralization, these servers have to belong to as many owners as possible. There seems to be a contradiction between these goals."),(0,i.kt)("p",null,"In Proof-of-Work networks, performance is often sacrificed for decentralization. Yet, claims arise that the centralization of Bitcoin, Ethereum etc. mining power is not entirely prevented. Mining Pools centralization remains an issue, as these pools are controlled by particular entities distributing rewards. For example, almost 60% of Bitcoin mining power is concentrated in just 4 pools and around 80% of all mining power originates in China. Just 2 mining pools control 52% of Ethereum hashrate, more than 50% of which originates in China."),(0,i.kt)("p",null,"In Proof-of-Stake, the correlation between network performance and concentration of power (money in this case) is even more apparent, as one does not need to buy, set up, and manage complicated mining farms. It can ultimately be claimed that POS is trading performance for decentralization (look no further than EOS centralization, Steemit network overtaking etc.)."),(0,i.kt)("p",null,"It seems that enabling small token holders to participate in network governance is a very important decentralization property."),(0,i.kt)("h2",{id:"motivation"},"Motivation"),(0,i.kt)("p",null,'Everscale blockchain needs all newly created blocks to be validated in order to run correctly. For this it relies on special designated nodes called "Validators", and offers substantial reward for their work. However, becoming a validator requires a substantial cryptocurrency deposit. The required amount might far exceed an individual validator budget. On the other hand, blockchain users with no validating system might be interested in investing in validation duty. This is where the Decentralized Pool (DePool) smart contract comes in.'),(0,i.kt)("p",null,"There are two main use cases of DePool:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"User has no Validator capabilities but some free funds. User can support a third-party Validator and receive rewards."),(0,i.kt)("li",{parentName:"ul"},"User has Validator capabilities and but doesn't have necessary amount of funds to participate in validator elections and subsequent rewards.")),(0,i.kt)("h2",{id:"basic-terms"},"Basic terms"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"DePool")," \u2014 a smart contract that allows other smart contracts to invest stakes into a common pool of funds and after some period of time to receive it back with interest."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Elector")," \u2014 a system level smart contract, deployed to masterchain from zero state. Runs validator elections periodically."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"DePool Proxy (proxy)")," \u2014 a smart contract that delivers messages between DePool and Elector."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Participant")," \u2014 a smart contract that invests funds into DePool."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Validator")," \u2014 software running blockchain node. Each DePool works with one node only. This node must be a DePool participant."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Validator wallet")," \u2014 a smart contract that is used by Validator to send election requests to DePool and receive the Validator reward. Validator wallet should be a Multisig contract with 3 custodians."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"DePool Helper")," \u2014 a smart contract that stores the address of the actual DePool and works with the Timer contract."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Global Validators Set (GVS)")," \u2014 current set of validators chosen in the latest elections."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Validation period")," \u2014 period of time for which GVS is elected."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Investment round")," \u2014 period of time between Participant investing a stake in DePool and receiving it back (with or without interest)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Timer")," \u2014 a smart contract that can call other smart contracts periodically.")),(0,i.kt)("h2",{id:"architecture"},"Architecture"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"DePool Architecture",src:n(6013).Z,width:"758",height:"482"})),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"DePool is designed to receive investment stakes from Participants, allocate the pool funds to a validator in order to participate in elections of the GVS and, after the end of the validation cycle, distribute stakes with certain rewards back to the Participants."),(0,i.kt)("li",{parentName:"ol"},"DePool is deployed to basechain. But it cannot communicate with Elector directly, because Elector rejects messages from non-masterchain contracts. Thus there are DePool proxies that are deployed to masterchain and deliver messages from DePool to Elector and back. This is done, because DePool is a large and complex contract, and gas and storage fees are 10 times lower in basechain compared to masterchain. Keeping DePool on masterchain would be unreasonably expensive."),(0,i.kt)("li",{parentName:"ol"},"DePool is open for Participants\u2019 stakes at all times, however, there is a deadline for participation in the upcoming elections. The deadline depends on the timer of the Elector. After the deadline, the incoming stakes will be accumulated for participation in the next elections."),(0,i.kt)("li",{parentName:"ol"},"DePool distinguishes stakes received before the deadline and after the deadline, therefore it stores information on Participant stakes in separate ",(0,i.kt)("strong",{parentName:"li"},"investment rounds (or rounds)"),", one for every elections, to facilitate subsequent distribution of stakes and rewards. To separate Elector communication, DePool uses 2 proxies: one for even rounds, one for odd."),(0,i.kt)("li",{parentName:"ol"},"In order to be time-aware, the DePool should be called from time to time. For this purpose the Timer contract is used. DePool Helper asks Timer to call it periodically and transmits every call from Timer to DePool. Interval between calls is chosen according to the elections interval."),(0,i.kt)("li",{parentName:"ol"},"DePool must be linked to a validator wallet to participate in elections on behalf of the latter. This validator wallet address is specified during DePool deployment and cannot be changed afterwards. When elections start, DePool waits for signed election requests from linked wallet, then attaches round stake to request and transmits it to Elector."),(0,i.kt)("li",{parentName:"ol"},"Validator can validate many DePools with 1 Validator wallet. Reputation of Validator wallet therefore is available and can be analyzed over time."),(0,i.kt)("li",{parentName:"ol"},'To ensure that the validator will perform its functions correctly (be always online and not "lie" to other validators), the validator wallet must itself become a Participant and invest in every investment round at least ',(0,i.kt)("strong",{parentName:"li"},"m_validatorAssurance"),", which is initialized in DePool constructor. This can be achieved with any of the three available types of stakes."),(0,i.kt)("li",{parentName:"ol"},"When Elector unfreezes validator stakes, DePool returns its stake back with round rewards. Part of the total reward is used to top up the DePool's own balance to a certain value. The rest is distributed as follows: ",(0,i.kt)("strong",{parentName:"li"},"m_validatorRewardFraction%")," goes to Validator wallet balance. ",(0,i.kt)("strong",{parentName:"li"},"m_participantRewardFraction%")," is distributed among all Participants in investment round (validator is also participant). ",(0,i.kt)("strong",{parentName:"li"},"m_associationRewardFraction%")," (can be equal to zero) goes to ",(0,i.kt)("strong",{parentName:"li"},"m_association")," address."),(0,i.kt)("li",{parentName:"ol"},"DePool keeps a balance for each Participant and can automatically reinvest Participant's stake into the next investment round if appropriate flag is enabled."),(0,i.kt)("li",{parentName:"ol"},"Participant can transfer part of its total stake to another Participant's stake inside DePool storage. This function allows for collateralization of the stake to provide liquidity to stake holders.")),(0,i.kt)("h2",{id:"special-kinds-of-stakes"},"Special kinds of stakes"),(0,i.kt)("p",null,"Along with the basic ordinary stake, that functions according to the rules detailed above, there are 2 types of special stakes: vesting and lock stake."),(0,i.kt)("p",null,"While the entire ordinary stake is invested into the current pooling round (and will thus be reinvested every second round), lock and vesting stakes are split into two equal parts upon reception, which are invested into the current pooling round, and the next round. This way they can be continuously reinvested into both odd and even rounds."),(0,i.kt)("h3",{id:"vesting-stake"},"Vesting Stake"),(0,i.kt)("p",null,"Any address can make a vesting stake and define a target participant address (",(0,i.kt)("strong",{parentName:"p"},"beneficiary"),") who will own this stake. But not the whole stake is available to the ",(0,i.kt)("strong",{parentName:"p"},"beneficiary")," at once. Instead it is split into logical parts and the next part of stake becomes available to the participant only when next vesting period is ended. At completion step of every round DePool decides how many vesting parts should be unlocked and subtracted from vesting stake and become available to owner since last unlocking. These funds are added to beneficiary's ordinary stake."),(0,i.kt)("p",null,"Example: address A makes a vesting stake of 120 tons for 1 year with vesting period of 1 month and defines address B as the stake ",(0,i.kt)("strong",{parentName:"p"},"beneficiary"),". It means that after 1 month 10 tons become available to address B and 110 tons are still locked in the pool. After 1 year vesting stake will be equal to 0 and last 10 tons will become available to owner."),(0,i.kt)("p",null,"Vesting for validator beneficiaries is subject to additional rules: At the end of every withdrawal period, the part of the vesting stake to be released is divided proportionally into 2 parts \u2014 for rounds in this period when DePool successfully completed validation and received a reward (without slashing) and for rounds when DePool missed elections or was slashed. The portion of the stake corresponding to the successful rounds is sent to the validator, while the portion corresponding to the failed rounds is returned to the vesting stake owner. For example, if there were 100 rounds within the withdrawal period, and DePool successfully completed 80 of them, missed elections in 5 more and was slashed in the remaining 15, the validator will receive 80% of the unlocked part of the vesting stake, and the stake owner will get back 20% of it."),(0,i.kt)("h3",{id:"lock-stake"},"Lock Stake"),(0,i.kt)("p",null,"Any address can make a lock stake, in which it locks its funds in DePool for a defined period, but rewards from this stake will be payed to another target participant (",(0,i.kt)("strong",{parentName:"p"},"beneficiary"),"). At the end of a period the Lock Stake should be returned to the address which locked it."),(0,i.kt)("p",null,"Example: address A makes a lock stake of 120 tons for 1 year with vesting period of 1 month and defines address B as the stake ",(0,i.kt)("strong",{parentName:"p"},"beneficiary"),". It means that after 1 month 10 tons become available to address A (as opposed to vesting, where these 10 tons would become available to address B, the ",(0,i.kt)("strong",{parentName:"p"},"beneficiary"),") and 110 tons are still locked in round. DePool will reinvest the gradually diminishing lock stake for a 1 year and pay rewards to B address. After 1 year DePool will return the remainder of the lock stake to address A."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"One Participant can be a ",(0,i.kt)("strong",{parentName:"p"},"beneficiary")," only of one lock and one vesting stake. Once current lock or vesting stake of the participant expires, it can be repeated. When a stake of either of these types is created, it is split equally into two last rounds, which means that the minimal value for such stake is ",(0,i.kt)("inlineCode",{parentName:"p"},"2 * minStake + fee"),".")),(0,i.kt)("h2",{id:"specification"},"Specification"),(0,i.kt)("h3",{id:"data-structures"},"Data Structures"),(0,i.kt)("p",null,"DePool contract uses library and inheritance from several simple base contacts to separate functionality and facilitate development and debugging of the contract. The core data set stored by DePool is the following:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"DePoolLib.sol")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"// Describes contract who deposit stakes in DePool pool\nstruct Participant {\n    // Count of rounds in which participant takes a part\n    uint8 roundQty;\n    // Sum of all rewards from completed rounds (for logging)\n    uint64 reward;\n    // count of parts of vesting stakes in the rounds\n    uint8 vestingParts;\n    // count of parts of lock stakes in the rounds\n    uint8 lockParts;\n    // Flag whether to reinvest ordinary stakes and rewards\n    bool reinvest;\n    // Target tons that will be transferred to participant after rounds are completed\n    // After each round this value is decreased\n    uint64 withdrawValue;\n}\n\n// Request for elections from validator wallet.\nstruct Request {\n    // Random query id.\n    uint64 queryId;\n    // Validator's public key that will be used as validator key if validator will win elections.\n    uint256 validatorKey;\n    // current election id.\n    uint32 stakeAt;\n    // Validator's stake factor.\n    uint32 maxFactor;\n    // Validator's address in adnl overlay network.\n    uint256 adnlAddr;\n    // Ed25519 signature of above values.\n    bytes signature;\n}\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"DePoolRounds.sol")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"// roundPre0 = m_rounds[m_roundQty - 1] \u2014 pre-pooling. Helper round for adding vesting and lock\n//                                        stakes. When vesting/lock stake is added than stake is\n//                                        split into two part. And first part invested into pooling\n//                                        round and second part \u2014 pre-pooling.\n//\n// round0 = m_rounds[m_roundQty - 2] \u2014 pooling\n// round1 = m_rounds[m_roundQty - 3] \u2014 election or validation\n// round2 = m_rounds[m_roundQty - 4] \u2014 validation or investigation\n// Algo of round rotation:\n//     delete round2\n//     round1         -> round2\n//     round0         -> round1\n//     roundPre0      -> round0\n//     createNewRound -> roundPre0\nmapping(uint64 => Round) m_rounds;\n\n// count of created rounds\nuint64 m_roundQty = 0;\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"DePoolBase.sol")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"// Dictionary of participants for rounds\nmapping (address => Participant) m_participants;\n\n// Address of the validator wallet\naddress m_validatorWallet;\n\n// Array of proxies addresses.\naddress[] m_proxies;\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"DePool.sol")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"// Indicates that pool is closed. Closed pool doesn't accept stakes from other contracts.\nbool m_poolClosed;\n// Min stake accepted to the pool in nTon (for gas efficiency reasons): 10 tons is recommended.\nuint64 m_minStake;\n// Minimum validator stake in each round\nuint64 m_validatorAssurance;\n// % of participant rewards\nuint8 m_participantRewardFraction;\n// % of validator rewards\nuint8 m_validatorRewardFraction;\n// % of dePool association rewards\nuint8 m_associationRewardFraction;\n// Association address\naddress m_association;\n// Minimum balance\nuint64 m_minimumBalance;\n")),(0,i.kt)("h3",{id:"depool-initialization"},"DePool Initialization"),(0,i.kt)("p",null,"When deployed, the DePool constructor is called with the following parameters:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"/// @dev DePool's constructor.\n/// @param minStake Min stake that participant may have in one round.\n/// @param validatorAssurance Min validator stake.\n/// @param proxyCode Code of proxy contract.\n/// @param validatorWallet Address of validator wallet.\n/// @param participantRewardFraction % of reward that distributed among participants.\nconstructor(\n    uint64 minStake,\n    uint64 validatorAssurance,\n    TvmCell proxyCode,\n    address validatorWallet,\n    uint8 participantRewardFraction,\n)\n")),(0,i.kt)("p",null,"At initialization the variable ",(0,i.kt)("inlineCode",{parentName:"p"},"m_balanceThreshold")," is set as current DePool account balance \u2014 5 tokens. DePool will replenish its balance from validation rewards to this value every round it receives rewards."),(0,i.kt)("h2",{id:"participant-functions"},"Participant functions"),(0,i.kt)("p",null,"DePool stores some participant information in a dictionary (",(0,i.kt)("inlineCode",{parentName:"p"},"m_participants"),") where key \u2014 Participant's address and value \u2014 ",(0,i.kt)("inlineCode",{parentName:"p"},"Participant")," structure."),(0,i.kt)("p",null,"Functions used by participants perform checks and send ",(0,i.kt)("inlineCode",{parentName:"p"},"receiveAnswer")," message back to the caller with an error code and a comment in case of failure. If all conditions are met, DePool sends a confirmation message (",(0,i.kt)("inlineCode",{parentName:"p"},"receiveAnswer")," with status ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),") back to the caller."),(0,i.kt)("p",null,"All functions can be called by internal messages only."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"addOrdinaryStake(uint64 stake)")," \u2014 allows to make an ordinary stake in the current pooling round. The source address of the message is taken as Participant's address. The Participant's total stake is increased by stake amount.")),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"stake")," \u2014 value of participant's stake in nanotons.")),(0,i.kt)("p",null,"Function checks that:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"inbound message value is at least ",(0,i.kt)("inlineCode",{parentName:"li"},"(stake + ADD_STAKE_FEE)"),";"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"stake")," is at least min stake;"),(0,i.kt)("li",{parentName:"ul"},"pool is not closed.")),(0,i.kt)("p",null,"Function returns change (part of unused ",(0,i.kt)("inlineCode",{parentName:"p"},"ADD_STAKE_FEE"),")."),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"addVestingStake(uint64 stake, address beneficiary, uint32 withdrawalPeriod, uint32 totalPeriod)")," \u2014 allows to add a vesting stake for another participant (",(0,i.kt)("strong",{parentName:"li"},"beneficiary"),"). The source address of the message is saved as the vesting stake owner.")),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"stake")," \u2014 value of participant's stake in nanotons (Note: this value is divided into 2 parts and is added to 2 rounds)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"beneficiary")," \u2014 address of target participant (beneficiary);"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"withdrawalPeriod")," \u2014 the period in seconds after which the part of the vesting becomes available for beneficiary;"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"totalPeriod")," \u2014 total period of vesting in seconds after which beneficiary becomes owner of the whole stake.")),(0,i.kt)("p",null,"Function checks that:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"DePool is not closed (",(0,i.kt)("inlineCode",{parentName:"li"},"m_poolClosed")," \u2260 true);"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"beneficiary")," is an ",(0,i.kt)("inlineCode",{parentName:"li"},"addr_std"),". It's not zero address. It's not the message sender (not self vesting);"),(0,i.kt)("li",{parentName:"ul"},"inbound ",(0,i.kt)("inlineCode",{parentName:"li"},"msg.value \u2265 (m_minStake + ADD_STAKE_FEE)"),";"),(0,i.kt)("li",{parentName:"ul"},"Message value is at least ",(0,i.kt)("inlineCode",{parentName:"li"},"stake + STAKE_FEE"),";"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"stake / 2")," is at least min stake;"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"withdrawalPeriod \u2264 totalPeriod"),";"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"totalPeriod < 18 years"),";"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"withdrawalPeriod \u2260 0"),";"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"totalPeriod % withdrawalPeriod = 0"),";"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"beneficiary")," doesn't have a vesting stake.")),(0,i.kt)("ol",{start:3},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"addLockStake(uint64 stake, address beneficiary, uint32 withdrawalPeriod, uint32 totalPeriod)")," \u2014 allows to add a stake that will bring rewards to another participant (",(0,i.kt)("strong",{parentName:"li"},"beneficiary"),"). The source address of the message is saved as the lock stake owner.")),(0,i.kt)("p",null,"It has the same parameters and checks as ",(0,i.kt)("inlineCode",{parentName:"p"},"addVestingStake"),", but it checks that participant doesn't have a lock stake instead of a vesting stake."),(0,i.kt)("ol",{start:4},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"withdrawFromPoolingRound(uint64 withdrawValue)")," \u2014 allows to remove Participant's stake from the current pooling round.")),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"withdrawValue")," \u2014 desired amount of stake to be removed.")),(0,i.kt)("p",null,"Function checks that:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"inbound ",(0,i.kt)("inlineCode",{parentName:"li"},"msg.sender")," address is address of an existing participant.")),(0,i.kt)("p",null,"If real ordinary stake is less than ",(0,i.kt)("inlineCode",{parentName:"p"},"withdrawValue"),", then DePool returns the whole stake from pooling round."),(0,i.kt)("p",null,"If the remaining stake in the pooling round is less than ",(0,i.kt)("inlineCode",{parentName:"p"},"m_minStake"),", then the whole stake is transferred to Participant."),(0,i.kt)("p",null,"If the remaining total stake of Participant is 0, then it is removed from the ",(0,i.kt)("inlineCode",{parentName:"p"},"m_stakeholders")," dictionary."),(0,i.kt)("ol",{start:5},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"withdrawPart(uint64 withdrawValue)")," \u2014 Allows a participant to withdraw some value from DePool. This function withdraws withdrawValue nanotons when rounds are completed. If participant stake becomes less than minStake, then the whole stake is sent to participant.")),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"withdrawValue")," \u2014 desired amount of stake to be removed.")),(0,i.kt)("p",null,"Function checks that:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"pool is not closed (",(0,i.kt)("inlineCode",{parentName:"li"},"m_poolClosed \u2260 true"),");"),(0,i.kt)("li",{parentName:"ul"},"inbound ",(0,i.kt)("inlineCode",{parentName:"li"},"msg.sender")," address is address of an existing participant.")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"If the remaining stake in the round is less than ",(0,i.kt)("inlineCode",{parentName:"p"},"m_minStake"),", then the whole stake will be transferred to Participant (after completing round).\nIf the remaining total stake of Participant is 0, then it is removed from the ",(0,i.kt)("inlineCode",{parentName:"p"},"m_stakeholders")," dictionary.\n6. ",(0,i.kt)("inlineCode",{parentName:"p"},"withdrawAll()")," \u2014 Set global flag for the participant that indicates to return participant's ordinary stake after completing rounds.")),(0,i.kt)("p",null,"Function checks that:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"pool is not closed (",(0,i.kt)("inlineCode",{parentName:"li"},"m_poolClosed \u2260 true"),");"),(0,i.kt)("li",{parentName:"ul"},"inbound msg.sender address is address of an existing participant.",(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},"After transferring all Participant's stake, the Participant will be removed from the m_stakeholders dictionary.")))),(0,i.kt)("ol",{start:7},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"cancelWithdrawal()")," \u2014 Cancel effect of calls of functions ",(0,i.kt)("inlineCode",{parentName:"p"},"withdrawAll")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"withdrawPart"),".")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"transferStake(address dest, uint64 amount)")," \u2014 allows to move amount of stake from ",(0,i.kt)("inlineCode",{parentName:"p"},"msg.sender")," Participant to ",(0,i.kt)("inlineCode",{parentName:"p"},"dest")," Participant inside DePool storage."))),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"dest")," \u2014 stake beneficiary;"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"amount")," \u2014 stake value transferred to dest in nanotons.")),(0,i.kt)("p",null,"Function checks that:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"pool is not closed (",(0,i.kt)("inlineCode",{parentName:"li"},"m_poolClosed \u2260 true"),");"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"destination")," is a non-zero ",(0,i.kt)("inlineCode",{parentName:"li"},"addr_std"),";"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"msg.sender \u2260 dest"),";"),(0,i.kt)("li",{parentName:"ul"},"neither ",(0,i.kt)("inlineCode",{parentName:"li"},"destination")," nor ",(0,i.kt)("inlineCode",{parentName:"li"},"msg.sender")," is the validator wallet;"),(0,i.kt)("li",{parentName:"ul"},"inbound ",(0,i.kt)("inlineCode",{parentName:"li"},"msg.sender")," address is address of an existing participant;"),(0,i.kt)("li",{parentName:"ul"},"desired ",(0,i.kt)("inlineCode",{parentName:"li"},"amount")," can be transferred and transfer doesn't leave stake less than ",(0,i.kt)("inlineCode",{parentName:"li"},"m_minStake")," in any round.",(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},"In case of success DePool sends back a notification via onTransfer function calling to beneficiary.")))),(0,i.kt)("h3",{id:"functions-of-interface-depoolinfogetter"},"Functions of interface DePoolInfoGetter:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"function getLastRoundInfo() public")),(0,i.kt)("p",null,"If there is no completed round yet, call callback function ",(0,i.kt)("inlineCode",{parentName:"p"},"receiveDePoolInfo")," with struct containing default values, else send call with struct containing info about last completed round."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"// Represent info about last completed round\nstruct LastRoundInfo {\n    uint32 supposedElectedAt;\n    uint8 participantRewardFraction;\n    uint8 validatorRewardFraction;\n    uint32 participantQty;\n    uint64 roundStake;\n    address validatorWallet;\n    uint256 validatorPubkey;\n    uint64 validatorAssurance;\n}\n")),(0,i.kt)("h3",{id:"participant-callback-functions"},"Participant callback functions:"),(0,i.kt)("p",null,"These functions are called by DePool to send notifications to Participant."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"receiveAnswer(uint32 errcode, uint64 comment)")," \u2014 function, which is called as an answer from DePool to Participant.")),(0,i.kt)("p",null,"Arguments:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"errcode")," \u2014 error code. List of codes:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"uint8 constant STATUS_SUCCESS                                        =  0;\nuint8 constant STATUS_STAKE_TOO_SMALL                                =  1;\nuint8 constant STATUS_DEPOOL_CLOSED                                  =  3;\nuint8 constant STATUS_NO_PARTICIPANT                                 =  6;\nuint8 constant STATUS_PARTICIPANT_HAVE_ALREADY_VESTING               =  9;\nuint8 constant STATUS_WITHDRAWAL_PERIOD_GREATER_TOTAL_PERIOD         = 10;\nuint8 constant STATUS_TOTAL_PERIOD_MORE_18YEARS                      = 11;\nuint8 constant STATUS_WITHDRAWAL_PERIOD_IS_ZERO                      = 12;\nuint8 constant STATUS_TOTAL_PERIOD_IS_NOT_DIVED_BY_WITHDRAWAL_PERIOD = 13;\nuint8 constant STATUS_PERIOD_PAYMENT_IS_ZERO                         = 14;\nuint8 constant STATUS_REMAINING_STAKE_LESS_THAN_MINIMAL              = 16;\nuint8 constant STATUS_PARTICIPANT_HAVE_ALREADY_LOCK                  = 17;\nuint8 constant STATUS_TRANSFER_AMOUNT_IS_TOO_BIG                     = 18;\nuint8 constant STATUS_TRANSFER_SELF                                  = 19;\nuint8 constant STATUS_TRANSFER_TO_OR_FROM_VALIDATOR                  = 20;\nuint8 constant STATUS_FEE_TOO_SMALL                                  = 21;\nuint8 constant STATUS_INVALID_ADDRESS                                = 22;\nuint8 constant STATUS_INVALID_BENEFICIARY                            = 23;\nuint8 constant STATUS_NO_ELECTION_ROUND                              = 24;\nuint8 constant STATUS_INVALID_ELECTION_ID                            = 25;\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"comment")," \u2014 some value attached to error code.")),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"onTransfer(address source, uint128 amount)")," \u2014 function, which is called after successful ",(0,i.kt)("inlineCode",{parentName:"li"},"transferStake")," to inform beneficiary.")),(0,i.kt)("p",null,"Arguments:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"source")," \u2014 address of Participant who made transfer;"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"amount")," \u2014 funds that were transferred.")),(0,i.kt)("ol",{start:3},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"onRoundComplete(uint64 roundId, uint64 reward, uint64 ordinaryStake, uint64 vestingStake, uint64 lockStake, bool reinvest, uint8 reason)")," \u2014 send a notification from DePool to Participant when round is completed:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"roundId")," \u2014 Id of completed round;"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"reward")," \u2014 Participant's reward in completed round in nanotons;"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ordinaryStake")," \u2014 ordinary stake in completed round;"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"vestingStake")," \u2014 vesting stake in completed round;"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"lockStake")," \u2014 lock stake in completed round;"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"reinvest")," \u2014 are ordinary stakes automatically reinvested (prolonged)?"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"reason")," \u2014 reason why round is completed (See enum CompletionReason).")),(0,i.kt)("h2",{id:"depool-owner-functions"},"DePool owner functions:"),(0,i.kt)("p",null,"These functions can be called only by the DePool owner, ",(0,i.kt)("strong",{parentName:"p"},"as they have to be signed with the deploy keypair"),"."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"terminator()")," ","[external msg only]"," \u2014 a method to close DePool. All stakes from all rounds are returned in several phases:")),(0,i.kt)("p",null,"a. first of all, stakes from pooling round are returned immediately.\nb.",(0,i.kt)("inlineCode",{parentName:"p"},"m_poolClosed = true"),';\nc. All other rounds will return stakes after their "completed" step.'),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Important:")," remaining parts of vesting/lock stakes will be sent to owners of those stakes (not to beneficiaries)")),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"setValidatorRewardFraction(uint8 fraction)")," ",(0,i.kt)("strong",{parentName:"li"},"[external msg only]"))),(0,i.kt)("p",null,"Sets new validator's reward fraction and calculates new participants' reward fraction. New validator's reward fraction must be less than current one and be not zero."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"fraction")," \u2014 new validator's reward fraction."),(0,i.kt)("h3",{id:"events"},"Events"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"DePoolClosed()")," \u2014 event emitted when pool is closed by terminator() function."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"RoundStakeIsAccepted(uint64 queryId, uint32 comment)")," \u2014 event is emitted on accepting stake by elector."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"RoundStakeIsRejected(uint64 queryId, uint32 comment)")," \u2014 event is emitted on rejecting stake by elector."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ProxyHasRejectedTheStake(uint64 queryId)")," \u2014 event is emitted if stake is returned by proxy (IProxy.process_new_stake) because too low balance of proxy contract."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ProxyHasRejectedRecoverRequest(uint64 roundId)")," \u2014 event is emitted if stake cannot be returned from elector (IProxy.recover_stake) because too low balance of proxy contract."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"RoundCompleted(TruncatedRound round)")," \u2014 event is emitted on completing round."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"StakeSigningRequested(uint32 electionId, address proxy)")," \u2014 Event emitted when round is switched from pooling to election. DePool is waiting for signed election request from validator wallet."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"TooLowDePoolBalance(uint replenishment)")," \u2014 event emitted when pure DePool's balance becomes too low. replenishment minimal value that must be sent to DePool via receiveFunds function."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"RewardFractionsChanged(uint8 validator, uint8 participants)")," \u2014 event emitted when contract owner changes reward fractions. validator \u2014 validator's reward fraction. participants \u2014 participants' reward fraction.")),(0,i.kt)("h2",{id:"get-methods"},"Get-methods"),(0,i.kt)("p",null,"These get-methods are used for local run."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"getParticipantInfo(address addr)")," \u2014 returns participant's information about stakes in every rounds;"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"getDePoolInfo()")," \u2014 returns DePool configuration parameters and constants;"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"getParticipants()")," \u2014 return list of all participants;"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"getRounds()")," \u2014 returns information about all rounds."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"getDePoolBalance()")," \u2014 returns DePool's own balance in nanotokens.")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"The DePool does not store validator public keys or ADNL address, because, according to the official Everscale guide, the Validator generates a new keypair and ADNL for every elections. The contract stores only Validator wallet address.")),(0,i.kt)("h2",{id:"state-update-function"},"State update function"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ticktock()"),' \u2014 this function is the "engine" of DePool. This function rotates rounds: creates a new round if necessary and removes an old one. Switches steps of rounds and calls various internal functions if certain conditions are satisfied and so on.'),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ticktock()")," \u2014 does not ",(0,i.kt)("inlineCode",{parentName:"p"},"accept")," external inbound messages and can be called only from other contracts ",(0,i.kt)("inlineCode",{parentName:"p"},"ticktock")," returns unspent message value (change) back to caller."),(0,i.kt)("h2",{id:"multi-round-elections"},"Multi-Round elections"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Multi-Round elections",src:n(2984).Z,width:"1033",height:"144"})),(0,i.kt)("p",null,"Every round goes through several steps:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},'"PrePooling"')," step (RoundStep.PrePooling) \u2014 it's an imaginary round introduced to store half of vesting/lock stake from participants. See ",(0,i.kt)("inlineCode",{parentName:"li"},"addVestingStake/addLockStake")," functions."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},'"Pooling"')," step (RoundStep.Pooling) \u2014 round is ready to accept stakes from Participants. This round receives ordinary, vesting and lock stakes."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},'"waiting for election requests"')," step (RoundStep.WaitingValidatorRequest) \u2014 round is switched to this step when validator elections begin. DePool is waiting for signed election request from validator wallet. See ",(0,i.kt)("inlineCode",{parentName:"li"},"process_new_stake")," function of ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/tonlabs/ton-1/blob/master/crypto/smartcont/elector-code.fc"},"Elector")," to properly generate election request.",(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Important:")," Validator wallet must also be a Participant and invest at least ",(0,i.kt)("inlineCode",{parentName:"p"},"m_validatorAssurance")," stake in the round. If it doesn't, round is completed and stakes are reinvested in another round or are returned to participants."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},'"Waiting if stake is accepted by elector"')," (RoundStep.WaitingIfStakeAccepted) \u2014 DePool has received the validator signed election request. DePool has sent the whole round stake to elector through one of its proxies. Now DePool is waiting for elector answer. Note: elector will call DePool's ",(0,i.kt)("inlineCode",{parentName:"li"},"onStakeAccept")," function if election request is accepted successfully or ",(0,i.kt)("inlineCode",{parentName:"li"},"onStakeReject")," in case of an error."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},'"waiting for validation start"')," (RoundStep.WaitingValidationStart) \u2014 round stake was accepted by elector. Validator is a candidate. DePool now is waiting for the start of the validation to find out if validator won the elections."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},'"waiting for election result"')," (RoundStep.WaitingIfValidatorWinElections) \u2014 DePool has tried to recover stake in validation period to find out if validator won elections. Waiting for elector answer. Note: If validator won the elections, elector returns no stake. If Validator lost the elections, elector returns the whole stake."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},'"waiting stake unfreeze"')," (RoundStep.WaitingUnfreeze) \u2014 If ",(0,i.kt)("inlineCode",{parentName:"li"},"CompletionReason != Undefined"),", the round is waiting round rotation to return/reinvest funds because elections were lost. Else validator won elections. DePool is waiting for ending of unfreeze period to recover funds from elector."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},'"waiting for a reward"')," (RoundStep.WaitingReward) \u2014 Unfreeze period has been ended. Request to recover stake has been sent to elector. DePool is waiting for answer from elector."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},'"completing"')," step (RoundStep.Completing) \u2014 DePool receives reward and replenishes its balance from it. Then it returns or reinvests participant's stakes. Also on this step DePool recounts vesting and lock stakes and modifies them if necessary."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},'"completed"')," (RoundStep.Completed) \u2014 round switches to this step after processing all the Participants in the round. In next ",(0,i.kt)("inlineCode",{parentName:"li"},"ticktock")," this round will be deleted.")),(0,i.kt)("h2",{id:"round-completion"},"Round completion"),(0,i.kt)("p",null,'When a round switches to "completing" step (',(0,i.kt)("inlineCode",{parentName:"p"},"completeRound")," function), the DePool replenishes its balance from received rewards and then starts to cycle through all stakes in the round. If Participant's reinvestment flag is ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),", DePool sends it back to the Participant, otherwise \u2014 adds it to the pooling round. Also DePool sends notification message (",(0,i.kt)("inlineCode",{parentName:"p"},"onRoundComplete"),") to Participant."),(0,i.kt)("p",null,"DePool goes through all vesting and lock stakes of the completing round and checks whether a withdrawal period has finished for the current stake. If it has, DePool modifies the stake via transferring part of it to Participants ordinary stake (in case of Vesting) and/or transferring part of the stake back to the owner (in case of Lock or in case of Vesting for validator which was slashed or lost elections over the course of the completed withdrawal period)."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Remark:")," if there are 15000 stakes in round, then the contract should split completion to 375 transactions sending 375 ",(0,i.kt)("inlineCode",{parentName:"p"},"completePendingRound")," messages to itself. All these transactions can fit in 1-2 blocks and the whole operation will take about 5-20 seconds.")),(0,i.kt)("h2",{id:"depool-decentralization"},"DePool decentralization"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"No inherent way to replace the contract code (no SETCODE);"),(0,i.kt)("li",{parentName:"ol"},"No inherent way to transfer an arbitrary amount of currency from the DePool;"),(0,i.kt)("li",{parentName:"ol"},"Any contract can call the ",(0,i.kt)("inlineCode",{parentName:"li"},"ticktock()")," function to update the state of the DePool;"),(0,i.kt)("li",{parentName:"ol"},"No one has special privileges, except for deployer of DePool who can only close DePool and start a procedure of returning all stakes back to Participants;"),(0,i.kt)("li",{parentName:"ol"},"Fees cannot be changed after the contract is deployed;"),(0,i.kt)("li",{parentName:"ol"},"Validator wallet must be a Participant as well to share risks with other Participants.")),(0,i.kt)("h2",{id:"depool-contract-fee"},"DePool contract fee"),(0,i.kt)("p",null,"Caller of DePool's ",(0,i.kt)("inlineCode",{parentName:"p"},"ticktock")," function must pay for consumed gas. Unused message value is returned back when ",(0,i.kt)("inlineCode",{parentName:"p"},"ticktock")," is finished.\nAt the beginning of completing step DePool first takes from the total reward an amount of tokens to replenish it's balance to ",(0,i.kt)("inlineCode",{parentName:"p"},"m_balanceThreshold"),", and then additionally ",(0,i.kt)("inlineCode",{parentName:"p"},"RET_OR_REINV_FEE * (N + 1)"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"N")," is the number of participants, to cover the costs of stake processing."),(0,i.kt)("h2",{id:"links"},"Links"),(0,i.kt)("p",null,"DePool contract is available on ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/tonlabs/ton-labs-contracts/tree/master/solidity/depool"},"github"),"."),(0,i.kt)("p",null,"DePool deployment instructions can be found ",(0,i.kt)("a",{parentName:"p",href:"https://docs.ton.dev/86757ecb2/v/0/p/37a848-run-depool"},"here"),"."))}k.isMDXComponent=!0},6013:function(e,t,n){t.Z=n.p+"assets/images/depool-architecture-0457518c7676eb3193a2deb197b5fbe3.svg"},2984:function(e,t,n){t.Z=n.p+"assets/images/multi-round-elections-18455b71b86973aa66b9b03aa8a095c6.png"}}]);
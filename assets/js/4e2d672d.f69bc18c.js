"use strict";(self.webpackChunkeverscale_docs_website=self.webpackChunkeverscale_docs_website||[]).push([[6426],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>k});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=a.createContext({}),c=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(i.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(n),m=r,k=d["".concat(i,".").concat(m)]||d[m]||u[m]||o;return n?a.createElement(k,s(s({ref:t},p),{},{components:n})):a.createElement(k,s({ref:t},p))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=m;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l[d]="string"==typeof e?e:r,s[1]=l;for(var c=2;c<o;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1741:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const o={sidebar_position:3},s="Tutorial: Tokensale",l={unversionedId:"develop/smart-contracts/tokensale",id:"develop/smart-contracts/tokensale",title:"Tutorial: Tokensale",description:"Let's write a simple, step-by-step tokensale contract.",source:"@site/../../src/develop/smart-contracts/tokensale.md",sourceDirName:"develop/smart-contracts",slug:"/develop/smart-contracts/tokensale",permalink:"/develop/smart-contracts/tokensale",draft:!1,editUrl:"https://github.com/everscale-org/docs/edit/main/.build/website/../../src/develop/smart-contracts/tokensale.md",tags:[],version:"current",lastUpdatedAt:1686132519,formattedLastUpdatedAt:"Jun 7, 2023",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Deploy TIP-3 Token",permalink:"/develop/smart-contracts/use-fungible-tokens"},next:{title:"Tutorial: Voting system",permalink:"/develop/smart-contracts/voting-system"}},i={},c=[],p={toc:c},d="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"tutorial-tokensale"},"Tutorial: Tokensale"),(0,r.kt)("p",null,"Let's write a simple, step-by-step tokensale contract. "),(0,r.kt)("p",null,"For this we need an Everscale development environment. If you don't have it installed yet, please ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/broxus/locklift#quick-start"},"follow this link"),".",(0,r.kt)("br",{parentName:"p"}),"\n","In case you do, please proceed with locklift init. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"npx locklift init --path my-first-crowdsale\n")),(0,r.kt)("p",null,"Now, we need TIP-3 sources. Let\u2019s add them."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="package.json" showLineNumbers',title:'"package.json"',showLineNumbers:!0},'{\n  "devDependencies": {\n    "tip3": "git://github.com/broxus/tip3#v5",\n    ...\n  },\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="locklift.config.ts" showLineNumbers',title:'"locklift.config.ts"',showLineNumbers:!0},'compiler: {\n    ...\n    externalContracts: {\n      "node_modules/tip3/build": ["TokenRoot", "TokenWallet"],\n    },\n  }\n')),(0,r.kt)("p",null,"Well done! Now it's the time to proceed with our tokensale contract.",(0,r.kt)("br",{parentName:"p"}),"\n","Create a ",(0,r.kt)("inlineCode",{parentName:"p"},"Tokensale.sol")," file in your contracts folder. Let's firstly arrange pragmas and imports."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity",metastring:'title="Tokensale.sol" showLineNumbers',title:'"Tokensale.sol"',showLineNumbers:!0},'pragma ever-solidity >= 0.61.2;\npragma AbiHeader expire;\npragma AbiHeader pubkey;\n\nimport "tip3/contracts/interfaces/IAcceptTokensTransferCallback.sol";\nimport "tip3/contracts/interfaces/ITokenRoot.sol";\nimport "tip3/contracts/interfaces/ITokenWallet.sol";\n')),(0,r.kt)("p",null,"We will use some interfaces from the TIP-3 implementation. Let's define our contract state and constructor."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity",metastring:'title="Tokensale.sol" showLineNumbers',title:'"Tokensale.sol"',showLineNumbers:!0},"contract Tokensale {\n    uint16  static _nonce; // Some random value to affect on contract address\n    address static _owner; // Tokensale owner. Will receive all transfers\n\n    address public _distributedTokenRoot; // TIP3 TokenRoot address for deploying wallet for Tokensale. This token will be distributed\n    address public _distributedTokenWallet; // TIP3 wallet for Tokensale for sending purchased tokens\n    uint256 public _supply; // How much tokens will be distributed (with decimals)\n    uint128 public _rate; // How much tokens buyer will receive for 1 nanoever (1*10^9)\n\n    constructor(\n        address distributedTokenRoot,\n        uint256 supply,\n        uint128 rate,\n        address sendRemainingGasTo\n    ) public {\n        tvm.accept(); // This action is required to process external messages that bring no value - deploy as we have.\n        tvm.rawReserve(1 ever, 0); // we will always reserve 1 ever on this contract\n        _distributedTokenRoot = distributedTokenRoot;\n        _rate = rate;\n        _supply = supply;\n\n        // fundamental mechanic of dapps working with tip3 - deploy it's own wallet to operate with. check tip3 specs for more info\n        ITokenRoot(distributedTokenRoot).deployWallet {\n            value: 0.2 ever,\n            flag: 1,\n            callback: Tokensale.onTokenWallet // this callback will be called by TokenRoot after deploying wallet for tokensale\n        } (\n            address(this),\n            0.1 ever\n        );\n        // sending remaining gas after setups\n        sendRemainingGasTo.transfer({ value: 0, flag: 128, bounce: false });\n    }\n}\n")),(0,r.kt)("p",null,"Let's delve a bit into some mechanics of this piece of code. The first thing that you should look at is gas management.",(0,r.kt)("br",{parentName:"p"}),"\n","Look at these two lines:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"tvm.rawReserve(1 ever, 0);\nsendRemainingGasTo.transfer({ value: 0, flag: 128, bounce: false });\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},"first line")," reserves 1 EVER in this contract. Practically, it generates an outbound message carrying reserve nanoevers to oneself so that the next actions performed would not be able to spend more evers than the remainder."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"The second line")," is a best practice for gas management in Everscale. You should always send the remaining gas to the message sender or another given address. "),(0,r.kt)("p",null,"Pay attention to ",(0,r.kt)("inlineCode",{parentName:"p"},"value")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"flag")," parameters of ",(0,r.kt)("inlineCode",{parentName:"p"},"transfer")," function. Flag 128 means that this transfer will carry all remaining non-reserved gas! To sum up, we have the following flow:"),(0,r.kt)("p",null,"Reserving some initial contract balance for an always active state.",(0,r.kt)("br",{parentName:"p"}),"\n","Perform contract logic (may be checking inbound value in case needed).",(0,r.kt)("br",{parentName:"p"}),"\n","Send remaining gas with 128 flag to the message sender or another pointed address.",(0,r.kt)("br",{parentName:"p"}),"\n","The next important logic of our constructor code is deploying a wallet for the contract on-chain.       "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity",metastring:'title="Tokensale.sol" showLineNumbers',title:'"Tokensale.sol"',showLineNumbers:!0},"...\n        ITokenRoot(distributedTokenRoot).deployWallet {\n            value: 0.2 ever,\n            flag: 1,\n            callback: Tokensale.onTokenWallet // this callback will be called by TokenRoot after deploying wallet for tokensale\n        } (\n            address(this),\n            0.1 ever\n        );\n...\n")),(0,r.kt)("p",null,"This action generates an outbound message to ",(0,r.kt)("inlineCode",{parentName:"p"},"TokenRoot")," contract by calling a ",(0,r.kt)("inlineCode",{parentName:"p"},"deployWallet")," function. This function is ",(0,r.kt)("inlineCode",{parentName:"p"},"responsible"),". It means that it will generate an internal outbound message by ",(0,r.kt)("inlineCode",{parentName:"p"},"calling")," a function that was passed in a callback parameter (",(0,r.kt)("inlineCode",{parentName:"p"},"onTokenWallet")," in our case). Let's implement this function for our ",(0,r.kt)("inlineCode",{parentName:"p"},"Tokensale")," contract. From TIP-3 source code we know that ",(0,r.kt)("inlineCode",{parentName:"p"},"deployWallet")," returns only one parameter - deployed wallet address. So, just store it in our state."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity",metastring:'title="Tokensale.sol" showLineNumbers',title:'"Tokensale.sol"',showLineNumbers:!0},"...\n    function onTokenWallet(address value) external {\n        require (\n            msg.sender.value != 0 &&\n            msg.sender == _distributedTokenRoot, // check, that calling was from TokenRoot we need\n            101 // some error code for this require\n        );\n        tvm.rawReserve(1 ever, 0);\n        _distributedTokenWallet = value; // store deployed tip3 wallet address\n        _owner.transfer({ value: 0, flag: 128, bounce: false }); // sending remaining gas after setups\n    }\n...\n")),(0,r.kt)("p",null,"That's all. When we deploy the ",(0,r.kt)("inlineCode",{parentName:"p"},"Tokensale")," contract, ",(0,r.kt)("inlineCode",{parentName:"p"},"deployWallet")," will be called too and the returned value will be stored in our contract state. All we need is a function to sell our tokens."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity",metastring:'title="Tokensale.sol" showLineNumbers',title:'"Tokensale.sol"',showLineNumbers:!0},"...\n    function buyTokens(uint128 deposit) external view {\n        tvm.rawReserve(1 ever, 0);\n        // 1 ever is a technical value for fee...remaining gas will be returned after tokens transfer (from tip3 wallet)\n        if (deposit > msg.value + 1 ever) { // if we using require, we are frozing incoming value in this contract, so just return it \n            msg.sender.transfer({ value: 0, flag: 128, bounce: false });\n        } else {\n            uint128 purchase = _rate * deposit;\n            if (purchase > _supply) {\n                msg.sender.transfer({ value: 0, flag: 128, bounce: false});\n            } else {\n                TvmCell empty;\n                // here we just operate with deployed in constructor wallet. owner should provide token supply on this wallet before sales!\n                ITokenWallet(_distributedTokenWallet).transfer{ value: 0, flag: 128 }(\n                    purchase,\n                    msg.sender,\n                    0.1 ever, // this parameter allows to deploy wallet for user, if it's not deployed yet. (fee takes from message so will be payed by user)\n                    msg.sender,\n                    false,\n                    empty\n                );\n            }\n        }\n    }\n...\n")),(0,r.kt)("p",null,"Notice that we don't use ",(0,r.kt)("inlineCode",{parentName:"p"},"require")," instruction to check incoming value. If we use ",(0,r.kt)("inlineCode",{parentName:"p"},"require"),", the user's deposit will not be returned to the sender and will stay in the contract. So anyone can take this as a remaining gas, according to gas management (because these evers won't be reserved). Best practice - when you check something incoming (evers, other TIP-3 tokens), you should use ",(0,r.kt)("inlineCode",{parentName:"p"},"if")," instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"require"),"."),(0,r.kt)("p",null,"The next mechanic is already familiar to you. Tokensale just calls its own deployed in the constructor wallet to transfer tokens for a buyer. Of course, you should transfer supply tokens to the tokensale wallet before the sale starts :)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"ITokenWallet(_distributedTokenWallet).transfer{ value: 0, flag: 128 }(\n    purchase,\n    msg.sender,\n    0.1 ever, // this parameter allows to deploy wallet for user, if it's not deployed yet. (fee takes from message so will be payed by user)\n    msg.sender,\n    false,\n    empty\n);\n")),(0,r.kt)("p",null,"Pay attention to ",(0,r.kt)("inlineCode",{parentName:"p"},"value")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"flag"),". Again 0 and 128. This allows us to delegate sending of the remaining gas to the TokenWallet contract (of course if you are sure, that delegate performs this action). We send all remaining non-reserved gas to TokenWallet, and, after its own actions, TokenWallet will return the remaining gas where required. (4th parameter of transfer function)."),(0,r.kt)("p",null,"So, let's check our final contract code"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity",metastring:'title="Tokensale.sol" showLineNumbers',title:'"Tokensale.sol"',showLineNumbers:!0},'pragma ever-solidity >= 0.61.2;\npragma AbiHeader expire;\npragma AbiHeader pubkey;\n\nimport "tip3/contracts/interfaces/IAcceptTokensTransferCallback.sol";\nimport "tip3/contracts/interfaces/ITokenRoot.sol";\nimport "tip3/contracts/interfaces/ITokenWallet.sol";\n\n\ncontract Tokensale {\n    uint16  static _nonce; // some random value to affect on contract address\n    address static _owner; // tokensale owner. will receive all transfers\n\n    address public _distributedTokenRoot; // TIP3 TokenRoot address for deploying wallet for Tokensale. This token will be distributed\n    address public _distributedTokenWallet; // TIP3 wallet for Tokensale for sending purchased tokens\n    uint256 public _supply; // How much tokens will be distributed (with decimals)\n    uint128 public _rate; // How much tokens buyer will receive for 1 nanoever (1*10^9)\n\n    constructor(\n        address distributedTokenRoot,\n        uint256 supply,\n        uint128 rate,\n        address sendRemainingGasTo\n    ) public {\n        tvm.accept();\n        tvm.rawReserve(1 ever, 0); // we will always reserve 1 ever on this contract\n        _distributedTokenRoot = distributedTokenRoot;\n        _rate = rate;\n        _supply = supply;\n\n        // fundamental mechanic of dapps working with tip3 - deploy it\'s own wallet to operate with. check tip3 specs for more info\n        ITokenRoot(distributedTokenRoot).deployWallet {\n            value: 0.2 ever,\n            flag: 1,\n            callback: Tokensale.onTokenWallet // this callback will be called by TokenRoot after deploying wallet for tokensale\n        } (\n            address(this),\n            0.1 ever\n        );\n        // sending remaining gas after setups\n        sendRemainingGasTo.transfer({ value: 0, flag: 128, bounce: false });\n    }\n\n    function onTokenWallet(address value) external {\n        require (\n            msg.sender.value != 0 &&\n            msg.sender == _distributedTokenRoot,\n            101\n        );\n        tvm.rawReserve(1 ever, 0);\n        _distributedTokenWallet = value; // store deployed tip3 wallet address\n        _owner.transfer({ value: 0, flag: 128, bounce: false }); // sending remaining gas after setups\n    }\n\n    function buyTokens(uint128 deposit) external view {\n        tvm.rawReserve(1 ever, 0);\n        // 1 ever is a technical value for fee...remaining gas will be returned after tokens transfer (from tip3 wallet)\n        if (deposit > msg.value + 1 ever) { // if we using require, we are frozing incoming value in this contract, so just return it \n            msg.sender.transfer({ value: 0, flag: 128, bounce: false });\n        } else {\n            uint128 purchase = _rate * deposit;\n            if (purchase > _supply) {\n                msg.sender.transfer({ value: 0, flag: 128, bounce: false});\n            } else {\n                TvmCell empty;\n                // here we just operate with deployed in constructor wallet. owner should provide token supply on this wallet before sales!\n                ITokenWallet(_distributedTokenWallet).transfer{ value: 0, flag: 128 }(\n                    purchase,\n                    msg.sender,\n                    0.1 ever, // this parameter allows to deploy wallet for user, if it\'s not deployed yet. (fee takes from message so will be payed by user)\n                    msg.sender,\n                    false,\n                    empty\n                );\n            }\n        }\n    }\n}\n')),(0,r.kt)("p",null,"All you need now is to write some tests with locklift support. There are some simple tests and deploy scripts available in the following ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/venom-blockchain/guides/tree/master/tokensale-contracts"},"repo"),"."))}u.isMDXComponent=!0}}]);
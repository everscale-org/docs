"use strict";(self.webpackChunkeverscale_docs_website=self.webpackChunkeverscale_docs_website||[]).push([[870],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>c});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var o=a.createContext({}),s=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=s(e.components);return a.createElement(o.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},k=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,o=e.parentName,d=p(e,["components","mdxType","originalType","parentName"]),m=s(n),k=i,c=m["".concat(o,".").concat(k)]||m[k]||u[k]||l;return n?a.createElement(c,r(r({ref:t},d),{},{components:n})):a.createElement(c,r({ref:t},d))}));function c(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,r=new Array(l);r[0]=k;var p={};for(var o in t)hasOwnProperty.call(t,o)&&(p[o]=t[o]);p.originalType=e,p[m]="string"==typeof e?e:i,r[1]=p;for(var s=2;s<l;s++)r[s]=n[s];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}k.displayName="MDXCreateElement"},9634:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>u,frontMatter:()=>l,metadata:()=>p,toc:()=>s});var a=n(7462),i=(n(7294),n(3905));const l={title:"ABI Specification"},r="Smart Contracts ABI v2.3 Specification",p={unversionedId:"spec/abi",id:"spec/abi",title:"ABI Specification",description:"ABI specifies message body layout for client-to-contract and contract-to-contract interactions.",source:"@site/../../src/spec/10-abi.md",sourceDirName:"spec",slug:"/spec/abi",permalink:"/spec/abi",draft:!1,editUrl:"https://github.com/everscale-org/docs/edit/main/.build/website/../../src/spec/10-abi.md",tags:[],version:"current",lastUpdatedAt:1712027538,formattedLastUpdatedAt:"Apr 2, 2024",sidebarPosition:10,frontMatter:{title:"ABI Specification"},sidebar:"tutorialSidebar",previous:{title:"Specifications",permalink:"/spec"},next:{title:"DePools",permalink:"/spec/depool-specification"}},o={},s=[{value:"Introduction",id:"introduction",level:2},{value:"Message body",id:"message-body",level:2},{value:"External Inbound Messages",id:"external-inbound-messages",level:3},{value:"External Outbound Messages",id:"external-outbound-messages",level:3},{value:"Internal Messages",id:"internal-messages",level:3},{value:"Message Body Signing",id:"message-body-signing",level:2},{value:"Signing Algorithm",id:"signing-algorithm",level:2},{value:"Function Signature (Function ID)",id:"function-signature-function-id",level:2},{value:"Function Signature Syntax",id:"function-signature-syntax",level:3},{value:"Signature Calculation Syntax",id:"signature-calculation-syntax",level:3},{value:"Sample Implementation",id:"sample-implementation",level:3},{value:"Event ID",id:"event-id",level:3},{value:"Header parameter types",id:"header-parameter-types",level:2},{value:"Function parameter types",id:"function-parameter-types",level:2},{value:"Encoding of function ID and its arguments",id:"encoding-of-function-id-and-its-arguments",level:2},{value:"Encoding header for external messages",id:"encoding-header-for-external-messages",level:2},{value:"ABI JSON",id:"abi-json",level:2},{value:"Header",id:"header",level:3},{value:"Functions",id:"functions",level:3},{value:"Events",id:"events",level:3},{value:"Data",id:"data",level:3},{value:"Fields",id:"fields",level:3},{value:"Types Reference",id:"types-reference",level:3},{value:"<code>time</code>",id:"time",level:4},{value:"<code>expire</code>",id:"expire",level:4},{value:"<code>pubkey</code>",id:"pubkey",level:4},{value:"<code>int&lt;N&gt;</code>",id:"intn",level:4},{value:"<code>uint&lt;N&gt;</code>",id:"uintn",level:4},{value:"<code>varint&lt;N&gt;</code>",id:"varintn",level:4},{value:"<code>varuint&lt;N&gt;</code>",id:"varuintn",level:4},{value:"<code>bool</code>",id:"bool",level:4},{value:"<code>tuple</code>",id:"tuple",level:4},{value:"<code>map(&lt;keyType&gt;,&lt;valueType&gt;)</code>",id:"mapkeytypevaluetype",level:4},{value:"<code>cell</code>",id:"cell",level:4},{value:"<code>address</code>",id:"address",level:4},{value:"<code>bytes</code>",id:"bytes",level:4},{value:"<code>fixedbytes&lt;N&gt;</code>",id:"fixedbytesn",level:4},{value:"<code>string</code>",id:"string",level:4},{value:"<code>optional(innerType)</code>",id:"optionalinnertype",level:4},{value:"<code>itemType[]</code>",id:"itemtype",level:4},{value:"&quot;Big&quot; structures as values in mappings and arrays",id:"big-structures-as-values-in-mappings-and-arrays",level:3},{value:"Reference",id:"reference",level:2}],d={toc:s},m="wrapper";function u(e){let{components:t,...n}=e;return(0,i.kt)(m,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"smart-contracts-abi-v23-specification"},"Smart Contracts ABI v2.3 Specification"),(0,i.kt)("p",null,"ABI specifies message body layout for client-to-contract and contract-to-contract interactions."),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"In Everscale, client-to-contract and contract-to-contract interaction occurs through external and internal messages respectively."),(0,i.kt)("p",null,"ABI specification describes the structure of the body of these messages. ABI stored as JSON serves as an interface for smart contracts and is used when calling contract methods externally or on-chain."),(0,i.kt)("p",null,"The goal of the ABI specification is to design ABI types that are cheap to read to reduce gas consumption and gas costs. Some types are optimized for storing without write access."),(0,i.kt)("h2",{id:"message-body"},"Message body"),(0,i.kt)("h3",{id:"external-inbound-messages"},"External Inbound Messages"),(0,i.kt)("p",null,"Message body with encoded function call has the following format:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Maybe(Signature)")," +  ",(0,i.kt)("inlineCode",{parentName:"p"},"Enc(Header)")," +",(0,i.kt)("inlineCode",{parentName:"p"},"Function ID")," +  ",(0,i.kt)("inlineCode",{parentName:"p"},"Enc(Arguments)")),(0,i.kt)("p",null,"First comes an optional signature. It is prefixed by a one-bit flag that indicates the signature presence. If it is ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),", then in the next ",(0,i.kt)("inlineCode",{parentName:"p"},"512 bit")," a signature is placed, otherwise, the signature is omitted."),(0,i.kt)("p",null,"Then comes the encoded header parameters set  (same for all functions)."),(0,i.kt)("p",null,"It is followed by ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"32 bits"))," of function ID identifying which contract functions are called. The ",(0,i.kt)("inlineCode",{parentName:"p"},"function ID")," comes within the first ",(0,i.kt)("inlineCode",{parentName:"p"},"32 bits")," of the ",(0,i.kt)("inlineCode",{parentName:"p"},"SHA256")," hash of the function signature."),(0,i.kt)("p",null,"The highest bit is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," for function ID in external inbound messages, and to ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," for external outbound messages."),(0,i.kt)("p",null,"Function parameters are next. They are encoded in compliance with the present specification and stored either in the root cell or the next one in the chain."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"An encoded parameter cannot be split between different cells")),(0,i.kt)("h3",{id:"external-outbound-messages"},"External Outbound Messages"),(0,i.kt)("p",null,"External outbound messages are used to return values from functions or to emit events."),(0,i.kt)("p",null,"Return values are encoded and put into the message response:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Function ID"),"+",(0,i.kt)("inlineCode",{parentName:"p"},"Enc(Return values)")),(0,i.kt)("p",null,"Function ID's highest bit is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),"."),(0,i.kt)("p",null,"Events are encoded as follows:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Event ID")," + ",(0,i.kt)("inlineCode",{parentName:"p"},"Enc(event args)")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Event ID")," - 32 bits of SHA256 hash of the event function signature with the highest bit set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),"."),(0,i.kt)("h3",{id:"internal-messages"},"Internal Messages"),(0,i.kt)("p",null,"Internal messages are used for contract-to-contract interaction; they have the following body format:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Function ID")," + ",(0,i.kt)("inlineCode",{parentName:"p"},"Enc(Arguments)")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Function ID")," - 32 bits functionID calculated as the first 32 bits SHA256 hash of the function signature. The highest bit of function ID is ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),". Internal messages contain only function calls and no responses."),(0,i.kt)("h2",{id:"message-body-signing"},"Message Body Signing"),(0,i.kt)("p",null,"The message body can be protected with a cryptographic signature to identify a user outside the blockchain. In this case, an ",(0,i.kt)("em",{parentName:"p"},"External inbound message")," that calls the function carries a user ",(0,i.kt)("em",{parentName:"p"},"private key")," signature. This requirement applies only to ",(0,i.kt)("em",{parentName:"p"},"External inbound messages")," because ",(0,i.kt)("em",{parentName:"p"},"Internal inbound messages")," are generated within the blockchain, and ",(0,i.kt)("em",{parentName:"p"},"src address")," can be used to identify the caller."),(0,i.kt)("p",null,"If a user does not want to sign a message, bit ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," should be placed to the root cell start and signature omitted."),(0,i.kt)("p",null,"The message body signature is generated from the ",(0,i.kt)("em",{parentName:"p"},"representation hash")," of the bag of cells following the signature prepended with the source address."),(0,i.kt)("h2",{id:"signing-algorithm"},"Signing Algorithm"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"ABI serialization generates a bag of cells containing header parameters, function ID, and function parameters.\n591 free bits are reserved in the root cell for the destination address (",(0,i.kt)("a",{parentName:"li",href:"#address"},"the maximum size of address"),")."),(0,i.kt)("li",{parentName:"ol"},"The root cell data is prepended with actual destination address data without padding to maximum size."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("em",{parentName:"li"},"Representation hash")," of the bag is signed using the ",(0,i.kt)("em",{parentName:"li"},"Ed25519")," algorithm."),(0,i.kt)("li",{parentName:"ol"},"Address data is removed from the root cell and replaced with bit ",(0,i.kt)("inlineCode",{parentName:"li"},"1")," followed by 512 bits of the signature.")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"This functionality has been added since ",(0,i.kt)("inlineCode",{parentName:"p"},"ABI v2.3")," and supported starting with ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/tonlabs/TON-Solidity-Compiler/blob/master/Changelog.md#0640-2022-08-18"},"0.64.0")," version of the Solidity compiler.")),(0,i.kt)("h2",{id:"function-signature-function-id"},"Function Signature (Function ID)"),(0,i.kt)("p",null,"The following syntax is used for defining a signature:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"function name"),(0,i.kt)("li",{parentName:"ul"},"list of input parameter types (input list) in parenthesis"),(0,i.kt)("li",{parentName:"ul"},"list of return values types (output list) in parenthesis"),(0,i.kt)("li",{parentName:"ul"},"ABI version")),(0,i.kt)("p",null,"Single comma is used to divide each input parameter and return value type from one another. Spaces are not used."),(0,i.kt)("p",null,"Parameter and return value names are not included."),(0,i.kt)("p",null,"The function name, input and output lists are not separated and immediately follow each other."),(0,i.kt)("p",null,"If a function has no input parameters or does not return any values, the corresponding input or output lists are empty (empty parenthesis)."),(0,i.kt)("p",null," Function ID may be indicated in ABI separately. Then the first bit stays the same regardless of incoming/outgoing message."),(0,i.kt)("h3",{id:"function-signature-syntax"},"Function Signature Syntax"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"function_name(input_type1,input_type2,...,input_typeN)(output_type1,output_type2,...,output_typeM)v2")),(0,i.kt)("h3",{id:"signature-calculation-syntax"},"Signature Calculation Syntax"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},'SHA256("function_name(input_type1,input_type2,...,input_typeN)(output_type1,output_type2,...,output_typeM)v2")')),(0,i.kt)("h3",{id:"sample-implementation"},"Sample Implementation"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Function")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"func(int64 param1, bool param2) -> uint32")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Function Signature")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"func(int64,bool)(uint32)v2")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Function Hash")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},'sha256("func(int64,bool)(uint32)v2") = 0x1354f2c85b50aa84c2f65ebb8cec69aba0aa3269c21e03e142e014e84ea59649')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"function ID")," then is ",(0,i.kt)("inlineCode",{parentName:"p"},"0x1354f2c8")," for function call and ",(0,i.kt)("inlineCode",{parentName:"p"},"0x9354f2c8")," for function response"),(0,i.kt)("h3",{id:"event-id"},"Event ID"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Event ID")," is calculated in the same way as the ",(0,i.kt)("strong",{parentName:"p"},"function ID")," except for cases when the event signature does not contain the list of return values types: ",(0,i.kt)("inlineCode",{parentName:"p"},"event(int64,bool)v2")),(0,i.kt)("h2",{id:"header-parameter-types"},"Header parameter types"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#time"},(0,i.kt)("inlineCode",{parentName:"a"},"time")),": message creation timestamp. Encoded as 64 bit Unix time in milliseconds.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#expire"},(0,i.kt)("inlineCode",{parentName:"a"},"expire")),": Unix time (in seconds, 32 bit) after that message should not be processed by contract.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#pubkey"},(0,i.kt)("inlineCode",{parentName:"a"},"pubkey")),": public key from key pair used for signing the message body. This parameter is optional."))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note"),": Header may also contain any of standard function parameter types described below to be used in custom checks."),(0,i.kt)("h2",{id:"function-parameter-types"},"Function parameter types"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#intn"},(0,i.kt)("inlineCode",{parentName:"a"},"int<N>")),": two\u2019s complement signed ",(0,i.kt)("inlineCode",{parentName:"p"},"N")," bit integer. Big-endian encoded signed integer stored in the cell-data.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#uintn"},(0,i.kt)("inlineCode",{parentName:"a"},"uint<N>")),": unsigned ",(0,i.kt)("inlineCode",{parentName:"p"},"N")," bit integer. Big-endian encoded unsigned integer stored in the cell-data.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#varintn"},(0,i.kt)("inlineCode",{parentName:"a"},"varint<N>")),": variable-length signed integer. Bit length is between ",(0,i.kt)("inlineCode",{parentName:"p"},"log2(N)")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"8 * (N-1)"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"N")," is equal to 16 or 32.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#varuintn"},(0,i.kt)("inlineCode",{parentName:"a"},"varuint<N>")),": variable-length unsigned integer with bit length equal to 8 * N, where Nis equal to 16 or 32 e.g. Processed like ",(0,i.kt)("inlineCode",{parentName:"p"},"varint<N>"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#bool"},(0,i.kt)("inlineCode",{parentName:"a"},"bool")),": equivalent to uint1.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#tuple"},"tuple ",(0,i.kt)("inlineCode",{parentName:"a"},"(T1, T2, ..., Tn)")),": tuple that includes ",(0,i.kt)("inlineCode",{parentName:"p"},"T1"),", ..., ",(0,i.kt)("inlineCode",{parentName:"p"},"Tn"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"n>=0")," types encoded in the following way:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"Enc(X(1)) Enc(X(2)) ..., Enc(X(n)); where X(i) is value of T(i) for i in 1..n \n")),(0,i.kt)("p",{parentName:"li"},"Tuple elements are encoded as independent values so they can be placed in different cells")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#mapkeytypevaluetype"},(0,i.kt)("inlineCode",{parentName:"a"},"map(K,V)"))," is a dictionary of ",(0,i.kt)("inlineCode",{parentName:"p"},"V")," type values with ",(0,i.kt)("inlineCode",{parentName:"p"},"K")," type key. Dictionary is encoded as  ",(0,i.kt)("inlineCode",{parentName:"p"},"HashmapE")," type (one bit put into cell data as dictionary root and one reference with data is added if the dictionary is not empty).")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#cell"},(0,i.kt)("inlineCode",{parentName:"a"},"cell")),": a type for defining a raw tree of cells. Stored as a reference in the current cell. Must be decoded with ",(0,i.kt)("inlineCode",{parentName:"p"},"LDREF"),"  command and stored as-is."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Note: this type is useful to store payloads as a tree of cells analog to contract code and data in the form of ",(0,i.kt)("inlineCode",{parentName:"li"},"StateInit")," structure of ",(0,i.kt)("inlineCode",{parentName:"li"},"message")," structure."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#address"},(0,i.kt)("inlineCode",{parentName:"a"},"address"))," is an account address in Everscale blockchain. Encoded as ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgAddress")," struct (see TL-B schema in blockchain ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/ton-blockchain/ton/blob/master/crypto/block/block.tlb#L107"},"spec"),").")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#bytes"},(0,i.kt)("inlineCode",{parentName:"a"},"bytes")),": an array of ",(0,i.kt)("inlineCode",{parentName:"p"},"uint8")," type elements. The array is put into a separate cell. ")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#fixedbytesn"},(0,i.kt)("inlineCode",{parentName:"a"},"fixedbytes<N>")),": a fixed-size array of ",(0,i.kt)("inlineCode",{parentName:"p"},"N")," ",(0,i.kt)("inlineCode",{parentName:"p"},"uint8")," type elements. Encoding is equivalent to ",(0,i.kt)("inlineCode",{parentName:"p"},"bytes"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#string"},(0,i.kt)("inlineCode",{parentName:"a"},"string"))," - a type containing UTF-8 string data, encoded like ",(0,i.kt)("inlineCode",{parentName:"p"},"bytes"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#optionalinnertype"},(0,i.kt)("inlineCode",{parentName:"a"},"optional"))," - value of optional type ",(0,i.kt)("inlineCode",{parentName:"p"},"optional(innerType)")," can store a value of ",(0,i.kt)("inlineCode",{parentName:"p"},"innerType")," or be empty.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#itemtype"},(0,i.kt)("inlineCode",{parentName:"a"},"itemType[]"))," is a dynamic array of ",(0,i.kt)("inlineCode",{parentName:"p"},"itemType")," type elements. It is encoded as a TVM dictionary.  ",(0,i.kt)("inlineCode",{parentName:"p"},"uint32")," defines the array elements count placed into the cell body.  ",(0,i.kt)("inlineCode",{parentName:"p"},"HashmapE")," (see TL-B schema in TVM spec) struct is then added (one bit as a dictionary root and one reference with data if the dictionary is not empty). The dictionary key is a serialized ",(0,i.kt)("inlineCode",{parentName:"p"},"uint32")," index of the array element, and the value is a serialized array element as ",(0,i.kt)("inlineCode",{parentName:"p"},"itemType")," type."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"T[k]")," is a static size array of ",(0,i.kt)("inlineCode",{parentName:"li"},"T")," type elements. Encoding is equivalent to ",(0,i.kt)("inlineCode",{parentName:"li"},"T[]")," without elements count.")))),(0,i.kt)("h2",{id:"encoding-of-function-id-and-its-arguments"},"Encoding of function ID and its arguments"),(0,i.kt)("p",null,"Function ID and the function arguments are located in the chain of cells. The last reference of each cell (except for the last cell in the chain) refers to the next cell. After adding the current parameter in the current cell we must presume an invariant (rule that stays true for the object) for our cell: number of unassigned references in the cell must be not less than 1 because the last reference is used for storing the reference on the next cell. The last cell in the chain can use all 4 references to store argument's values."),(0,i.kt)("p",null,"When we add a specific value of some function argument to the cell we assume that it takes the max bit and max ref size for a particular argument type (see ",(0,i.kt)("a",{parentName:"p",href:"#types-reference"},(0,i.kt)("inlineCode",{parentName:"a"},"types reference"))," section). Only if the current parameter (by max bit or max ref size) does not fit into the current cell do we create a new cell and insert the parameter in the new cell. But if the current argument and all the following arguments fit into the current cell by max size, then we push the parameters in the cell. The serialized argument value takes up only the necessary bits and refs size without aligning to max sizes of its type."),(0,i.kt)("p",null,"In the end we connect the created cells in the chain of cells by assigning the last reference in each cell to next cell."),(0,i.kt)("p",null,"Below are some examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"function f(address a, address b) public;\n")),(0,i.kt)("p",null,"Here we create 2 cells. In the first cell there is function id and  ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),". There may be not more than 32+591=623 bits (591 bits is the ",(0,i.kt)("a",{parentName:"p",href:"#address"},"maximum size of 'address'"),"). So it is not more than 1023 bits. The next parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," thus can't fit into the first cell. In the second cell there is only ",(0,i.kt)("inlineCode",{parentName:"p"},"b"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"function f(mapping(uint=>uint) a, mapping(uint=>uint) b, mapping(uint=>uint) c, mapping(uint=>uint) d)\n")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"#mapkeytypevaluetype"},"map")," type takes up maximum 1 bit and 1 ref so all parameters can fit into one cell: function ID, ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," ",(0,i.kt)("inlineCode",{parentName:"p"},"c"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"d"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"struct A {\n  string a;\n  string b;\n  string c;\n  string d;\n}\n\nfunction f(A a, uint32 e) public;\n")),(0,i.kt)("p",null,"Same as the previous example, this fits in one cell because ",(0,i.kt)("a",{parentName:"p",href:"#string"},"string")," takes 32 bits and 1 ref."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"function f(string a, string b, string c, string d, uint32 e) public\n")),(0,i.kt)("p",null,"Function ID, ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"b"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"c")," are located in the first cell. ",(0,i.kt)("inlineCode",{parentName:"p"},"d")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"e")," fit in the first cell by max size. That's why we push all parameters in the fist cell."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"function f(string a, string b, string c, string d, uint e, uint f, uint g, uint h) public\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"uint")," in Solidity is equal to ",(0,i.kt)("inlineCode",{parentName:"p"},"uint256"),". We use 3 cells. In the first cell there are function Id, ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"b,")," ",(0,i.kt)("inlineCode",{parentName:"p"},"c"),". In the second - ",(0,i.kt)("inlineCode",{parentName:"p"},"d"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"e"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"f"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"g"),". In the third - ",(0,i.kt)("inlineCode",{parentName:"p"},"h"),"."),(0,i.kt)("h2",{id:"encoding-header-for-external-messages"},"Encoding header for external messages"),(0,i.kt)("p",null,"External message's body contains function call header in addition to function ID and arguments. Header has up to 3 optional parameters and mandatory signature. Function ID and function parameters are put after header parameters."),(0,i.kt)("p",null,"Maximum header size is calculated as follows (no references used)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"maxHeader =\n  591 +\n  (hasPubkey ? 1 + 256 : 0) +\n  (hasTime ? 64 : 0)  +\n  (hasExpire ? 32 : 0);\n")),(0,i.kt)("p",null,"591 bits are reserved for message destination address to use it while ",(0,i.kt)("a",{parentName:"p",href:"#signing-algorithm"},"signing")," the body."),(0,i.kt)("p",null,"Let's look at some examples of header encoding. Assume that header contains ",(0,i.kt)("inlineCode",{parentName:"p"},"time")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"expire")," parameters. It requires ",(0,i.kt)("inlineCode",{parentName:"p"},"591 + 64 + 32 = 687")," bits"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"function f(address a, address b) public;\n")),(0,i.kt)("p",null,"Now we have to use 3 cells. In the first cell we put header and function ID. Parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," can not fit in first cell so it goes to second and ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," is put in the third cell."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"function f(mapping(uint=>uint) a, mapping(uint=>uint) b, mapping(uint=>uint) c, mapping(uint=>uint) d)\n")),(0,i.kt)("p",null,"Here header and all arguments fit in the first cell. After signing it will contain 645 bits and 4 refs."),(0,i.kt)("h2",{id:"abi-json"},"ABI JSON"),(0,i.kt)("p",null,"The contract interface is stored as a JSON file called contract ABI. It includes all public functions with data described by ABI types. Below is a structure of an ABI file in TypeScript notation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"type Abi = {\n  version: string,\n  header?: HeaderParam[],\n  functions: Function[],\n  events?: Event[],\n  data?: Data[],\n  fields?: Param[],\n}\n\ntype HeaderParam = Param | string\n\ntype Function = {\n  name: string,\n  inputs?: Param[],\n  outputs?: Param[],\n  id?: number,\n}\n\ntype Event = {\n  name: string,\n  inputs?: Param[],\n  id?: number,\n}\n\ntype Data = Param & {\n  key: number,\n}\n\ntype Param = {\n  name: string,\n  type: string,\n  components?: Param[],\n}\n")),(0,i.kt)("h3",{id:"header"},"Header"),(0,i.kt)("p",null,"This section describes additional parameters of functions within the contract. Header-specific types are specified as strings with the type ",(0,i.kt)("inlineCode",{parentName:"p"},"name"),". Other types are specified as function parameter type (see ",(0,i.kt)("a",{parentName:"p",href:"#function-parameter-types"},"Functions"),"))"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "header": [\n    "header_type",\n    {\n      "name": "param_name",\n      "type": "param_type"\n    }\n  ]\n}\n')),(0,i.kt)("p",null,"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json5"},'{\n  "header": [\n    "time",\n    "expire",\n    {\n      "name": "custom",\n      "type": "int256"\n    }\n  ]\n}\n')),(0,i.kt)("h3",{id:"functions"},"Functions"),(0,i.kt)("p",null,"Specifies each interface function signature, including its name, input, and output parameters. Functions specified in the contract interface can be called from other contracts or from outside the blockchain via ABI call."),(0,i.kt)("p",null,"Functions section has the following fields:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json5"},'{\n  "functions": [\n    {\n      "name": "method_name",\n      "inputs": [\n        {"name": "func_name", "type": "ABI_type"},\n      ],\n      "outputs": [],\n      "id": "0xXXXXXXXX", //optional\n    }\n  ]\n}\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"name"),": function name;"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"inputs"),": an array of objects, each containing:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"name"),": parameter name;"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"type"),": the canonical parameter type."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"components"),": used for tuple types, optional."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"id"),": an optional ",(0,i.kt)("inlineCode",{parentName:"li"},"uint32")," ",(0,i.kt)("inlineCode",{parentName:"li"},"id")," parameter can be added. This ",(0,i.kt)("inlineCode",{parentName:"li"},"id")," will be used as a ",(0,i.kt)("inlineCode",{parentName:"li"},"Function ID")," instead of automatically calculated. PS: the last case can be used for contracts that are not ABI-compatible."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"outputs"),": an array of objects similar to ",(0,i.kt)("inlineCode",{parentName:"li"},"inputs"),". It can be omitted if the function does not return anything;")),(0,i.kt)("h3",{id:"events"},"Events"),(0,i.kt)("p",null,"This section specifies the events used in the contract. An event is an external outbound message with ABI-encoded parameters in the body."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json5"},'{\n  "events": [\n    {\n      "name": "event_name",\n      "inputs": [],\n      "id": "0xXXXXXXXX", //optional\n    },\n  ]\n}\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"inputs")," have the same format as for functions."),(0,i.kt)("h3",{id:"data"},"Data"),(0,i.kt)("p",null,"This section covers the contract global public variables. Data is typically used when deploying multiple identical contracts with the same deployer keys. It affects the contract address, and thus varying data results in unique addresses for identical contracts."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json5"},'{\n  "data": [\n    {\n      "name": "var_name",\n      "type": "abi_type",\n      "key": "<number>" // index of variable in contract data dictionary\n    },\n  ]\n}\n')),(0,i.kt)("h3",{id:"fields"},"Fields"),(0,i.kt)("p",null,"This section describes internal structure of the smart contracts data."),(0,i.kt)("p",null,"Data structure is described as a list of variables' names with corresponding data types.\nIt includes contract state variables and some internal contract specific hidden variables.\nThey are listed in the order in which they are stored in the data field of the contract.\nExample for a Solidity contract ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/tonlabs/samples/blob/master/solidity/5_BankClient.sol"},"BankClient"),":"),(0,i.kt)("p",null,"Contract state variables:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"contract BankClient {\n  uint public creditLimit = 0;  // allowed credit limit;\n  uint public totalDebt = 0;    // contract total debt;\n  uint public balance = 0;    // contract balance;\n  uint public value = 0;      // inbound message value.\n}\n")),(0,i.kt)("p",null,"Fields section of the abi file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "fields": [\n    {"name":"_pubkey","type":"uint256"},\n    {"name":"_timestamp","type":"uint64"},\n    {"name":"_constructorFlag","type":"bool"},\n    {"name":"creditLimit","type":"uint256"},\n    {"name":"totalDebt","type":"uint256"},\n    {"name":"balance","type":"uint256"},\n    {"name":"value","type":"uint256"}\n  ]\n}\n')),(0,i.kt)("h3",{id:"types-reference"},"Types Reference"),(0,i.kt)("h4",{id:"time"},(0,i.kt)("inlineCode",{parentName:"h4"},"time")),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Header parameter type.")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"time")," is the message creation timestamp. Used for ",(0,i.kt)("strong",{parentName:"p"},"replay attack protection"),", encoded as 64 bit Unix time in milliseconds."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Usage"),(0,i.kt)("th",{parentName:"tr",align:null},"Value"),(0,i.kt)("th",{parentName:"tr",align:null},"Examples"),(0,i.kt)("th",{parentName:"tr",align:null},"Max bit size"),(0,i.kt)("th",{parentName:"tr",align:null},"Max ref size"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Cell"),(0,i.kt)("td",{parentName:"tr",align:null},"64 bit, big endian"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"64 bits"),(0,i.kt)("td",{parentName:"tr",align:null},"0 refs")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"JSON object"),(0,i.kt)("td",{parentName:"tr",align:null},"string with hex or decimal representation"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},'"1685634471"')),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})))),(0,i.kt)("p",null," ",(0,i.kt)("strong",{parentName:"p"},"Rule"),": the contract should store the timestamp of the last accepted message. The initial timestamp is 0. When a new message is received, the contract should do the following check:"),(0,i.kt)("p",null,"  ",(0,i.kt)("inlineCode",{parentName:"p"},"last_time")," < ",(0,i.kt)("inlineCode",{parentName:"p"},"new_time")," < ",(0,i.kt)("inlineCode",{parentName:"p"},"now + interval"),", where"),(0,i.kt)("p",null,"  ",(0,i.kt)("inlineCode",{parentName:"p"},"last_time")," - last accepted message timestamp (loaded from c4 register),"),(0,i.kt)("p",null,"  ",(0,i.kt)("inlineCode",{parentName:"p"},"new_time")," - inbound external message timestamp (loaded from message body),"),(0,i.kt)("p",null,"  ",(0,i.kt)("inlineCode",{parentName:"p"},"now")," - current block creation time (just as NOW TVM primitive),"),(0,i.kt)("p",null,"  ",(0,i.kt)("inlineCode",{parentName:"p"},"interval")," - 30 min."),(0,i.kt)("p",null,"  The contract should continue execution if these requirements are met. Otherwise, the inbound message should be rejected."),(0,i.kt)("h4",{id:"expire"},(0,i.kt)("inlineCode",{parentName:"h4"},"expire")),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Header parameter type.")),(0,i.kt)("p",null,"Unix time (in seconds, 32 bit) after which message should not be processed by contract. It is used for indicating lost external inbound messages."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Usage"),(0,i.kt)("th",{parentName:"tr",align:null},"Value"),(0,i.kt)("th",{parentName:"tr",align:null},"Examples"),(0,i.kt)("th",{parentName:"tr",align:null},"Max bit size"),(0,i.kt)("th",{parentName:"tr",align:null},"Max ref size"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Cell"),(0,i.kt)("td",{parentName:"tr",align:null},"32 bit, big endian"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"32 bits"),(0,i.kt)("td",{parentName:"tr",align:null},"0 refs")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"JSON object"),(0,i.kt)("td",{parentName:"tr",align:null},"string with hex or decimal representation"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},'"3600"')),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})))),(0,i.kt)("p",null,"  ",(0,i.kt)("strong",{parentName:"p"},"Rule"),":  if contract execution time is less then ",(0,i.kt)("inlineCode",{parentName:"p"},"expire")," time, then execution is continued. Otherwise, the message is expired, and the transaction aborts itself (by ",(0,i.kt)("inlineCode",{parentName:"p"},"ACCEPT")," primitive). The client waits for message processing until the ",(0,i.kt)("inlineCode",{parentName:"p"},"expire")," time. If the message wasn't processed during that interval it is considered to be expired."),(0,i.kt)("h4",{id:"pubkey"},(0,i.kt)("inlineCode",{parentName:"h4"},"pubkey")),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Header parameter type.")),(0,i.kt)("p",null,"Public key from key pair used for signing the message body. This parameter is optional. The client decides if they need to set the public key or not. It is encoded as bit 1 followed by 256 bit of public key if parameter provided, or by bit ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," if it is not."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Usage"),(0,i.kt)("th",{parentName:"tr",align:null},"Value"),(0,i.kt)("th",{parentName:"tr",align:null},"Examples"),(0,i.kt)("th",{parentName:"tr",align:null},"Max bit size"),(0,i.kt)("th",{parentName:"tr",align:null},"Max ref size"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Cell"),(0,i.kt)("td",{parentName:"tr",align:null},"1 bit, ",(0,i.kt)("inlineCode",{parentName:"td"},"0")," or ",(0,i.kt)("inlineCode",{parentName:"td"},"1")," + 256 bit key if if first bit=1"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"257 bit"),(0,i.kt)("td",{parentName:"tr",align:null},"0 refs")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"JSON object"),(0,i.kt)("td",{parentName:"tr",align:null},"string hexadecimal representation of byte array"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},'"33a2ed7a92bb55b3aabe1185d0107d48 faa798246c95ed76f262d857c3d1227b"')),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})))),(0,i.kt)("h4",{id:"intn"},(0,i.kt)("inlineCode",{parentName:"h4"},"int<N>")),(0,i.kt)("p",null,"Fixed-sized signed integer, where ",(0,i.kt)("inlineCode",{parentName:"p"},"N")," is a decimal bit length. Examples: ",(0,i.kt)("inlineCode",{parentName:"p"},"int8"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"int32"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"int256"),"."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Usage"),(0,i.kt)("th",{parentName:"tr",align:null},"Value"),(0,i.kt)("th",{parentName:"tr",align:null},"Examples"),(0,i.kt)("th",{parentName:"tr",align:null},"Max bit size"),(0,i.kt)("th",{parentName:"tr",align:null},"Max ref size"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Cell"),(0,i.kt)("td",{parentName:"tr",align:null},"N bit, big endian"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"N bits"),(0,i.kt)("td",{parentName:"tr",align:null},"0 refs")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"JSON (returns)"),(0,i.kt)("td",{parentName:"tr",align:null},"string with hex or decimal representation"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},'"0x12"'),", ",(0,i.kt)("inlineCode",{parentName:"td"},'"100"')),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"JSON (accepts)"),(0,i.kt)("td",{parentName:"tr",align:null},"number or string with hex or decimal representation"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"12"),", ",(0,i.kt)("inlineCode",{parentName:"td"},'"0x10"'),", ",(0,i.kt)("inlineCode",{parentName:"td"},'"100"')),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})))),(0,i.kt)("h4",{id:"uintn"},(0,i.kt)("inlineCode",{parentName:"h4"},"uint<N>")),(0,i.kt)("p",null,"Fixed-sized unsigned integer, where N is a decimal bit length e.g., ",(0,i.kt)("inlineCode",{parentName:"p"},"uint8"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"uint32"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"uint256"),".\nProcessed like ",(0,i.kt)("inlineCode",{parentName:"p"},"int<N>"),"."),(0,i.kt)("h4",{id:"varintn"},(0,i.kt)("inlineCode",{parentName:"h4"},"varint<N>")),(0,i.kt)("p",null,"Variable-length signed integer. Bit length is between ",(0,i.kt)("inlineCode",{parentName:"p"},"log2(N)")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"8 * (N-1)"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"N")," is equal to 16 or 32, e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"varint16"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"varint32"),"."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Usage"),(0,i.kt)("th",{parentName:"tr",align:null},"Value"),(0,i.kt)("th",{parentName:"tr",align:null},"Examples"),(0,i.kt)("th",{parentName:"tr",align:null},"Max bit size"),(0,i.kt)("th",{parentName:"tr",align:null},"Max ref size"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Cell"),(0,i.kt)("td",{parentName:"tr",align:null},"4 (N=16) of 5 (N=32) bits that encode byte length of the number ",(0,i.kt)("inlineCode",{parentName:"td"},"len"),(0,i.kt)("br",null),"followed by ",(0,i.kt)("inlineCode",{parentName:"td"},"len * 8")," bit number in big endian"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"varint16")," type \u2014 124 bits, ",(0,i.kt)("inlineCode",{parentName:"td"},"varint32")," type \u2014 253 bits, etc."),(0,i.kt)("td",{parentName:"tr",align:null},"0 refs")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"JSON (returns)"),(0,i.kt)("td",{parentName:"tr",align:null},"string with hex or decimal representation"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},'"0x12"'),", ",(0,i.kt)("inlineCode",{parentName:"td"},'"100"')),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"JSON (accepts)"),(0,i.kt)("td",{parentName:"tr",align:null},"number or string with hex or decimal representation"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"12"),", ",(0,i.kt)("inlineCode",{parentName:"td"},'"0x10"'),", ",(0,i.kt)("inlineCode",{parentName:"td"},'"100"')),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})))),(0,i.kt)("h4",{id:"varuintn"},(0,i.kt)("inlineCode",{parentName:"h4"},"varuint<N>")),(0,i.kt)("p",null,"Variable-length unsigned integer with bit length equal to ",(0,i.kt)("inlineCode",{parentName:"p"},"8 * N"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"N"),"is equal to 16 or 32 e.g., ",(0,i.kt)("inlineCode",{parentName:"p"},"varint16"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"varint32"),".\nProcessed like ",(0,i.kt)("inlineCode",{parentName:"p"},"varint<N>"),"."),(0,i.kt)("h4",{id:"bool"},(0,i.kt)("inlineCode",{parentName:"h4"},"bool")),(0,i.kt)("p",null,"Boolean type."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Usage"),(0,i.kt)("th",{parentName:"tr",align:null},"Usage"),(0,i.kt)("th",{parentName:"tr",align:null},"Examples"),(0,i.kt)("th",{parentName:"tr",align:null},"Max bit size"),(0,i.kt)("th",{parentName:"tr",align:null},"Max ref size"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Cell"),(0,i.kt)("td",{parentName:"tr",align:null},"1 bit, ",(0,i.kt)("inlineCode",{parentName:"td"},"0")," or ",(0,i.kt)("inlineCode",{parentName:"td"},"1")),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"1 bit"),(0,i.kt)("td",{parentName:"tr",align:null},"0 refs")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"JSON (returns)"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"true"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"false")),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"JSON (accepts)"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"true"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"false"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"0"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"1"),", ",(0,i.kt)("inlineCode",{parentName:"td"},'"true"'),", ",(0,i.kt)("inlineCode",{parentName:"td"},'"false"')),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"0"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"true"),", ",(0,i.kt)("inlineCode",{parentName:"td"},'"false"')),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})))),(0,i.kt)("h4",{id:"tuple"},(0,i.kt)("inlineCode",{parentName:"h4"},"tuple")),(0,i.kt)("p",null,"Struct type, consists of fields of different types. All fields should be specified as an array in the ",(0,i.kt)("inlineCode",{parentName:"p"},"components")," section of the type."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"structure (aka tuple)")," type is considered as a sequence of its types when we encode the function parameters. That's why ",(0,i.kt)("inlineCode",{parentName:"p"},"tuple")," type doesn't have max bit or max ref size. Nested ",(0,i.kt)("inlineCode",{parentName:"p"},"tuple"),"'s also are considered as a sequence of its types. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"struct A {\n  uint8 a;\n  uint16 b;\n}\n\nstruct B {\n  uint24 d;\n  A a;\n  uint32 d;\n}\n")),(0,i.kt)("p",null,"structure ",(0,i.kt)("inlineCode",{parentName:"p"},"B")," is considered as a sequence of ",(0,i.kt)("inlineCode",{parentName:"p"},"uint24"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"uint8"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"uint16"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"uint32")," types."),(0,i.kt)("p",null,"For example, for structure ",(0,i.kt)("inlineCode",{parentName:"p"},"S"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"struct S {\n  uint32 a;\n  uint128 b;\n  uint64 c;\n}\n")),(0,i.kt)("p",null,"parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"s")," of type ",(0,i.kt)("inlineCode",{parentName:"p"},"S")," would be described like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "components": [\n    {"name":"a","type":"uint32"},\n    {"name":"b","type":"uint128"},\n    {"name":"c","type":"uint64"}\n  ],\n  "name":"s",\n  "type":"tuple"\n}\n')),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Usage"),(0,i.kt)("th",{parentName:"tr",align:null},"Value"),(0,i.kt)("th",{parentName:"tr",align:null},"Examples"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Cell"),(0,i.kt)("td",{parentName:"tr",align:null},"chain of cells with tuple data types encoded consistently",(0,i.kt)("br",null),"(without splitting value between cells)"),(0,i.kt)("td",{parentName:"tr",align:null})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"JSON object"),(0,i.kt)("td",{parentName:"tr",align:null},"dictionary of struct field names with their values"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},'{"a": 1, "b": 2, "c": 3}'))))),(0,i.kt)("h4",{id:"mapkeytypevaluetype"},(0,i.kt)("inlineCode",{parentName:"h4"},"map(<keyType>,<valueType>)")),(0,i.kt)("p",null,"Hashtable mapping keys of ",(0,i.kt)("inlineCode",{parentName:"p"},"keyType")," to values of the ",(0,i.kt)("inlineCode",{parentName:"p"},"valueType"),", e.g., ",(0,i.kt)("inlineCode",{parentName:"p"},"map(int32, address)"),". Key may be any of ",(0,i.kt)("inlineCode",{parentName:"p"},"int<N>/uint<N>")," types with ",(0,i.kt)("inlineCode",{parentName:"p"},"N")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"1023")," or address of std format."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Usage"),(0,i.kt)("th",{parentName:"tr",align:null},"Value"),(0,i.kt)("th",{parentName:"tr",align:null},"Examples"),(0,i.kt)("th",{parentName:"tr",align:null},"Max bit size"),(0,i.kt)("th",{parentName:"tr",align:null},"Max ref size"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Cell"),(0,i.kt)("td",{parentName:"tr",align:null},"1 bit (",(0,i.kt)("inlineCode",{parentName:"td"},"0")," - for empty mapping, otherwise ",(0,i.kt)("inlineCode",{parentName:"td"},"1"),") and ref to the cell with dictionary"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"1 bit"),(0,i.kt)("td",{parentName:"tr",align:null},"1 ref")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"JSON object"),(0,i.kt)("td",{parentName:"tr",align:null},"dictionary of keys and values"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},'{"0x1":"0x2"}'),", ",(0,i.kt)("inlineCode",{parentName:"td"},'{"2":"3","3":"55"}')),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})))),(0,i.kt)("p",null,'There are some specifics when working with "big" structures as values in mappings. Read ',(0,i.kt)("a",{parentName:"p",href:"#big-structures-as-values-in-mappings-and-arrays"},"below")," how to implement them correctly."),(0,i.kt)("h4",{id:"cell"},(0,i.kt)("inlineCode",{parentName:"h4"},"cell")),(0,i.kt)("p",null,"TVM Cell type."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Usage"),(0,i.kt)("th",{parentName:"tr",align:null},"Value"),(0,i.kt)("th",{parentName:"tr",align:null},"Examples"),(0,i.kt)("th",{parentName:"tr",align:null},"Max bit size"),(0,i.kt)("th",{parentName:"tr",align:null},"Max ref size"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Cell"),(0,i.kt)("td",{parentName:"tr",align:null},"stored in a ref"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"0 bit"),(0,i.kt)("td",{parentName:"tr",align:null},"1 ref")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"JSON object"),(0,i.kt)("td",{parentName:"tr",align:null},"cell serialized into boc and encoded in base64"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},'"te6ccgEBAQEAEgAAH/////////////////////g="')),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})))),(0,i.kt)("h4",{id:"address"},(0,i.kt)("inlineCode",{parentName:"h4"},"address")),(0,i.kt)("p",null,"Contract address in type ",(0,i.kt)("inlineCode",{parentName:"p"},"address"),", can be any of the ",(0,i.kt)("a",{parentName:"p",href:"/arch/accounts#account-address"},"existing variants")," (although not all may be supported by the compilator you are using)."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Important notes:")),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"All hexadecimal values represented in ",(0,i.kt)("strong",{parentName:"li"},"lower case"),"."),(0,i.kt)("li",{parentName:"ol"},"Bitstrings are represented in hexadecimal variable length form with ",(0,i.kt)("inlineCode",{parentName:"li"},"_")," suffix if length is not multiple of 4. When length is multiple of 4 bitstring is always encoded ",(0,i.kt)("strong",{parentName:"li"},"without")," ",(0,i.kt)("inlineCode",{parentName:"li"},"_")," suffix.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Format")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},'"" // None\n":A...A" // External\n"[N..N:]W:A...A" // Internal\n')),(0,i.kt)("p",null,"where:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"W")," is a decimal signed representation for workchain_id."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"A...A")," is a string representation of bitstring (see important nodes above);"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"N...N")," is a string representation of bitstring with anycast rewrite prefix.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Serialization")),(0,i.kt)("p",null,"Internal addresses are serialised as:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"std")," when workchain id is 8-bit and address is 256-bit"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"var")," otherwise.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Size")),(0,i.kt)("p",null,"Maximum size allocated for address is 591 bits: see ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/ton-blockchain/ton/blob/master/crypto/block/block.tlb#L107"},"https://github.com/ton-blockchain/ton/blob/master/crypto/block/block.tlb#L107")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-TL-B"},"anycast_info$_ depth:(#<= 30) { depth >= 1 }\n   rewrite_pfx:(bits depth) = Anycast;\n\naddr_var$11 anycast:(Maybe Anycast) addr_len:(## 9) \n   workchain_id:int32 address:(bits addr_len) = MsgAddressInt;\n\n2 +          // 11 \n1 + 5 + 30 + // anycast\n9 +          // addr_len\n32 +         // workchain_id:int32\n512          // address\n = \n591\n")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Usage"),(0,i.kt)("th",{parentName:"tr",align:null},"Value"),(0,i.kt)("th",{parentName:"tr",align:null},"Examples"),(0,i.kt)("th",{parentName:"tr",align:null},"Max bit size"),(0,i.kt)("th",{parentName:"tr",align:null},"Max ref size"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Cell"),(0,i.kt)("td",{parentName:"tr",align:null},"2 bits of address type, 1 bit of anycast, wid - 8 bit signed integer and address value - 256 bit unsigned integer"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"591 bits"),(0,i.kt)("td",{parentName:"tr",align:null},"0 refs")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"JSON object"),(0,i.kt)("td",{parentName:"tr",align:null},"string"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},'"123:000000000000000000000000000000 000000000000000000000000000001e0f3"')),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})))),(0,i.kt)("h4",{id:"bytes"},(0,i.kt)("inlineCode",{parentName:"h4"},"bytes")),(0,i.kt)("p",null,"An array of ",(0,i.kt)("inlineCode",{parentName:"p"},"uint8")," type elements. The array is put into a separate cell. In the case of array overflow, the maximum cell-data size it's split into multiple sequential cells."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note"),": contract stores this type as-is without parsing. For high-speed decoding, cut reference from body slice as ",(0,i.kt)("inlineCode",{parentName:"p"},"LDREF"),". This type is helpful if some raw data must be stored in the contract without write or random access to elements."),(0,i.kt)("p",null,"Analog of ",(0,i.kt)("inlineCode",{parentName:"p"},"bytes")," in Solidity. In C lang can be used as ",(0,i.kt)("inlineCode",{parentName:"p"},"void*"),"."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Usage"),(0,i.kt)("th",{parentName:"tr",align:null},"Value"),(0,i.kt)("th",{parentName:"tr",align:null},"Examples"),(0,i.kt)("th",{parentName:"tr",align:null},"Max bit size"),(0,i.kt)("th",{parentName:"tr",align:null},"Max ref size"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Cell"),(0,i.kt)("td",{parentName:"tr",align:null},"cell with data stored in a ref"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"0 bit"),(0,i.kt)("td",{parentName:"tr",align:null},"1 ref")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"JSON object"),(0,i.kt)("td",{parentName:"tr",align:null},"binary daya represented as hex string"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},'"313233"')),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})))),(0,i.kt)("h4",{id:"fixedbytesn"},(0,i.kt)("inlineCode",{parentName:"h4"},"fixedbytes<N>")),(0,i.kt)("p",null,"Where N is a decimal byte length from 1 to 32. It is denoted in abi as ",(0,i.kt)("inlineCode",{parentName:"p"},"uint<M>"),",\nwhere ",(0,i.kt)("inlineCode",{parentName:"p"},"M")," is a bit length and ",(0,i.kt)("inlineCode",{parentName:"p"},"M = 8 * N"),".\nProcessed like ",(0,i.kt)("inlineCode",{parentName:"p"},"int<N>"),"."),(0,i.kt)("h4",{id:"string"},(0,i.kt)("inlineCode",{parentName:"h4"},"string")),(0,i.kt)("p",null,"UTF-8 String data. Encoded like ",(0,i.kt)("inlineCode",{parentName:"p"},"bytes"),". In JSON is represented as a sting."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Usage"),(0,i.kt)("th",{parentName:"tr",align:null},"Value"),(0,i.kt)("th",{parentName:"tr",align:null},"Examples"),(0,i.kt)("th",{parentName:"tr",align:null},"Max bit size"),(0,i.kt)("th",{parentName:"tr",align:null},"Max ref size"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Cell"),(0,i.kt)("td",{parentName:"tr",align:null},"cell with data stored in a ref"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"0 bit"),(0,i.kt)("td",{parentName:"tr",align:null},"1 ref")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"JSON object"),(0,i.kt)("td",{parentName:"tr",align:null},"string data"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},'"hello"')),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})))),(0,i.kt)("h4",{id:"optionalinnertype"},(0,i.kt)("inlineCode",{parentName:"h4"},"optional(innerType)")),(0,i.kt)("p",null,"Value of optional type ",(0,i.kt)("inlineCode",{parentName:"p"},"optional(innerType)")," can store a value of ",(0,i.kt)("inlineCode",{parentName:"p"},"innerType")," or be empty."),(0,i.kt)("p",null,"Example: ",(0,i.kt)("inlineCode",{parentName:"p"},"optional(string)"),"."),(0,i.kt)("p",null,"The optional type is a  ",(0,i.kt)("inlineCode",{parentName:"p"},"large")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"maxBitSize(InnerType) + 1 > 1023 || maxRefSize(InnerType) >= 4"),"."),(0,i.kt)("p",null,"Large optional values are always stored as a reference. The optional bit itself is stored on the main branch."),(0,i.kt)("p",null,"Small optional values are stored in the same cell with the optional bit."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Usage"),(0,i.kt)("th",{parentName:"tr",align:null},"Value"),(0,i.kt)("th",{parentName:"tr",align:null},"Examples"),(0,i.kt)("th",{parentName:"tr",align:null},"Max bit size"),(0,i.kt)("th",{parentName:"tr",align:null},"Max ref size"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Cell"),(0,i.kt)("td",{parentName:"tr",align:null},"1 bit flag (",(0,i.kt)("inlineCode",{parentName:"td"},"1")," - value is stored, otherwise ",(0,i.kt)("inlineCode",{parentName:"td"},"0"),") and the value itself (according to ",(0,i.kt)("inlineCode",{parentName:"td"},"innerType"),") if it presents"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"1 bit if ",(0,i.kt)("inlineCode",{parentName:"td"},"optional")," is large, ",(0,i.kt)("inlineCode",{parentName:"td"},"1 bit + maxBitQty(T), maxRefQty(T)")," otherwise"),(0,i.kt)("td",{parentName:"tr",align:null},"1 ref if ",(0,i.kt)("inlineCode",{parentName:"td"},"optional")," is large, 0 refs otherwise")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"JSON object"),(0,i.kt)("td",{parentName:"tr",align:null},"according to ",(0,i.kt)("inlineCode",{parentName:"td"},"innerType")," or ",(0,i.kt)("inlineCode",{parentName:"td"},"null")," if it is empty"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},'"hello"')),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})))),(0,i.kt)("h4",{id:"itemtype"},(0,i.kt)("inlineCode",{parentName:"h4"},"itemType[]")),(0,i.kt)("p",null,"Array of the ",(0,i.kt)("inlineCode",{parentName:"p"},"itemType")," values. Example: ",(0,i.kt)("inlineCode",{parentName:"p"},"uint256[]")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Usage"),(0,i.kt)("th",{parentName:"tr",align:null},"Value"),(0,i.kt)("th",{parentName:"tr",align:null},"Examples"),(0,i.kt)("th",{parentName:"tr",align:null},"Max bit size"),(0,i.kt)("th",{parentName:"tr",align:null},"Max ref size"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Cell"),(0,i.kt)("td",{parentName:"tr",align:null},"32 unsigned bit length of the array, 1 bit flag (",(0,i.kt)("inlineCode",{parentName:"td"},"0")," if array is empty, otherwise ",(0,i.kt)("inlineCode",{parentName:"td"},"1"),") and dictionary of keys and values where key is 32 unsigned bit index and value is ",(0,i.kt)("inlineCode",{parentName:"td"},"itemType")),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"33 bit"),(0,i.kt)("td",{parentName:"tr",align:null},"1 ref")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"JSON object"),(0,i.kt)("td",{parentName:"tr",align:null},"list of ",(0,i.kt)("inlineCode",{parentName:"td"},"itemType")," values in ",(0,i.kt)("inlineCode",{parentName:"td"},"[]")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"[1, 2, 3]"),", ",(0,i.kt)("inlineCode",{parentName:"td"},'["hello", "world"]')),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})))),(0,i.kt)("p",null,'There are some specifics when working with "big" structures as values in arrays. Read ',(0,i.kt)("a",{parentName:"p",href:"#big-structures-as-values-in-mappings-and-arrays"},"below")," how to implement them correctly."),(0,i.kt)("h3",{id:"big-structures-as-values-in-mappings-and-arrays"},'"Big" structures as values in mappings and arrays'),(0,i.kt)("p",null,'When working with "big" structures in mappings and arrays data may be written in two possible ways - either into cell or into reference, depending on the size:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"if (12 + len(key) + maxValueBitLength <= 1023) then write data into cell\n\nelse write data to reference.\n\n12 = 2 + 10 \u2265 2 + log2(keyLength).\n")),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/ton-blockchain/ton/blob/master/crypto/block/block.tlb#L30"},"https://github.com/ton-blockchain/ton/blob/master/crypto/block/block.tlb#L30")),(0,i.kt)("h2",{id:"reference"},"Reference"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/tonlabs/ever-abi/tree/master/docs"},"ABI changelog specifications")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/tonlabs/ever-abi"},"ABI implementation")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/broxus/everscale-web-tools/tree/master/abi-parser"},"ABI parser")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://ever.bytie.moe/serializer"},"ABI serializer"))))}u.isMDXComponent=!0}}]);
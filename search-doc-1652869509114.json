[{"title":"Basics of Everscale Blockchain","type":0,"sectionRef":"#","url":"arch/basics","content":"","keywords":""},{"title":"Blockchain structure​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#blockchain-structure","content":"At the moment blockchain consists of 2 workchains. One of them (-1), so-called masterchain, is needed for service contracts and validator contracts, another one (0) is for simple users. In the future, it is possible to add more simple workchains (1, 2, etc) to the blockchain. In turn, workchain is splitted into shards (so-called shardchains). When the load is low there are 16 shards, when it increases shards split and when decreases they merge. Blockchain is validated by validators. Part of them validate masterchain, others are splitted into groups and validate shardchains. Periodically global set of validators changes with elections. Within one election cycle shardchain validators rotate as well. "},{"title":"Account (contract)​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#account-contract","content":"Account (contract) is identified by its full address consisting of workchain and ID. Full information about Account is stored in its state. Account can have some balance, a place for its code, place for its data and many other fields. It can have 1 owner, many owners and no owners at all. Account ID is calculated during deploy from its initial code and data. "},{"title":"About deploy​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#about-deploy","content":"Deploy — placing code of the account into blockchain. You can not deploy account's code if its balance is empty because deploy is paid out of that money. This is why any deploy operation must begin with sponsoring the account with some tokens. Because account's ID is unequivocally calculated from code and data, this calculation can be done before actual deploy. "},{"title":"About address​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#about-address","content":"Address is calculated from initial contract's code and data, that is attached to the deploy message. When contract performs SETCODE operation, its address does not change. To calculate the contract address, you need to know its code and its initial data (public key of the owner is also stored in data). "},{"title":"About money transfer​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#about-money-transfer","content":"Money can be transferred from one account to another only by execution of the account's code. Do not transfer money to the addresses where you can not deploy code because they will stay there forever. "},{"title":"About commissions​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#about-commissions","content":"There are several types of fees for operations with contracts. For example, commission for storage, for execution, for message delivery. Read more about them here Fee calculation details. "},{"title":"About get methods​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#about-get-methods","content":"Get method is a method of the contract which doesn't change contract state, thus can be executed locally on the client's machine for free. What shard my account is in right now? Account shard is defined by the first bits of its address and the current list of shards. Encode hex shard prefix to binary format, discard the most right 1. You just got the shard mask. Put this mask on top of account address, if the bits are equal — the account is in this shard. Account can change its shard depending on the load of the network. So before calculating account's shard check the current list of shards. "},{"title":"Message​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#message","content":"All interactions in Free TON are performed via messages. External inbound messages help deploy and call contracts from outside. Internal messages allow contracts to communicate with each other. External outbound messages are the events the contracts produce for the outside world. Use them to implement some off-chain logic — subscribe for these messages and perform some off-chain actions whenever you receive them. For example, simple value transfer can be initiated with an external inbound message (by a human or some service) or with internal message from another contract. This message will produce a transaction (read below) and an internal message with value transfer. "},{"title":"Transaction​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#transaction","content":"Transaction is the result of contract execution. In general transaction is generated with one incoming message (external or internal) and can generate several outcoming messages (external or internal) as a result. Transaction can be successful or aborted. For example, simple value transfer consists of 2 transactions — Sender's transaction which generated an internal message with value transfer, and Recipient's transaction where it received the message with value and updated its balance. "},{"title":"BOC (Bag of cells)​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#boc-bag-of-cells","content":"Is a universal format for data packaging in Free TON. Every object — account, transaction, message, block are stored in blockchain database as bocs. By the way, boc of the block includes bocs of all messages and transactions that were executed in this block inside of it. "},{"title":"TVM​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#tvm","content":"Ton Virtual Machine. Turing complete virtual machine for contract code execution. It works with data represented in boc format. TVM itself does not calculate any commissions and can be used on client side for running get methods of the contracts. TVM is used for debot engine execution on client side as well. Also, TVM is used on validators together with higher level protocols, such as Transaction Executor, to additionally calculate commissions and perform other necessary checks "},{"title":"Transaction Executor​","type":1,"pageTitle":"Basics of Everscale Blockchain","url":"arch/basics#transaction-executor","content":"Take results of TVM, calculate fees, checks balance and other things. Used by validators to validate blocks. Can also be used on the client side to debug contract execution. "},{"title":"Accounts","type":0,"sectionRef":"#","url":"arch/accounts","content":"","keywords":""},{"title":"Account Structure Definition​","type":1,"pageTitle":"Accounts","url":"arch/accounts#account-structure-definition","content":"The account structure is defined as follows: struct AccountStuff { addr: MsgAddressInt, storage_stat: StorageInfo, storage: AccountStorage, } type Account = Option&lt;AccountStuff&gt;;  AccountStuff structure fields​ Field\tDescriptionaddr\tAccount address storage_stat\tAccount storage use statistics storage\tAccount smart-contract storage "},{"title":"Account Address​","type":1,"pageTitle":"Accounts","url":"arch/accounts#account-address","content":"The location of an account in Everscale blockchain is represented as a two-value structure: the workchain number and the account identifier. This structure is called an account address. Hereinafter, we just call it address for greater convenience. Addresses are defined as follows: pub enum MsgAddressInt { AddrStd(MsgAddrStd), AddrVar(MsgAddrVar), } pub struct MsgAddrStd { pub anycast: Option&lt;AnycastInfo&gt;, pub workchain_id: i8, pub address: AccountId, } pub type AccountId = SliceData;  The address may be encoded by one of the two structures: MsgAddrStd or MsgAddrVar. The latter is used to locate accounts in huge blockchains, when the standard 8-bit workchain_id is not enough, and not supported currently. Type SliceData denotes a binary blob encoded in a tree data structure.Type i8 is an 8-bit signed integer. MsgAddrStd structure fields​ Field\tDescriptionanycast\tMulti-shard contracts routing information workchain_id\tWorkchain identifier address\tAccount identifier within the workchain caution Anycast-addresses are planned to be removed shortly. "},{"title":"Account Storage​","type":1,"pageTitle":"Accounts","url":"arch/accounts#account-storage","content":"Any account in the Everscale blockchain is being charged for occupying space, on a regular basis. The fee depends on the size of data being stored, the current prices and when the last charge took place. In some circumstances, an account may also have a debt, called due payment. Most of this information is stored in the StorageInfo structure. pub struct StorageInfo { used: StorageUsed, last_paid: u32, due_payment: Option&lt;Grams&gt;, } pub struct StorageUsed { cells: VarUInteger7, bits: VarUInteger7, public_cells: VarUInteger7, }  StorageInfo structure fields​ Field\tDescriptionused\tBlockchain storage use statistics last_paid\tTime of the latest payment, in Unix Epoch due_payment\tDebt of the account Type Grams denotes a set of natural numbers {0,...,2256}\\{0, ..., 2^{256}\\}{0,...,2256}, equipped with ⊕\\oplus⊕ and ⊖\\ominus⊖ operators, such that: a⊕b=(a+b) mod 2256a \\oplus b = (a + b) \\,\\, \\boldsymbol{mod} \\,\\, 2^{256}a⊕b=(a+b)mod2256 a⊖b=max(a−b,0)a \\ominus b = \\boldsymbol{max}(a - b, 0)a⊖b=max(a−b,0) Here +++ and −-− operators are standard addition and subtraction operators in a set of integers Z\\mathbb{Z}Z. Amount of storage used by the account is encoded with StorageUsed struct. StorageUsed structure fields​ Field\tDescriptioncells\tNumber of cells occupied by the account bits\tNumber of bits occupied by the account public_cells\tField is not used To store the data in a tree-like form, it is encoded as a series of interlinked cells. This data structure also consume some space and it is accounted in the cells field. The bits field refer to data size being encoded in the cells. "},{"title":"Account Data​","type":1,"pageTitle":"Accounts","url":"arch/accounts#account-data","content":"The full account record is represented by several nested data structures: Account storageAccount stateSmart-contract storage called StateInit "},{"title":"Account Storage structure​","type":1,"pageTitle":"Accounts","url":"arch/accounts#account-storage-structure","content":"The most outer record is the account storage. It contains the account balance and the account state. The account state may contain the smart-contract code and data, described by the structure called StateInit. pub struct AccountStorage { last_trans_lt: u64, balance: CurrencyCollection, state: AccountState, }  AccountStorage fields​ Field\tDescriptionlast_trans_lt\tLast transaction logical time balance\tAmount of cryptocurrency tokens available for the account state\tCurrent account state "},{"title":"Account State​","type":1,"pageTitle":"Accounts","url":"arch/accounts#account-state","content":"The account state defines the mode of operation for the account, during the message being executed for that account. The Transaction Executor logic vary greatly depending of what is the current account state is. The account state may have additional data fields. See the enumeration below. enum AccountState { AccountUninit, AccountActive{ init_code_hash: Option&lt;UInt256&gt;, state_init: StateInit, }, AccountFrozen{ init_code_hash: Option&lt;UInt256&gt;, state_init_hash: UInt256, }, }  The life cycle of an account is depicted on Fig. Let us clarify the fields of enumeration items. For the AccountActive, the value state_init defines the byte-code and data of the associated smart-contract. The field init_code_hash defines the hash of the field state_init.code that was used at the moment of the account initialization, or at the moment of the account freeze. In Everscale, it is possible to change the smart-contract's code on the fly using the SetCode action. However, the value init_code_hash stays unaffected. The same holds for AccountFrozen. The value of state_init_hash defines the hash of the smart-contract state_init.code at the moment of a freeze. "},{"title":"Smart-Contract Storage (StateInit)​","type":1,"pageTitle":"Accounts","url":"arch/accounts#smart-contract-storage-stateinit","content":"The byte-code and data of a contract are stored within a structure called StateInit. Its name may seem quite confusing. It could have been named just State. The Init part comes from the fact that this structure is also used for the initialization of an account when it is uninitialized. pub struct StateInit { pub split_depth: Option&lt;Number5&gt;, pub special: Option&lt;TickTock&gt;, pub code: Option&lt;Cell&gt;, pub data: Option&lt;Cell&gt;, pub library: StateInitLib, }  split_depth field was initially devoted to large multi-shard smart-contracts, but currently it is not used. special fields signals the fact that the smart-contract is related to the blockchain system functioning. This is related to very small amount or contracts residing in the Masterchain, i.e. Elector, Config, Giver, etc. There is a special logic of executing messages destined to those contracts. code and data fields encodes the current byte-code and data of a contract. Here, data denote values of contract's variables. library used to encode the code libraries the contract may refer to from its code. This mechanism is deprecated. "},{"title":"Contract composition","type":0,"sectionRef":"#","url":"arch/contract-composition","content":"Contract composition","keywords":""},{"title":"What is Ever OS","type":0,"sectionRef":"#","url":"arch/ever-os","content":"","keywords":""},{"title":"Why we call it Ever OS?​","type":1,"pageTitle":"What is Ever OS","url":"arch/ever-os#why-we-call-it-ever-os","content":"A modern blockchain like Everscale is not just an immutable ledger. Bitcoin and other earlier blockchains were mostly ledgers, yet even Bitcoin supports a non-Turing complete script that provides some transaction execution instructions. In fact, the Bitcoin script is a Forth-like instruction set, which makes it somewhat similar in origin to TON Virtual Machine assembly language, but more on that later. Most blockchains after Ethereum are, in large part, distributed computing engines that execute and verify Turing-complete programs called smart contracts. In simpler words they are a special breed of network processors working in orchestration (called &quot;consensus&quot;) to perform common operations and in that way verify correctness of their execution. In Everscale this paradigm is taken to the extreme. The immutable ledger is quite a small part of Everscale. Of course it is an immutable ledger and a chain of blocks — that is how the data is written and transmitted from one network processor to another — yet there are at least two aspects which make Everscale uniquely more so a computing engine than a simple ledger. Almost everything in Everscale is smart contracts. Every account in Everscale must be associated with a smart contract code (or initialized) in order for a user to be able to perform any operation with it. Smart contracts are Everscale Assembly programs executed in the Everscale Virtual machine much like any assembly code is executed by hardware or by a virtual processor in a regular computer. Between a regular computer and a user (which may be a developer who would like to write programs for that computer or a regular user who would like to execute and interact with these programs) there is something called an operating system. That is how GNU defines operating system: Linux is an operating system: a series of programs that let you interact with your computer and run other programs. An operating system consists of various fundamental programs which are needed by your computer so that it can communicate and receive instructions from users; read and write data to hard disks, tapes, and printers; control the use of memory; and run other software. It is quite obvious why computers need an operating system. Before operating systems existed, interaction with computers looked something like this:  I still think the &quot;world computer&quot; is a good analogy. The idea that you have a shared computing environment that anybody can build and run stuff on is still a totally legitimate and valuable thing to emphasize. — Vitalik Buterin Any way you look at it, blockchain is quite a good candidate to be called a decentralized computer. At least some of the blockchains are. Everscale most definitely is. And just as with any computer, a blockchain needs an intermediate layer (or layers) that manages its resources and provides services to the programs the user runs or interacts with. Of course blockchain, in terms of architecture, cannot perhaps be compared directly 1:1 with a regular PC. But in logical terms, whenever we think about a software stack needed to enable interaction with a user — to call it an operating system is quite compelling. Let's run some arguments. For reasons of practicality we will not talk only about Free Everscale blockchain, but most of the arguments could be applied to some other modern blockchains as well. A classical operating system is expected to provide: Memory Management Processor Managing Device Managing File handling Security Handling System performance control Job accounting and handling Error detecting and handling Synchronization with other software and users Let's compare with Ever OS and the services it provides: "},{"title":"Memory Management​","type":1,"pageTitle":"What is Ever OS","url":"arch/ever-os#memory-management","content":"Individual blocks containing data are created, validated and finalized under governance by the consensus blockchain software. Nodes participating in processing blocks are chosen dynamically without requiring interference from the blockchain user. "},{"title":"Processor Managing​","type":1,"pageTitle":"What is Ever OS","url":"arch/ever-os#processor-managing","content":"Smart contracts are blockchain programs that are executed by the Everscale Virtual Machine across many network devices and locally (if we consider how a user is accessing the blockchain). A user does not think about how a smart contract is executed. Following some deployment instructions, a developer can deploy and run smart contracts without thinking about which virtual machine it is executed on or how this execution has been synchronized across the network and verified. In this respect it is safe to say that Ever OS provides processor management capabilities. "},{"title":"Device Managing​","type":1,"pageTitle":"What is Ever OS","url":"arch/ever-os#device-managing","content":"Blockchain software, including full node implementation, allows users to control, handle, configure and diagnose individual blockchain nodes. "},{"title":"File handling​","type":1,"pageTitle":"What is Ever OS","url":"arch/ever-os#file-handling","content":"Via a smart contract users can store and access persistent data on the blockchain. "},{"title":"Security Handling​","type":1,"pageTitle":"What is Ever OS","url":"arch/ever-os#security-handling","content":"Access to restricted areas of the system is authorized through extensive use of specialized smart contracts. Cases of unauthorized access attempts are recorded and monitored using security smart contracts. "},{"title":"System performance control​","type":1,"pageTitle":"What is Ever OS","url":"arch/ever-os#system-performance-control","content":"System-wide smart contracts deployed to the blockchain are in charge of monitoring system performance and receiving events which pinpoint various cases of system malfunction. "},{"title":"Job accounting and handling​","type":1,"pageTitle":"What is Ever OS","url":"arch/ever-os#job-accounting-and-handling","content":"Smart contracts execution inside the blockchain is governed by specialized software modules. Details of the execution are available for view and analysis through the blockchain explorer. "},{"title":"Error detecting and handling​","type":1,"pageTitle":"What is Ever OS","url":"arch/ever-os#error-detecting-and-handling","content":"Cases of misbehavior and inconsistency of smart contracts and blockchain software are monitored, collected and stored for subsequent analysis by specialized smart contracts. "},{"title":"Synchronization with other software and users​","type":1,"pageTitle":"What is Ever OS","url":"arch/ever-os#synchronization-with-other-software-and-users","content":"System smart contracts form an interconnected decentralized network by exchanging addresses, interfaces and specifications with each other to provide users and other smart contracts with the information required to properly utilize their functionality. "},{"title":"Fee calculation","type":0,"sectionRef":"#","url":"arch/fee-calculation","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Fee calculation","url":"arch/fee-calculation#introduction","content":"Transaction fees consist of a few types of different fees connected to the execution of a single transaction. Transactions itself are complex processes, and fees are paid relative to different stages of executing them. In this document, we explain how the fees are calculated. We shall define transaction_fee as a sum of all fees for a single transaction. transaction_fee = inbound_external_message_fee + storage_fees + gas_fees + total_action_fees + outbound_internal_messages_fee  Where: inbound_external_message_fee — is deducted, if an inbound external message is imported in the transaction. storage_fees — storage costs since the moment of the last transaction. gas_fees — include all gas fees associated with the transaction. You can find more info in the Gas calculation basics section. total_action_fees — fees for performing send message actions. outbound_internal_messages_fee — is calculated as a sum of fees for all outbound internal messages generated by the transaction. Depending on the nature of the transaction, all of these except storage fees may not be applicable. Below we examine these types of fees in detail. Note: Block creation fee is not to be confused with the fees discussed in this document. Block creation fee is the new coins minted by the elector contract and distributed among validators as reward for creating blocks. It is not part of transaction fees. "},{"title":"Storage fees​","type":1,"pageTitle":"Fee calculation","url":"arch/fee-calculation#storage-fees","content":"Every transaction in TON has a storage phase that implies a certain storage fee charged on an account balance. This fee is charged for the period between transactions and is calculated according to the following formula: storage_fees = CEIL( ( account.bits * global_bit_price + account.cells * global_cell_price ) * period / 2 ^ 16 )  Where: account.bits and account.cells — stand for a number of bits and cells in the Account structure represented as tree of cells (including code and data). global_bit_price — is a global configuration parameter (p18 for both masterchain and workchains), price for storing one bit. global_cell_price — another global configuration parameter (p18 for both masterchain and workchains), price for storing one cell. period — number of seconds since previous storage fee payment. Note: While account.bits are generally easy to estimate, the account.cells value can vary greatly for different types of data. A cell can contain no more than 1023 bits and 4 references to other cells. Contract code and numerical variables tend to be packed into cells effectively, resulting in mostly full cells, and thus a minimal number of cells needed to store the data. More complex data structures can be packed into cells less efficiently, taking up more cells to store the same amount of data. Example: Let's calculate a minimal fee for storing 1KB of data for the duration of one day on a workchain: global_bit_price = 1 global_cell_price = 500 period = 86400 seconds account.bits = 8192 The minimal account.cells value for 8192 bits of data is 9 (rounding 8192/1023 up to the nearest integer). Thus the minimum storage fee would be calculated as follows: storage_fees = CEIL( ( 8192 * 1 + 9 * 500 ) * 86400 / 65536 ) = 16733 nanotokens = 0.000016733 tokens  Real storage fees for 1KB account can be higher, depending on the specific features of the contract. If the account balance is less than the due storage fee, the account is frozen and its balance is subtracted from storage fee and reduced to zero. Remaining storage fee is stored in account as debt. Note: Current global configuration can be always reviewed on [ever.live]( https:/ /ever.live/) in the master config section of the latest key block details (example) FIXME broken link. It can only be changed by a vote of validators. "},{"title":"Message fees​","type":1,"pageTitle":"Fee calculation","url":"arch/fee-calculation#message-fees","content":"Every message is subject to a forwarding fee, which is calculated according to the following formula: msg_fwd_fee = ( lump_price + CEIL( ( bit_price * msg.bits + cell_price * msg.cells ) / 2 ^ 16 ) )  msg.bits and msg.cells are calculated from message represented as a tree of cells. Root cell is not counted. lump_price, bit_price, cell_price are contained in global config parameters p24 and p25, and can and can only be changed by a vote of validators. Note: Like in storage fees, msg.bits are generally easy to estimate, while the msg.cells value can vary for different types of messages. Example: Let's calculate a minimal forward fee for sending a 1KB message on a workchain: lump_price = 10000000 bit_price = 655360000 cell_price = 65536000000 To calculate msg.bits we subtract the root cell bits from the total message bits. For this example we'll assume that the root cell is filled completely (usually this is not the case, and the subtracted value is smaller, which results in a higher fee): msg.bits = 8192 - 1023 = 7169  To calculate msg.cells we subtract the root cell from the total umber of cells. The minimal number of cells in a 1 KB message is 9 (rounding 8192/1023 up to the nearest integer). Thus msg.cells is calculated as follows: msg.bits = 9 - 1 = 8  The minimum forward fee for a 1KB message would be calculated as follows: msg_fwd_fee = ( 10000000 + CEIL( ( 655360000 * 7169 + 65536000000 * 8 ) / 65536 ) ) = 89690000 nanotokens = 0.08969 tokens  Real forward fees for 1 KB messages may be higher, depending on the type and contents of the message. Note: Current global configuration can be always reviewed on ever.live in the master config section of the latest key block details (example) FIXME broken link. "},{"title":"Outbound messages​","type":1,"pageTitle":"Fee calculation","url":"arch/fee-calculation#outbound-messages","content":"outbound_internal_messages_fee is calculated as a sum of outbound internal message fees for every message generated as result of transaction execution: outbound_internal_messages_fee = SUM( out_int_msg.header.fwd_fee + out_int_msg.header.ihr_fee )  Where out_int_msg.header.fwd_fee is a part of the standard forward fee for the outbound internal message. out_int_msg.header.ihr_fee is currently disabled. Routing​ The forward fee for outbound internal message is split into int_msg_mine_fee and int_msg_remain_fee: msg_forward_fee = int_msg_mine_fee + int_msg_remain_fee  Where: int_msg_mine_fee = msg_forward_fee * first_frac / 2 ^ 16  first_frac — is contained in global config parameters p24 and p25, and determines the fraction of the fee, that the current set of validators receive. Note: Current global configuration can be always reviewed on ever.live in the master config section of the latest key block details (example) FIXME broken link. int_msg_mine_fee then becomes part of transaction action fees (see below). The remaining int_msg_remain_fee is placed in the header of outbound internal message (becoming out_int_msg.header.fwd_fee) and will go to validators who will process the message. If, while being forwarded to the destination address, the message passes through additional validator sets (i.e. if the validator set changes more than once while the message is being forwarded), a part of out_int_msg.header.fwd_fee is payed to the relevant validator set every time and the remaining fee in the message header is reduced by this amount: intermediate_fee = out_int_msg.header.fwd_fee * next_frac / 2 ^ 16  next_frac — is contained in global config parameters p24 and p25, and determines the fraction of the remaining forward fee, that intermediary validators receive. Note: Current global configuration can be always reviewed on ever.live in the master config section of the latest key block details (example) FIXME broken link. Note: Length of route does not affect the initial calculation of the forward fee. The fee is simply split between all involved validators according to global config parameters. Note: If an exception is thrown, and a bounce message is generated, it is subject to fees, just like a single regular outbound message. "},{"title":"Inbound external messages​","type":1,"pageTitle":"Fee calculation","url":"arch/fee-calculation#inbound-external-messages","content":"Whenever an inbound external message needs to be imported for transaction execution, the for this action fee is calculated according to the standard forwarding fee formula, and paid to the current validators. "},{"title":"Action fees​","type":1,"pageTitle":"Fee calculation","url":"arch/fee-calculation#action-fees","content":"Action fees pay for performing 'send message' actions. They consist of all fees for external outbound messages, and the first fraction of internal outbound message fees. They are calculated as follows: total_action_fees = total_out_ext_msg_fwd_fee + total_int_msg_mine_fee  where: total_out_ext_msg_fwd_fee — sum of implicit forward fee for all generated outbound external messages.total_int_msg_mine_fee — sum of 'mine' parts of message forward fees for outbound internal messages.total_fwd_fees — is a separate way to calculate total forwarding fees. total_fwd_fees = total_action_fees + SUM( int_msg_remain_fee + out_int_msg.header.ihr_fee )  out_int_msg.header.ihr_fee — this fee is currently zero. The action fee might be absent if no actions are performed during the transaction. "},{"title":"Gas fees​","type":1,"pageTitle":"Fee calculation","url":"arch/fee-calculation#gas-fees","content":"trans.gas_fees include all gas fees associated with the transaction. You can find more information in the Gas calculation basics section. Same as action fees, gas fees are not always present. They can be skipped if the TVM compute phase is not initialized in a transaction. "},{"title":"Managing gas","type":0,"sectionRef":"#","url":"arch/managing-gas","content":"","keywords":""},{"title":"Gas calculation basics​","type":1,"pageTitle":"Managing gas","url":"arch/managing-gas#gas-calculation-basics","content":""},{"title":"Specification Overview​","type":1,"pageTitle":"Managing gas","url":"arch/managing-gas#specification-overview","content":"The entire state of TVM consists of the five components: StackControl registersCurrent continuationCurrent codepageGas limits Collectively these are called SCCCG. Check out section 1.4 of the TVM specification. The Gas component limits gas usage and сontains four signed 64-bit integers: the remaining gas: grthe current gas limit: glthe maximal gas limit: gmthe gas credit: gc The following is always true: 0≤gl≤gm,gc≥0,andgr≤gl+gc0 ≤ gl ≤ gm, gc ≥ 0, and gr ≤ gl + gc0≤gl≤gm,gc≥0,andgr≤gl+gc gc is initialized by zero for internal messages, gr is initialized by gl + gc and gradually decreases, as the TVM runs. When gr becomes negative or if contract terminates with gc &gt; 0, an out of gas exception is triggered. "},{"title":"Gas prices​","type":1,"pageTitle":"Managing gas","url":"arch/managing-gas#gas-prices","content":"As stated in A.1 of the TVM specification. According to the original TON, for most primitives gas is calculated according to the following formula: Pb:=10+bPb := 10 + bPb:=10+b where b is the instruction length in bits. The same is true for EverX implementation. For example: the gas required for A0 (ADD) instruction is 10 + 8 = 18 gas, while the gas for A6cc (ADDCONST cc) instruction is 10 + 16 = 26 gas. For some instructions this rule does not apply. TVM specification lists either total gas prices, or prices in addition to the basic Pb for them explicitly. Instruction list with additional information may be obtained in A.2 through A.13 of the TVM specification. Apart from integer constants, the following expressions may appear: The total price of loading cells. Currently it is 100 gas units per cell. Reloading a cell again now costs 25 gas units.The total price of creating new Cells from Builders. Currently it is 500 gas units.Exception throwing. 50 gas units per exception.Exiting the block costs 5 gas units per implicit RET. Jumping to the first link costs 10 gas units - implicit JUMP.Moving to a new continuation with transferring parameters costs gas if there are more then 32 parameters. It costs N-32 gas, where N is the number of parameters.Tuple gas price. 1 gas unit for every tuple element. Note: that the most expensive operations are dictionary read/write operations. Dictionaries are stored in the form of trees of cells, where each cell can only be linked to four others. As result, these trees can grow quite large, depending on the data that needs to be stored. To read data in any cell, all its parent cells need to be read first, at the price of 100 gas per cell, and to write data in a cell, similarly all its parent cells need to be (re)created at the price of 500 gas per cell. "},{"title":"Global gas limits​","type":1,"pageTitle":"Managing gas","url":"arch/managing-gas#global-gas-limits","content":"Global gas limits are values stored in the masterchain configuration contract. Global values are standard and do not change at contract deployment. Only validator consensus can modify them. The values currently used can always be reviewed on ever.live in the latest key block details (example FIXME broken link). p20 config parameter values are used for masterchain and p21 values are used for workchain. "},{"title":"Gas-related TVM primitives​","type":1,"pageTitle":"Managing gas","url":"arch/managing-gas#gas-related-tvm-primitives","content":"These is the list of official TVM primitives used for gas-related operations: F800 — ACCEPT, sets current gas limit gl to its maximal allowed value gm, and resets the gas credit gc to zero, decreasing the value of gr by gc in the process. In other words, the current smart contract agrees to buy some gas to finish the current transaction. This action is required to process external messages, which bring no value (hence no gas) with themselves.F801 — SETGASLIMIT (g – ), sets current gas limit gl to the minimum of g and gm, and resets the gas credit gc to zero. If the gas consumed so far (including the present instruction) exceeds the resulting value of gl, an (unhandled) out of gas exception is thrown before setting new gas limits. Notice that SETGASLIMIT with an argument g ≥ 2 63 − 1 is equivalent to ACCEPT.F802 — BUYGAS (x – ), computes the amount of gas that can be bought for x nanotokens, and sets gl accordingly in the same way as SETGASLIMIT.F804 — GRAMTOGAS (x – g), computes the amount of gas that can be bought for x nanotokens. If x is negative, returns 0. If g exceeds 2 63−1, it is replaced with this value.F805 — GASTOGRAM (g – x), computes the price of g gas in nanotokens.F806–F80F — Reserved for gas-related primitives. These are yet to be released. Note: F802, F804, F805 are not implemented in Telegram TON node. In Evernode, the general gas formula is the same as specified by TON specifications. Overall, Evernode operate in compliance with the specification. For every executed primitive, the amount of gas is added to the virtual machine according to the specification formula. Gas value for every primitive is based on gr. "},{"title":"Gas initialization types​","type":1,"pageTitle":"Managing gas","url":"arch/managing-gas#gas-initialization-types","content":""},{"title":"1. Calling contract from another contract​","type":1,"pageTitle":"Managing gas","url":"arch/managing-gas#1-calling-contract-from-another-contract","content":"An internal message with a balance value is received. In this case, the following formulas are applied to determine limits: gm = MIN(account balance / gas price, global_gas_limit) gl = MIN(message value / gas price, global_gas_limit) gc = 0 gr = gc + gl  By default, gas costs are allocated to the caller contract that triggers the transaction with a message. Accepting is also available for internal contracts. If ACCEPT is not called, gas is taken from the caller contract according to the message value. In other words, the message value defines the current limit. The message value determines the starting TVM gas limit. So, to put it plain, if ACCEPT is not called, the message pays, if ACCEPT is used, additional gas can be bought by the target contract. This approach enables flexible contract design where either total gas is paid by the caller contract (but in this case it has to have enough gas at any moment of time) or the target contract also incurs costs. "},{"title":"2. Offchain contract call​","type":1,"pageTitle":"Managing gas","url":"arch/managing-gas#2-offchain-contract-call","content":"External messages do not carry balance values. In this case, the values are calculated according to the following formulas: gm = MIN(account balance / gas price, global_gas_limit) gl = 0 gc = MIN(gm, global_gas_credit) gr = gc + gl  As external messages have no gas value, gas is credited to execute it. Target contracts have to cover costs by calling Accept to buy gas. If a contract returns an exception before the credit is given, no gas fee applies. As the public code for node has just been released this documentation is likely to be updated. Managing Gas in Solidity Some Theory Anyone can send external message to your contract. When a message arrives, the contract initial gas limit is equal to 10,000 units of credit gas that should be bought later by the ACCEPT TVM primitive. Otherwise when credit gas falls to zero, the TVM throws the out of gas exception. The contract is supposed to spend these 10,000 units of 'free' gas to check the body of an inbound message tp make sure that it is valid and can be processed by contract successfully. The idea of credit gas allowance is that as long as it is beyond zero, any exception thrown by contract prevents all further gas charges. But once the contract accepts a message, all gas consumed by contract is converted to gas fees regardless of whether a transaction is aborted or not. ACCEPT is useful in internal messages too. When another contract sends an internal message to your contract, initial gas limit is equal to an inbound message value divided by the gas_price or global gas limit, if it is smaller. If this value is not enough to finish execution, the contract then can increase its gas limit by calling ACCEPT or SETGASLIMIT primitive. The ACCEPT primitive increases the limit to the value of its balance divided by the gas_price, and the SETGASLIMIT primitive sets the current gas limit to the value popped from the TVM stack (the value cannot be bigger than the gm limit). With the ACCEPT command a contract can choose whether gas for its execution is paid by the caller contract or by the contract itself. Implementation In EverX the ACCEPT primitive is implemented in Solidity as a private function called by public functions. Find below actual usage examples. All can be compiled using EverX Solidity compiler. Accept gas inside function To avoid gas payment when the foo function is called by another contract, we can use the following code: Remember that the caller contract should attach enough tokens to its message to cover all gas that will be spend by foo function. Accept gas inside modifier contract AcceptExample2 { uint _sum = 0; modifier AlwaysAccept() { tvm.accept(); _; } function foo(uint a, uint b) AlwaysAccept() public { _sum = a + b; } }  Important: modifier is called before arguments are deserialized from inbound message body. In the example above AlwaysAccept() will be called before a and b are decoded. "},{"title":"Message","type":0,"sectionRef":"#","url":"arch/message","content":"","keywords":""},{"title":"Message Header​","type":1,"pageTitle":"Message","url":"arch/message#message-header","content":"Any message has a message header: a data-structure defining, among other things, the message type and source and destination addresses. The message header defines its type. It is described by the following enumeration: pub enum CommonMsgInfo { IntMsgInfo(InternalMessageHeader), ExtInMsgInfo(ExternalInboundMessageHeader), ExtOutMsgInfo(ExtOutMessageHeader), }  "},{"title":"Internal Message​","type":1,"pageTitle":"Message","url":"arch/message#internal-message","content":"Within Everscale blockchain, smart-contracts communicate with each other by exchanging messages. Messages sent by smart-contracts are called internal. They are opposed to external messages that are sent by off-chain applications to smart-contracts. The message header of an internal message is defined as follows: pub struct InternalMessageHeader { pub ihr_disabled: bool, pub bounce: bool, pub bounced: bool, pub src: MsgAddressIntOrNone, pub dst: MsgAddressInt, pub value: CurrencyCollection, pub ihr_fee: Grams, pub fwd_fee: Grams, pub created_lt: u64, pub created_at: UnixTime32, }  InternalMessageHeader fields​ Field\tDescriptionihr_disabled\tIHR routing protocol disabled, always true bounce\tShould the answer message be generated in case of an error bounced\tIs this message was auto-generated by error handling src\tMessage source address dst\tMessage destination address value\tAmount of coins attached to the message ihr_fee\tIHR fee amount, always 0 fwd_fee\tMessage delivery fee amount created_lt\tMessage creation logic time created_at\tMessage creation time in Epoch Some clarifications: bounced flag is set when the message itself was auto-generated as a result of an error. If the message with bounced flag leads to an error itself, the next bounced message will not be generated.value is measured in Nano Evers (10−910^{-9}10−9)reated_lt is a monotonically increasing counter, thanks to this field, each new generated message is unique, even if the message payload is the same. The message creation logic time is also used to guarantee order of delivery. We do not dive deep into this question, because it is protocol-level details. "},{"title":"External Message​","type":1,"pageTitle":"Message","url":"arch/message#external-message","content":"External messages are created outside of the blockchain and get sent through specially distinguished validator nodes called DApp Servers2. External message header is defined as follows: pub struct ExternalInboundMessageHeader { pub src: MsgAddressExt, pub dst: MsgAddressInt, pub import_fee: Grams, }  Fields src and dst are source and destination addresses.Field import_fee should have been the value paid to the validator for processing an external message. But in the current node, this field is not used. Hence, the fee is not paid. We reported this issue to the developers.The source address for an external message is always set to AddrNone. pub enum MsgAddressExt { AddrNone, AddrExtern(MsgAddrExt), }  The second variant AddrExtern is not supported currently. "},{"title":"Events​","type":1,"pageTitle":"Message","url":"arch/message#events","content":"Event can be considered as a log record. It is used to signal external observers of reaching some significant state in a smart-contract. Usually, observers are external non-blockchain applications that constantly monitor blockchain state3. Other smart-contracts are not able to catch events. pub struct ExtOutMessageHeader { pub src: MsgAddressIntOrNone, pub dst: MsgAddressExt, pub created_lt: u64, pub created_at: UnixTime32, }  pub enum MsgAddressIntOrNone { None, Some(MsgAddressInt) }  Transaction Executor automatically assigns the source address src to be equal to the smart-contract address emitting the event.The destination address dst may contain any identifier. It is included for easier integration with off-chain applications, i.e. applications can monitor emitted events based on their destination address, and consume only those events destined to their custom identifier.Fields created_lt, created_at defines the logical creation time and epoch creation time. "},{"title":"Reference​","type":1,"pageTitle":"Message","url":"arch/message#reference","content":"In the original TON, message dichotomy is different: they distinguish 4 types of messages: (inbound + outbound) * (internal + external). We find this dichotomy a bit tedious to use in practice↩In the current protocol implementation, not all validator nodes process external messages. This is subject to change in the future protocol versions↩For example, by sending GraphQL requests to the DApp-server↩ "},{"title":"Pseudo-code Semantics","type":0,"sectionRef":"#","url":"arch/pseudo-code","content":"Pseudo-code Semantics A few words about the pseudo-code language we use to define the behavior of the Architecture parts. The language used is Python-like, with nearly intuitive semantics. We would like to highlight the following: For basic values like Ints and Bools, the assignment operator copies the value.For complex data types (objects), the assignment operator copies a reference to the object instead of creating a new instance.The call obj.clone() creates a deep copy of the object obj.The input arguments are passed by reference, so, mutating them within the function would mutate them for the caller also.Sometimes, the default value is irrelevant and not specified explicitly. Default values for structure fields are: 0 for IntsFalse for BoolsNone for OptionFor Enum types, the default value is the first item in the enumeration. In few places, we use idiomatic Python values swap: a, b = b, a This construct exchanges the values of a and b.The object method syntax is used in few places, for example: obj.method(p1, p2,...) = method(obj, p1, p2,...).Types and namespaces begin with uppercase letter, for example: TransactionExecutor.TrExecutorError() denotes the object TrExecutorError residing in the namespace TransactionExecutorWe use is operator to do type test. For example, to test that message is internal, we use the following construct: if in_msg.header is IntMsgInfo: return ExecuteInternalMessage(in_msg, ...) We omit details of some global objects, and just assume they exist. For example, the virtual machine is created using some abstract TVM object. The same goes for system error enumerations. It is done this way not to overload the pseudo-code with easily recoverable details.","keywords":""},{"title":"Querying","type":0,"sectionRef":"#","url":"arch/querying","content":"Querying","keywords":""},{"title":"Smart Contract Security","type":0,"sectionRef":"#","url":"arch/security","content":"","keywords":""},{"title":"Replay Attack Protection​","type":1,"pageTitle":"Smart Contract Security","url":"arch/security#replay-attack-protection","content":"All external messages must be protected against replay attacks. Otherwise, a malicious party can resend an external message obtained from blockchain and repeat a transaction for a smart contract. For example, a hacker can repeat a Token transfer and bring an account balance to zero. For internal messages the risk of replay attacks is irrelevant, as they only can be generated inside blockchain by other contracts. "},{"title":"Implementation Options​","type":1,"pageTitle":"Smart Contract Security","url":"arch/security#implementation-options","content":"Different approaches to implementing replay attack protection exist. None of them is a silver bullet, but there are several indicators applied to compare and evaluate them: Gas consumptionStorage feesRace conditionUsability "},{"title":"Sequence number​","type":1,"pageTitle":"Smart Contract Security","url":"arch/security#sequence-number","content":"This is a very simple protection option. It implies that each protected contract stores a counter (i.e. 32bit integer) that is initially set to zero. An external message is then accepted by the contract only under condition that it contains a number equal to the current contract counter value. Each time a new message is accepted, the contract counter value is incremented by one. Pros: simple implementation in contractslow gas and storage fees Cons: To get the right sequence number off-chain, a client must request the contract state from blockchain before sending an external message. If the state is large, it can cause a network traffic overheadRace condition issue that arises when there are multiple contract owners who can simultaneously call it. One owner can increment the contract counter value before this counter becomes available to the next ownerLess sensitive issue of a potential counter overflow in the future. In this case the TVM will throw an exception causing the owner to lose access to the contract "},{"title":"Timestamp​","type":1,"pageTitle":"Smart Contract Security","url":"arch/security#timestamp","content":"Another simple protection option is adding a timestamp to every external message. It can be a 64-bit value in unixtime format. The contract must store the timestamp of the last accepted external message. When a new external message comes, the contract verifies the message timestamp. It must to be bigger than the previous message timestamp and less then now + interval. The interval value is necessary, because now does not stand for the current time, but indicates creation time of the relevant block. The interval can be equal the block generation period or bigger. Pros: Very simple implementationNo need to request account state before sending external messages Cons: Race condition issues remains unresolved as in case of sequence number implementationClient time must be synchronized with blockchain time "},{"title":"Set of accepted messages​","type":1,"pageTitle":"Smart Contract Security","url":"arch/security#set-of-accepted-messages","content":"Dictionary of randoms This option implies that every external message contains a random value, for example, a 32bit integer. A protected contract, in turn, stores previously used randoms in a dictionary, compares message randoms with it and rejects a message if there is a match detected. Pros: No need to request account state before sending an external messageNo race condition; simultaneous access to contract of multiple parties is supported. Collisions are still possible when multiple clients have the same random, but chances can be minimized. Cons: Consumes a lot of gas for dictionary write/read operations. Note that the gas fee will increase in the futureHigh storage fees for storing dictionary Dictionary of messages with garbage collection This option implies that every external message contains an expire-at integer that defines the time when the message becomes invalid (i.e. expires). The contract, in turn, must store a dictionary with all recently accepted and not expired external messages. The key is a message hash, the value is the relevant expire-at integer. The contract then rejects all messages that are already present in its dictionary. To avoid persistent data increase, a protected contract can delete messages with the expire-at value less than now from its dictionary. Pros: No need to request the account state before sending an external messageNo race condition issues Cons: Harder to implement compared to the above option with a dictionary of randomsHigh gas fees caused by the need to access a dictionaryHigh storage fees, yet these can be reduced by deleting expired messages from the dictionaryGarbage collecting also involves some gas costs "},{"title":"Sessions​","type":1,"pageTitle":"Smart Contract Security","url":"arch/security#sessions","content":"Before sending requests to contract, a user creates a session with a contract by sending a create_session external message. The message contains a new session ID, its expired-at time and a starting sequence number. The contract stores a session dictionary. After a session is created, the user adds the session_id and the next session sequence number to every external message. For every external message (not create_session) the contract checks that: The message session ID exists in dictionary The message sequence number is equal to the stored session number, and The now value is less then the expired-at value for session If all checks are passed successfully, the contract increments the stored sequence number for the session. In case of failure, the message is rejected. Also, expired sessions require some garbage collection. Pros: No need to request the account state before sending an external messageNo race condition issuesNo collisions Cons: Harder to implement compared to all the options covered aboveHigh gas feesHigh storage feesNeed to use garbage collectingUnsuitable for simple single-user contracts "},{"title":"Conclusion​","type":1,"pageTitle":"Smart Contract Security","url":"arch/security#conclusion","content":"In EverX, we selected a lightweight and simple replay protection option, it will be implemented in the compiler by default and based on the timestamp approach. It is supposed to work well for single-user contracts, as well as for contracts without heavy race conditions. It is easy to use given that EverX SDK enables inserting a timestamp automatically on the client side. Also, there will be an option to redefine the default protection method by overloading a special contract function. This is how contract developers will be able to implement any protection option they seem fit. "},{"title":"Serialization","type":0,"sectionRef":"#","url":"arch/serialization","content":"Serialization","keywords":""},{"title":"Bug bounty program","type":0,"sectionRef":"#","url":"contribute/bug-bounty-program","content":"Bug bounty program","keywords":""},{"title":"Community maintainers","type":0,"sectionRef":"#","url":"contribute/community-maintainers","content":"Community maintainers","keywords":""},{"title":"Hot topics for contributors","type":0,"sectionRef":"#","url":"contribute/hot-topics-for-contributors","content":"Hot topics for contributors","keywords":""},{"title":"Rewards","type":0,"sectionRef":"#","url":"contribute/rewards","content":"Rewards","keywords":""},{"title":"Getting started","type":0,"sectionRef":"#","url":"contribute/tutorial/getting-started","content":"Getting started","keywords":""},{"title":"How to","type":0,"sectionRef":"#","url":"contribute/tutorial/how-to","content":"How to","keywords":""},{"title":"How to contribute code","type":0,"sectionRef":"#","url":"contribute/tutorial/how-to-contribute-code","content":"How to contribute code","keywords":""},{"title":"How to contribute to docs","type":0,"sectionRef":"#","url":"contribute/tutorial/how-to-contribute-to-docs","content":"How to contribute to docs","keywords":""},{"title":"How to contribute to website","type":0,"sectionRef":"#","url":"contribute/tutorial/how-to-contribute-to-website","content":"How to contribute to website","keywords":""},{"title":"Comparison with Bitcoin","type":0,"sectionRef":"#","url":"develop/from-another-platform/comparison-with-bitcoin","content":"Comparison with Bitcoin","keywords":""},{"title":"Comparison with Ethereum","type":0,"sectionRef":"#","url":"develop/from-another-platform/comparison-with-ethereum","content":"Comparison with Ethereum","keywords":""},{"title":"Comparison with Ethereum contracts","type":0,"sectionRef":"#","url":"develop/from-another-platform/comparison-with-ethereum-contracts","content":"Comparison with Ethereum contracts","keywords":""},{"title":"Comparison with Solana","type":0,"sectionRef":"#","url":"develop/from-another-platform/comparison-with-solana","content":"Comparison with Solana","keywords":""},{"title":"Transaction executor","type":0,"sectionRef":"#","url":"arch/executor","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#introduction","content":"Transaction Executor is a crucial part of Everscale blockchain node. It applies incoming messages to accounts, sealing the end result of this operation into a block in the form of a transaction object. The Transaction Executor algorithms determine several critical aspects of smart-contracts behavior, such as: How a balance of an account is affected after the message gets processedWhat outbound messages will be generated as a resultShould the account be frozen or deleted?What fees should be charged from the accounts balance To be able to rigorously reason about a smart-contract behavior, it is important to construct the accurate model of this module, explain the main concepts, define its properties. In other words, make the groundwork for you, the reader, to foster the integration of this logic into the reasoning framework of your choice. In the current work, we made the best-effort attempt to write such specification. "},{"title":"Document Structure​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#document-structure","content":"The document consists of two logical parts, intermixed with each other: the explanation part and the specification part. The explanation part is done by providing extensive comments for data structures used through-out the Transaction Executor. The data structures are presented as Rust code snippets, taken from the original Node code. Sometimes, we intentionally omit details that are not relevant to the Transaction Executor, requiring much wider context to be explained. The specification part is presented in two flavors. When the precision is required, we describe the behavior by providing the pseudo-code implementing some algorithm. For more general properties, we formulate them in a form of semi-formal statements about the system behavior. By comparison to the program implementation, the specification pseudo-code overapproximates the implementation by throwing away non-relevant parts of the logic, for example: sophisticated error handling, non-interesting parts of the state being removed, introducing reasonable assumptions that greatly simplifies the logic, etc. In other words, the pseudo-code shows how the system behaves for its significant parts, putting away everything else. "},{"title":"Everscale Platform Architecture​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#everscale-platform-architecture","content":"The main actors of the EverScale blockchain are smart-contracts. Smart-contracts are programs that operate user valuable assets on their behalf. Valuable assets are usually cryptocurrency tokens or some digital goods, like NFTs. Smart-contract execution is triggered by a message sent from some other party. If the message was delivered from the outside world (i.e. from the user program), it is said to be external. Otherwise, the message is considered internal. Smart-contracts may also generate log records called events. Those records are used as information signals for an external observers. They foster communication between smart-contracts and off-chain programs. The platform overall architecture is depicted​  "},{"title":"Platform Implementation​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#platform-implementation","content":"EverScale blockchain is a database operated by a peer-to-peer network of computing nodes. The database store users code and data in a form of programmable units called smart-contracts. Smart-contacts may communicate with other contracts and outside world by sending messages. The computing node is called blockchain node in our context. Among other things, blockchain nodes are responsible for storing the smart-contract state, delivering messages from users and smart-contracts, executing the smart-contacts code when needed. Transaction Executor module is a part of the blockchain node responsible for proper execution of a smart-contract code upon receiving a message addressed to that smart-contract. The result of this execution is an updated smart-contract state and the transaction record that gets sealed into the block candidate. We now go into details on the internals of this module. "},{"title":"Transaction Executor Module​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#transaction-executor-module","content":"In this section, we go into the technical details of Transaction Executor module. The source code of the module is available here. "},{"title":"Remark​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#remark","content":"In our opinion, the name of this module was chosen quite unfortunate. In its current form, it feels like the object being executed is a transaction. This is not true. Transaction is an outcome of executing a message on a smart-contract state using the Transaction Executor logic. Hence, it is the message that is being executed, not the transaction. Nevertheless, we stick with the original name not to confuse developers too much. "},{"title":"Inputs and Outputs​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#inputs-and-outputs","content":"The principal architecture of the module is depicted​  We now describe each input/output entity in detail, together with the logic of the computation. "},{"title":"Multichain Architecture​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#multichain-architecture","content":"Everscale has a native support for multiple blockchains running in parallel. Each blockchain might be established by introducing a separate chain called workchain. Each workchain has a unique integer identifier in a range -127 ... 127, the values -1 and 0 are already taken. Smart-contracts from different workchains may interact with each other by message passing. At the moment, the system implements only two workchains — Masterchain (id -1) and Workchain (id 0). caution Currently, the creation of new workchains is not supported. "},{"title":"Multicurrency payments​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#multicurrency-payments","content":"The native coin of Everscale blockchain is called EVER. However, Everscale has an ability to work with other types of coins. While system payments like gas and storage fees are made only in Evers, the other value transfers may contain coins of other currencies. This contrasts with most of other blockchains where there is only a single native cryptocurrency, and other currencies may be made only using artificial token smart-contracts. Currently, this feature is not used widely. caution In this document, we limit our specification effort only for the case of a single currency — Evers. This choice significantly simplifies the business logic of the execution handlers. "},{"title":"Hashing Algorithm​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#hashing-algorithm","content":"Transaction Executor uses hashing in several places to compactly store data structures fingerprints. It is done in two steps. First, the data structure gets converted into a tree-like form. Then, a special hashing algorithm is applied to that tree. The basic hash function used is SHA256 from Sha2 Rust package. The exact hashing algorithm, as well as tree-like representation is not interesting for our purposes, so we do not consider it here. For details, check this. "},{"title":"Parameters​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#parameters","content":"Besides, incoming message and account, Transaction Executor has to have some external information regarding the current blockchain and non-blockchain state to support the TVM capabilities. For example, it has to know the current time to provide it for smart-contracts. It has to have some random seed to support the random number generator facility. All of this is passed using the ExecuteParams structure. pub struct ExecuteParams { pub state_libs: HashmapE, pub block_unixtime: u32, pub block_lt: u64, pub last_tr_lt: Arc&lt;AtomicU64&gt;, pub seed_block: UInt256, pub debug: bool }  ExecuteParams fields​ Field\tDescriptionstate_libs\tA set of references to external libraries. This mechanism is not supported currently block_unixtime\tCurrent time in Unix Epoch block_lt\tBlock logical time last_tr_lt\tThe last transaction logical time seed_block\tRandom number generator seed debug\tShould the TVM output debug information during its execution "},{"title":"Transaction​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#transaction","content":"Transaction is an object that describes the successful execution of a message on the account. If a message execution results in an error, such execution does not lead to a transaction creation. After transaction is created, it gets sealed into the block. And after the block is negotiated with fellow validators, it find its way into the Masterchain. From that point, it stays there forever1. Transaction is an output of the Transaction Executor, so we have to examine it more closely. pub struct Transaction { pub account_addr: AccountId, pub lt: u64, pub prev_trans_hash: UInt256, pub prev_trans_lt: u64, pub now: u32, pub outmsg_cnt: i16, pub orig_status: AccountStatus, pub end_status: AccountStatus, pub in_msg: Option&lt;ChildCell&lt;Message&gt;&gt;, pub out_msgs: OutMessages, pub total_fees: CurrencyCollection, pub state_update: ChildCell&lt;HashUpdate&gt;, pub description: ChildCell&lt;TransactionDescr&gt;, }  ExecuteParams fields​ Field\tDescriptionaccount_addr\tAccount identifier lt\tTransaction creation logical time prev_trans_hash\tPrevious transaction hash value prev_trans_lt\tPrevious transaction logical time now\tCurrent time in Unix Epoch outmsg_cnt\tNumber of generated outbound messages orig_status\tAccount state upon receiving the message end_status\tAccount state after executing the message in_msg\tProcessed message out_msgs\tSet of generated outbound messages total_fees\tTotal fee amount for all the processing state_update\tHash footprint of the account state change description\tTransaction Descriptor "},{"title":"Transaction Executor​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#transaction-executor-1","content":"Transaction Executor module is responsible for applying the incoming message to the destination account, using the supplied parameters. In case of success, Transaction Executor outputs the newly created transaction and the updated account. The main entry point is the function execute_with_libs_and_params() within transaction_executor.rs module. Other entry points were either flagged as deprecated, or reduce to calling this function after some minor parameters mangling. The message execution is being done in several phases. A phase is a logical step during the message execution. It may finish successfully or with an error. In case of an error, the next phase may not be executed. Phases are done mostly in a fixed order, but there are some nuances. Let us warn you that the phase is not just an implementation detail of the Transaction Executor internals that may be easily discarded. Message execution phases are a part of EverScale smart-contracts programming architecture. It is assumed that you have a good grasp on it, to be able to do proper troubleshooting in case something is not working as expected. Without this knowledge, it may be challenging to debug the problem. This document aims to support programmers in their strive for this knowledge. Transaction executor message processing general scheme​  Credit — Message coins are put on the balance agent Storage.Storage — Storage fee is deducted from the balance agent Computer.Computer — The contract bytecode gets executed inside TVM with proper parameters. Contract generate Actions.Action — Generated actions get executed by the action handler, producing outbound messages.Bounce — Bounce phase is executed if failure happened on compute phase or action phase. It sends back the reply with coins, mostly.Out messages — Queue get propagated to other validators. "},{"title":"Transaction Executor Types​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#transaction-executor-types","content":"There are several type of messages in EverScale. Besides already mentioned ordinary messages, there are also a special type of messages that is a part of a wider protocol. For example, TickTock messages, SplitMerge messages, etc. For each type of messages, there exists a separate Transaction Executor. In this work, we consider only the OrdinaryTransactionExecutor, that is defined in ordinary_transaction.rs. "},{"title":"Main Entry Point​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#main-entry-point","content":"fn execute_with_libs_and_params( &amp;self, in_msg: Option&lt;&amp;Message&gt;, account_root: &amp;mut Cell, params: ExecuteParams, ) -&gt; Result&lt;Transaction&gt;  ExecuteParams fields​ Field\tDescriptionself\tReference to the object calling the function in_msg\tIncoming message messages account_root\tAccount record serialized in a form of Cells account params\tTransaction Executor parameters parameters As a result, the function returns either Ok(Transaction) object or Err value. Please note that besides returning the Transaction, there is a side-effect of mutating the account_root object. This justifies our generalization that it returns two objects: the transaction and the updated account record. "},{"title":"BlockchainConfig parameters​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#blockchainconfig-parameters","content":"Besides ExecuteParams, the Transaction Executor relies on BlockchainConfig parameters. They are passed implicitly, at the Transaction Executor creation time. BlockchainConfig is a set of globally defined parameters regulating different nuances of blockchain work. For example, prices for smart-contract execution, storage and a set of system contract addresses. The latter is needed to let Transaction Executor apply special logic for them. Those parameters are global to the network, and negotiated between all the validators in advance. They are stored in a special system smart-contract, in the Masterchain. pub struct BlockchainConfig { gas_prices_mc: GasLimitsPrices, gas_prices_wc: GasLimitsPrices, fwd_prices_mc: MsgForwardPrices, fwd_prices_wc: MsgForwardPrices, storage_prices: AccStoragePrices, special_contracts: FundamentalSmcAddresses, capabilities: u64, global_version: u32, raw_config: ConfigParams, }  Field\tDescriptiongas_prices_mc\tFees for Masterchain smart-contract execution gas_prices_wc\tFees for Workchain smart-contract execution fwd_prices_mc\tFees for delivering messages in Masterchain fwd_prices_wc\tFees for delivering messages in Workchain storage_prices\tFees for information storage special_contracts\tSet of system smart-contract addresses capabilities\tSet of operation-mode flags global_version\tMinimum blocks version number allowed to be included in the chain raw_config\tDictionary with blockchain settings "},{"title":"Code Execution Fee​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#code-execution-fee","content":"As in most of blockchain, in Everscale the execution of a smart-contract costs money. Usually, this fee is deduced from the coins attached to the message initiating the call, but there are nuances. The fee amount to be deducted from the balance is calculated based on values found in gas_price_mc, gas_price_wc structures. They are defined as follows: pub struct GasLimitsPrices { pub gas_price: u64, pub gas_limit: u64, pub special_gas_limit: u64, pub gas_credit: u64, pub block_gas_limit: u64, pub freeze_due_limit: u64, pub delete_due_limit: u64, pub flat_gas_limit: u64, pub flat_gas_price: u64, pub max_gas_threshold: u128, }  Field\tDescriptiongas_price\tPrice of 1 unit of gas, expressed in Nano Evers gas_limit\tMaximum gas amount for execution of a single message for an ordinary account special_gas_limit\tMaximum gas amount for execution of a single message for a system account gas_credit\tGas credited for an account to execute the external message block_gas_limit\tMaximum gas amount of the whole block freeze_due_limit\tValue of an account debt leading to account freeze delete_due_limit\tValue of an account debt leading to account removal flat_gas_limit flat_gas_price max_gas_threshold\t "},{"title":"Message Passing Fee​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#message-passing-fee","content":"Validators do the work of message delivery. To compensate their efforts, account pays for the message passing. The message passing fee depends on BlockchainConfig parameters fwd_pricesand the message size. The fwd_prices_mc and fwd_prices_wchave the following definition: pub struct MsgForwardPrices { pub lump_price: u64, pub bit_price: u64, pub cell_price: u64, pub ihr_price_factor: u32, pub first_frac: u16, pub next_frac: u16, }  The fee amount is calculated using the expression: msg_fwd_fees=lump_price+bit_price×msg.bits+cell_price×msg.cellsmsg\\_fwd\\_fees = lump\\_price + bit\\_price \\times msg.bits + cell\\_price \\times msg.cellsmsg_fwd_fees=lump_price+bit_price×msg.bits+cell_price×msg.cells Here, msg.bits — bit-length of the message body, msg.cells is a total amount of cells that this message consists of. "},{"title":"Data Storage Fee​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#data-storage-fee","content":"In Everscale, account is charged a fee for storing the data. The fee amount is calculated using the formula: fee=(cells∗prices.cell_price+bits∗prices.bit_price)∗Δfee = (cells * prices.cell\\_price + bits * prices.bit\\_price) * \\Deltafee=(cells∗prices.cell_price+bits∗prices.bit_price)∗Δ Δ\\DeltaΔ — the time interval between now and the latest payment moment, measured in seconds. Here, we assume that storage prices stay constant during the Δ\\DeltaΔ interval. The storage fee gets charged on each message processing storage_phase. For greater flexibility, the storage prices may be changed depending on the current supply/demand situation. It is done by negotiating new blockchain config parameters prices.cell_priceprices.cell\\_priceprices.cell_priceand prices.bit_priceprices.bit\\_priceprices.bit_price among validators. After validators accept it, new parameters are written in the Masterchain config smart-contract. After the change, previous price parameters do no get lost. The whole history of storage price changes is stored in the config. It is done to provide precise calculation of the storage fee that take into account all the price changes during the interval of calculation. Data Storage Fee Calculation​ Here we describe the storage fee calculation expression in its generality. Lets assume we have the following list of prices equipped with a timestamp of a moment when the price change took place: T={t0,t1,...,tN}T = \\{ t_0, t_1, ..., t_N \\}T={t0​,t1​,...,tN​} Pr=⟨(pr0,t0),(pr1,t1),...,(prN,tN)⟩Pr = \\langle (pr_0, t_0), (pr_1, t_1), ..., (pr_N, t_N) \\ranglePr=⟨(pr0​,t0​),(pr1​,t1​),...,(prN​,tN​)⟩ Here, pr_0 is reserved for the initial prices set in the genesis block of the blockchain, and t0t_0t0​ is a timestamp of those initial prices being set. Let now denote the current timestamp, i.e. the moment of time when we want to calculate the storage fee, measured in Unix Epoch. Its value is always greater or equal than the most recent price change timestamp. Let last_paid denote the timestamp of the latest storage payment. If the payment didn't take place, last_paid=0last\\_paid = 0last_paid=0. To simplify the calculation formula, let us introduce a new listPr′Pr'Pr′, such that: Pr′=⟨(prk,tk),...,(prN,tN)⟩Pr' = \\langle (pr_k, t_k), ..., (pr_N, t_N) \\ranglePr′=⟨(prk​,tk​),...,(prN​,tN​)⟩ where t_k is the least timestamp among values t1...tNt_1 ... t_Nt1​...tN​ that is greater than last_paid. tk=min{ti∣ti∈T∧ti&gt;last_paid}t_k = min \\{ t_i | t_i \\in T \\land t_i &gt; last\\_paid \\}tk​=min{ti​∣ti​∈T∧ti​&gt;last_paid} In other words, the values tk,...,tNt_k, ..., t_Ntk​,...,tN​ form a subset ofT where each value is strictly greater than last_paid. We also add two more elements from the left and the right: Pr′′=⟨(prk,last_paid)⟩⋅Pr′⋅⟨(prN,now)⟩Pr'' = \\langle (pr_k, last\\_paid) \\rangle \\cdot Pr' \\cdot \\langle (pr_N, now) \\ranglePr′′=⟨(prk​,last_paid)⟩⋅Pr′⋅⟨(prN​,now)⟩ Here, dot operator denotes lists concatenation operation. We use the following shortcuts: pri=fst(Pri′′)pr_i = fst(Pr''_i)pri​=fst(Pri′′​) the first element of a two-element tuple, and ti=snd(Pri′′)t_i = snd(Pr''_i)ti​=snd(Pri′′​), the second element. The total storage fee for the time interval is: total_storage_fee=∑i=1..∣Pr′′∣(cells∗pri.cell_price+bits∗pri.bits_price)∗(ti−ti−1)total\\_storage\\_fee = \\sum_{i=1..|Pr''|}{(cells * pr_{i}.cell\\_price + bits * pr_{i}.bits\\_price) * (t_i - t_{i-1})}total_storage_fee=∑i=1..∣Pr′′∣​(cells∗pri​.cell_price+bits∗pri​.bits_price)∗(ti​−ti−1​) Data Storage Fee Calculation Algorithm​ For greater convenience, besides having the formula, we provide the pseudo-code for the algorithm calc_storage_fee, implemented in imperative fashion. Input: config — current blockchain configuration, has type BlockchainConfigstorage_info — the account storage info struct, has type StorageInfo.is_masterchain — is the account inhabits Masterchain or not, has type Boolnow — current time, measured in Unix Epoch, has type UInt Output: fee — the fee amount to be deducted from the account balance, has type UIntstorage_info — updated account storage info, has type StorageInfo def calc_storage_fee(config, storage_info, is_masterchain, now): cells = storage_info.used.cells bits = storage_info.used.bits last_paid = storage_info.last_paid prices = config.storage_prices # see AccStoragePrices assert len(prices) &gt; 0 if now &lt;= last_paid or last_paid == 0 or now &lt;= prices[0].utime_since: return 0 fee = 0 # calculate the fee according to prices that were actual # during the specific period of time for i in len(prices): cur_price = prices[i] if i &lt; len(prices) - 1: end = prices[i + 1].utime_since else: end = now_time if end &gt;= last_paid: delta = end - max(cur_price.utime_since, last_paid) if is_masterchain: fee += (cells * cur_price.mc_cell_prices_ps + \\ bits * cur_price.mc_bit_price_ps) * delta else: fee += (cells * cur_price.cell_price_ps + \\ bits * cur_price.bit_price_ps) * delta storage_info.last_paid = end return (fee, storage_info)  "},{"title":"Special Smart-Contracts​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#special-smart-contracts","content":"In Everscale blockchain, there is a set of smart-contracts that have a distinguished status in the system. For those contracts, validators are obligated to process their execution in a special priveledged manner. Such smart-contracts are called special or system. Accounts storing those contracts are called the same. Special smart-contracts enjoy the following privilege: No fee gets deducted for the code executionNo fee gets deducted for the storage useNo fee gets deducted for message passingIt has a special maximum gas limit, see GasLimitsPrices.special_gas_limitAllowed to process TickTock timer messages Upon executing a message for one of those special contracts, the Transaction Executor has to apply all those conditions. caution In this document, we mainly focus on ordinary accounts, leaving the special accounts processing details aside. "},{"title":"GlobalCapabilities Options​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#globalcapabilities-options","content":"There are several flags defining different aspects of the blockchain node operation mode. They are defined in GlobalCapabilities enumeration. Parameter\tDescriptionCapCreateStatsEnabled\tAllow update block statistics. Not related to Transaction Executor. CapBounceMsgBody\tInclude the first 256 bits of the original message in the bounce message body. CapReportVersion\tInclude the blockchain version info into the block. CapShortDequeue\tSome special mode of managing outbound messages by the Validator. Not related to Transaction Executor CapFastStorageStat\tUse alternative algorithm to update the structs AccountsStat. CapInitCodeHash\tUse the field init_code_hash in the AccountState. CapOffHypercube\tTurn off Hypercube routing algorithm for message delivery CapMycode\tProvide the virtual machine with the code of a smart-contract being executed. CapMbppEnabled\tNot used CapIhrEnabled\tNot used CapSplitMergeTransactions\tNot used "},{"title":"RawConfig options​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#rawconfig-options","content":"Besides already mentioned options, there are yet another set of options residing in the BlockchainConfig.raw_config. This field has the following structure: pub struct ConfigParams { pub config_addr: UInt256, pub config_params: HashmapE // &lt;u32, SliceData&gt; }  config_addr — is the configuration smart-contract account identifier (the workchain identifier equals - 1);config_params — dictionary with parameters, dictionary keys refers to an option number. We will not go deep into those options, because they are not relevant to our work. See ton-labs-block/src/config_params.rs for further investigation. "},{"title":"Error Code Enumeration​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#error-code-enumeration","content":"When Transaction Executor encounters an error during message processing, it returns a special answer to the calling side. The answer contains an error code. Here we list possible error codes and their short description. In our further discussion, we rely on those mnemonic names. "},{"title":"Error Code Enumeration​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#error-code-enumeration-1","content":"When Transaction Executor encounters an error during message processing, it returns a special answer to the calling side. The answer contains an error code. Here we list possible error codes and their short description. In our further discussion, we rely on those mnemonic names. Error Mnemonic Name\tDescriptionInvalidExtMessage\tIncorrect format of an incoming external message TrExecutorError(e)\tWide range of errors during message processing TvmExceptionCode(e)\tTVM produced exception e during byte-code execution NoAcceptError\tThe smart-contract did not accept external message NoFundsToImportMsg\tNot enough funds to process external message ExtMsgComputeSkipped(r)\tDuring the external message processing, the Compute phase was skipped with the reason r "},{"title":"Account State Update​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#account-state-update","content":"In the transaction object, there is a special field reflecting the change of the account state, the state_update field of type HashUpdate. The type is defined as follows: pub struct HashUpdate { pub old_hash: UInt256, pub new_hash: UInt256, }  Here old_hash refers to a hash value taken from the initial account state, before message processing; the new_hash is a hash taken from the updated account state, after successful message processing. "},{"title":"Transaction Description Object​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#transaction-description-object","content":"During the incoming message processing, Transaction Executor constructs the report about the processing. This report has a special name — Transaction Description, and defined by the following structure: pub struct TransactionDescrOrdinary { pub credit_first: bool, pub storage_ph: Option&lt;TrStoragePhase&gt;, pub credit_ph: Option&lt;TrCreditPhase&gt;, pub compute_ph: TrComputePhase, pub action: Option&lt;TrActionPhase&gt;, pub aborted: bool, pub bounce: Option&lt;TrBouncePhase&gt;, pub destroyed: bool }  This description object may be used for fast checkups on the main system invariants, critical for its safety, during runtime. Field\tDescriptionstorage_ph\tStorage phase descriptor credit_ph\tCredit phase descriptor compute_ph\tCompute phase descriptor action\tAction phase descriptor bounce\tBounce phase descriptor credit_first\tCredit phase was executed before Storage phase aborted\tIs Action phase failed destroyed\tIs account deleted after message execution We now describe each descriptor separately. Storage Phase Descriptor​ pub struct TrStoragePhase { pub storage_fees_collected: Grams, pub storage_fees_due: Option&lt;Grams&gt;, pub status_change: AccStatusChange }  storage_fees_collected denotes the amount of tokens deducted from the account balance to cover the storage fee.storage_fees_due denotes the debt value, if there is any. Otherwise, this value equals None.status_change denotes the possible account status change. It may have been the case that the status were frozen or deleted due to having a significant debt value. Possible values are: pub enum AccStatusChange { Unchanged, Frozen, Deleted, }  Credit Phase Descriptor​ The Credit Phase descriptor is defined as follows: pub struct TrCreditPhase { pub due_fees_collected: Option&lt;Grams&gt;, pub credit: CurrencyCollection, }  Field\tDescriptiondue_fees_collected\tAmount of coins deducted from the message balance to cover the debt of the account, if any existed at the beginning of the credit phase. If there were no debt, the value is None . credit\tMessage value after the fees were conducted from it. Compute Phase Descriptor​ Compute Phase descriptor is defined with the following enumeration: pub enum TrComputePhase { Skipped(TrComputePhaseSkipped), Vm(TrComputePhaseVm) }  Choice 1. Skipped​ If the Compute phase was not successfully performed, the descriptor value is Skippedin this case. It should have an argument with following type: pub struct TrComputePhaseSkipped { pub reason: ComputeSkipReason }  reason has to be one of the following: pub enum ComputeSkipReason { NoState, BadState, NoGas, }  Field\tDescriptionNoState\tCaused by the following conditions: 1) The account did not exist by the time of message arrival, and the incoming message did not contain the StateInit part; 2) The account was not initialized and the incoming message did not contain the StateInit part. NoState\tCaused by the following conditions: 1) The account did not exist by the time of message arrival, and the incoming message did not contain the StateInit part; 2) The account was not initialized and the incoming message did not contain the StateInit part. BadState\tCaused by the following conditions: 1) The account was in AccStateUninit state, the message did contain the StateInit part, but an attempt to initialize the account with the given StateInit failed due to being inconsistent with the account; 2) The account was in AccStateFrozen state, the message contained the StateInit part, but an attempt to unfreeze the account with the given state init failed due to being inconsistent with the account. NoGas\tCaused by the following conditions: 1) After Credit and Storage phases, the account balance had no coins: its balance equals zero; 2) Values gas_limit and gas_credit, calculated with the init_gas algorithm, both equals 0. Choice 2. Successful computation​ Successful Compute phase result is defined by the following TrComputePhaseVm structure: pub struct TrComputePhaseVm { pub success: bool, pub msg_state_used: bool, pub account_activated: bool, pub gas_fees: Grams, pub gas_used: VarUInteger7, pub gas_limit: VarUInteger7, pub gas_credit: Option&lt;VarUInteger3&gt;, pub mode: i8, pub exit_code: i32, pub exit_arg: Option&lt;i32&gt;, pub vm_steps: u32, pub vm_init_state_hash: UInt256, pub vm_final_state_hash: UInt256 }  Field\tDescriptionsuccess\tCompute phase completion status. See compute_phase_success gas_fees\tFees for the gas used by a smart-contract execution, see here gas_used\tAn exact amount of gas used by the VM during the execution gas_limit\tA strict upper bound on the amount of gas allowed for this account init_gas gas_credit\tAn amount of gas credited to be used for external messages before being accepted init_gas vm_steps\tNumber of steps performed by the VM exit_code\tComputation exit code, see compute_phase_exitcode exit_arg\tComputation exit argument, see compute_phase_exitcode mode\tAlways equals 0 vm_init_state_hash\tNot used vm_final_state_hash\tNot used msg_stated_used\tNot used account_activated\tNot used Action Phase Descriptor​ Action Phase descriptor is defined as follows: pub struct TrActionPhase { pub success: bool, pub valid: bool, pub no_funds: bool, pub status_change: AccStatusChange, pub total_fwd_fees: Option&lt;Grams&gt;, pub total_action_fees: Option&lt;Grams&gt;, pub result_code: i32, pub result_arg: Option&lt;i32&gt;, pub tot_actions: i16, pub spec_actions: i16, pub skipped_actions: i16, pub msgs_created: i16, pub action_list_hash: UInt256, pub tot_msg_size: StorageUsedShort, }  Field\tDescriptionsuccess\tAction phase completed successfully. The success condition is described here. valid\tAction phase is valid. The validity condition is described here. result_code\tAction phase failed with the result code, see action_result_codes. In case of success, the value equals to 0 result_arg\tIn case of an error, the item number of an action in the action list that caused the error no_funds\tTrue if the error was caused by a balance insufficiency status_change\tEquals AccStatusChange::Deleted in case of the account being deleted after processing actions total_fwd_fees\tTotal fees for the SendMsg actions processing total_action_fees\tTotal fees for the whole action list processing tot_actions\tTotal number of actions in the action list at a beginning of the Action phase spec_actions\tNumber of special actions, i.e. Reserve, SetCode, SetLib msg_created\tNumber of successful SendMsg actions action_list_hash\tHash of action list calculated at a beginning of the Action phase tot_msg_size\tTotal size of all the generated messages skipped_actions\tNot used Action Result Codes​ Result Code\tDescriptionRESULT_CODE_ACTIONLIST_INVALID\tMessage serialization error RESULT_CODE_TOO_MANY_ACTIONS\tContract generated more actions than allowed. Maximum actions count is 255 RESULT_CODE_UNKNOWN_OR_INVALID_ACTION\tBinary serialization error, or invalid flags. See remarks. RESULT_CODE_INCORRECT_SRC_ADDRESS\tWide source address address, or the source address does not equal to the account address RESULT_CODE_INCORRECT_DST_ADDRESS\tIncorrect destination address, or destination workchain is not allowed to receive messages, or destination workchain does not exist RESULT_CODE_ANYCAST\tDestination address of type Anycast. It is no longer supported and considered an error. RESULT_CODE_NOT_ENOUGH_GRAMS\tInsufficient balance. See remarks. RESULT_CODE_NOT_ENOUGH_EXTRA\tExtra-tokens balance is insufficient to execute to action RESULT_CODE_INVALID_BALANCE\tReserve action lead to an error, or outgoing message is too big to process RESULT_CODE_BAD_ACCOUNT_STATE\tActions SetCode or ChangeLib lead to an error RESULT_CODE_UNSUPPORTED\tSendMsg action has incorrect flags set Remarks:​ RESULT_CODE_UNKNOWN_OR_INVALID_ACTION reasons are: Actions serialization errorSendMsg action has invalid flags, that is: The mutually exclusive flags are set: SENDMSG_REMAINING_MSG_BALANCE and SENDMSG_ALL_BALANCEMessage was sent with an unknown flag sendmsg_flags;The flag SENDMSG_DELETE_IF_EMPTY is set, but the flag SENDMSG_ALL_BALANCE isn't; Reserve action has invalid flags Unknown flag is setFlag RESERVE_PLUS_ORIG is set, but RESERVE_REVERSE isn't RESULT_CODE_NOT_ENOUGH_GRAMS reasons are: For SendMsg action, the flag SENDMSG_REMAINING_MSG_BALANCE is set, but SENDMSG_PAY_FEE_SEPARATELY isn'tMessage balance is insufficient to cover message delivery feesAccount balance is insufficient to cover all message delivery fees Bounce Phase Transaction Descriptor​ Bounce Phase descriptor is defined with the following enumeration: pub enum TrBouncePhase { Negfunds, Nofunds(TrBouncePhaseNofunds), Ok(TrBouncePhaseOk), }  Negfunds choice is not used.Nofunds(TrBouncePhaseNofunds) denotes the insufficiency of account balance, details are put into the parameter valueOk(TrBouncePhaseOk) denotes success, i.e. that the bounce message has been formed and put into the Msg queue. Details of the phase are put into the parameter value. Choice 1. Nofunds​ pub struct TrBouncePhaseNofunds { pub msg_size: StorageUsedShort, pub req_fwd_fees: Grams, }  msg_size denotes the size of generated bounce message. This value is not used.req_fwd_fees denotes the fee for the message delivery. Choice 2. Ok(TrBouncePhaseOk)​ pub struct TrBouncePhaseOk { pub msg_size: StorageUsedShort, pub msg_fees: Grams, pub fwd_fees: Grams, }  msg_size not used.fwd_fees is a full forwarding fee for the bounce message.msg_fees is a part of fwd_fees that goes to the validator processing the message. "},{"title":"Actions​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#actions","content":"After successfully executing a smart-contract code, the TVM virtual machine provides the executor with updated contract state and a list of actions to be further processed. In our context, an action refers to an order for the Transaction Executor to perform a distinguished stateful act. It could be sending a message, changing the smart-contract's code or reserving coins on the balance. "},{"title":"Type of Actions​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#type-of-actions","content":"Here we provide a set of possible actions, with the description. We go deep on each of them further. pub enum OutAction { None, // default value SendMsg { mode: u8, out_msg: Message, }, SetCode { new_code: Cell, }, ReserveCurrency { mode: u8, value: CurrencyCollection, }, ChangeLibrary { mode: u8, code: Option&lt;Cell&gt;, hash: Option&lt;UInt256&gt;, } }  Action\tDescriptionSendMsg\tSend the message out_msg to some account using the provided mode ReserveCurrency\tManage the account's balance to guarantee its sufficiency SetCode\tChange the contract byte-code with the given new_code ChangeLibrary\tUpdate code library "},{"title":"Action SendMsg​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#action-sendmsg","content":"SendMsg(mode,outmsg)SendMsg(mode,out_msg)SendMsg(mode,outm​sg) action sends a message to an account. The message out_msgout\\_msgout_msg contains the destination address as well as the payload to be delivered. This action has a lot of modes that can be combined using logicalOR operator. Some mode combinations are prohibited. See rc_remarks. Mode\tValue\tDescriptionSENDMSG_ORDINARY\t0\tSend the message. Without other modes, the forwarding fee for the delivery is paid by the receiver. SENDMSG_PAY_FEE_SEPARATELY\t1\tSend the message. The forwarding fee is paid by the sender. SENDMSG_IGNORE_ERROR\t2\tIf an error occurs during the processing of this action, ignore it. SENDMSG_DELETE_IF_EMPTY\t32\tThe account gets deleted if, after the action processed, the balance becomes zero SENDMSG_REMAINING_MSG_BALANCE\t64\tThe message should carry all the remaining value of the inbound message additionally to the value specified in the field SENDMSG_ALL_BALANCE\t128\tThe message should carry all the remaining balance of the account, instead of the value specified in the value field "},{"title":"Action ReserveCurrency​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#action-reservecurrency","content":"ReserveCurrency(mode,val)ReserveCurrency(mode, val)ReserveCurrency(mode,val) action makes a coin reserve on the balance. This action has several modes of operation. Modes can be combined. Mode\tValue\tDescriptionRESERVE_EXACTLY\t0\tReserve exactly valvalval coins RESERVE_ALL_BUT\t1\tReserve acc_balance−valacc\\_balance - valacc_balance−val coins, where acc_balanceacc\\_balanceacc_balance is a remaining balance of the account RESERVE_IGNORE_ERROR\t2\tSkip the action on failure RESERVE_PLUS_ORIG\t4\tReserve acc_balance+valacc\\_balance + valacc_balance+val coins. It should be used only with RESERVE_REVERSE. RESERVE_REVERSE\t8\tReverse value of valvalval in the calculation of the reserve, i.e. substitute valvalval with −val-val−val "},{"title":"Action SetCode​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#action-setcode","content":"Currently, we skip this action. "},{"title":"Message Processing Algorithm​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#message-processing-algorithm","content":"In this section, we present a pseudo-code for incoming message processing algorithm. The algorithm is divided in two mutually exclusive parts: ExecuteInternalMessage — internal message execution internal_message_processingExecuteExternalMessage — external message execution external_message_processing Both algorithms rely on executing some or all of the phases: Credit phase credit_phaseStorage phase storage_phaseCompute phase compute_phaseAction phase action_phaseBounce phase bounce_phase Please note that we consider only ordinary accounts here. The algorithm for executing messages on special accounts is not considered. Input: in_msg — incoming message, has type Messageaccount — account, has type Accountparams — executor parameters, has type Parametersconfig — blockchain configuration, has type BlockchainConfig Output: On success, returns Ok(acc1, trans), such that: acc1 — updated account, has type Accounttrans — transaction, has type Transaction On error, returns error of the type ExecutorError Modifies: def ExecuteMessage(in_msg, account, params, config): if in_msg.header is ExtOutMsgInfo: return ExecutorError.InvalidExtMessage if in_msg.header.dst == None: return ExecutorError.TrExecutorError() if in_msg.header is ExtInMessageHeader and account.balance == 0: return ExecutorError.NoFundsToImportMsg() acc = account.clone() if in_msg.header is ExtInMsgInfo: return ExecuteExternalMessage(in_msg, acc, params, config) elif in_msg.header is IntMsgInfo: return ExecuteInternalMessage(in_msg, acc, params, config) return ExecutorError.TrExecutorError()  "},{"title":"Internal Message Processing Algorithm​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#internal-message-processing-algorithm","content":"At this point, the message is known to be internal. Execute it with the given account. Input: in_msg — incoming message, has type Messageaccount — account, has type Accountparams — executor parameters, has type Parametersconfig — blockchain configuration, has type BlockchainConfig Output: On success, returns Ok(acc1, trans), such that: acc1 — updated account, has type Accounttrans — transaction, has type Transaction On error, returns error of the type TransactionExecutor.TrExecutorError Modifies: account def ExecuteInternalMessage(in_msg, account, params, config): acc_balance = account.balance msg_balance = in_msg.hdr.value credit_first = not in_msg.hdr.bounce lt = max(account.last_tr_time, max(params.last_tr_lt, in_msg.lt + 1)) tr = Transaction(account.account_id, account.status, lt, now(), in_msg) descr = TransactionDescrOrdinary(credit_first: credit_first) # If the bounce flag is not set, execute the Credit Phase # before Storage phase if credit_first: credit_ph_res = credit_phase(account, tr, msg_balance, acc_balance) if credit_ph_res is Ok: descr.credit_ph = credit_ph_res.credit_ph else: return ExecutorError.TrExecutorError() # Execute Storage Phase storage_ph_res = storage_phase(account, acc_balance, tr, is_masterchain, config) descr.storage_ph = storage_ph_res.storage_ph # Why this is needed? if credit_first and (msg_balance &gt; acc_balance): msg_balance = acc_balance original_acc_balance = account.balance - tr.total_fees if not credit_first: credit_ph_res = credit_phase(account, tr, msg_balance, acc_balance) if credit_ph_res is Ok: descr.credit_ph = credit_ph_res.credit_ph else: return ExecutorError.TrExecutorError() # Both storage and credit phases are completed at this point. # We need to update the last_paid field not to loose this # information in case of some further errors showing up. account.last_paid = params.block_unixtime # Parameters to be passed into TVM smci = build_contract_info(acc_balance, account.address, params.block_lt, lt, params.seed_block) # First element is the bottom of the stack stack = Stack([acc_balance, msg_balance, Cell(in_msg), in_msg.body, False]) # Execute Compute Phase compute_ph_res = compute_phase(in_msg, account, acc_balance, msg_balance, params.state_libs, smci, stack, is_masterchain) if not (compute_ph_res is Ok): return ExecutorError.TrExecutorError() descr.compute_ph = compute_ph_res.compute_ph actions = compute_ph_res.actions new_data = compute_ph_res.new_data # Generated outbound messages to be sent into other accounts out_msgs = [] compute_gas_fees = descr.compute_ph.gas_fees tr.total_fee = tr.total_fee + compute_gas_fees if descr.compute_ph.success: act_phase_res = action_phase(tr, account, original_acc_balance, acc_balance, msg_balance, phase.gas_fees, actions, new_data) if act_phase_res is Ok: descr.action = act_phase_res.action_ph out_msgs = act_phase_res.msgs else: return ExecutorError.TrExecutorError() if descr.action != None: if descr.action.status_change == AccStatusChange.Deleted: account = Account() descr.destroyed = True descr.aborted = not descr.action.success else: descr.aborted = True # If the Action Phase failed, and the incoming message allows # bounce answer, execute the Bounce Phase if (descr.aborted == True) and (in_msg.hdr.bounce = True): if descr.compute_ph is Vm: bounce_ph_res = \\ bounce_phase(msg_balance, acc_balance, compute_gas_fees, tr, my_addr) if bounce_ph_res is Ok: descr.bounce = bounce_ph_res.bounce_ph if (bounce_ph_res.bounce_msg != None): out_msgs = out_msgs + [bounce_ph_res.bounce_msg] else: return ExecutorError.TrExecutorError() if descr.bounce is Ok: acc_balance = original_acc_balance if account.status == AccountStatus.AccStateUninit and \\ acc_balance == 0: account = Account() else: if account.is_none() and acc_balance != 0: account = Account.uninit(is_msg.hdr.dst, 0, last_paid, acc_balance) if account.status() == AccountStatus.AccStateUninit and acc_balance == 0: account = Account() tr.acc_end_status = account.status account.balance = acc_balance params.last_tr_lt = lt upd_lt = add_messages(tr, out_msgs, params.last_tr_lt) account.last_tr_time = upd_lt tr.descr = descr return Ok(tr, account)  The function add_messages assigns the proper logical timestamp for each message from the out_msgs collection, and then include the message into the transaction. def add_messages(tr, out_msgs, lt): lt_next = lt + len(out_msgs) + 1 lt_next += 1 for msg in out_msgs: msg.at = now() msg.lt = lt tr.add_out_message(msg) lt_next += 1 return Ok(lt_next)  "},{"title":"External Message Processing Algorithm​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#external-message-processing-algorithm","content":"The execution of external message on the given account. Input: in_msg — incoming message, has type Messageaccount — account, has type Accountparams — executor parameters, has type Parametersconfig — blockchain configuration, has type BlockchainConfig Output: On success, returns Ok(acc1, trans), such that: acc1 — updated account, has type Accounttrans — transaction, has type Transaction On error, returns error of the type TransactionExecutor.TrExecutorError Modifies: account def ExecuteExternalMessage(in_msg, account, params, config): acc_balance = account.balance msg_balance = in_msg.hdr.value is_masterchain = (in_msg.dst_workchain_id == -1) lt = max(account.last_tr_time, max(params.last_tr_lt, in_msg.lt + 1)) tr = Transaction(account.account_id, account.status, lt, now(), Cell(in_msg)) descr = TransactionDescrOrdinary(credit_first: True) in_fwd_fee = fwd_fee(Cell(in_msg)) if acc_balance &lt; in_fwd_fee: return ExecutorError.NoFundsToImportMsg tr.total_fee = tr.total_fee + in_fwd_fee # Execute Storage Phase storage_ph_res = storage_phase(account, acc_balance, tr, is_masterchain, config) descr.storage_ph = storage_ph_res.storage_ph if account.balance &gt;= tr.total_fees: original_acc_balance = account.balance - tr.total_fees else: original_acc_balance = account_balance # Credit Phase is skipped for external messages # Storage phase is completed at this point # We need to update the last_paid field not to loose this # information in case of some further errors showing up account.last_paid = params.block_unixtime # Parameters to be passed into TVM smci = build_contract_info(acc_balance, account.address, params.block_lt, lt, params.seed_block) # First element is the bottom of the stack stack = Stack([acc_balance, msg_balance, Cell(in_msg), in_msg.body, False]) # Execute Compute Phase compute_ph_res = compute_phase(in_msg, account, acc_balance, msg_balance, params.state_libs, smci, stack, is_masterchain) if compute_ph_res is Ok: descr.compute_ph = compute_ph_res.compute_ph else: return ExecutorError.TrExecutorError() # Generated outbound messages to be sent into other # accounts out_msgs = [] compute_gas_fees = descr.compute_ph.gas_fees tr.total_fee = tr.total_fee + compute_gas_fees if descr.compute_ph.success: act_phase_res = action_phase(tr, account, original_acc_balance, acc_balance, msg_balance, phase.gas_fees, accounts, compute_ph_res.new_data) if act_phase_res is Ok: descr.action = act_phase_res.action_ph out_msgs = act_phase_res.msgs else: return ExecutorError.TrExecutorError() if descr.action != None: if descr.action.status_change == AccStatusChange.Deleted: account = Account() descr.destroyed = True descr.aborted = not descr.action.success else: descr.aborted = True # The Bounce Phase is skipped for external messages if account.status() == AccountStatus.AccStateUninit and acc_balance == 0: account = Account() tr.acc_end_status = account.status account.balance = acc_balance params.last_tr_lt = lt upd_lt = add_messages(tr, out_msgs, params.last_tr_lt) account.last_tr_time = upd_lt tr.descr = descr return Ok(tr, account)  "},{"title":"Credit Phase​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#credit-phase","content":"At this phase, coins from the message balance goes to the account balance. This phase is executed only for internal messages. External messages have no coins attached. Input: account — account that the message is executed on, Accounttr — forming transaction, has type Transactionmsg_balance — message balance, has type Gramsacc_balance — current balance of the account, has type Grams Output: The phase always succeeds. It returns the value of type: /Ok(TrCreditPhase(collected, msg_balance))/, such that: collected — the amount of coins withheld for the account debt, if any.msg_balance — the amount of coins put on the account balance after the debt fee was conducted. Modifies: account — updates the due_payment field with the remaining debt, if anytr — updates the total_fees fieldmsg_balance — the original message balance after the debt conducted, if anyacc_balance — the account balance with message coins def credit_phase(account, tr, msg_balance, acc_balance): due_payment = account.due_payment collected = min(due_payment, msg_balance) msg_balance = msg_balance - collected due_payment_remaining = due_payment - collected account.due_payment = due_payment_remaining tr.total_fees = tr.total_fees + collected # put message coins on the account balance acc_balance = acc_balance + msg_balance return Ok(TrCreditPhase(collected, msg_balance))  "},{"title":"Storage Phase​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#storage-phase","content":"This phase withholds the storage fee from the account balance. The fee amount is calculated using the algorithm calc_storage_fee calc_storage_fee Input: account — account that the message is executed on, has type Accounttr — forming transaction, has type Transactionmsg_balance — message balance, has type Gramsacc_balance — current balance of the account, has type Gramsconfig — main blockchain parameters, has type BlockchainConfig Output: This phase always succeeds. The return values may differ Ok(TrStoragePhase(collected, fee, status_change)), such that: collected — the amount of coins withheld for the storage feedebt — if the balance was insufficient, the remaining debt of the accountstatus_change — should the account be frozen or deleted afterwards Modifies: account — updates due_payment and status fieldsacc_balance — the current balance after the fee got deductedtr — updates the total_fee field def storage_phase(account, tr, msg_balance, acc_balance, config): # It is assumed that the current transaction must have a more # recent timestamp than the latest payment timestamp. # Otherwise, something is terribly wrong. assert (tr.now &gt;= acc.last_paid) # The account does not occupy any space, so do not charge the fee if account == None: return Ok(TrStoragePhase()) fee, account.storage_info = config.calc_storage_fee(account.storage_info, is_masterchain, tr.now) if account.due_payment &gt; 0: fee = fee + account.due_payment account.due_payment = None if acc_balance &gt;= fee: acc_balance = acc_balance - fee tr.total_fee = tr.total_fee + fee return Ok(TrStoragePhase(fee, None, AccStatusChange.Unchanged)) storage_fees_collected = acc_balance acc_balance = 0 tr.total_fee = tr.total_fee + storage_fees_collected fee = fee - storage_fees_collected need_freeze = fee &gt; config.get_gas_config(is_masterchanin).freeze_due_limit need_delete = \\ (account.status == AccountStatus.AccStateUninit or \\ account.status == AccountStatus.AccStateFrozen) and \\ fee &gt; config.get_gas_config(is_masterchain).delete_due_limit if need_delete: tr.total_fee = 0 account = Account() return Ok(TrStoragePhase(storage_fees_collected, fee, AccStatusChange.Deleted)) elif need_freeze: account.due_payment = fee if account.status == AccountStatus.AccStateActive: account.status = AccountStatus.AccStateFrozen return Ok(TrStoragePhase(storage_fees_collected, fee, AccStatusChange.Frozen)) else: return Ok(TrStoragePhase(storage_fees_collected, fee, AccStatusChange.Unchanged)) else: account.due_payment = fee return Ok(TrStoragePhase(storage_fees_collected, fee, AccStatusChange.Unchanged))  "},{"title":"Compute Phase​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#compute-phase","content":"Execute the account smart-contract, update the state, gather generated actions to pass on the next phase. Input: msg — message, has type Messageaccount — account, has type Accountacc_balance — current account balance, has type Gramsmsg_balance — message balance,has type Gramsstate_libs — code libraries, has type Blob (not relevant; omitted)smc_info — extra data for TVM, has type SmartContractInfostack — TVM initial stack valuesis_masterchain — is the account belongs to Masterchain, has type bool Output: On success, returns Ok(TrComputePhase, out_actions, new_data), such that: TrComputePhase — actual Compute Phase Descriptorout_actions — an ordered list of generated actionsnew_data — updated smart-contract state On error, returns Err(ExecutorError) with proper code. Modifies: account — updated account statesmc_info — mycode field set to point to the code of the smart-contractacc_balance — account balance after the gas fee deduction def uninit_account(account): if account.storage.state is AccountState.AccountActive: account.storage.state = AccountState.AccountUninit def compute_phase(msg, account, acc_balance, msg_balance, state_libs, smc_info, stack, is_masterchain): result_acc = account.clone() vm_phase = TrComputePhaseVm() is_external = msg.header is ExtInMsgInfo if result_acc == None: new_acc = account_from_message(msg, msg_balance) if new_acc != None: result_acc = new_acc result_acc.last_paid = smc_info.unix_time account = result_acc account.uninit_account() if acc_balance == 0: return Ok(TrComputePhase:skipped(ComputeSkipReason.NoGas), None, None) gas_config = config.get_gas_config(is_masterchain) gas = init_gas(acc_balance, msg_balance, is_external, gas_config) # Is it possible? if gas.gas_limit == 0 and gas.gas_credit == 0: return Ok(TrComputePhase.skipped(ComputeSkipReason.NoGas), None, None) libs = [] if msg.state_init != None: libs = state_init.libraries (reason, result_acc) = result_acc.compute_new_state(acc_balance, msg) if reason != None: return Ok(TrComputePhase.skipped(reason), None, None) vm_phase.gas_credit = gas.gas_credit vm_phase.gas_limit = gas.gas_limit if result_acc.code == None: if is_external: return ExecutorError.NoAcceptError() vm_phase.success = False vm_phase.gas_fees = gas_config.calc_gas_fee(0) if acc_balance &lt; vm_phase.gas_fees: return ExecutorError.TrExecutorError() acc_balance -= vm_phase.gas_fees account = result_acc return Ok(TrComputePhase.Vm(vm_phase), None, None) code = result_acc.code data = result_acc.data libs.push(result_acc.libraries) # local libraries libs.push(state_libs) # masterchain libraries smc_info.mycode = code # Here, we initialize abstract TVM virtual machine. # The exact behavior of this device is out of scope. vm = TVM(code) vm.smc_info = smc_info vm.config = config vm.stack = stack vm.data = data vm.libraries = libs vm.gas = gas result = vm.execute() vm_phase.success = vm.commited_state.is_committed # vm.gas may have been updated after the execution gas_vm = vm.gas # how much credited gas remains unspent credit = gas_vm.gas_credit used = gas_vm.gas_used vm_phase.gas_used = used if credit != 0: if is_external: # The smart-contract has to explicitly accept the external message, # otherwise it gets rejected. The acceptance of a message manifests # itself in the credit field being equal to 0. return ExecutorError.NoAcceptError() vm_phase.gas_fees = 0 else: gas_fees = gas_config.calc_gas_fee(used) vm_phase.gas_fees = gas_fees vm_phase.mode = 0 vm_phase.vm_steps = vm.steps new_data = vm.commited_state if new_data == None: vm_phase.success = False out_actions = vm.actions if out_actions = None: vm_phase.success = False account = result_acc return Ok(TrComputePhase.Vm(vm_phase), out_actions, new_data)  "},{"title":"Compute Phase Success Conditions​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#compute-phase-success-conditions","content":"We would like to explicitly articulate what it means for theCompute Phase to succeed. To do that,we specify the opposite condition, i.e. when it fails. In all other scenarios the phase is considered successful. The success status is important, because it decides if the action phase has to be executed afterwards. For the phase to fail, one of the following conditions must hold: The smart-contract data is not committed after the execution1The new smart-contract data is ill-formedThe generated actions list is ill-formed caution The compute phase may be considered successful even if the computation thrown an exception. This is quite unintuitive, yet very important fact. "},{"title":"Compute Phase Exit Code​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#compute-phase-exit-code","content":"The exit code value shows if the computation finished normally or was aborted due to some exception. In case of the former, the exit code should have values 0 or 1. In case of the latter, the exception might be of a system or custom type. If the exception is a system one, i.e. not intentionally emitted by the code using a special TVM instruction, the exit code contains one of the standard exit codes. If the exception is custom, then the exit code should also equal to 0 or 1, but there is an extra exit_arg field that provides the user defined code. For standard TVM exception codes, see here. "},{"title":"Calculate Gas Fee Algorithm​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#calculate-gas-fee-algorithm","content":"The algorithm to calculate the amount of coins to be paid for the consumed gas. Input: gas_prices — a structure with actual gas prices, has type GasLimitsPricegas_used — amount of gas units consumed by the computation, has type Uint Output: The amount of coins to be paid for the gas. Modifies: None. def calc_gas_fee(gas_prices, gas_used): if gas_used &lt;= gas_prices.flat_gas_limit: return gas_prices.flat_gas_limit gas_fee = flat_gas_price + (gas_used - gas_prices.flag_gas_limit) * \\ gas_prices.gas_price return gas_fee  "},{"title":"Compute New State Algorithm​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#compute-new-state-algorithm","content":"The algorithm compute_new_state computes the actual account state by given account record, the balance and the message. In particular, this algorithm is used to initialize uninitialized accounts with code and data borrowed from an external message with non-emptystate_init field. Input: account — account structure, has type Accountacc_balace — current account balance, has type Uintin_msg — message being executed, has type Message Output: On success, returns None.On failure, returns one of the ComputeSkipReason codes. Modifies: account def compute_new_state(account, acc_balance, in_msg): if account.status == AccountStatus.AccStateNonexist: if in_msg.state_init == None: return ComputeSkipReason.NoState else: return ComputeSkipReason.BadState elif account.status == AccountStatus.AccStateActive: return None elif account.status == AccountStatus.AccStateUninit: if in_msg.state_init != None: if account.try_activate_by_init_code_hash(in_msg.state_init) != None: return None else: return ComputeSkipReason.BadState else: return ComputeSkipReason.NoState elif account.status == AccountStatus.AccStateFrozen: if acc_balance != 0 and in_msg.state_init != None: if account.try_activate_by_init_code_hash(in_msg.state_init) != None: return None else: return ComputeSkipReason.BadState return ComputeSkipReason.NoState return None  "},{"title":"Activate By Init Algorithm​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#activate-by-init-algorithm","content":"The algorithm try_activate_by_init_code_hash does the initialization or re-initialization of the account, with the given state_init. Input: account — account structure to be initializedstate_init — state_init field from the inbound message Output: On success, returns OkOn failure, returns Err Modifies: account — the field storage.state gets updated by the state_init on success def try_activate_by_init_code_hash(account, state_init): if account == None: return Err new_state = None if account.storage.state == AccountState.AccountUninit: if hash(state_init) == account.addr.address: new_state = AccountState.AccountActive( hash(state_init.code), state_init ) else: return Err elif account.storage.state == \\ AccountState.AccountFrozen(init_code_hash, state_init_hash): if state_init_hash == hash(state_init): new_state = AccountState.AccountActive(init_code_hash, state_init) else: return Err else: new_state = account.storage.state account.storage.state = new_state return Ok  "},{"title":"Initial Gas Algorithm​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#initial-gas-algorithm","content":"The algorithm computes TVM Gas-related initial values. Those values are provided to the virtual machine right before a smart-contract execution. If the execution takes more than allowed gas, it gets stopped. Input acc_balance: current account balancemsg_balance: message balanceis_external: is the message externalgas_info: structure with limits and prices for the workchain Output Returns the structure Gas() containing 4 values: gas_limit: the maximum gas value available for any smart-contract of the workchaingas_credit: the amount of gas to be credited for the execution before the smart-contract accepts the messagegas_max: the maximum allowed gas to be spent on the execution of the current smart-contractgas_prices: a structure with gas prices Modifies: None def init_gas(acc_balance, msg_balance, is_external, gas_info): gas_max = min(gas_info.gas_limit, gas_info.calc_gas(acc_balance)) gas_credit = 0 if is_external: gas_credit = min(gas_info.gas_credit, gas_max) gas_limit = gas_credit else: gas_limit = min(gas_max, gas_info.calc_gas(msg_balance)) return Gas(gas_limit, gas_credit, gas_max, gas_info.get_real_gas_price())  "},{"title":"Account From Message Algorithm​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#account-from-message-algorithm","content":"The algorithm creates new account by using data from the internal message. External messages are rejected. Creation of a new account based on an external message is located elsewhere. Seecompute_new_state algorithm. Input msg: incoming message being processed, has type Messagemsg_remaining_balance: the current amount of coins left on the message balance, has type Uint Output Either returns a new Account object, or None. Both results are considered successful. Modifies: None def account_from_message(msg, msg_remaining_balance): if not (msg.header is IntMsgInfo): return None if msg_remaining_balance == 0: return None header = msg.header init = msg.state_init if init != None and init.code != None and hash(init) == header.dst.address: return Account.active_by_init_code_hash(hdr.dst, msg_remaining_balance, 0, init) if header.bounce: return None else: return Account.uninit(hdr.dst, 0, 0, msg_remaining_balance)  "},{"title":"Action Phase​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#action-phase","content":"By given ordered action list, the Action phase executes each action item in the list by applying proper action handler. Input: tr — transaction being constructed, has type Transactionaccount — account executing the message, has type Accountoriginal_acc_balance — account balance after storage and credit phase, has type Uintacc_balance — the mutable copy of the original_acc_balance, has type Uintmsg_remaining_balance — message balance without debt value if any, has type Uintcompute_phase_fees — gas fees from the compute phase, has type Uintactions — list of actions generated on the Compute Phase, has type list(OutAction)new_data — the smart-contract data after the Compute Phase, some binary blob. Output: On success, returns Ok(phase, messages) such that: phase denotes the Action Phase Descriptormessages denotes a list of messages to be sent, has type list(Message) On error, returns Err(result_code), such that: result_code describes a type of an error, see here. Modifies: traccountacc_balancemsg_remaining_balance MAX_ACTIONS = 255 def action_phase(tr, account, original_acc_balance, acc_balance, msg_remaining_balance, compute_phase_fees, actions, new_data): acc_copy = account.clone() acc_remaining_balance = acc_balance phase = TrActionPhase() total_reserved_value = 0 # Serialization issues are put aside, it is too low-level for # our purpose. # Interesting to note, actions overload leads to OK, not Error? if len(actions) &gt; MAX_ACTIONS: phase.result_code = RESULT_CODE_TOO_MANY_ACTIONS return Ok(phase, []) phase.action_list_hash = hash(actions) phase.tot_actions = len(actions) account_deleted = False out_msgs_tmp = [] address = acc_copy.address for action in actions: if action is OutAction.SendMsg: if action.mode &amp; SENDMSG_ALL_BALANCE: out_msgs_tmp.push((action.mode, action.out_msg)) continue result = outmsg_action_handler(phase, action.mode, action.out_msg, acc_remaining_balance, msg_remaining_balance, compute_phase_fees, config, address, total_reserved_value, account_deleted) if result is Ok: phase.msgs_created += 1 out_msgs_tmp.push((action.mode, action.out_msg)) else: return result elif action is OutAction.ReserveCurrency: result = reserve_action_handler(action.mode, action.value, original_acc_balance, acc_remaining_balance) if result is Ok: phase.spec_actions += 1 total_reserved_value += result.reserved_value else: phase.valid = True phase.result_code = result # phase.no_funds = True return Ok(phase, []) else: return Ok(phase, []) # process messages that have SENDMSG_ALL_BALANCE flag set last # skipping all other already processed messages out_msgs = [] for (mode, out_msg) in out_msgs_tmp: if not (mode &amp; SENDMSG_ALL_BALANCE): out_msgs.push(out_msg) continue result = outmsg_action_handler(phase, mode, out_msg, acc_remaining_balance, msg_remaining_balance, compute_phase_fees, config, address, total_reserved_value, account_deleted) if result == Ok: phase.msgs_created += 1 out_msgs.push(out_msg) else: return Ok(phase, []) acc_remaining_balance += total_reserved_value tr.total_fee += phase.total_action_fees if account_deleted: phase.status_change = AccStatusChange.Deleted phase.valid = True phase.success = True acc_balance = acc_remaining_balance account = acc_copy account.data = new_data return Ok(phase, out_msgs)  "},{"title":"Action Phase Success Condition​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#action-phase-success-condition","content":"All actions formed at the Compute Phase were successfully processed. If an action had a special error-canceling flag set, such error will not result in the whole phase failure. The action will be skipped in this case. "},{"title":"Action Phase Validity Condition​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#action-phase-validity-condition","content":"To specify the validity condition, we will define the opposite, i.e. when the action phase is considered invalid. The number of actions in the action list is greater than MAX_ACTIONSAny SendMsg action processing finished with an errorThe unknown action type was found during the processing In all other cases, the action phase is considered valid. "},{"title":"SendMsg Action Handler​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#sendmsg-action-handler","content":"The SendMsg action handler is responsible for generating messages to be sent. It may fail due to several reasons. In this case, the action phase get stopped, unless the SENDMSG_IGNORE_ERROR flag is set. Input: phase — actual Action Phase Descriptormode — flags for sending the messagemsg — message being sent, has type Messageacc_balance — actual account balance, has type UIntmsg_balance — the message balance after debt being deducted, has type Uintcompute_phase_fees — gas fees from Compute Phaseconfig — blockchain configuration, has type BlockchainConfigmy_addr — account addressreserved_value — the value of coins reserved by the ReserveCoins actionsaccount_deleted — the output value, set to True if account needs to be deleted Output: On success, returns Ok(value), such that: value — the amount of coins to be deducted from the account balance On failure, returns Err(result_code), such that: result_code — describes the error, see here Modifies: phasemodemsgacc_balancemsg_balanceaccount_deleted MAX_MSG_BITS = 2**21 # 2 Mb MAX_MSG_CELLS = 2**13 def get_fwd_prices(config, is_masterchain): if is_masterchain: return config.fwd_prices_mc else: return config.fwd_prices_wc def outmsg_action_handler(phase, mode, msg, acc_balance, msg_balance, compute_phase_fees, config, my_addr, reserved_value, account_deleted): invalid_flags = SENDMSG_REMAINING_MSG_BALANCE or SENDMSG_ALL_BALANCE mode_not_valid = mode and (not SENDMSG_VALID_FLAGS) mode_has_invalid = mode and invalid_flags == invalid_flags mode_delete_not_sab = (mode and SENDMSG_DELETE_IF_EMPTY) and \\ (not (mode and SENDMSG_ALL_BALANCE)) if mode_not_valid or mode_has_invalid or mode_delete_not_sab: return Err(RESULT_CODE_UNSUPPORTED) skip = not (mode and SENDMSG_IGNORE_ERROR) msg.header.src = my_addr fwd_prices = config.get_fwd_prices(msg.is_masterchain()) compute_wd_fee = fwd_prices.fwd_fee(Cell(msg)) # The message should be either internal message or event. # It is impossible to send external message from the smart-contract. if not ((msg.header is IntMsgInfo) or (msg.header is ExtOutMsgInfo)): return Err(-1) if msg.header is IntMsgInfo: # ===================================== # Internal message # ===================================== msg.header.bounced = False result_value = msg.header.value msg.header.ihr_disabled = True msg.header.ihr_fee = 0 fwd_fee = max(msg.header.fwd_fee, compute_wd_fee) fwd_mine_fee = fwd_prices.mine_fee(fwd_fee) total_fwd_fees = fwd_fee + msg.header.ihr_fee fwd_remain_fee = fwd_fee - fwd_mine_fee if (mode and SENDMSG_ALL_BALANCE): result_value = acc_balance msg.header.value = acc_balance mode = (mode and (not SENDMSG_PAY_FEE_SEPARATELY)) if (mode and SENDMSG_REMAINING_MSG_BALANCE): # Send all the remaining balance of the inbound message result_value += msg_balance if not (mode and SENDMSG_PAY_FEE_SEPARATELY): if result_value &lt; compute_phase_fees: return Err() result_value -= compute_phase_fees msg.header.value = result_value if (mode and SENDMSG_PAY_FEE_SEPARATELY): result_value += total_fwd_fees else: if msg.header.value &lt; total_fwd_fees: return Err() else: msg.header.value -= total_fwd_fees msg.header.fwd_fee = fwd_remain_fee else: # ===================================== # Event # ===================================== fwd_mine_fee = compute_fwd_fee total_fwd_fees = compute_fwd_fee result_value = compute_fwd_fee if acc_balance &lt; result_value: return Err(RESULT_CODE_NOT_ENOUGH_GRAMS) if (mode and SENDMSG_DELETE_IF_EMPTY) and \\ (mode and SENDMSG_ALL_BALANCE) and \\ (acc_balance + reserved_value == 0): account_deleted = True if total_fwd_fees != 0: phase.total_fwd_fees += total_fed_fees if fwd_mine_fee != 0: phase.total_action_fees += fwd_mine_fee phase.tot_msg_size.append(Cell(msg)) if phase.tot_msg_size.bits() &gt; MAX_MSG_BITS or \\ phase.tot_msg_size.cells() &gt; MAX_MSG_CELLS: return Err(RESULT_CODE_INVALID_BALANCE) if mode and (SENDMSG_ALL_BALANCE or SENDMSG_REMAINING_MSG_BALANCE): msg_balance = 0 return Ok(result_value)  "},{"title":"ReserveCurrency Action Handler​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#reservecurrency-action-handler","content":"ReserveCurrency action handler is responsible for managing the reserve coins. Input: mode — Reserve flags for the reserve action, has type Uintval — amount of coins to be reserved, has type Uintorig_acc_balance — account balance after the deduction of the storage fee and the debt, if any, has type Uintacc_remaining_balance — amount of coins left on the balance after the reserve, has type Uint Output: On success, returnsOk(reserved) value, such that: reserved denotes the amount of coins being reserved for the account On failure, returns Err(result_code), such that: result_code Modifies: acc_remaining_balance — remaining account balance after the reserve amount being withheld def reserve_action_handler(mode, val, orig_acc_balance, acc_remaining_balance): if mode and (not RESERVE_VALID_MODES): return Err(RESULT_CODE_UNKNOWN_OR_INVALID_ACTION) reserved = 0 if mode and RESERVE_PLUS_ORIG: if mode and RESERVE_REVERSE: reserved = orig_acc_balance if reserved &lt; val: return Err(RESULT_CODE_UNSUPPORTED) reserved -= val else: reserved = val reserved += orig_acc_balance else: if mode and RESERVE_REVERSE: return Err(RESULT_CODE_UNKNOWN_OR_INVALID_ACTION) reserved = val if mode and RESERVE_IGNORE_ERROR: reserved = min(reserved, acc_remaining_balance) remaining = acc_remaining_balance if remaining &lt; reserved: return Err(RESULT_CODE_NOT_ENOUGH_GRAMS) remaining -= reserved remaining, acc_remaining_balance = acc_remaining_balance, remaining if mode and RESERVE_ALL_BUT: reserved, acc_remaining_balance = acc_remaining_balance, reserved return Ok(reserved)  "},{"title":"Bounce Phase​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#bounce-phase","content":"If error happens on the previous phases, the bounce phase takes place. Input: remaining_msg_balance — message balance after all previous phases executed, has type Uintacc_balance — remaining account balance after all previous phases executed, has type Uintcompute_phase_fees — the fees of the compute phase, has type Uintmsg — message being processed, has type Messagetr — transaction object, has type Transaction Output: On success, returns Ok(TrBouncePhase, bounce_message), such that: TrBouncePhase is a Bounce Phase Descriptorbounce_message is a bounce message to be included into the out_msgs queue On error, returns /ExecutorError.TrExecutorError/ Modifies: tr — adds the bounce message delivery fee to the total NOTE: Function get_fwd_prices() was defined here. def bounce_phase(remaining_msg_balance, acc_balance, compute_phase_fees, msg, tr): header = msg.header if not header.bounce: return ExecutorError.TrExecutorError() header2 = header.clone() header2.src, header2.dst = header.dst, header.src storage = StorageUsedShort() fwd_prices = config.get_fwd_prices(msg.is_masterchain) fwd_full_fees = fwd_prices.fwd_fee(Cell()) fwd_mine_fees = fwd_prices.mine_fee(fwd_full_fees) fwd_fees = fwd_full_fees - fwd_mine_fees if remaining_msg_balance &lt; fwd_full_fees + compute_phase_fees: return Ok(TrBouncePhase.no_funds, None) acc_balance -= remaining_msg_balance remaining_msg_balance -= fwd_full_fees remaining_msg_balance -= compute_phase_fees header2.ihr_disabled = True header2.bounce = False header2.bounced = True header2.ihr_fee = 0 header2.fwd_fee = fwd_fees header2.value = remaining_msg_balance bounce_msg = Message.with_header(header2) if config.has_capability(GlobalCapabilities.CapBounceMsgBody): body = msg.body.clone() body.shrink_data(0..256) # leave only 256 bits of the original body bounce_msg.body = body tr.total_fees += fwd_mine_fees return Ok(TrBouncePhase.ok(storage, fwd_mine_fees, fwd_fees), bounce_msg)  "},{"title":"Functional Properties​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#functional-properties","content":"In this section, we define the main risks of malfunction in the module, and define several higher-level properties that should hold for the module to mitigate those risks. "},{"title":"Risks​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#risks","content":"We define a risk as a hazard event causing a significant loss for the end user. We distinguish the following types of risks. Financial Risks​ The Transaction Executor is the only place in the Node that is responsible for changing the account balance. Hence, any errors in related operations lead to tokens loss for the user. We identify the following financial risks for the module: Incorrect storage, delivery or gas fees calculation logicIncorrect message value processing logicIncorrect SendMsg, ReserveCoins actions processing logic Behavioral Risks​ Everscale blockchain praises the distributed programming paradigm in application development. It means that instead of producing huge smart-contract monoliths, it is encouraged to separate the system into many manageable smart-contracts that communicate with each other by means of message passing. The message passing scheme used in a system induces some protocol. If message passing breaks in an unexpected way, the whole protocol may stall, potentially leading to global system deadlocks. It is of utter importance to guarantee that all produced correct messages will be eventually delivered to the destination account. The delivery process is complicated and rely on several node components. Here, we identify risks related to the Transaction Executor part of it: Successful SendMsg action does not lead to creation of a corresponding messageGenerated messages do not occur in the Out Message queueMessage delivery order gets brokenA bounce message does not get generated as expected "},{"title":"Assumptions​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#assumptions","content":"All the properties formulated with the following assumptions in mind: We consider only ordinary accounts, not system (special) accounts. For the latter, the properties might look different. "},{"title":"System Properties​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#system-properties","content":"System properties are high-level general statements on the system behavior that the Transaction Executor should obey to. A subset of those statements related to mitigating the main risks, identified in the previous section. Fees​ FEE1 — Gas fees for the computation equal the amount calculated using the algorithm calc_gas_fee.FEE2 — Storage fees for an account equal the amount calculated using the algorithm calc_storage_fee.FEE3 — Forwarding fees are calculated according to the algorithm message_passing_fees .FEE4 — During the message execution process, all type of fees get deducted only once for an account. Message Processing​ MSG1 — The message coins get credited to the account balance before executing a smart-contract logic.MSG2 — Messages delivery order between the current account a1a_1a1​ and some other account a2a_2a2​does not depend on messages sent from a1a_1a1​ to some other account a3a_3a3​, when a2≠a3a_2 \\neq a_3a2​=a3​. Credit Phase Processing​ CRD1 — If the inbound message is external, the credit phase does not get executed.CRD2 — If the inbound message is internal, the account's balance get credited with the message value minus the account debt, if any. Storage Phase Processing​ STR1 — If there is not enough funds to cover the storage phase fee on the account's balance, and if the account is in the Active status, then the account gets a debt storing in the due_payment field of the account. If the debt value exceeds the freeze_due_limit value, the account is switched into a frozen status. If the debt exceeds the delete_due_limit value, the account gets deleted. Compute Phase Processing​ CMP1 — If the Compute Phase fails, the execution of a message is aborted. The bounce message is not created in this case.CMP2 — After the Compute Phase, the account's balance gets decreased exactly on the amount of consumed gas. Action Phase Processing​ ACT1 — Each successful SendMsg action leads to creation of a message.ACT2 — Successfully created message is added into the out queue exactly once.ACT3 — If the action phase fails and the incoming message has the bounce flag set, then a single bounce message is generated and put into the out queue. Bounce Phase Processing​ BNC1 — The bounce message is generated only if and only if all of the following conditions hold: 1) The incoming message is an internal message 2) The incoming message has the bounce flag set 3) During the message processing, the action phase was executed, but failed 4) After the failed action phase, there is enough funds left on the incoming message balance to cover the bounce message processing2. BNC2 — A bounce message attach all the original message value minus the storage, gas and delivery fees. "},{"title":"Footnotes​","type":1,"pageTitle":"Transaction executor","url":"arch/executor#footnotes","content":"Well, at least, until the part of the chain residing the transaction gets cut-off to reduce the disk space consumption.↩See the definition of COMMIT TVM instruction.↩ "},{"title":"Comparison with Solidity Contracts","type":0,"sectionRef":"#","url":"develop/from-another-platform/comparison-with-solidity","content":"Comparison with Solidity Contracts","keywords":""},{"title":"Bridge integration","type":0,"sectionRef":"#","url":"develop/integrate/bridge-integration","content":"Bridge integration","keywords":""},{"title":"Hackathons & Grants","type":0,"sectionRef":"#","url":"develop/hackathons-grants","content":"Hackathons &amp; Grants","keywords":""},{"title":"Add EVER to your Exchange","type":0,"sectionRef":"#","url":"develop/integrate/tutorial/add-everscale-to-your-exchange","content":"Add EVER to your Exchange","keywords":""},{"title":"How to read Network details","type":0,"sectionRef":"#","url":"develop/integrate/tutorial/how-to-read-network-details","content":"How to read Network details","keywords":""},{"title":"Getting started","type":0,"sectionRef":"#","url":"develop/integrate/tutorial/getting-started","content":"Getting started","keywords":""},{"title":"Overview","type":0,"sectionRef":"#","url":"develop/overview","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Overview","url":"develop/overview#introduction","content":"Welcome to the most exciting and innovative platform to build your blockchain application on Everscale Blockchain. Blockchain technology is poised to revolutionize the way the digital world handles data and does business. Be a part of this revolution and get a head start with decentralized application development on Everscale. This page will tell you how to best choose the development approaches and tools for yourself. Attention! Before you read this article, we recommend that you study the Everscale Overview page and the block of pages in the Architecture section if you want to develop complex products on the Everscale blockchain. "},{"title":"Let’s start​","type":1,"pageTitle":"Overview","url":"develop/overview#lets-start","content":"Before you start developing or integrating anything into Everscale, we would like to tell you about the tools and environment that you will use in your work. First of all, it is worth noting that Everscale is really a decentralized blockchain, not only from a technical point of view, but also from a management side, so the key tools and approaches to development may differ from different teams, technical contributors on the network. At the moment, there are two active companies of technical contributors in Everscale network: BroxusEverX And it is their solutions and tools that you will use when developing, while you will have every opportunity to write your own solutions as well, if necessary or desired. You can learn more in the Development tools section. Here are ways to dive into development on Everscale for any case you need We assume that there are several main cases of developers interacting with Everscale: Build your dApp - knowledge of network architecture, understanding of smart contracts, standards and node devices will be useful to you. Learn the network architectureLearn the standardsLearn the development toolsLearn the specifics of writing smart contractsLearn how to issue tokensExplore the development team incentive programs in Everscale Migrate your dApp from another network Learn the network architectureLearn the comparison with EthereumLearn the comparison of Ethereum contractsLearn the development toolsLearn how to write contracts on Solidity Integrate Everscale blockchain in your on-chain or off-chain project - you'll find it helpful to explore the Everscale Overview page as well as the pages block in Architecture, after which it's a good idea to take a look at Getting Started in the Integrate section. Learn Everscale Overview pageLearn how to integrate anything with EverscaleLearn the development toolsLearn popular integration cases(exchange integration) "},{"title":"More useful links​","type":1,"pageTitle":"Overview","url":"develop/overview#more-useful-links","content":"Join onboarding chat for developersExplore helpful development articlesLearn developer tools "},{"title":"Contract management","type":0,"sectionRef":"#","url":"develop/sdk-tools/contract-management","content":"Contract management","keywords":""},{"title":"Ever.bytie.moe","type":0,"sectionRef":"#","url":"develop/sdk-tools/ever-bytie","content":"Ever.bytie.moe","keywords":""},{"title":"Ever Cloud","type":0,"sectionRef":"#","url":"develop/sdk-tools/ever-cloud","content":"Ever Cloud","keywords":""},{"title":"Everdev CLI","type":0,"sectionRef":"#","url":"develop/sdk-tools/everdev-cli","content":"Everdev CLI","keywords":""},{"title":"C++","type":0,"sectionRef":"#","url":"develop/sdk-tools/everdev/command-line-interface/c","content":"","keywords":""},{"title":"Create your first contract​","type":1,"pageTitle":"C++","url":"develop/sdk-tools/everdev/command-line-interface/c#create-your-first-contract","content":"This command creates a basic C++ contract with comments that you can observe and compile. everdev clang create Contract  "},{"title":"Compile​","type":1,"pageTitle":"C++","url":"develop/sdk-tools/everdev/command-line-interface/c#compile","content":"This command compiles and links a selected C++ contract. After successful compilation you get .abi.json and .tvc files that you can later use in your DApps to deploy and run contract methods. everdev clang compile Contract.cpp  "},{"title":"Version​","type":1,"pageTitle":"C++","url":"develop/sdk-tools/everdev/command-line-interface/c#version","content":"This command shows the currently installed C++ compiler version. everdev clang version  "},{"title":"Update​","type":1,"pageTitle":"C++","url":"develop/sdk-tools/everdev/command-line-interface/c#update","content":"This command updates the compiler to the latest version. everdev clang update  Use --force or -f option to force reinstall, if the compiler is already up to date. "},{"title":"Set​","type":1,"pageTitle":"C++","url":"develop/sdk-tools/everdev/command-line-interface/c#set","content":"This command sets the compiler version and downloads it if needed. everdev clang set --compiler 7.0.0  Use --force or -f option to force reinstall, if the current version is the same as the requested version. "},{"title":"DeBrowser","type":0,"sectionRef":"#","url":"develop/sdk-tools/everdev/command-line-interface/debrowser","content":"","keywords":""},{"title":"Version​","type":1,"pageTitle":"DeBrowser","url":"develop/sdk-tools/everdev/command-line-interface/debrowser#version","content":"This command shows the list of available versions. everdev debrowser version Available Versions: 1.1.0, 1.2.0, 1.2.1, 1.3.1  "},{"title":"Interfaces​","type":1,"pageTitle":"DeBrowser","url":"develop/sdk-tools/everdev/command-line-interface/debrowser#interfaces","content":"This command shows the list of implemented interfaces. everdev debrowser interfaces Realised interfaces: - Address Input - Amount Input - Confirm Input - Menu - Network - Number Input - QR Code - Signing Box Input - Terminal - User Info  "},{"title":"Start​","type":1,"pageTitle":"DeBrowser","url":"develop/sdk-tools/everdev/command-line-interface/debrowser#start","content":"This command downloads image and starts DeBrowser container (Docker must be launched). everdev debrowser start 1.3.1  "},{"title":"Stop​","type":1,"pageTitle":"DeBrowser","url":"develop/sdk-tools/everdev/command-line-interface/debrowser#stop","content":"This command stops DeBrowser container. everdev debrowser stop  "},{"title":"Evernode SE","type":0,"sectionRef":"#","url":"develop/sdk-tools/everdev/command-line-interface/evernode-platform-startup-edition-se","content":"","keywords":""},{"title":"Start​","type":1,"pageTitle":"Evernode SE","url":"develop/sdk-tools/everdev/command-line-interface/evernode-platform-startup-edition-se#start","content":"This command starts the Evernode SE container (Docker must be launched). When executed for the first time downloads the latest SE image from dockerhub. everdev se start  To make sure ArangoDB starts, set the ArangoDB port. "},{"title":"Version​","type":1,"pageTitle":"Evernode SE","url":"develop/sdk-tools/everdev/command-line-interface/evernode-platform-startup-edition-se#version","content":"This command shows the default Evernode SE version and list of other available versions. everdev se version default: 0.24.12 Available Versions: 0, 0.24, 0.24.5, 0.24.6, 0.24.8, 0.24.9, 0.24.10, 0.24.11, 0.24.12, latest  "},{"title":"Set​","type":1,"pageTitle":"Evernode SE","url":"develop/sdk-tools/everdev/command-line-interface/evernode-platform-startup-edition-se#set","content":"This command switches Evernode SE to the specified version and port and downloads it, if it is missing. Attention! This command does not start TON OS SE, you need to run start command separately. everdev se set --version 0.24.11 --port 2020  To make sure ArangoDB starts, use --db-port option to set the ArangoDB port: everdev se set --db-port 8081  "},{"title":"Reset​","type":1,"pageTitle":"Evernode SE","url":"develop/sdk-tools/everdev/command-line-interface/evernode-platform-startup-edition-se#reset","content":"This command resets the Evernode SE container (Docker must be launched) - restarts it from scratch with a clean database. everdev se reset  "},{"title":"Update​","type":1,"pageTitle":"Evernode SE","url":"develop/sdk-tools/everdev/command-line-interface/evernode-platform-startup-edition-se#update","content":"This command downloads the latest Evernode SE image (Docker must be launched) and starts it. everdev se update  "},{"title":"Stop​","type":1,"pageTitle":"Evernode SE","url":"develop/sdk-tools/everdev/command-line-interface/evernode-platform-startup-edition-se#stop","content":"This command stops Evernode SE container. everdev se stop  "},{"title":"Info​","type":1,"pageTitle":"Evernode SE","url":"develop/sdk-tools/everdev/command-line-interface/evernode-platform-startup-edition-se#info","content":"This command shows info about the downloaded versions. everdev se info Instance State Version GraphQL Port ArangoDB Port Docker Container Docker Image -------- ------- ------- ------------ ------------- -------------------------- -------------------------- default running 0.24.12 2020 tonlabs-tonos-se-ekaterina tonlabs/local-node:0.24.12  "},{"title":"Contract Management","type":0,"sectionRef":"#","url":"develop/sdk-tools/everdev/command-line-interface/contract-management","content":"","keywords":""},{"title":"View contract info​","type":1,"pageTitle":"Contract Management","url":"develop/sdk-tools/everdev/command-line-interface/contract-management#view-contract-info","content":"This command displays a detailed summary for a contract. Contract ABI and TVC files are required to run it. Account address on the network is calculated from TVC and signer. everdev contract info abi_filename  Result example: $ everdev contract info SetcodeMultisigWallet.abi.json Configuration Network: dev (eri01.net.everos.dev, rbx01.net.everos.dev, gra01.net.everos.dev) Signer: test (public ad4bf7bd8da244932c52127a943bfa9217b6e215c1b3307272283c4d64f34486) Address: 0:04dee1edc3f3d6b23529dcf5a6133627d06a39826bb14cc6334ffea272b15d50 (calculated from TVC and signer public) Code Hash: e2b60b6b602c10ced7ea8ede4bdf96342c97570a3798066f3fb50a4b2b27a208 (from TVC file) Account: Active Balance: 1919381000 (≈ 2 tokens) Details: { &quot;json_version&quot;: 5, &quot;id&quot;: &quot;0:04dee1edc3f3d6b23529dcf5a6133627d06a39826bb14cc6334ffea272b15d50&quot;, &quot;workchain_id&quot;: 0, &quot;boc&quot;: &quot;te6ccgECZwEAGvQAAm/AAE3uHtw/PW ... 4MEDIoIQ/////byxkOAB8AH4R26Q3o (6912 bytes)&quot;, &quot;last_paid&quot;: 1619084675, &quot;bits&quot;: &quot;0xcbc7&quot;, &quot;cells&quot;: &quot;0x67&quot;, &quot;public_cells&quot;: &quot;0x0&quot;, &quot;last_trans_lt&quot;: &quot;0x3baac81fb43&quot;, &quot;balance&quot;: &quot;0x72676e08&quot;, &quot;code&quot;: &quot;te6ccgECXwEAGcoAAib/APSkICLAAZ ... wQMighD////9vLGQ4AHwAfhHbpDeg= (6614 bytes)&quot;, &quot;code_hash&quot;: &quot;e2b60b6b602c10ced7ea8ede4bdf96342c97570a3798066f3fb50a4b2b27a208&quot;, &quot;data&quot;: &quot;te6ccgEBBwEA7gAC361L972NokSTLF ... S/Xy90TNN3lUFM1WGpdlIcBQDAAAFA (249 bytes)&quot;, &quot;data_hash&quot;: &quot;ec28abd34e75f40a66561bdc06b436cbe24d10d5da7519a7d5db41026c67155d&quot;, &quot;acc_type&quot;: 1, &quot;acc_type_name&quot;: &quot;Active&quot; }  Network, signer, data and account address parameters can be overridden with the following options: $ everdev contract info -h EverDev Version: 0.5.0 Use: everdev contract info file [options] Args: file ABI file Options: --help, -h Show command usage --network, -n Network name --signer, -s Signer key name --data, -d Deploying initial data as name:value,... This data is required to calculate the account address and to deploy contract. Array values must be specified as [item,...]. Spaces are not allowed. If value contains spaces or special symbols &quot;[],:&quot; it must be enclosed in &quot;&quot; or '' --address, -a Account address  "},{"title":"Deploy contract​","type":1,"pageTitle":"Contract Management","url":"develop/sdk-tools/everdev/command-line-interface/contract-management#deploy-contract","content":"This command deploys a contract to the blockchain. Contract ABI and TVC files are required to run it. everdev contract deploy abi_filename  Command displays deployment summary and requests constructor function parameters. Result example: $ everdev contract deploy Contract.abi.json Configuration Network: dev Signer: sign1 Address: 0:0435cb4e70585759ac514bb9fd1770caeb8c3941d882b5a16d589b368cb49261 Enter constructor parameters param1 (uint256[]): value Enter constructor parameters param2 (uint8): value Deploying...  Deploy parameters can be specified in the deploy command with the following options: $ everdev contract deploy -h EverDev Version: 0.5.0 Use: everdev contract deploy file function [options] Args: file ABI file function Function name Options: --help, -h Show command usage --network, -n Network name --signer, -s Signer key name --input, -i Function parameters as name:value,... Array values must be specified as [item,...]. Spaces are not allowed. If value contains spaces or special symbols &quot;[],:&quot; it must be enclosed in &quot;&quot; or '' --data, -d Deploying initial data as name:value,... This data is required to calculate the account address and to deploy contract. Array values must be specified as [item,...]. Spaces are not allowed. If value contains spaces or special symbols &quot;[],:&quot; it must be enclosed in &quot;&quot; or '' --value, -v Deploying balance value in nano tokens --prevent-ui, -p Prevent user interaction Useful in shell scripting e.g. on server or in some automating to disable waiting for the user input. Instead everdev will abort with error. For example when some parameters are missing in command line then ton dev will prompt user to input values for missing parameters (or fails if prevent-ui option is specified).  Example of a 2/3 multisig wallet deployment command: everdev contract deploy SetcodeMultisigWallet.abi.json constructor -n dev -s sign1 -i owners:[0xad4bf7bd8da244932c52127a943bfa9217b6e215c1b3307272283c4d64f34486,0x5c2e348c5caeb420a863dc5e972f897ebe5ee899a6ef2a8299aac352eca4380a,0x8534c46f7a135058773fa1298cb3a299a5ddd40dafe41cb06c64f274da360bfb],reqConfirms:2  "},{"title":"Run contract deployed on the network​","type":1,"pageTitle":"Contract Management","url":"develop/sdk-tools/everdev/command-line-interface/contract-management#run-contract-deployed-on-the-network","content":"This command runs any function of a contract deployed on the blockchain. Contract ABI and TVC files are required to run it. everdev contract run abi_filename  Command displays available functions and asks to select one. Result example: $ everdev contract run Contract.abi.json Configuration Network: dev Signer: sign1 Address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc Available functions: 1) func1 2) func2 Select function (number): 2 Running...  Network, signer and account address parameters can be overridden and function parameters specified in the command with the following options: $ everdev contract run -h EverDev Version: 0.5.0 Use: everdev contract run file function [options] Args: file ABI file function Function name Options: --help, -h Show command usage --network, -n Network name --signer, -s Signer key name --data, -d Deploying initial data as name:value,... This data is required to calculate the account address and to deploy contract. Array values must be specified as [item,...]. Spaces are not allowed. If value contains spaces or special symbols &quot;[],:&quot; it must be enclosed in &quot;&quot; or '' --address, -a Account address --input, -i Function parameters as name:value,... Array values must be specified as [item,...]. Spaces are not allowed. If value contains spaces or special symbols &quot;[],:&quot; it must be enclosed in &quot;&quot; or '' --prevent-ui, -p Prevent user interaction Useful in shell scripting e.g. on server or in some automating to disable waiting for the user input. Instead everdev will abort with error. For example when some parameters are missing in command line then ton dev will prompt user to input values for missing parameters (or fails if prevent-ui option is specified).  Example of creating a transaction and confirming it in a multisig wallet: everdev contract run SetcodeMultisigWallet.abi.json submitTransaction -n dev -s sign1 -i dest:255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f3,value:500000000,bounce:true,allBalance:false,payload:&quot;&quot;  everdev contract run SetcodeMultisigWallet.abi.json confirmTransaction -n dev -a 0:04dee1edc3f3d6b23529dcf5a6133627d06a39826bb14cc6334ffea272b15d50 -s sign2 -i transactionId:6954030467099431873  To execute a contract without signing, use signer none option: everdev contract run --signer none --address &lt;address&gt;  or everdev contract run -s none -a &lt;address&gt;  In this case you have to explicitly specify address in run function because otherwise everdev may calculate a wrong address from empty pubkey. To execute a smart contract function with bytes argument, the argument needs to be in hex format. Example: cat bytes | xxd -p | tr -d '\\n' &gt; bytes.hex everdev contract run contract.abi.json function_name -i value:$(cat bytes.hex)  Execute a smart contract function with structure arguments: everdev contract run shapes.tvc \\ savePoint \\ --address 0:540c1837656674d548c934258ddec9b5fd11b543da977b0016c14b5650bc7eb5 \\ --input '{ &quot;point&quot;: { &quot;color&quot;: &quot;red&quot;, &quot;center&quot;: { &quot;x&quot;: 1, &quot;y&quot;: 2 } } }'  or with an array of structures: everdev contract run shapes.tvc \\ savePoints \\ --address 0:540c1837656674d548c934258ddec9b5fd11b543da977b0016c14b5650bc7eb5 \\ --input \\ '{ &quot;points&quot;: [ { &quot;color&quot;: &quot;pink&quot;, &quot;center&quot;: { &quot;x&quot;: 4, &quot;y&quot;: 5 }}, { &quot;color&quot;: &quot;gray&quot;, &quot;center&quot;: { &quot;x&quot;: 6, &quot;y&quot;: 7 }} ]}'  Run contract locally on TVM​ This command downloads a contract and runs it locally on TVM. Contract ABI and TVC files are required to run it. everdev contract run-local abi_filename  Command displays available functions and asks to select one. Result example: $ everdev contract run-local Contract.abi.json Configuration Network: dev Signer: sign1 Address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc Available functions: 1) func1 2) func1 Select function (number):  Network, signer and account address parameters can be overridden and function parameters specified in the command with the following options: $ everdev contract run-local -h EverDev Version: 0.5.0 Use: everdev contract run-local file function [options] Args: file ABI file function Function name Options: --help, -h Show command usage --network, -n Network name --signer, -s Signer key name --data, -d Deploying initial data as name:value,... This data is required to calculate the account address and to deploy contract. Array values must be specified as [item,...]. Spaces are not allowed. If value contains spaces or special symbols &quot;[],:&quot; it must be enclosed in &quot;&quot; or '' --address, -a Account address --input, -i Function parameters as name:value,... Array values must be specified as [item,...]. Spaces are not allowed. If value contains spaces or special symbols &quot;[],:&quot; it must be enclosed in &quot;&quot; or '' --prevent-ui, -p Prevent user interaction Useful in shell scripting e.g. on server or in some automating to disable waiting for the user input. Instead everdev will abort with error. For example when some parameters are missing in command line then ton dev will prompt user to input values for missing parameters (or fails if prevent-ui option is specified).  "},{"title":"Emulate transaction executor locally on TVM​","type":1,"pageTitle":"Contract Management","url":"develop/sdk-tools/everdev/command-line-interface/contract-management#emulate-transaction-executor-locally-on-tvm","content":"This command downloads a contract and emulates transaction execution locally on TVM. Contract ABI and TVC files are required to run it. everdev contract run-executor abi_filename  Command displays available functions and asks to select one. Result: $ everdev contract run-executor Contract.abi.json Configuration Network: dev Signer: sign1 Address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc Available functions: 1) func1 2) func2 Select function (number):  Network, signer and account address parameters can be overridden and function parameters specified in the command with the following options: $ everdev contract run-executor -h EverDev Version: 0.5.0 Use: everdev contract run-executor file function [options] Args: file ABI file function Function name Options: --help, -h Show command usage --network, -n Network name --signer, -s Signer key name --data, -d Deploying initial data as name:value,... This data is required to calculate the account address and to deploy contract. Array values must be specified as [item,...]. Spaces are not allowed. If value contains spaces or special symbols &quot;[],:&quot; it must be enclosed in &quot;&quot; or '' --address, -a Account address --input, -i Function parameters as name:value,... Array values must be specified as [item,...]. Spaces are not allowed. If value contains spaces or special symbols &quot;[],:&quot; it must be enclosed in &quot;&quot; or '' --prevent-ui, -p Prevent user interaction Useful in shell scripting e.g. on server or in some automating to disable waiting for the user input. Instead everdev will abort with error. For example when some parameters are missing in command line then ton dev will prompt user to input values for missing parameters (or fails if prevent-ui option is specified).  "},{"title":"Top up contract balance from giver​","type":1,"pageTitle":"Contract Management","url":"develop/sdk-tools/everdev/command-line-interface/contract-management#top-up-contract-balance-from-giver","content":"If you have set a giver for a network, you can top up contract balances on it with the following command. everdev contract topup abi_filename  Defalt signer and giver parameters will be used, unless otherwise specified through the following options: $ everdev contract topup -h EverDev Version: 0.5.0 Use: everdev contract topup file [options] Args: file ABI file Options: --help, -h Show command usage --address, -a Account address --network, -n Network name --signer, -s Signer key name --data, -d Deploying initial data as name:value,... This data is required to calculate the account address and to deploy contract. Array values must be specified as [item,...]. Spaces are not allowed. If value contains spaces or special symbols &quot;[],:&quot; it must be enclosed in &quot;&quot; or '' --value, -v Deploying balance value in nano tokens  To top up any known address without providing keys or contract files, use the following command: everdev contract topup --address &lt;address&gt;  or everdev ct -a &lt;addrress&gt;  "},{"title":"Network Tool","type":0,"sectionRef":"#","url":"develop/sdk-tools/everdev/command-line-interface/network-tool","content":"","keywords":""},{"title":"Add a network​","type":1,"pageTitle":"Network Tool","url":"develop/sdk-tools/everdev/command-line-interface/network-tool#add-a-network","content":"This command adds a network to the everdev registry. everdev network add network_name network_endpoints  See other available network addition options with help command: $ everdev network add -h EverDev Version: 0.5.0 Use: everdev network add name endpoints [options] Args: name endpoints Comma separated endpoints Options: --help, -h Show command usage --force, -f Overwrite key if already exists  Example with mainnet endpoints: everdev network add main eri01.main.everos.dev,gra01.main.everos.dev,gra02.main.everos.dev,lim01.main.everos.dev,rbx01.main.everos.dev  "},{"title":"Set a giver for a network​","type":1,"pageTitle":"Network Tool","url":"develop/sdk-tools/everdev/command-line-interface/network-tool#set-a-giver-for-a-network","content":"This command sets a giver account for a network. Giver will be used to top up your account balances on the network, including during deployment. everdev network giver network_name giver_address  See other available network addition options with help command: $ everdev network giver -h EverDev Version: 0.5.0 Use: everdev network giver name address [options] Args: name Network name address Giver address Options: --help, -h Show command usage --signer, -s Signer to be used with giver --value, -v Deploying account initial balance in nanotokens  Note: The default signer and the initial balance value of 10 tokens will be used, unless otherwise specified through options. Also note, that some contracts may require a higher initial balance for successful deployment. DePool contract, for instance, requires a minimun of 21 tokens. Only one giver can be set for a network. Setting another one will overwrite the current giver. To view the current giver settings for all networks, use the everdev network list command (for details see the section below). "},{"title":"List registered networks​","type":1,"pageTitle":"Network Tool","url":"develop/sdk-tools/everdev/command-line-interface/network-tool#list-registered-networks","content":"This command lists all registered networks, their public endpoints, and their giver addresses, if any. everdev network list  Result: $ everdev network list Network Endpoints Giver ------------- ----------------------------------------------- ------------------------------------------------------------------ se http://localhost 0:b5e9240fc2d2f1ff8cbb1d1dee7fb7cae155e5f6320e585fcc685698994a19a5 dev (Default) eri01.net.everos.dev, rbx01.net.everos.dev, gra01.net.everos.dev 0:255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f3  "},{"title":"Set default network​","type":1,"pageTitle":"Network Tool","url":"develop/sdk-tools/everdev/command-line-interface/network-tool#set-default-network","content":"This command sets a previously added network as default (initially the mainnet is used by default). everdev network default network_name  "},{"title":"Delete a network​","type":1,"pageTitle":"Network Tool","url":"develop/sdk-tools/everdev/command-line-interface/network-tool#delete-a-network","content":"This command deletes a network from everdev registry. everdev network delete network_name  "},{"title":"SDK","type":0,"sectionRef":"#","url":"develop/sdk-tools/everdev/command-line-interface/sdk","content":"","keywords":""},{"title":"See the list of available demo projects​","type":1,"pageTitle":"SDK","url":"develop/sdk-tools/everdev/command-line-interface/sdk#see-the-list-of-available-demo-projects","content":"This command shows the list of available demo projects everdev js demo  Result: $ everdev js demo Demo Description ------------ ------------------------- hello-wallet Simple NodeJs Application  "},{"title":"Install demo project​","type":1,"pageTitle":"SDK","url":"develop/sdk-tools/everdev/command-line-interface/sdk#install-demo-project","content":"This command installs the specified demo project to the current directory. Proceed the instructions in the terminal to run it. everdev js demo hello-wallet  "},{"title":"Create an empty project​","type":1,"pageTitle":"SDK","url":"develop/sdk-tools/everdev/command-line-interface/sdk#create-an-empty-project","content":"This command creates a Node.js project with SDK latest dependencies and index.js file with main Client object creation. everdev js create test_project  "},{"title":"Create contract JS wrapper​","type":1,"pageTitle":"SDK","url":"develop/sdk-tools/everdev/command-line-interface/sdk#create-contract-js-wrapper","content":"This command takes abi and, optionally, tvc file and generates a JS wrapper with abi and tvc converted into base64 that can be used further in SDK. tvc file must have the same name as abi. everdev js wrap contractName.abi.json  The result name of the wrapper will be &quot;ContractName||&quot;Contract&quot;.js&quot;. See other available generation options with help command: everdev js wrap -h EverDev Version: 0.4.0 Use: everdev js wrap file [options] Args: file ABI file Options: --help, -h Show command usage --print, -p Print code to console --output, -o Set output file name (default is built from source ABI file name) --export, -e Export type and options commonjs Use CommonJS modules (NodeJs) commonjs-default Use CommonJS modules (NodeJS) with default export es6 Use ES6 modules es6-default Use ES6 modules with default export  "},{"title":"Solidity","type":0,"sectionRef":"#","url":"develop/sdk-tools/everdev/command-line-interface/solidity","content":"","keywords":""},{"title":"Create your first contract​","type":1,"pageTitle":"Solidity","url":"develop/sdk-tools/everdev/command-line-interface/solidity#create-your-first-contract","content":"This command creates a hello-world Solidity contract with comments that you can observe and compile. everdev sol create Contract  "},{"title":"Compile​","type":1,"pageTitle":"Solidity","url":"develop/sdk-tools/everdev/command-line-interface/solidity#compile","content":"This command compiles and links a selected Solidity contract. After successful compilation you get .abi.json and .tvc files that you can later use in your DApps to deploy and run contract methods. everdev sol compile Contract.sol  To save generated assembler code use -c option (default is false) everdev sol compile Contract.sol -c path/to/output/file  Assembler code will be saved in path/to/output/file with the extension code You can specify the output files location with the -o option: everdev sol compile Contract.sol -o path/to/output/file  "},{"title":"Ast​","type":1,"pageTitle":"Solidity","url":"develop/sdk-tools/everdev/command-line-interface/solidity#ast","content":"This command parses a ton-solidity file and creates an abstract syntax tree (AST) to the output directory. everdev sol ast Contract.sol  To specify the ast format type, use -f or --format option: everdev sol ast-json Contract.sol -f &lt;json | compact-json&gt;  To point the location of the output folder, use the -o or --output-dir option: everdev sol ast-json Contract.sol -f &lt;json | compact-json&gt; -o path/to/output/file  "},{"title":"Version​","type":1,"pageTitle":"Solidity","url":"develop/sdk-tools/everdev/command-line-interface/solidity#version","content":"This command shows the currently installed Solidity compiler version. everdev sol version  "},{"title":"Update​","type":1,"pageTitle":"Solidity","url":"develop/sdk-tools/everdev/command-line-interface/solidity#update","content":"This command updates the compiler and linker to the latest version. everdev sol update  Attention! Use --force option to force update of components that do not update their version. "},{"title":"Set​","type":1,"pageTitle":"Solidity","url":"develop/sdk-tools/everdev/command-line-interface/solidity#set","content":"This command sets the compiler and linker versions and downloads them if needed. everdev sol set --compiler 0.38.0 --linker 0.23.54  Attention! Use --force option to force update of components that do not update their version. "},{"title":"Signer Tool","type":0,"sectionRef":"#","url":"develop/sdk-tools/everdev/command-line-interface/signer-tool","content":"","keywords":""},{"title":"Add a signer with randomly generated keys​","type":1,"pageTitle":"Signer Tool","url":"develop/sdk-tools/everdev/command-line-interface/signer-tool#add-a-signer-with-randomly-generated-keys","content":"This command adds a signer with randomly generated keys. everdev signer generate signer_name  See other available generation options with help command: everdev signer generate -h EverDev Version: 0.5.0 Use: everdev signer generate name [options] Args: name Signer name Options: --help, -h Show command usage --mnemonic, -m Use mnemonic phrase --dictionary, -d Mnemonic dictionary 0 TON 1 English 2 Chinese Simplified 3 Chinese Traditional 4 French 5 Italian 6 Japanese 7 Korean 8 Spanish --words, -w Number of mnemonic words --force, -f Overwrite signer if already exists  "},{"title":"Add a signer with specific keys​","type":1,"pageTitle":"Signer Tool","url":"develop/sdk-tools/everdev/command-line-interface/signer-tool#add-a-signer-with-specific-keys","content":"This command adds a signer with previously generated (e.g. with tonos-cli) keys. everdev signer add signer_name signer_secret_key_or_seed_phrase_in_quotes  See other available signer addition options with help command: everdev signer add -h EverDev Version: 0.5.0 Use: everdev signer add name secret [options] Args: name Signer name secret Secret key or seed phrase Options: --help, -h Show command usage --dictionary, -d Mnemonic dictionary 0 TON 1 English 2 Chinese Simplified 3 Chinese Traditional 4 French 5 Italian 6 Japanese 7 Korean 8 Spanish --force, -f Overwrite signer if already exists  Note: By default the dictionary is set to english, which allows using seed phrases generated by other TONOS tools, such as tonos-cli. "},{"title":"List registered signers​","type":1,"pageTitle":"Signer Tool","url":"develop/sdk-tools/everdev/command-line-interface/signer-tool#list-registered-signers","content":"This command lists all registered signers with their public keys. everdev signer list  Result: $ everdev signer list Signer Public Key --------------- ---------------------------------------------------------------- sign1 (Default) cffd3a2f1d241807b2205220a7d6df980e67a3cc7c47eba2766cdc1bbddfc0e3 sign2 0fc4e781720d80f76257db333c6b6934090562418652cf30352878c87707aa94  "},{"title":"Get signer details​","type":1,"pageTitle":"Signer Tool","url":"develop/sdk-tools/everdev/command-line-interface/signer-tool#get-signer-details","content":"This command lists all information (including secret data) for a specified signer. everdev signer info signer_name  Result: $ everdev signer info sign2 { &quot;name&quot;: &quot;sign2&quot;, &quot;description&quot;: &quot;&quot;, &quot;keys&quot;: { &quot;public&quot;: &quot;760d69964d038997d891fca0a0407c2ffefb701e7cb2f9ff0a87fbbf1e8098f2&quot;, &quot;secret&quot;: &quot;72571b5a9392e6bb215b460ca3c0545c34d790e185f66f5b2e7564329ffea86c&quot; } }  "},{"title":"Set default signer​","type":1,"pageTitle":"Signer Tool","url":"develop/sdk-tools/everdev/command-line-interface/signer-tool#set-default-signer","content":"This command sets a previously added signer as default (initially the first added signer is used by default). everdev signer default signer_name  "},{"title":"Delete a signer​","type":1,"pageTitle":"Signer Tool","url":"develop/sdk-tools/everdev/command-line-interface/signer-tool#delete-a-signer","content":"This command deletes a previously added signer from signer registry. everdev signer delete signer_name  "},{"title":"TestSuite4","type":0,"sectionRef":"#","url":"develop/sdk-tools/everdev/command-line-interface/testsuite4","content":"","keywords":""},{"title":"Version​","type":1,"pageTitle":"TestSuite4","url":"develop/sdk-tools/everdev/command-line-interface/testsuite4#version","content":"This command shows the currently installed and available TestSuite4 framework versions. everdev ts4 version  "},{"title":"Install​","type":1,"pageTitle":"TestSuite4","url":"develop/sdk-tools/everdev/command-line-interface/testsuite4#install","content":"This command installs (using pip) TestSuite4's latest or selected version and downloads them if needed. everdev ts4 install # install latest version everdev ts4 install 0.2.0 # install version 0.2.0  "},{"title":"Update​","type":1,"pageTitle":"TestSuite4","url":"develop/sdk-tools/everdev/command-line-interface/testsuite4#update","content":"This command updates TestSuite4 to the latest version. everdev ts4 update  "},{"title":"Create​","type":1,"pageTitle":"TestSuite4","url":"develop/sdk-tools/everdev/command-line-interface/testsuite4#create","content":"This command creates a TestSuite4's template of the test (TestName.py). everdev ts4 create TestName everdev ts4 create TestName --folder tests # creates tests/TestName.py (folder must exist)  "},{"title":"Run​","type":1,"pageTitle":"TestSuite4","url":"develop/sdk-tools/everdev/command-line-interface/testsuite4#run","content":"This command runs selected test (TestName.py). everdev ts4 run TestName  "},{"title":"TONOS-CLI","type":0,"sectionRef":"#","url":"develop/sdk-tools/everdev/command-line-interface/tonos-cli","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"TONOS-CLI","url":"develop/sdk-tools/everdev/command-line-interface/tonos-cli#install","content":"This command installs the latest tonos-cli everdev tonos-cli install  The installer requires NPM to be installed, so it can install packages globally without using sudo. In case of error, manually set environment variable PATH=$PATH:$HOME/.everdev/solidity "},{"title":"Version​","type":1,"pageTitle":"TONOS-CLI","url":"develop/sdk-tools/everdev/command-line-interface/tonos-cli#version","content":"This command shows the used tonos-cli version and list of available for download versions everdev tonos-cli version Version Available --------- ------------------------------------------------------ 0.8.1 0.6.0, 0.6.1, 0.6.2, 0.7.1, 0.6.3, 0.7.0, 0.8.0, 0.8.1  "},{"title":"Set​","type":1,"pageTitle":"TONOS-CLI","url":"develop/sdk-tools/everdev/command-line-interface/tonos-cli#set","content":"This command specifies tonos-cli version to use and downloads it if needed. everdev tonos-cli set --version 0.8.0  "},{"title":"Update​","type":1,"pageTitle":"TONOS-CLI","url":"develop/sdk-tools/everdev/command-line-interface/tonos-cli#update","content":"This command updates tonos-cli version to the latest everdev tonos-cli update  "},{"title":"How to view controller info","type":0,"sectionRef":"#","url":"develop/sdk-tools/everdev/guides/controller-info","content":"How to view controller info This command displays a summary of all controller configurations. everdev info Output example: $ everdev info C++ compiler Component Version Available --------- ------- --------- clang 7.0.0 7.0.0 Solidity Compiler Component Available --------- ---------------------------------------------- compiler 0.42.0, 0.41.0, 0.40.0, 0.39.0, 0.38.2, 0.38.1 linker 0.3.0, 0.1.0 stdlib 0.42.0, 0.41.0, 0.40.0, 0.39.0, 0.38.2, 0.38.1 TON OS SE Instance State Version GraphQL Port Docker Container Docker Image -------- ------------- ------- ------------ -------------------- ----------------------- default not installed 0.27 80 tonlabs-tonos-se-test tonlabs/local-node:0.27 Network Registry Network Endpoints Giver ------------- ----------------------------------------------- ------------------------------------------------------------------ se http://localhost 0:b5e9240fc2d2f1ff8cbb1d1dee7fb7cae155e5f6320e585fcc685698994a19a5 dev (Default) net.ton.dev, net1.ton.dev, net5.ton.dev 0:255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f3 main main.ton.dev, main2.ton.dev, main3.ton.dev, ... Signer Registry Signer Public Key -------------- ---------------------------------------------------------------- surf 8534c46f7a135058773fa1298cb3a299a5ddd40dafe41cb06c64f274da360bfb test (Default) ad4bf7bd8da244932c52127a943bfa9217b6e215c1b3307272283c4d64f34486 test2 5c2e348c5caeb420a863dc5e972f897ebe5ee899a6ef2a8299aac352eca4380a TON OS CLI Component Version Available --------- ------- -------------------------------------------------------------------------------- tonoscli 0.11.3 0.11.4, 0.11.3, 0.11.2, 0.11.1, 0.11.0, 0.10.1, 0.10.0, 0.9.2, 0.9.1, 0.9.0, ... ","keywords":""},{"title":"How to create controller","type":0,"sectionRef":"#","url":"develop/sdk-tools/everdev/guides/create-controller","content":"","keywords":""},{"title":"What a controller should and what it shouldn't to do​","type":1,"pageTitle":"How to create controller","url":"develop/sdk-tools/everdev/guides/create-controller#what-a-controller-should-and-what-it-shouldnt-to-do","content":"Controller should: Expose functionality to the user as a list of commands.Install the required tool components on demand (on first usage).Start and stop the tool components that acts like a demons.Define three commands to control the tool version: version to show the currently installed tool version;update to update the tool to the latest available version;use to select the specified tool version as the current version. Controller shouldn't: Implement tool functionality itself. Controller is a connector between the user and the existing development tool.Implement user interaction itself. All user interaction must be implemented exactly in the terms of everdev extensibility. "},{"title":"How to implement a Controller​","type":1,"pageTitle":"How to create controller","url":"develop/sdk-tools/everdev/guides/create-controller#how-to-implement-a-controller","content":"Create a folder for a new controller: mkdir src/controllers/foo cd src/controllers/foo  Create index.ts with the controller's definition: import { ToolController } from &quot;../../core&quot;; import { versionCommand } from &quot;./version&quot;; import { updateCommand } from &quot;./update&quot;; import { runCommand } from &quot;./run&quot;; export const Foo: ToolController = { name: &quot;foo&quot;, title: &quot;Foo Tool&quot;, commands: [ versionCommand, updateCommand, runCommand, ], };  Create installer.ts to implement all the code related to the tool installation: import path from &quot;path&quot;; import fs from &quot;fs&quot;; import { Terminal, everdevHome } from &quot;../../core&quot;; function fooHome() { return path.resolve(everdevHome(), &quot;foo&quot;); } async function ensureInstalled(terminal: Terminal) { } export async function getVersion(): Promise&lt;string&gt; { return &quot;1.0.0&quot;; } export async function updateVersion(terminal: Terminal) { if (fs.existsSync(fooHome())) { fs.rmdirSync(fooHome(), { recursive: true }); } ensureInstalled(terminal); } export async function runFoo(terminal: Terminal, workDir: string, args: string[]): Promise&lt;void&gt; { ensureInstalled(terminal); terminal.log(&quot;Foo succeeded&quot;); };  Create version.ts command handler: import { getVersion } from &quot;./installer&quot;; import { Command, Terminal } from &quot;../../core&quot;; export const versionCommand: Command = { name: &quot;version&quot;, title: &quot;Show Foo Version&quot;, async run(terminal: Terminal, _args: {}): Promise&lt;void&gt; { terminal.log(await getVersion()); }, };  Create update.ts command handler: import { updateVersion } from &quot;./installer&quot;; import { Command, Terminal } from &quot;../../core&quot;; export const versionCommand: Command = { name: &quot;update&quot;, title: &quot;Update Foo Version&quot;, async run(terminal: Terminal, _args: {}): Promise&lt;void&gt; { await updateVersion(terminal); }, };  Create run.ts command handler: import { runFoo } from &quot;./installer&quot;; import { Command, Terminal } from &quot;../../core&quot;; export const runCommand: Command = { name: &quot;run&quot;, title: &quot;Run Foo&quot;, async run(terminal: Terminal, args: {}): Promise&lt;void&gt; { await runFoo(terminal, args); }, };  "},{"title":"Controller API Reference​","type":1,"pageTitle":"How to create controller","url":"develop/sdk-tools/everdev/guides/create-controller#controller-api-reference","content":"You can find API reference in form of TSDoc in src/core/index.ts. "},{"title":"Quick start","type":0,"sectionRef":"#","url":"develop/sdk-tools/everdev/guides/quick-start","content":"","keywords":""},{"title":"Guide overview​","type":1,"pageTitle":"Quick start","url":"develop/sdk-tools/everdev/guides/quick-start#guide-overview","content":"This guide will help you get started with such essensial Everscale tools as: Everdev CLISolidity CompilerLocal BlockchainEverscale Blockchain ExplorerGraphQL API You will learn how to: Create and compile your first Solidity contractRun Local blockchain for testingDeploy your first contractRun it on-chainRun a getter-function "},{"title":"Install everdev​","type":1,"pageTitle":"Quick start","url":"develop/sdk-tools/everdev/guides/quick-start#install-everdev","content":"everdev — single interface to access all the developer tools. npm install -g everdev  If you experience any problems with installation, check out our troubleshooting section. "},{"title":"Create helloWorld contract​","type":1,"pageTitle":"Quick start","url":"develop/sdk-tools/everdev/guides/quick-start#create-helloworld-contract","content":"npx everdev sol create helloWorld  "},{"title":"Compile it​","type":1,"pageTitle":"Quick start","url":"develop/sdk-tools/everdev/guides/quick-start#compile-it","content":"npx everdev sol compile helloWorld.sol  "},{"title":"Run Local Blockchain​","type":1,"pageTitle":"Quick start","url":"develop/sdk-tools/everdev/guides/quick-start#run-local-blockchain","content":"Attention Docker should be running. npx everdev se start  "},{"title":"Configure default network​","type":1,"pageTitle":"Quick start","url":"develop/sdk-tools/everdev/guides/quick-start#configure-default-network","content":"Set Local Blockchain SE (Simple Emulator) as the default network: npx everdev network default se  "},{"title":"Configure Giver wallet that will sponsor deploy operation​","type":1,"pageTitle":"Quick start","url":"develop/sdk-tools/everdev/guides/quick-start#configure-giver-wallet-that-will-sponsor-deploy-operation","content":"Here we use address and private key of SE High Load Giver. Attention! This giver is available only in SE. If you work in DevNet or MainNet, you need to deploy your own giver. Check how to do it in this guide. npx everdev signer add giver_keys 172af540e43a524763dd53b26a066d472a97c4de37d5498170564510608250c3 npx everdev network giver se 0:b5e9240fc2d2f1ff8cbb1d1dee7fb7cae155e5f6320e585fcc685698994a19a5 --signer giver_keys  "},{"title":"Generate the keys for contract ownership​","type":1,"pageTitle":"Quick start","url":"develop/sdk-tools/everdev/guides/quick-start#generate-the-keys-for-contract-ownership","content":"npx everdev signer generate owner_keys npx everdev signer default owner_keys npx everdev signer list Signer Public Key Used -------------------- --------------- --------------------------- giver_keys 2ada2e...b25a16 se network giver signer owner_keys (Default) 382620...1ecf7b  Note That there are shortcuts for all the commands: sl = signer list and sd = signer default :) Don't forget to make the owner key default otherwize giver keys will be used as default. "},{"title":"Calculate the contract address​","type":1,"pageTitle":"Quick start","url":"develop/sdk-tools/everdev/guides/quick-start#calculate-the-contract-address","content":"npx everdev contract info helloWorld Configuration Network: se (http://localhost) Signer: owner_keys (public 3826202b129ea8c041b8d49a655512648fc94377d1958a7a4fc9f4b3051ecf7b) Address: 0:e74c4258496e79e62e014ca96911acbf5cb0e286fd55dd6f4e3da54e4197ddf5 (calculated from TVC and signer public) Code Hash: c517820144a4daf5a3414c9233556b2b0ad34cdd228f200ea68a4c0327e0bd29 (from TVC file) Account: Doesn't exist  You can see that the contract does not exist yet (is not deployed) but you can already see its future address. "},{"title":"Deploy​","type":1,"pageTitle":"Quick start","url":"develop/sdk-tools/everdev/guides/quick-start#deploy","content":"Here we deploy the contract, sponsoring it with 10 Tokens (Everscale native currency has 9 decimals). The money for deploy are taken from the giver we configured in the previous steps. npx everdev contract deploy -v 10000000000 helloWorld Configuration Network: se (http://localhost) Signer: owner_keys (public 3826202b129ea8c041b8d49a655512648fc94377d1958a7a4fc9f4b3051ecf7b) Address: 0:e74c4258496e79e62e014ca96911acbf5cb0e286fd55dd6f4e3da54e4197ddf5 (calculated from TVC and signer public) Deploying... Contract has deployed at address: 0:e74c4258496e79e62e014ca96911acbf5cb0e286fd55dd6f4e3da54e4197ddf5  "},{"title":"View contract information with Explorer​","type":1,"pageTitle":"Quick start","url":"develop/sdk-tools/everdev/guides/quick-start#view-contract-information-with-explorer","content":"Go to localhost and search for your contract address in search bar. Open your account page. You will need it later to see its transactions and messages, that we will produce in the next steps. "},{"title":"Explore contract information with GraphQL​","type":1,"pageTitle":"Quick start","url":"develop/sdk-tools/everdev/guides/quick-start#explore-contract-information-with-graphql","content":"Go to localhost/graphql. Enter in the left pane and click Run button (replace the contract's address with the one you got in the previous steps). query { accounts( filter: { id: { eq: &quot;0:e74c4258496e79e62e014ca96911acbf5cb0e286fd55dd6f4e3da54e4197ddf5&quot; } } ) { acc_type_name balance code code_hash data } }  You will see: { &quot;data&quot;: { &quot;accounts&quot;: [ { &quot;acc_type_name&quot;: &quot;Active&quot;, &quot;balance&quot;: &quot;0x1db0832ba&quot;, &quot;code&quot;: &quot;te6ccgECEwEAAnkABCj/AIrtUyDjAyDA/+MCIMD+4wLyCxECARICoiHbPNMAAY4SgQIA1xgg+QFY+EIg+GX5EPKo3tM/AY4d+EMhuSCfMCD4I4ED6KiCCBt3QKC53pMg+GPg8jTYMNMfAfgjvPK50x8B2zz4R27yfAUDATQi0NcLA6k4ANwhxwDcIdMfId0B2zz4R27yfAMDQCCCEDtj1H67joDgIIIQaBflNbuOgOAgghBotV8/uuMCCwYEAlgw+EFu4wD4RvJzcfhm0fhC8uBl+EUgbpIwcN74Qrry4Gb4APgj+GrbPH/4ZwUPAHjtRNAg10nCAY4U0//TP9MA1wsf+Gp/+GH4Zvhj+GKOG/QFcPhqcAGAQPQO8r3XC//4YnD4Y3D4Zn/4YeICKCCCEFTWvRi64wIgghBoF+U1uuMCCAcBSts8+EqNBHAAAAAAAAAAAAAAAAA6BflNYMjOIc8LH8lw+wB/+GcQAnIw0ds8IcD/jikj0NMB+kAwMcjPhyDOjQQAAAAAAAAAAAAAAAANTWvRiM8WIc8UyXD7AN4w4wB/+GcJDwECiAoAFGhlbGxvV29ybGQCKCCCEDcxLkW64wIgghA7Y9R+uuMCDgwDSDD4QW7jAPpA1w1/ldTR0NN/39cMAJXU0dDSAN/R2zzjAH/4ZxANDwBU+EUgbpIwcN74Qrry4Gb4AFRxIMjPhYDKAHPPQM4B+gKAa89AyXD7AF8DAkAw+EFu4wDR+EUgbpIwcN74Qrry4Gb4APgj+GrbPH/4ZxAPAC74QsjL//hDzws/+EbPCwD4SgHLH8ntVAAu7UTQ0//TP9MA1wsf+Gp/+GH4Zvhj+GIBCvSkIPShEgAA&quot;, &quot;code_hash&quot;: &quot;c517820144a4daf5a3414c9233556b2b0ad34cdd228f200ea68a4c0327e0bd29&quot;, &quot;data&quot;: &quot;te6ccgEBAQEALwAAWTgmICsSnqjAQbjUmmVVEmSPyUN30ZWKek/J9LMFHs97AAABesq/uBawfEB6wA==&quot; } ] } }  You can specify any other fields in the result section that are available in GraphQL Schema. (Click Docs on the right side of your screen to explore it). What is GraphQL? This is the API of blockchain, to retrieve data from it and to send data into it. You can use this playground later, if you will need need to test some queries. "},{"title":"Run on-chain​","type":1,"pageTitle":"Quick start","url":"develop/sdk-tools/everdev/guides/quick-start#run-on-chain","content":"Let's move on and run an on-chain method. npx everdev contract run helloWorld Configuration Network: se (http://localhost) Signer: owner_key (public 3826202b129ea8c041b8d49a655512648fc94377d1958a7a4fc9f4b3051ecf7b) Address: 0:e74c4258496e79e62e014ca96911acbf5cb0e286fd55dd6f4e3da54e4197ddf5 (calculated from TVC and signer public) Available functions: 1) constructor 2) renderHelloWorld 3) touch 4) sendValue 5) timestamp Select function (number):  Let's enter 3. You will see the transaction ID of the operation. &quot;transaction&quot;: { &quot;json_version&quot;: 5, &quot;id&quot;: &quot;8087f774d4b8b4d4716cb31a74deea32550a04b40e853f55c64579fa3897108f&quot;, &quot;boc&quot;: &quot;te6ccgECBw...... ........................  You can also execute it inline like this: npx everdev contract run helloWorld touch In the result you can see the transaction_id. Search for it on your Contract's page in Explorer and in GraphQL playground (use transactions collection instead of accounts). "},{"title":"Run a getter function​","type":1,"pageTitle":"Quick start","url":"develop/sdk-tools/everdev/guides/quick-start#run-a-getter-function","content":"npx everdev contract run-local helloWorld timestamp Configuration Network: se (http://localhost) Signer: owner_keys (public 3826202b129ea8c041b8d49a655512648fc94377d1958a7a4fc9f4b3051ecf7b) Address: 0:e74c4258496e79e62e014ca96911acbf5cb0e286fd55dd6f4e3da54e4197ddf5 (calculated from TVC and signer public) Execution has finished with result: { &quot;output&quot;: { &quot;timestamp&quot;: &quot;1626898677&quot; }, &quot;out_messages&quot;: [] }  "},{"title":"Transfer some tokens​","type":1,"pageTitle":"Quick start","url":"develop/sdk-tools/everdev/guides/quick-start#transfer-some-tokens","content":"npx everdev contract run helloWorld sendValue Configuration Network: se (http://localhost) Signer: owner_keys (public 3826202b129ea8c041b8d49a655512648fc94377d1958a7a4fc9f4b3051ecf7b) Address: 0:e74c4258496e79e62e014ca96911acbf5cb0e286fd55dd6f4e3da54e4197ddf5 (calculated from TVC and signer public) Parameters of sendValue: dest (address): 0:b5e9240fc2d2f1ff8cbb1d1dee7fb7cae155e5f6320e585fcc685698994a19a5 amount (uint128): 1000000000 bounce (bool): true Running... Execution has finished with result: { &quot;transaction&quot;: { &quot;json_version&quot;: 5, &quot;id&quot;: &quot;550731bb26e5054387a781257e077dbdd769367f16b19bfa529c20475e2a08f6&quot;, &quot;boc&quot;: &quot;te6ccgECCwEAAkwAA7V+dMQlhJbnnmLgFMqWkRrL9csOKG/VXdb049pU5Bl931AAAAAAAAADdx7fDdz4W9u1NnBVF9To555bwxWhiXk8pjgn1OO6cR6wAAAAAAAAAzYPiDAAADRxN2doBQQBAg8MSMYbFBYEQAMCAG/Jh6EgTBRYQAAAAAAAAgAAAAAAAmHZXn3oj36iIsmePH9xls7+ruVE+XB4H24a  Attention! Contracts take value in nanotokens, so in this step we transfered 1 token.Bounce = true means that if the recipient does not exist, money will be returned back. If you plan to transfer money for deploy, specify Bounce = false! Again, now you can find this transaction in Explorer or GraphQL API. "},{"title":"What's next?​","type":1,"pageTitle":"Quick start","url":"develop/sdk-tools/everdev/guides/quick-start#whats-next","content":"If you want to migrate to Dev Network, read Working with DevNet guide.Also take a look at our blockchain basics page that will help you understand the core concepts of Everscale:)If you want to integrate your application with Everscale - dive into our SDK Quick Start!If you are an exchange - check out our exchange guide! If you have any difficulties/questions/suggestions/etc please write to telegram channel @everdev. "},{"title":"How to work with Devnet","type":0,"sectionRef":"#","url":"develop/sdk-tools/everdev/guides/work-with-devnet","content":"","keywords":""},{"title":"Contents​","type":1,"pageTitle":"How to work with Devnet","url":"develop/sdk-tools/everdev/guides/work-with-devnet#contents","content":"ContentsDeploying your own Giver Generate Giver keysCompile Giver codeCalculate Giver addressSponsor Giver with public faucetDeploy Giver contract Configure everdev to use your GiverTesting your new Giver Working with DevNet is similar to working with SE except you usually don't have any predeployed giver in DevNet. So you need to fund your contracts manually or deploy your own giver, which you will be able to use the same way as in SE. Deploying your own giver can be useful, if you need to deploy many contracts or need to frequently redeploy and test contract after subsequent midification. "},{"title":"Deploying your own Giver​","type":1,"pageTitle":"How to work with Devnet","url":"develop/sdk-tools/everdev/guides/work-with-devnet#deploying-your-own-giver","content":"In order to deploy the Giver, do the following steps, like for an ordinary contract: "},{"title":"Generate Giver keys​","type":1,"pageTitle":"How to work with Devnet","url":"develop/sdk-tools/everdev/guides/work-with-devnet#generate-giver-keys","content":"$ everdev signer generate devnet_giver_keys $ everdev s l Signer Public Key ----------------- ---------------------------------------------------------------- test (Default) de101cde5c94540926fe862e965cf109b1b803989e7048657cf7c4caaa2a257d devnet_giver_keys 5a343ccbd62c15e3df1076bc34957ad2717469d84e4d6b3ef26112db80ac8e1b  "},{"title":"Compile Giver code​","type":1,"pageTitle":"How to work with Devnet","url":"develop/sdk-tools/everdev/guides/work-with-devnet#compile-giver-code","content":"You can find compiled giver v2 contract with code here. You need to recompile code only if you want to change its code, so you can use compiled GiverV2.tvc file and move to the next step. Attention!The code in repo is not compatible with the latest Solidity compilers, so if you would like to compile it yourself, you would need to migrate code to the latest Solidity version first. After modifying code, compile it: $ everdev sol compile GiverV2.sol  In a case of success, compiler will generate two files: compiled code (GiverV2.tvc) and ABI (GiverV2.abi.json). You need these files for the next steps. "},{"title":"Calculate Giver address​","type":1,"pageTitle":"How to work with Devnet","url":"develop/sdk-tools/everdev/guides/work-with-devnet#calculate-giver-address","content":"In order to deploy contract, you need to know its address: $ everdev contract info -n dev -s devnet_giver_keys GiverV2.tvc Configuration Network: dev (net.ton.dev, net1.ton.dev, net5.ton.dev) Signer: devnet_giver_keys (public 5a343ccbd62c15e3df1076bc34957ad2717469d84e4d6b3ef26112db80ac8e1b) Address: 0:93139197f2f58d674bee4ee71a42d8f1e7b6a3c3e041ded7a54d330bcc44f3b3 (calculated from TVC and signer public) Code Hash: ccbfc821853aa641af3813ebd477e26818b51e4ca23e5f6d34509215aa7123d9 (from TVC file) Account: Doesn't exist  "},{"title":"Sponsor Giver with public faucet​","type":1,"pageTitle":"How to work with Devnet","url":"develop/sdk-tools/everdev/guides/work-with-devnet#sponsor-giver-with-public-faucet","content":"On the next step, you need to sponsor your Giver's address, which you have obtained on the previous step, with funds in order to be able to deploy contract. The easiest way to do it in DevNet is to use EverGiver[DevNet] Telegram bot. It can give you 111 rubies maximum per address. If you need more, or in a case of different test network, you can contact an owner of particular network (for DevNet it is EverX). In EverGiver Telegram bot type (change Giver's address to the address obtained at previous step): /give 111 0:93139197f2f58d674bee4ee71a42d8f1e7b6a3c3e041ded7a54d330bcc44f3b3  Wait for operation completion. Check address balance in Blockchain Explorer. "},{"title":"Deploy Giver contract​","type":1,"pageTitle":"How to work with Devnet","url":"develop/sdk-tools/everdev/guides/work-with-devnet#deploy-giver-contract","content":"For contract deployment you need to have compiled contract files (GiverV2.tvc and GiverV2.abi.json) and giver keys. To deploy contract execute next command: $ everdev contract deploy -n dev -s devnet_giver_keys GiverV2.tvc Configuration Network: dev (eri01.net.everos.dev, rbx01.net.everos.dev, gra01.net.everos.dev) Signer: devnet_giver_keys (public 5a343ccbd62c15e3df1076bc34957ad2717469d84e4d6b3ef26112db80ac8e1b) Address: 0:93139197f2f58d674bee4ee71a42d8f1e7b6a3c3e041ded7a54d330bcc44f3b3 (calculated from TVC and signer public) Deploying... Contract has deployed at address: 0:93139197f2f58d674bee4ee71a42d8f1e7b6a3c3e041ded7a54d330bcc44f3b3  Done, now you have your own Giver, deployed to the DevNet! Let's configure everdev to use your Giver by default. "},{"title":"Configure everdev to use your Giver​","type":1,"pageTitle":"How to work with Devnet","url":"develop/sdk-tools/everdev/guides/work-with-devnet#configure-everdev-to-use-your-giver","content":"For convenience, you might need to configure everdev in order to use your Giver as default. To do it, execute the next command (change address to your Giver's address, obtained on previous steps): $ everdev network giver dev 0:93139197f2f58d674bee4ee71a42d8f1e7b6a3c3e041ded7a54d330bcc44f3b3 --signer devnet_giver_keys  Check: $ everdev n l Network Endpoints Giver ------------ ----------------------------------------------- ------------------------------------------------------------------ se (Default) http://localhost 0:b5e9240fc2d2f1ff8cbb1d1dee7fb7cae155e5f6320e585fcc685698994a19a5 GiverV2 dev eri01.net.everos.dev, rbx01.net.everos.dev, gra01.net.everos.dev 0:93139197f2f58d674bee4ee71a42d8f1e7b6a3c3e041ded7a54d330bcc44f3b3 GiverV2 signed by devnet_giver_keys main eri01.main.everos.dev, gra01.main.everos.dev, gra02.main.everos.dev ...  If Giver is set, you will see you Giver's address and keypair name for the dev network. "},{"title":"Testing your new Giver​","type":1,"pageTitle":"How to work with Devnet","url":"develop/sdk-tools/everdev/guides/work-with-devnet#testing-your-new-giver","content":"For testing your new Giver, try to topup any address, for example, one of the contract's address, which you need to deploy: $ everdev contract topup --network dev --address &lt;address&gt; --value 10000 Configuration Network: dev (eri01.net.everos.dev, rbx01.net.everos.dev, gra01.net.everos.dev) Signer: test (public de101cde5c94540926fe862e965cf109b1b803989e7048657cf7c4caaa2a257d) Address: &lt;address&gt; 0.00001 tokens (10000 nano) were sent to address &lt;address&gt;  "},{"title":"Overview","type":0,"sectionRef":"#","url":"develop/sdk-tools/everdev/overview","content":"","keywords":""},{"title":"Quick Start​","type":1,"pageTitle":"Overview","url":"develop/sdk-tools/everdev/overview#quick-start","content":""},{"title":"What is EverDev?​","type":1,"pageTitle":"Overview","url":"develop/sdk-tools/everdev/overview#what-is-everdev","content":"EverDev is a Node.js package with CLI interface that allows to perform the following use-cases from the single interface for Developer: "},{"title":"Use-cases​","type":1,"pageTitle":"Overview","url":"develop/sdk-tools/everdev/overview#use-cases","content":"Easily manage all the core Ever OS Developer ToolsConfigure networks (including Local Blockchain, Developer Network, Everscale (main) network): add, configure giver;Manage keys: add, removeWork with Everscale blockchain from CLI Also, this project serves as a backend for EverDev VS Code extension. "},{"title":"EverDev Troubleshooting","type":0,"sectionRef":"#","url":"develop/sdk-tools/everdev/troubleshooting","content":"","keywords":""},{"title":"EACCESS errors during installation​","type":1,"pageTitle":"EverDev Troubleshooting","url":"develop/sdk-tools/everdev/troubleshooting#eaccess-errors-during-installation","content":"These errors can occur, if npm was installed without the use of a version manager. Refer to this article for ways to resolve the issue. "},{"title":"command not found: everdev​","type":1,"pageTitle":"EverDev Troubleshooting","url":"develop/sdk-tools/everdev/troubleshooting#command-not-found-everdev","content":"This error may happen because PATH environment variable was not correctly updated to contain path to Node.js binary. If you use Linux, ensure the following command is in your ~/.bashrc for bash shell or ~/.zshrc for zsh shell: export PATH=~/.npm-global/bin:$PATH  If you have installed Node.js using Homebrew on MacOS, npm binaries could be found in /usr/local/share/npm/bin. So, in your ~/.zshrc file add the following: export PATH=/usr/local/share/npm/bin:$PATH  If you use Windows, add path to NodeJS bin directory via environment variables settings dialogue and relaunch console window. Additionally, make sure permissions are alright. "},{"title":"Unspecified Error on everdev sol compile in Windows 10​","type":1,"pageTitle":"EverDev Troubleshooting","url":"develop/sdk-tools/everdev/troubleshooting#unspecified-error-on-everdev-sol-compile-in-windows-10","content":"1) Run \\Users\\UserName\\everdev\\solidity\\solc.exe and review error messages. 2) Update Visual Studio components and make sure vc_redist is installed. "},{"title":"TON OS SE: Couldn’t connect to Docker daemon​","type":1,"pageTitle":"EverDev Troubleshooting","url":"develop/sdk-tools/everdev/troubleshooting#ton-os-se-couldnt-connect-to-docker-daemon","content":"This error occurs in two cases. Either the docker daemon isn't running, or current user doesn't have rights to access docker. You can fix the rights issue either by running relevant commands as the superuser or adding the user to the docker group: sudo usermod -a -G docker $USER  Make sure to restart the system or log out and back in, for the new group settings to take effect. "},{"title":"After everdev is installed on Ubuntu WSL on Windows 10 old version is there​","type":1,"pageTitle":"EverDev Troubleshooting","url":"develop/sdk-tools/everdev/troubleshooting#after-everdev-is-installed-on-ubuntu-wsl-on-windows-10-old-version-is-there","content":"This issue can occur if npm was installed without correct permissions for Linux/Ubuntu. Refer to this article for ways to resolve it. After it is done, reload terminal and install everdev via `npm i everdev -g' again. "},{"title":"Evernode DApp Server (DS)","type":0,"sectionRef":"#","url":"develop/sdk-tools/evernode-ds","content":"","keywords":""},{"title":"About Evernode DS​","type":1,"pageTitle":"Evernode DApp Server (DS)","url":"develop/sdk-tools/evernode-ds#about-evernode-ds","content":"Evernode DS is a set of services enabling you to work with Everscale blockchain. The core element of Evernode DS is Everscale node written in Rust focused on performance and safety. Evernode DS provides a set of services serving EVER SDK endpoint: scalable multi-model database ArangoDB with the information about all blockchain entities (like accounts, blocks, transactions, etc.) stored over time, distributed high-throughput, low-latency streaming platform Kafka, Everscale GraphQL Server (aka Q-Server) for serving GraphQL queries to the database and Nginx web-server. This repository contains instructions on how to build and configure your own free instance of Evernode Platform to connect your application to Everscale. You can try to run a core network node yourself using the Evernode DS solution. "},{"title":"Evernode NQ","type":0,"sectionRef":"#","url":"develop/sdk-tools/evernode-nq","content":"Evernode NQ","keywords":""},{"title":"Evernode SE","type":0,"sectionRef":"#","url":"develop/sdk-tools/evernode-se","content":"Evernode SE","keywords":""},{"title":"Getting started","type":0,"sectionRef":"#","url":"develop/sdk-tools/getting-started","content":"Getting started","keywords":""},{"title":"Locklift","type":0,"sectionRef":"#","url":"develop/sdk-tools/locklift","content":"Locklift","keywords":""},{"title":"Network Tool","type":0,"sectionRef":"#","url":"develop/sdk-tools/network-tool","content":"Network Tool","keywords":""},{"title":"Eversclae Inpage Provider","type":0,"sectionRef":"#","url":"develop/sdk-tools/inpage-provider","content":"Eversclae Inpage Provider","keywords":""},{"title":"Overview","type":0,"sectionRef":"#","url":"develop/sdk-tools/overview","content":"Overview","keywords":""},{"title":"Signer Tool","type":0,"sectionRef":"#","url":"develop/sdk-tools/signer-tool","content":"Signer Tool","keywords":""},{"title":"TON Indexer","type":0,"sectionRef":"#","url":"develop/sdk-tools/ton-inderxer","content":"TON Indexer","keywords":""},{"title":"TON Kafka Producer","type":0,"sectionRef":"#","url":"develop/sdk-tools/ton-kafka","content":"TON Kafka Producer","keywords":""},{"title":"TON Wallet Api","type":0,"sectionRef":"#","url":"develop/sdk-tools/ton-wallet-api","content":"TON Wallet Api","keywords":""},{"title":"TONOS-CLI","type":0,"sectionRef":"#","url":"develop/sdk-tools/tonos-cli","content":"TONOS-CLI","keywords":""},{"title":"Comparison with EVM Solidity Contracts","type":0,"sectionRef":"#","url":"develop/smart-contract/comparison-with-evm-solidity","content":"Comparison with EVM Solidity Contracts","keywords":""},{"title":"Components","type":0,"sectionRef":"#","url":"develop/smart-contract/components","content":"Components","keywords":""},{"title":"DeBots","type":0,"sectionRef":"#","url":"develop/smart-contract/debots","content":"","keywords":""},{"title":"What is a DeBot?​","type":1,"pageTitle":"DeBots","url":"develop/smart-contract/debots#what-is-a-debot","content":"DeBot (Decentralized Bot) is an intuitive, no-prior-knowledge-required interface for smart contracts on Everscale Blockchain. Blockchain technology is complex and can be hard to learn for users without experience in the field or a technical background. With DeBots we aim to simplify the interactions required to achieve a user’s goals on the blockchain, and streamline the development process of blockchain-based services, while maintaining the level of security expected of such products. At its most basic a DeBot is a secure chat-based interface that allows a user to interact with a smart contract on the blockchain and access its various functions in the form of a dialogue. "},{"title":"Basic terms​","type":1,"pageTitle":"DeBots","url":"develop/smart-contract/debots#basic-terms","content":"DeBot — a smart contract facilitating conversation-like flow communication with a target smart contract.Target smart contract — a smart contract for which DeBot is created. DeBot is an interface to this smart contract.DeBot browser — a program that executes DeBot and parses its answer using DeBot protocol.DeBot protocol — a set of rules describing the communication between browser and DeBot: how to call DeBot functions and how to interpret its answers. DeBot is deployed to the blockchain. DeBot browser runs on client. It downloads DeBot code and runs it inside the engine. "},{"title":"DeBot interfaces​","type":1,"pageTitle":"DeBots","url":"develop/smart-contract/debots#debot-interfaces","content":"To fulfill their functions as a user interface DeBots must be able to facilitate a number of interactions between the user, the user's device and the target smart contract on the blockchain: receive input from users;query info about other smart contracts;query transactions and messages;receive data from external subsystems (like file system) and external devices (like NFC, camera and so on);call external function libraries that allow to do operations that are not supported by VM. For example, work with json, convert numbers to string and vice versa, encrypt/decrypt/sign data. These needs are covered in various DeBot Interfaces (DInterfaces) which can be used in DeBots and which must be supported in DeBot Browsers. To use an interface DeBot should import source file with DInterface declaration and call its methods as any other smart contract methods in Everscale — by sending internal messages to interface address, which is unique and explicitly defined for every interface. Every DInterface must be discussed and accepted by DeBot Interface Specifications (DIS) Consortium before it can be used in DeBots. All accepted interfaces are published in DeBot Interface Specifications Consortium. "},{"title":"Prerequisites​","type":1,"pageTitle":"DeBots","url":"develop/smart-contract/debots#prerequisites","content":"To build DeBots install everdev: npm install -g everdev  To run and debug DeBots install tonos-cli: note For run DeBots required tonos-cli version &gt;= 0.11.4. Install using everdev: npx everdev tonos-cli install  or npx everdev tonos-cli set --version 0.26.2  Or download binaries from here: LinuxMacOSWindows http://sdkbinaries.tonlabs.io/tonos-cli-0_26_2-linux.zip "},{"title":"DeBots​","type":1,"pageTitle":"DeBots","url":"develop/smart-contract/debots#debots-1","content":"Hello — Hello World DeBot. Can be used as a template for new DeBots.Multisig — DeBot for multi-signature wallet (multisig). Uses several basic DeBot interfaces: Terminal, AddressInput, AmountInput, ConfirmInput. It supports all functions of the multisig wallet contract, such as submitting and confirming transactions and viewing wallet information.DEvergence — DeBot for the Ever Surf App which the user employs to connect to a Tezos wallet and transact. DeBots are smart contracts with a chat interface similar to those on Telegram. "},{"title":"How to try DeBot​","type":1,"pageTitle":"DeBots","url":"develop/smart-contract/debots#how-to-try-debot","content":"You can start by trying out multisig DeBot. It's already deployed to net.ever.live and can be called through any DeBot browser that supports it. To try it out in Ever Surf, go to https://ever.surf/ or in tonos-cli call: "},{"title":"DeBot DEvergence​","type":1,"pageTitle":"DeBots","url":"develop/smart-contract/debots#debot-devergence","content":"tonos-cli config --url eri01.net.everos.dev tonos-cli debot fetch 0:38a53a8bff83c57b6334f369d5ff678bdaa2b8e229d9b5552dfdda2b4d90cf92  or in Ever Surf 0:38a53a8bff83c57b6334f369d5ff678bdaa2b8e229d9b5552dfdda2b4d90cf92 "},{"title":"DeBot Multisig​","type":1,"pageTitle":"DeBots","url":"develop/smart-contract/debots#debot-multisig","content":"tonos-cli config --url eri01.net.everos.dev tonos-cli debot fetch 0:c69a0ed4a11b467ec1a981f29139dc3ff6af47eeacd2cd93e67a6cfc6f771cfb  or in Ever Surf 0:c69a0ed4a11b467ec1a981f29139dc3ff6af47eeacd2cd93e67a6cfc6f771cfb If you do not have a multisig wallet to try it out with, you can use the following test wallet address and seed phrase: address: 0:66e01d6df5a8d7677d9ab2daf7f258f1e2a7fe73da5320300395f99e01dc3b5f seed phrase: final axis aware because grace sort giant defy dragon blouse motor virus  Please don't empty out its balance, so others can try it out too. "},{"title":"DInterfaces","type":0,"sectionRef":"#","url":"develop/smart-contract/debots/deinterfaces","content":"","keywords":""},{"title":"DeBot-IS-consortium​","type":1,"pageTitle":"DInterfaces","url":"develop/smart-contract/debots/deinterfaces#debot-is-consortium","content":"DeBot Interface Specifications (IS) Consortium. IS a place where community defines interfaces every DeBot browser should support. DeBot-IS-consortium repository "},{"title":"Application Rules:​","type":1,"pageTitle":"DInterfaces","url":"develop/smart-contract/debots/deinterfaces#application-rules","content":"Each new interface must create a folder, which has a readme.md desciption of an interface, example of its implementaion in both Solidity and C++ placed in an &quot;examples&quot; sub folder. "},{"title":"Interface submission proccess:​","type":1,"pageTitle":"DInterfaces","url":"develop/smart-contract/debots/deinterfaces#interface-submission-proccess","content":"You should create a specifications proposal, discuss it.After the discussion is over and proposal is accepted you should submit examples in both Solidity and C++.Only proposals with examples will be published. "},{"title":"Supported browsers:​","type":1,"pageTitle":"DInterfaces","url":"develop/smart-contract/debots/deinterfaces#supported-browsers","content":"If you implemented a DeBot browser we will be happy to list it. Please let us know.Your browser should clearly state interfaces which it supports (by version number as stated in repository). "},{"title":"Getting started","type":0,"sectionRef":"#","url":"develop/smart-contract/debots/getting-started","content":"Getting started","keywords":""},{"title":"Samples","type":0,"sectionRef":"#","url":"develop/smart-contract/debots/samples","content":"Samples","keywords":""},{"title":"Debugging","type":0,"sectionRef":"#","url":"develop/smart-contract/debugging","content":"Debugging","keywords":""},{"title":"Developing with C++","type":0,"sectionRef":"#","url":"develop/smart-contract/developing-with-c++","content":"Developing with C++","keywords":""},{"title":"Examples","type":0,"sectionRef":"#","url":"develop/smart-contract/examples","content":"Examples","keywords":""},{"title":"Developing with TVM Solidity","type":0,"sectionRef":"#","url":"develop/smart-contract/developing-with-tvm-solidity","content":"Developing with TVM Solidity","keywords":""},{"title":"FAQ","type":0,"sectionRef":"#","url":"develop/smart-contract/faq","content":"FAQ","keywords":""},{"title":"Frontend App","type":0,"sectionRef":"#","url":"develop/smart-contract/frontend-app","content":"Frontend App","keywords":""},{"title":"Getting started","type":0,"sectionRef":"#","url":"develop/smart-contract/getting-started","content":"","keywords":""},{"title":"Prerequisite​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/getting-started#prerequisite","content":"Node.js &gt;= 14.x installed Node Version Manager (NVM)NVM-windows Docker &gt;= 19.x installed and running "},{"title":"Generate a new project​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/getting-started#generate-a-new-project","content":"mkdir my-project &amp;&amp; cd $_ npm init --force npm install --save everdev  "},{"title":"Setup local environment​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/getting-started#setup-local-environment","content":"Set Local Blockchain SE (Startup Edition) as the default network: Startup SE at this step, you may have to wait until the docker image is downloaded: npx everdev se start  A local network explorer is available at localhost check it. Setting SE as default network: npx everdev network default se  "},{"title":"Configure Giver​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/getting-started#configure-giver","content":"Configure Giver wallet that will sponsor EVER for deploy operation: npx everdev signer add giver 172af540e43a524763dd53b26a066d472a97c4de37d5498170564510608250c3 npx everdev network giver se 0:b5e9240fc2d2f1ff8cbb1d1dee7fb7cae155e5f6320e585fcc685698994a19a5 --signer giver npx everdev network giver dev 0:b5e9240fc2d2f1ff8cbb1d1dee7fb7cae155e5f6320e585fcc685698994a19a5 --signer giver  "},{"title":"Generate the key pair for contract ownership​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/getting-started#generate-the-key-pair-for-contract-ownership","content":"Key pair file — used in contracts with implemented authorization. It is the file containing private and public keys authorized to access the contract. In --sign parameter the corresponding seed phrase may be used instead of it. npx everdev signer generate coder npx everdev signer default coder npx everdev signer list  "},{"title":"Generate a new smart-contract​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/getting-started#generate-a-new-smart-contract","content":"npx everdev sol create App  You are got App.sol: pragma ton-solidity &gt;= 0.35.0; pragma AbiHeader expire; // This is class that describes you smart contract. contract App { // Contract can have an instance variables. // In this example instance variable `timestamp` // is used to store the time of `constructor` // or `touch` function call. uint32 public timestamp; // Contract can have a `constructor`. // The function that will be called when contract will be deployed to the blockchain. // In this example constructor adds current time to the instance variable. // All contracts need call `tvm.accept()` for succeeded deploy. constructor() public { // Check that contract's public key is set require(tvm.pubkey() != 0, 101); // Check that message has signature (msg.pubkey() is not zero) and // message is signed with the owner's private key require(msg.pubkey() == tvm.pubkey(), 102); // The current smart contract agrees to buy some gas to finish the // current transaction. This actions required to process external // messages, which bring no value (hence no gas) with themselves. tvm.accept(); timestamp = now; } function renderHelloWorld () public pure returns (string) { return 'helloWorld'; } // Updates variable `timestamp` with current blockchain time. function touch() external { // Each function that accepts external message must check that // message is correctly signed. require(msg.pubkey() == tvm.pubkey(), 102); // Tells to the TVM that we accept this message. tvm.accept(); // Update timestamp timestamp = now; } function sendValue(address dest, uint128 amount, bool bounce) public view { require(msg.pubkey() == tvm.pubkey(), 102); tvm.accept(); // It allows to make a transfer with arbitrary settings dest.transfer(amount, bounce, 0); } }  For more about Solidity and specific of Everscale Solidity "},{"title":"Compile smart-contract​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/getting-started#compile-smart-contract","content":"npx everdev sol compile App.sol  You are got: App.abi.json — ABI *.abi.json file — a file that describes the contract interface, the methods and parameters used to interact with it, for detail see ABI Specification V2.App.tvc — TVC *.tvc file — the compiled smart contract file. Used only when generating contract address and deploying contract code to the blockchain. "},{"title":"Deploy smart-contract​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/getting-started#deploy-smart-contract","content":"The 1 EVER is 1000000000 nano EVER Local network: npx everdev contract deploy --network se --value 1000000000 App  Developer network: npx everdev contract deploy --network dev --value 1000000000 App  "},{"title":"Address smart-contract​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/getting-started#address-smart-contract","content":"Address of smart-contract is calculated from TVC and signer (coder) public: npx everdev contract info --network se --signer coder App  Getting only address: appAddress=$(npx everdev contract info --network se --signer coder App | grep Address | cut -d ' ' -f 4) echo $appAddress  "},{"title":"Interact with smart-contract​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/getting-started#interact-with-smart-contract","content":"Read: npx everdev contract run-local --network se App renderHelloWorld npx everdev contract run-local --network se App timestamp  Write: npx everdev contract run --network se --signer coder App touch  For more details see: Get started with Development Tools. "},{"title":"How the blockchain works on the block and queue level","type":0,"sectionRef":"#","url":"develop/smart-contract/learn/blockchain","content":"How the blockchain works on the block and queue level This note is just for a general understanding of how the blockchain works, it’s not 100% accurate, we are waiting for a description from the writers of the node. This may change after a new consensus. There is a workchain -1, this is the master chain, it is validated by the validators with the largest stake. Contracts can be deployed in the -1 workchain, but it is more expensive, and it was made mainly for governorship. (Probably in the future there will be no user contracts) There is a workchain 0, where contracts are mostly located. More workchains will be launched in the future. Workchains are further divided into Processing threads. There is a workchain parameter that indicates the minimum number of processing threads, and currently it is 16 for a 0 workchain. Thread processing is an interesting concept. In ES, only computation is shared between the validators of the same workchain, but they all have the same storage. Let’s look at what that means and how it works. For example, we have 160 validators for the 0 workchain. They are randomly divided into 16 groups of 10 validators, and each gets its own Processing thread. All workchain contracts are also divided into 16 groups, simply by address ranges. (0.00 - 0:08, 0:08 - 0.18, etc.). Each group of validators executes transactions only for their group of smart contracts, and releases blocks of their processing thread. But at the same time, they are constantly downloading blocks of other processing threads in order to see their outgoing and incoming message queues. At the same time, blocks are not a list of transactions that need to be rolled up, but a list of incoming messages + a state delta. So, when you download a block of another processing thread, you do not have to do computation in order to update your state. You’re just rolling state changes. How roughly works: The Masterchain generates block 1.All threads download the last master block.Threads create their own block and register it in the master block.The masterchain generates block 2, which contains the hashes of all blocks of threads that have registered in it.All threads download masterblock 2.All threads look at the hashes of the registered blocks of other threads, and download them all.All threads generate a block.This process gets repeated. Message delivery guarantees also work in this way. When you create a message, it is placed on that thread’s outgoing queue: Thread A generates a message for the contract that is in thread B, and creates a block with a new outgoing message in the outgoing queue.Thread A is registered in the master block.The masterchain generates a block.Thread B downloads the master block, and downloads the block of thread A registered there.Thread B sees the message in thread A and imports it into its inbound queue. (When a message is imported, it is immediately executed (transaction starts) If there is not enough gas for a transaction in the current block, then the message is simply not imported, and waits for its turn in another block. At the same time, there is a message import order, so that validators will not be able to ignore it forever).Thread B creates a block with a message in the incoming queue, and registers with the master.Thread A downloads the block in which it sees its message in thread B’s incoming queue and removes the message from its outgoing queue since it was delivered successfully.Generally, thread A generates a block, then registers it in the master block. Then thread B downloads it, sees that thread A has removed it from its outgoing queue, and deletes it from its incoming one. In fact, sharding in this blockchain is the sharding of computational resources. And the data is the same for everyone, with the expectation that all validators have gigabit channels, and we rest only on computation. If some processing thread is heavily loaded with the last N blocks, then it will split into two, and new processing threads can also split in turn. Then when the load drops, they all merge.","keywords":""},{"title":"Carefully working with value when creating messages","type":0,"sectionRef":"#","url":"develop/smart-contract/learn/carefully-working-with-value","content":"Carefully working with value when creating messages In general, whenever you create outgoing messages while processing incoming internal messages, you must be very careful with the value that you attach to messages. The subtlety here is that if you create outgoing messages while processing an incoming message, then value can be deducted from your contract account, even if there is not enough money to pay for this value in the incoming message and you did not call tvm.accept(). Here is an example of a function that can spend money from a contract account. function deployWallet( uint256 _wallet_public_key, uint128 _deploy_evers ) external { TvmCell stateInit = tvm.buildStateInit({ contr: TokenWalletContract, varInit: { root_address: address(this), wallet_code: wallet_code }, pubkey: _wallet_public_key, code: wallet_code }); new TokenWalletContract{ stateInit: stateInit, value: _deploy_evers, wid: address(this).wid, flag: 0 }(); } Everything seems to look good; the function should deploy the wallet and send the specified amount of EVER there. But due to the separation of phases (read above about phases), the creation of the message is paid from the money in the incoming message, and the message is put into the register of outgoing messages, where it will wait for the action phase. And in the action phase, it is created, and value is deducted from the contract account instead of the message account. And if we attach 1 ever to the message and request to deploy the wallet with 3 ever, then the remaining 2 ever will be deducted from the contract account. Working with flags and value can be very tricky and you need to play around with them to understand the logic of TVM. Here is another example: function deployWallet( uint256 _wallet_public_key, uint128 _deploy_evers ) external { require(msg.value - 0.1 ever &gt; _deploy_evers); TvmCell stateInit = tvm.buildStateInit({ contr: TokenWalletContract, varInit: { root_address: address(this), wallet_code: wallet_code }, pubkey: _wallet_public_key, code: wallet_code }); new TokenWalletContract{ stateInit: stateInit, value: _deploy_evers, wid: address(this).wid, flag: 0 }(); msg.sender.transfer({ value: 0, bounce: false, flag: 64 }); } Here we have the example as above, but now we’ve checked that the msg.value is 0.1 ever greater than the _deploy_evers, and we want to return the change back to the sender. But this is also incorrect. For example, we send 1 ever with the message and request to deploy the wallet with 0.5 ever. During the computation phase, TVM will queue the wallet creation request with 0.5 ever, and then the reverse transfer creation intention, with the value of 1 ever - gas (let’s say the price of gas is 0.01 ever), i.e. 0.99 ever. As a result, we will have two outgoing messages with 0.5 and 0.99 ever, and only 1 ever in the incoming message. The correct way to write this function is as follows: function deployWallet( uint256 _wallet_public_key, uint128 _deploy_evers ) external { tvm.rawReserve(address(this).balance - msg.value, 2); TvmCell stateInit = tvm.buildStateInit({ contr: TokenWalletContract, varInit: { root_address: address(this), wallet_code: wallet_code }, pubkey: _wallet_public_key, code: wallet_code }); new TokenWalletContract{ stateInit: stateInit, value: _deploy_evers, wid: address(this).wid, flag: 0 }(); msg.sender.transfer({ value: 0, bounce: false, flag: 128 }); } What we actually have to do first it to call tvm.rawReserve, which is like sending a message to yourself, with a value equal to the initial balance of the contract. Then we deploy the wallet with _deploy_evers, and at the end, all the money that is left on the balance after the first two messages is sent back to the caller. This function is guaranteed not to spend the money on the contract. If, in the action phase it does not have enough money to send a message, it will simply be aborted. The most important thing from the chapter above, when processing internal messages, is this: If you apply a value that is not 0 to a message, always call tvm.rawReserve first.Flag 64 can only be used if your transaction is only sending one outgoing message.","keywords":""},{"title":"Data structures","type":0,"sectionRef":"#","url":"develop/smart-contract/learn/data-structures","content":"","keywords":""},{"title":"TVM — Ton Virtual Machine.​","type":1,"pageTitle":"Data structures","url":"develop/smart-contract/learn/data-structures#tvm--ton-virtual-machine","content":"Realized 1 to 1 just like in Nikolai Durov’s whitepaper: https://ton.org/tvm.pdf What do you need to know about VM? It is just a virtual stacking machine, so when using it we are working with information that is on the stack. (Operations that occur there are of the following sort: Combine the two topmost numbers in the stack, or swap the 2nd position in the stack with the 10th). What is important: "},{"title":"The TVM code is standard data​","type":1,"pageTitle":"Data structures","url":"develop/smart-contract/learn/data-structures#the-tvm-code-is-standard-data","content":"The code is simply stored on the chain and can be shared via messages and rewritten. There is a tvm.setcode(code)operation the will change your contract code for your subsequent transactions and even a tvm.setCurrentCode(code)operation that will apply the new code to the current transaction you are making. There are nuances to consider when updating a contract, for more on that see the &quot;How to upgrade contracts&quot; section of this tutorial. "},{"title":"Messages and funds​","type":1,"pageTitle":"Data structures","url":"develop/smart-contract/learn/data-structures#messages-and-funds","content":"In an asynchronous architecture, all communication between contracts occurs through sending messages. The sequence is something like this (I am not going to delve into the questions of how exactly messages are delivered here, there will be a separate chapter in the appendices that cover this): The contract receives an external message from the outside world, and if the contract agrees to pay for it, a transaction is launched. As a result of the transaction launching, the contract can create any number of outgoing internal messages. The outgoing message contains the address of the destination contract, the function that should be called there and what arguments are attached.The destination contract receives an incoming internal message, and a transaction is started, as a result of which outgoing internal messages can be created. External messages are simple. 10k of gas credit are allocated to external messages and if a contract does not agree to supply the gas to pay for the transaction, then the message will simply be discarded and the transaction will not start. But with internal messages, everything is more complicated. When a contract receives an internal message, a transaction is started. Logically, in most cases the calling contract should pay for the gas for this transaction type, and not the called contract. But at the same time, it is obvious that the calling contract must control exactly how much gas it is willing to pay. What further complicates things is that contracts can find themselves in different shards, and one shard cannot spend the money of another shard. Therefore, in ES, all outgoing messages are appended with value ( ever-s ). When a contract receives a message, the gas is paid out of the money attached to this message, and if the money in the message runs out and the contract does not want to continue paying, then the transaction will run out of gas. If, after the transaction is completed, there is money left in the message, then it will be added to the contract’s account (or the contract can send the change back). All internal messages have to carry some amount of money with them. Even if the contract agrees to pay for the message, the message must have enough coins to pay for the download of the contract and the initial checks (until it gets to tvm.accept()). When you create a message, you have to show a flag which will determine where the money that gets attached to the message will come from and how the creation of the message will be paid for. The money can come from the contract account or be taken from money left over on the incoming message after the gas deduction. From this document https://github.com/tonlabs/TON-Solidity-Compiler : Regular money transfer: value — this is the amount of money you want to transfer. (Essentially, this is just the amount of EVER we attach to an internal message and it doesn’t matter that this is a regular money transfer or a call of some kind of method of a smart contract.) bounce — this is a flag that indicates whether we need to try to create a return message should an error occur during the processing of the message or there is no contract deployed on the destination address. By default, the flag will be true. If it is false, then, if there is an error, the money will just remain on the address. flag — flags indicate how, from where and how much money is sent with a message. Read the description from the document below and I will provide further explanation. "},{"title":"Excerpt from the TON Solidity compiler documentation:​","type":1,"pageTitle":"Data structures","url":"develop/smart-contract/learn/data-structures#excerpt-from-the--ton-solidity-compiler-documentation","content":"Possible values of parameter flag: @ 0 - message carries funds equal to the value parameter. Forward fee is subtracted from the value.128 - message carries all the remaining balance of the current smart contract. Parameter value is ignored. The contract's balance will be equal to zero after the message processing.64 - carries funds equal to the value parameter plus all the remaining value of the inbound message (that initiated the contract execution). Parameter flag can also be modified:flag + 1 - means that the sender wants to pay transfer fees separately from contract's balance.flag + 2 - means that any errors arising while processing this message during the action phase should be ignored. But if the message has wrong format, then the transaction fails and + 2 has no effect.flag + 32 - means that the current account must be destroyed if its resulting balance is zero. For example, flag: 128 + 32 is used to send all balance and destroy the contract. When messages are created, two things occur: payment for the creation of the actual message (payment for validators so that they deliver the message), and payment of the value (funds) which will be attached to the message. In most cases you will use the following flags: 0, 1, and 64. 0 and 1 you will use primarily when you start the transaction sequence yourself: 0 — this flag communicates that the creation of the message will be paid from the value that you attached to the message, meaning that a little less than the total value you attached will be sent. The value itself will be paid from the account of the contract (all of the money remaining with the message will be added to the account). 1 — the same thing as with 0, only the creation of the message will be paid from the contract account separately and the total amount attached to the message will be sent with it. 64 — This flag is used when processing an incoming internal message (when another contract calls you). You will most often use this flag with the value: 0. This indicates that for an outgoing message you have to attach the entire value that came with the incoming message, minus the spent gas. The creation of the outgoing message itself will also be paid for with the incoming money. This is a very important concept, in this paradigm other contracts do not spend money from your contract on calls. Below I will demonstrate a few simple examples. Here are some examples of using flags. Contract A gets an Ext message from its owner and begins a message sequence, calling B and attaching 0.5 EVER to the message. // Contract A function updateOwnerOnChildren( address children, uint256 new_pubkey ) external { require(msg.pubkey() == tvm.pubkey(), AErrors.error_message_sender_is_not_my_owner); tvm.accept(); // On the IB interface we call the setNewOnwer function // By default the flag will be 0, we don't have to change it. // So we send 0.5 ever and pay for the creation of the message // from these 0.5 ever IB(children).setNewOnwer{value : 0.5 ever}(new_pubkey); }  // Contract B function setNewOnwer( uint256 new_pubkey ) external { require(msg.sender == myRoot, BErrors.error_message_sender_is_not_my_root); // Here we won't call tvm.accept() because we don't want // the incoming message to be able to spend money on the smart contract account. tvm.setPubkey(new_pubkey); // We send the rest of the remaining value back to the sender. // value - 0, bounce - false, flag - 64 msg.sender.transfer(0, false, 64); }  This is the basic pattern according to which ES works. Even though the price of gas doesn’t fluctuate, we don’t calculate down to the penny the exact amount you need to send to the contract so that you will have enough to cover the transaction. We just send a a decent amount and then send the remainder back. (We know that what we send will cover the fees because the price of gas won’t rise). Doing this, we can create long chains, by putting the contract address that initiated the whole chain in the call arguments and then returning the change to that address at the end. "},{"title":"BoC. Now for the hard part :-)​","type":1,"pageTitle":"Data structures","url":"develop/smart-contract/learn/data-structures#boc-now-for-the-hard-part--","content":"All data in ES is stored and sent in a structure called the BoC (Bag of cell). This is a confusing structure invented by Nikolai Durov, and it’s not very clear whether it was necessary in order to create the blockchain, or Nikolai over-engineered here. In general, all data stored in the contract (not the code, the code is separate, but also the BoC is stored in the contract :-)) is stored in one BoC, this is a given cell (TVMCell) with links to subcells. The TVMCell is a structure that has 1023 Bits of data and 4 references to its child cells. A cell reference is the HASH of that cell. With ES have have a singly connected graph, where each node can have 4 descendants. And we need to pack all smart contract data or messages into a cell with sub cells. Thank God, by using Ton Solidty and knowing the interfaces of contracts, you don’t have to manually pack and unpack cells. The compiler will do everything for you. However, there are rare cases when you will have to do it yourself. In order to do this, there are special primitives in Solidity. When this is necessary, you simply declare state variables in Solidity and read and write to them as usual. The compiler will pack and unpack everything in the BoC for you. Some BoC properties to understand. BoC is an acyclic graph. The link to a cell c is a hash of its data and its hash links to subcells. So we cannot create a cycle. (Because if we add a link from the parent cell to the child cell, then, by doing so, we recalculate all hashes from the changed cell to the root cell and the link to the parent cell changes). The entire state of the contract is BoC. This is one cell with as many child cells as you like. Ton Solidity takes care of work with states for us, but you need to understand that, because of ES’s tree structure, we normally don’t write contracts with a lot of data. In order to illustrate how it works, consider (schematically) how a dictionary could be implemented in BoC.  Each circle in the picture is a separate cell. To get the value by key 2, TVM needs to load a cell of depth 0, then depth 1 and then depth 2. We have to pay gas for each time a cell is loaded. And if we change the value by key two, we will need to recalculate all references from the cell with the value of the root cell because the cell reference is a hash (cell.data + cell.refs). So, links to all cells along the way will change and we will need to change them from bottom to top. So, the more elements our dictionary has, the deeper the cell will be and the more expensive it will be to work with. For a dictionary, the cost of gas will increase to O(log n) in a worst case scenario. (In reality, everything would be more complicated but O (log n) can be useful to look at as a worst case scenario). Now, if we are creating an ERC20 token, then the more owners this token has, the more expensive the gas will be to use this contract (the size of the owner-number map will grow). And although O(Log n) doesn’t sound scary at all, and the cost of working with the map will increase very, very slowly after the first hundred elements, and then even slower after that, in ES there we have a storage fee that grows linearly. If you have accounts in your ERC-20 token that contain pennies, then the fees for holding these accounts will greatly exceed the value of these accounts over the years. Therefore, in ES it is customary to make separate contracts for separate accounts, which themselves pay for their storage. We will look at how the TIP-3 standard (a distributed replacement for ERC-20) works in the next chapter. Fun fact: this entire overcomplicated data storage scheme helps to scale the network, so that the validator can quickly execute smart contracts. Validators do not need to store the entire current state of the blockchain in Ram, because loading the smart contract state from the disk will be fast, since all smart contracts are small. Additionally, since all contracts are small, they are evenly distributed across all shards. "},{"title":"Gas limits and external message size","type":0,"sectionRef":"#","url":"develop/smart-contract/learn/gas-and-messages-limits","content":"Gas limits and external message size There are size restrictions for external messages (now it is about 16 kilobytes). So you will not be able to send more than 16 kb to a data contract in one message, and you will also not be able to deploy a contract with an external call larger than 16 kb. Of course, there are workarounds. You can make a contract where you first fill in the data bit by bit, and then the contract will glue this data together and send it in one big internal message. But it is better to keep contract sizes relatively small. These restrictions apply only to the size of external messages, not to the sizes of contracts and internal messages. There is also a limit on the amount of gas that one transaction can spend, and it is quite small. The absolute limit is about a million gas, but this will not tell you anything :-) You have to test it to see. For example, if you have a mapping with more than 1000 elements, you can write no more than 200 new keys in one transaction. Gas limits can be bypassed recursively by calling yourself (by sending an internal message to yourself). More about​ Managing gasFee calculationBlockchainConfig parameters","keywords":""},{"title":"How to upgrade contracts","type":0,"sectionRef":"#","url":"develop/smart-contract/learn/how-to-upgrade-contracts","content":"How to upgrade contracts There are two complications with upgrading contracts. The first complication with upgrading: We have tvm.setCode() and we can change the contract code at any time. But the problem is in contract storage. We have all the variables in one BoC, and Solidity simply uses the mapping to these cells, which is created at compiling time. If your state variables do not change, then you can simply do tvm.setCode() and complete the transaction as in this example. But we want to be able to change the storage structure. Let’s say that prior to the upgrade we had the following state variables: TvmCell proxyCode; mapping (address =&gt; uint128) balances; uint32 version; address root; uint256[] lastHashes; The Solidity compiler somehow distributes them into cells (you can see how storage is arranged in the chapter on BoC). For example, like this (this is just an example, in reality it is more complicated). And after tvm.setCode we will have more variables: TvmCell proxyCode; mapping (address =&gt; uint128) balances; mapping (address =&gt; uint128) approvedAddresses; uint32 version; address root; uint256[] lastHashes; And the compiler will map them to contract storage in a different way, for example, like this: Solidity expects a different mapping of state variables to storage, but we have the old storage mapping. Unfortunately, there is currently no way to automatically migrate from the old representation to the new one. After changing the code, you need to do tvm.resetStorage() and manually migrate the old data to the new storage. Below I will describe an example of how to do this in practice. We have contract A version 1 and we want to be able to upgrade it to version 2 in the future. In the version 1 contract, we implement the codeUpgrade function: function codeUpgrade(TvmCell _code, uint32 _newVersion) override public onlyRoot { // If a new version if (version != _newVersion) { TvmBuilder data; // We pack old the data from the old version into TvmCell data.store(_newVersion); TvmBuilder prevStateData; prevStateData.store(proxyCode); prevStateData.store(balances); prevStateData.store(lastHashes); data.storeRef(stateData); // Import the new code. // For the following transactions tvm.setcode(_code); // Establish the new code with the CURRENT code // Already in the framework of the current code (shock) tvm.setCurrentCode(_code); // Transfer to the onCodeUpgrade function the new code // With all the data we want to keep from the old contract onCodeUpgrade(data.toCell()); } } In the new version 2 contract, we implement the onCodeUpgrade function (this utility function can only be called after onCodeUpgrade). function onCodeUpgrade(TvmCell _data) private { // We erase contract storage to 0, because we have changed // the storage strcuture. This call will not affect // _pubkey, _constructorFlag or _replayTs variables. tvm.resetStorage(); //We decode TvmCell and rewrite it in the new storage structure TvmSlice s = _data.toSlice(); version = s.decode(uint32); TvmSlice params = s.loadRefAsSlice(); (proxyCode, balances, lastHashes) = params.decodeFunctionParams(prevVersionParams); } function prevVersionParams( TvmCell _proxyCode, mapping (address =&gt; uint128) _balances, uint256[] _lastHashes ) public {} By doing that we have essentially upgraded the contract. But then we run into complication number 2: As you already understand from the chapter on distributed programming, in many use cases in ES it is very important to have a computed contract address. The address is hash(code + static variables), tvm.setCode() does not change the contract address, the contract address is calculated at the time of deployment. What should we do if we have a Root contract that first deployed the v1 contract, and then we told it to deploy the updated contracts, and the old ones were updated? Contract addresses v1 and v2 will be calculated differently. To do this, we use a Proxy contract. The whole point of this contract is to be the starting point of the address. With it, we untie the contract address from the real code, and use the Proxy.sol code to calculate the address. In the constructor of this contract, we pass the Real code, and the data of the constructor, and it will immediately upgrade to the new code and call onCodeUpgrade(). pragma ton-solidity &gt;= 0.52.0; contract Proxy { address static root; // Root contract TvmCell static initialData; modifier onlyRoot { require(msg.sender == root, 100); _; } constructor(TvmCell _code, TvmCell _params) public onlyRoot { TvmBuilder builder; builder.store(uint32(0)); // Upgraded from version 0 builder.store(root); // Root address. Address depends on this data builder.store(initialData); // Static data. Address depends on this data builder.store(_params); // Dynamic params. Address does not depend on these params. //Set code for next transactions. tvm.setcode(_code); //Set new code right now for current transaction tvm.setCurrentCode(_code); // call onCodeUpgrade from new code onCodeUpgrade(builder.toCell()); } function onCodeUpgrade(TvmCell _data) private {} } We always deploy Proxy.sol from Root.sol, and immediately call for the migration to a new version of the code. And if the code changes, then we will still deploy Proxy.sol just with a different version, and the addresses will be considered the same for v1 and v2 (because they are calculated from the Proxy.sol code) You can find a fully-functional example here.","keywords":""},{"title":"Distributed programming","type":0,"sectionRef":"#","url":"develop/smart-contract/learn/distributed-programming","content":"","keywords":""},{"title":"Important concept​","type":1,"pageTitle":"Distributed programming","url":"develop/smart-contract/learn/distributed-programming#important-concept","content":"In ES, each contract address is a uniquely computed value. A contract address is a hash of the contract code and initial data (initial data is a value of static variables, and not what you pass to the constructor, since in ES the constructor is a function that you call after the deployment of the contract in one transaction). This is a very important pattern of distributed programming (as it is understood in ES). Knowing the code of a contract, and it initials data you can make sure that you are being called by a contract with the same parents as your own. Or, knowing the contract code and its initial data, you can compute the address of a contract on the fly and send messages to it. "},{"title":"How contracts are deployed​","type":1,"pageTitle":"Distributed programming","url":"develop/smart-contract/learn/distributed-programming#how-contracts-are-deployed","content":"The concept described above is also tied to how contracts are deployed in ES. The contract can naturally be deployed by another contract. But what should we do if we want to deploy a contract from outside? To do this, we have to take the contract code and its initial data, and compute its future address. After that, we simply send money there, with a bounce flag = false. And the money just stays on the address, which has no initialized code. Then we send a special external message to this address with the code and initial data, and we say “Look, here we have the code and initial data, the hash of which gives us this address, initialize it please” and the network initializes the contract. Now let’s look at a really simplified realization of a TIP-3 token. Our token consists of 2 contracts: Root.sol is controlled by whoever released the token, this allows them to print tokens and deploy the wallets of individual users.Wallet.sol is a wallet contract for individual users. Yes, each user has their own small contract that stores their token balance. By creating contract-wallets we solve a number of different problems: All wallets end up in different shards which distributes the load evenly throughout the network.Wallet contracts are very small with small states. Validators can load them very quickly from a disk.Storage fee. If we had one contract with a huge hash map, then it would have to pay a large fee for its storage, and it is not clear who would pay and how for this storage. If there are many accounts with small balances that their owners no longer need, then naturally they will not pay for its storage, and the rest of the holders of this token will have to pay for all of the “remainders.” So that smart contract programmers do not have to think about how to force users to pay for storage (so that the entire contract is not frozen) or clean up old data inside the contract, ES has allowed each user to deploy their own contract. Each user determines how long they will pay for storage and can always adjust these parameters. Below we are going to look at the code underlying this to understand how it works and why it is safe. A few thoughts to keep in mind while looking at the code: The contract address is the hash (contract code + static variables).If we know the wallet contract code and its initial variables (what the root address of the contract is and what pubkey controls it), then we can calculate what address this contract will have.When one wallet receives a message from another wallet, it can determine from the sender's address whether the sending wallet has exactly the same code, to see if it really has the tokens it is sending you. "},{"title":"Root.sol​","type":1,"pageTitle":"Distributed programming","url":"develop/smart-contract/learn/distributed-programming#root","content":"pragma ton-solidity &gt;= 0.53.0; pragma AbiHeader expire; pragma AbiHeader pubkey; import &quot;TokenWallet.sol&quot;; interface ITokenRootContract { function deployEmptyWallet( uint256 _wallet_public_key, uint128 _deploy_evers ) external responsible returns(address); function mint( address to, uint128 tokens ) external; function deployWalletWithBalance( uint256 _wallet_public_key, uint128 _deploy_evers, uint128 _tokens ) external returns ( address ); } library TokenRootContractErrors { uint8 constant error_tvm_pubkey_not_set = 100; uint8 constant error_message_sender_is_not_my_owner = 101; uint8 constant error_deploy_ever_to_small = 102; uint8 constant error_insufficient_evers_on_contract_balance = 103; uint8 constant error_deploy_wallet_pubkey_not_set = 104; } contract TokenRootContract is ITokenRootContract { uint128 public start_gas_balance; uint128 public total_supply; // The code of the wallet contract is needed to deploy the wallet contract. // In the tvm the code is also stored in the TvmCell and it can be sent via messages. TvmCell static wallet_code; constructor() public { require(tvm.pubkey() != 0, TokenRootContractErrors.error_tvm_pubkey_not_set); tvm.accept(); start_gas_balance = address(this).balance; } modifier onlyOwner() { require(tvm.pubkey() != 0 &amp;&amp; tvm.pubkey() == msg.pubkey(), TokenRootContractErrors.error_message_sender_is_not_my_owner); _; } function deployWallet( uint256 _wallet_public_key, uint128 _deploy_evers ) private returns (address) { // stateInit - the message deploying the contract where we establish the code // the contract and its static variables. // Essentially the hash(stateInit) is the contract address. // The contract address depends on the code and the intial variables. // So we can determine the contract address just by knowing its code // and initial variables (not those that are sent in the constructor). // Pay attention to what the wallet address depends on. // It depends on the root_address(this), the wallet code and the owner's public key. TvmCell stateInit = tvm.buildStateInit({ //We specify the contract interface so Solidity correctly packs // varInit into TvmCell (BoC, see the previous chapter). contr: TokenWalletContract, varInit: { //the value of static variables root_address: address(this), wallet_code: wallet_code }, // pubkey - this will return the tvm.pubkey(). // Essentially this is just another static variable that is introduced separately. pubkey: _wallet_public_key, code: wallet_code }); // Here we create one message that will deploy the contract // (if the contract is already deployed , nothing will happen) // also, this message will call the constructor // () without arguments . address wallet = new TokenWalletContract{ stateInit: stateInit, value: _deploy_evers, //the amount of native coins we are sending with the message wid: address(this).wid, flag: 0 //this flag denotes that we are paying for the creation of the message from the value we are sending with the contract. }(); return wallet; } function deployEmptyWallet( uint256 _wallet_public_key, uint128 _deploy_evers ) override external responsible returns (address) { // With the help of this function, any other contract can deploy a wallet. require(_wallet_public_key != 0, TokenRootContractErrors.error_deploy_wallet_pubkey_not_set); require(_deploy_evers &gt;= 0.05 ton, TokenRootContractErrors.error_deploy_ever_to_small); // This function reserves money on the contract account equal to the balance // of the contract at the moment when the transaction is started. In order not to allow the message // to spend money from the contract balance. // This is a complex moment and we will look at the details in the Additional Materials section // in &quot;Carefully working with value&quot; tvm.rawReserve(0, 4); address deployed_contract = deployWallet(_wallet_public_key, _deploy_evers); // Our function is labelled responsible, this means that it is possible to be called // with a smart contract and it will create a message with a callback. // The compiler will simply add a field to the function arguments // answerID, which shows the ID of the function that will be called // by sending a message back to the msg.sender address // Why do we use 128 here and not 64 - because from this transaction // we have two external calls, one is to deploy the wallet contract, // and the second is the answer: responsible. // You can find more details about this in the &quot;Carefully working with value&quot; section. return { value: 0, bounce: false, flag: 128 } deployed_contract; } //minting tokens function mint( address _to, uint128 _tokens ) override external onlyOwner { // This method is called by an external message, // here we have put some fool-proof protection in place. // This way we will pay for the fulfillment of the transaction from the contract account, // then we check that there are more EVERs on the contract account // then there were when it was deployed. This prevents a situation in which // there are no funds on the contract account and it gets deleted from the network // or frozen because it conannot pay for its storage. require(address(this).balance &gt; start_gas_balance, TokenRootContractErrors.error_insufficient_evers_on_contract_balance); require(_tokens &gt; 0); // We agree to pay for the transaction from the contract account. tvm.accept(); // We send a message with a call of the accept function to the contract at the indicated address. // To the message a sum of 0.01 EVER from the account address will be attached // (this will be done automatically, unless otherwise indicated) ITokenWalletContract(_to).accept(_tokens); total_supply += _tokens; } function deployWalletWithBalance( uint256 _wallet_public_key, uint128 _deploy_evers, uint128 _tokens ) override external onlyOwner returns ( address ) { require(_wallet_public_key != 0, TokenRootContractErrors.error_deploy_wallet_pubkey_not_set); require(_deploy_evers &gt;= 0.1 ton, TokenRootContractErrors.error_deploy_ever_to_small); // Similar fool-proof mechanism to the one above, // but here we also add _deploy_evers require(address(this).balance &gt; start_gas_balance + _deploy_evers, TokenRootContractErrors.error_insufficient_evers_on_contract_balance); require(_tokens &gt; 0); tvm.accept(); // we deploy the wallet address deployed_contract = deployWallet(_wallet_public_key, _deploy_evers); // we send tokens to the wallet in the following message. ITokenWalletContract(deployed_contract).accept(_tokens); total_supply += _tokens; return deployed_contract; } onBounce(TvmSlice slice) external { tvm.accept(); // This is a utility function for handling errors. You probably noticed that in // the mint function we did not check if the contract was deployed at the destination // address. By default, when calling another contract, the message // will have a flag bounce value of: true. If when the message is being processed by the contract // an exception occurs at the destination address or the contract // does not exist, then automatically (if there is enough money // attached to the message) a return message is sent with a call to // the onBounce function and with arguments. // Here there is a stupid limitation requiring that arguments fit // into 224 bits (WTF) but hopefully this is changed. // We use this function to show you how to handle a situation // when tokens are minted to a non-existing address and to subtract from the total_supply // as the tokens were not printed. // This function cannot just be called, the message must // have a special bounced: true flag, // which cannot be added manually when sending. // So there is no need to do additional checks that we actually sent the message // as no bad actor can subtract from the total supply by sending an unexpected bounced message. uint32 functionId = slice.decode(uint32); if (functionId == tvm.functionId(ITokenWalletContract.accept)) { uint128 latest_bounced_tokens = slice.decode(uint128); total_supply -= latest_bounced_tokens; } } }  "},{"title":"Wallet.sol​","type":1,"pageTitle":"Distributed programming","url":"develop/smart-contract/learn/distributed-programming#wallet","content":"pragma ton-solidity &gt;= 0.53.0; pragma AbiHeader expire; pragma AbiHeader pubkey; interface ITokenWalletContract { function getBalance() external view responsible returns (uint128); function accept(uint128 _tokens) external; function transferToRecipient(uint256 _recipient_public_key, uint128 _tokens, uint128 _deploy_evers, uint128 _transfer_evers) external; function internalTransfer(uint128 _tokens, uint256 _sender_public_key, address _send_gas_to) external; } library TokenWalletContractErrors { uint8 constant error_tvm_pubkey_not_set = 100; uint8 constant error_message_sender_is_not_my_owner = 101; uint8 constant error_message_transfer_not_enough_balance = 102; uint8 constant error_message_transfer_wrong_recipient = 103; uint8 constant error_message_transfer_low_message_value = 104; uint8 constant error_message_internal_transfer_bad_sender = 105; uint8 constant error_message_transfer_balance_too_low = 106; } contract TokenWalletContract is ITokenWalletContract { address static root_address; TvmCell static wallet_code; uint128 public balance; constructor() public { //We check that the public key has been set require(tvm.pubkey() != 0, TokenWalletContractErrors.error_tvm_pubkey_not_set); tvm.accept(); } modifier onlyRoot() { require(root_address == msg.sender, TokenWalletContractErrors.error_message_sender_is_not_my_owner); _; } modifier onlyOwner() { require(tvm.pubkey() == msg.pubkey(), TokenWalletContractErrors.error_message_sender_is_not_my_owner); _; } function accept(uint128 _tokens) override external onlyRoot { // We simply accept any amount of tokens the Root contract wants to send us tvm.accept(); balance += _tokens; } function getBalance() override external view responsible returns (uint128) { // Any contract can get our wallet balance return { value: 0, bounce: false, flag: 64 } balance; } function transferToRecipient( uint256 _recipient_public_key, uint128 _tokens, uint128 _deploy_evers, uint128 _transfer_evers ) override external onlyOwner { // With this method we can send tokens to any similar wallet // directly. When doing this we can say that we want to first // deploy this wallet. require(_tokens &gt; 0); require(_tokens &lt;= balance, TokenWalletContractErrors.error_message_transfer_not_enough_balance); require(_recipient_public_key != 0, TokenWalletContractErrors.error_message_transfer_wrong_recipient); // You cannot send it to yourself :-) require(_recipient_public_key != tvm.pubkey()); require(address(this).balance &gt; _deploy_evers + _transfer_evers, TokenWalletContractErrors.error_message_transfer_balance_too_low); // A check to make sure we want to add no less than // 0.01 ever to the outgoing message. If we don't add enough, the transaction will fail // and onBounce won't work. // This is an empirical value, as on our network gas does not fluctuate // and will only decrease from the original value. require(_transfer_evers &gt;= 0.01 ever, TokenWalletContractErrors.error_message_transfer_low_message_value); tvm.accept(); // We calculate the destination address of the wallet contract. TvmCell stateInit = tvm.buildStateInit({ contr: TokenWalletContract, varInit: { root_address: root_address, wallet_code: wallet_code }, pubkey: _recipient_public_key, code: wallet_code }); address to; if (_deploy_evers &gt; 0) { // We deploy the wallet, here everything should be familiar. to = new TokenWalletContract{ stateInit: stateInit, value: _deploy_evers, wid: address(this).wid, flag: 1 // this means that we will pay for the creation of the outgoing message not from с _deploy_evers but from the wallet balance }(); } else { // We simply determine the destination wallet address. to = address(tvm.hash(stateInit)); } balance -= _tokens; // Here we send a message with a call to the internalTransfer function, // described below. Since we have a guarantee in the blockchain on the order of // message delivery, even if we just sent a deploy message // for the contract above, we can be sure that it will deploy // before the internalTransfer will be called. We also put in // bounce: true, in case there is an error (we did not // deploy the contract for example) to call the // onBounce function and return the money to ourselves. ITokenWalletContract(to).internalTransfer{ value: _transfer_evers, flag: 1, bounce: true } ( _tokens, tvm.pubkey(), address(this) ); } function internalTransfer( uint128 _tokens, uint256 _sender_public_key, address _send_gas_to ) override external { // Transfer accepting function. This is a very nice concept. // We can send tokens directly from one wallet // to another because in ES a contract address is a uniquely // computed value. We can check that the contract that is // calling us is the same kind of contract as ours and has the same // Root and code. So we know for sure if the contract calls us // these tokens are real and come from the contract root. // We determine the address of the contract that called us // from _sender_public_key address expectedSenderAddress = getExpectedAddress(_sender_public_key); // We make sure that the right address called us. require(msg.sender == expectedSenderAddress, TokenWalletContractErrors.error_message_internal_transfer_bad_sender); // Accept transfer. balance += _tokens; if (_send_gas_to.value != 0) { // We send all the unspent value that was in the message back // to the contract. This is also possible to do via msg.sender, // but we want to show you here that you can send // in a long chain the address to where the change should be returned // if we have a long interaction. _send_gas_to.transfer({ value: 0, flag: 64 }); } } function getExpectedAddress( uint256 _wallet_public_key ) private inline view returns ( address ) { TvmCell stateInit = tvm.buildStateInit({ contr: TokenWalletContract, varInit: { root_address: root_address, wallet_code: wallet_code }, pubkey: _wallet_public_key, code: wallet_code }); return address(tvm.hash(stateInit)); } onBounce(TvmSlice body) external { // This is a utility function, messages will only end up here // if during message processing, an error occurs // but there is enough money to create // an onBounce message. No additional checks that you sent the // message here are needed, you can't send a message here manually. tvm.accept(); uint32 functionId = body.decode(uint32); if (functionId == tvm.functionId(ITokenWalletContract.internalTransfer)) { // Our transfer was not sent, we return the money to our balance. uint128 tokens = body.decode(uint128); balance += tokens; } } }  "},{"title":"ThirdParty.sol​","type":1,"pageTitle":"Distributed programming","url":"develop/smart-contract/learn/distributed-programming#third-party","content":"And here are some examples of ThirdParty.sol to show how to work with responsible. pragma ton-solidity &gt;= 0.53.0; pragma AbiHeader expire; pragma AbiHeader pubkey; import &quot;TokenRoot.sol&quot;; contract ThirdPartyContract { address public lastDeployedWallet; constructor() public { require(tvm.pubkey() != 0, 2); tvm.accept(); } modifier onlyOwner() { require(tvm.pubkey() == msg.pubkey(), 3); _; } function deployWallet( address _root_contract, uint256 _wallet_public_key, uint128 _send_evers, uint128 _deploy_evers ) external onlyOwner { // This entire Third party contract was done to show you how to // call the responsible function. // Everything is simple here, we just call the function and transfer // callback - this is the ID function to call tvm.accept(); ITokenRootContract(_root_contract).deployEmptyWallet{ value: _send_evers, callback: onGetDeployed }(_wallet_public_key, _deploy_evers); } function onGetDeployed( address _address ) public { // The callback which Root will call in answer to deployEmptyWallet. // There is no built-in check to make sure this function // is truly being called in answer to your call. // So you have to check if you really made this call. // For example, by storing the address of root that you are interacting with // and checking that the response is something like require(msg.sender == root_address) // Fun fact, when we get an answer here, that does not mean // that the wallet is deployed. This means that the Root // contract created an outgoing deploy message. // We can receive this message before the wallet is deployed // (the message is en route). // In principle, the LT (see Additional information) guarantees us, // that if we want to call a wallet method from here, // our message will not arrive earlier than the wallet is deployed. lastDeployedWallet = _address; } }  By carefully reading the examples above, and playing around with the code available here https://github.com/mnill/everscale-education-simple-tip3, you should be able to understand the principles of distributed programming, how separate contracts are deployed in ES for different users and why it is safe. If you’ve been able to piece everything together in your head, you are likely to also have appreciated the beauty of such a solution with distributed wallets. It solves several problems at once: There is no single big map where all balances are stored. Validators can load contracts from disks as quickly as possible.Every user deploys their own wallet and pays for the storage of their data on the blockchain.By transferring money directly between wallets, the load is distributed as evenly as possible throughout the blockchain. Each wallet ends up in a random shard, depending on the address of the wallet. So, if there is a sharp increase in the number of transfers, we do not have to rely on the performance of a particular shard, since we do not have a central smart contract through which all transfers must pass and which would cause a bottleneck. "},{"title":"Introduction","type":0,"sectionRef":"#","url":"develop/smart-contract/learn/introduction","content":"","keywords":""},{"title":"The Everscale Philosophy​","type":1,"pageTitle":"Introduction","url":"develop/smart-contract/learn/introduction#the-everscale-philosophy","content":"In order to introduce the tutorial, we would like to speak about the Everscale blockchain and what makes it so promising. When Nikolai Durov was creating TON, he was faced with the task of designing a blockchain platform that could accommodate millions of users while having low, stable transaction fees. Durov was able to achieve this, and this is how: "},{"title":"1. Infinite Sharding​","type":1,"pageTitle":"Introduction","url":"develop/smart-contract/learn/introduction#1-infinite-sharding","content":"On ES shards are dynamically added as the load increases and then merged back. This is possible because all contracts on the chain communicate with each other asynchronously, and therefore we can split one shard into two shards without any problems occurring (Shards are just divided in half according to the ranges of contract addresses). "},{"title":"2. Rejection of radical decentralization​","type":1,"pageTitle":"Introduction","url":"develop/smart-contract/learn/introduction#2-rejection-of-radical-decentralization","content":"The ES blockchain was not built to allow just anyone to become a validator. Validation is a critical process, requires professional equipment and access to an appropriate server. The total number of validators will at most be in the thousands, not in the tens of thousands. And validator machines have high server and channel requirements (the current requirements are 48 CPUs, 128 RAM and 1TB SSD) and a 1GB channel (the network is used extensively). This allows for the blockchain to support a very quick block release speed and often rotate validators in the shards. "},{"title":"4. Paid storage​","type":1,"pageTitle":"Introduction","url":"develop/smart-contract/learn/introduction#4-paid-storage","content":"This is a completely brilliant and daring decision that no other blockchain has implemented. When you write something on a classic blockchain (like Ethereum), you put information on the chain forever. So, if you buy a meme coin, data reflecting that purchase will be on the chain until the chain dies. You only pay on creating and accessing that information. However, validators must store that information forever. This give rise to a curious economy — blockchains are forced to artificially limit their rate of recording so that the size of the blockchain state does not grow faster than the rate at which data storage becomes cheaper (In fact, they are even forced to try and prevent the blockchain state from growing faster than the rate at which RAM becomes cheaper). As a result, users are forced to compete with each other in auctions for the right to write data to the blockchain, and transaction fees are increasing all the time. On ES, this problem is solved very simply — each contract is required to pay rent for the validators to store its state, and when the contract runs out of money, it gets deleted. Yes, this is radical, by doing this, users do not need to compete with each other for the right to write indelibly on the blockchain. On ES, each user determines how long they want their data to remain on the blockchain and has the option to extend that time frame. This makes the tokenomics of the chain completely unique, adding flexibility to the data inputed to the chain. Essentially, ES aims to be a decentralized replacement for AWS. Just as you can host your application on AWS, you can host it on ES. Hosting it on ES will not be much more expensive (if it is rarely used, it will be cheaper), but it will have maximum fault tolerance. "},{"title":"Blockchain​","type":1,"pageTitle":"Introduction","url":"develop/smart-contract/learn/introduction#blockchain","content":"This guide is not going to delve into the details of how exactly the ES blockchain works, because you don’t need all of that to understand how to write smart contracts for ES. In the course of the guide, we will analyze the guarantees that the blockchain gives and everything you need to know to write smart contracts. What do you need to know about the blockchain? ES is a multithreaded blockchain. There are different work chains (like global shards, they differ in parameters — there are 2 of them now), and the work chains are further divided into processing threads (like shards, just different validators execute transactions in different smart contracts in parallel, they are added dynamically with increasing load and then deleted). But what you really need to know is that you don't have to think about where your smart contracts are. All communications between contracts are asynchronous via sending messages. It doesn’t matter if two contracts are in the same processing thread or even in different workchains, any call to another contract is a message being sent, and if you are waiting for a response, it will come in another transaction. "},{"title":"Everything is a smart contract!​","type":1,"pageTitle":"Introduction","url":"develop/smart-contract/learn/introduction#everything-is-a-smart-contract","content":"On Ethereum, there are two built-in types of accounts: contract accounts that are deployed to the network and externally owned (wallet) accounts that are controlled by anyone with private keys and can initiate transactions. On ES, there are only contracts, there are no built-in contracts in the form of wallets on the blockchain. A wallet is just a smart contract, and there are many different kinds. Transaction chains on ES can be started by any contract with the help of an external message (if the contract supports receiving external messages). Transactions are started when a smart contract receives a message. During a transaction, a contract can send as many messages as it wants to another contract. (Once received, these messages will begin another transaction). "},{"title":"There are two types of messages​","type":1,"pageTitle":"Introduction","url":"develop/smart-contract/learn/introduction#there-are-two-types-of-messages","content":""},{"title":"External message​","type":1,"pageTitle":"Introduction","url":"develop/smart-contract/learn/introduction#external-message","content":"A message from nowhere or to nowhere :-) This kind of message has only a destination address or a sender’s address. Primarily, this kind of message is used to call contracts from the outside world (from programs or wallets). This is a fairly unique concept that allows any contract to start a chain of messages. External messages work like this: you send a message with data from nowhere to a contract. A validator allocates 10k of gas credit to this message, and attempts to complete the transaction by calling the contract and passing your message to it. The smart contract must agree to pay for the transaction from the contract account by calling the tvm.accept() method before it runs out of gas. If this method is called then the transaction continues and the contract can create other outgoing messages. If an exception occurs or the contract does not call tvm.accept() or the gas credit runs out, then the message does not go to the blockchain and is discarded by the validator (in simple terms, a message cannot get into the mempool if it cannot be successfully added to the blockchain). Interestingly, an external message can contain any data and does not have to contain a signature (for example, you can make a contract receive an arbitrary message every minute from anyone you’d like and as a result perform some kind of action, like a timer). Here is an example of a simple wallet smart contract, which can only transfer money after receiving an external message: pragma ton-solidity &gt;= 0.35.0; // This header informs sdk which will create the external message has to be signed by a key. // Also directing the compiler that it should only accepted signed external messages. pragma AbiHeader pubkey; contract Wallet { constructor() public { // We check that the conract has a pubkey set. // tvm.pubkey() — is essentially a static variable, // which is set at the moment of the creation of the contract, // We can set any pubkey here or just leave it empty. require(tvm.pubkey() != 0, 101); // msg.pubkey() — public key with which the message was signed, // it can be 0 if the pragma AbiHeader pubkey has not been defined; // We check that the constructor was called by a message signed by a private key // from that pubkey that was set when the contract was deployed. require(msg.pubkey() == tvm.pubkey(), 102); // we agree to pay for the transaction calling the constructor // from the balance of the smart contract tvm.accept(); } function send(address dest, uint128 value, bool bounce) public pure { // we check that the signature of the external message is right require(msg.pubkey() == tvm.pubkey(), 100); // we aggree to pay for the external message from the contract balance tvm.accept(); // everything is simple here, we create an outgoing message // internal message which carries the value nano evers // bounce — a flag, which tells TVM what to do if dest contract // does not exist or throws an exception on our internal message. // bounce — true — this will try to create a return message to us with an error // and the remaining money (if there are enough funds to create a message), // bounce — false, this will leave the funds there. // 0 — the flag of message creation, we will get to that later. // 0 means that with the message we have to send value EVER // and pay the fee for the creation of a message from that value. // (by sending a little less than the value) dest.transfer(value, bounce, 0); } }  "},{"title":"Internal message​","type":1,"pageTitle":"Introduction","url":"develop/smart-contract/learn/introduction#internal-message","content":"Internal message. This is basically just a message from one contract to another. This kind of message always has to carry with it a certain amount of EVER, because when another contract is called there is no gas credit like there is with an external message, and before calling tvm.accept() (if this occurs) gas will be paid for from the VALUE attached to the message. If the sum of EVER cannot cover the gas fees, the transaction will fail. dest.transfer(value, bounce, 0) — This is essentially the creation of an internal message with the value sent which will call to the receive() function of the receiving contract without any kind of data. contract Receiver { uint public counter = 0; receive() external { ++counter; } }  "},{"title":"Important Concept​","type":1,"pageTitle":"Introduction","url":"develop/smart-contract/learn/introduction#important-concept","content":"On ES there are guarantees for the delivery and order of internal messages on the blockchain protocol level. If you send a message, it will be delivered. If contract A sends two messages to contract B, they will be delivered to contract B in the order in which they were sent from contract A. It does not matter whether the messages were sent via one transaction or via different transactions.  "},{"title":"Gas usage​","type":1,"pageTitle":"Introduction","url":"develop/smart-contract/learn/introduction#gas-usage","content":"We are not going to cover the exact formulas you can find more information in the Fee calculation section. We will just cover what you need to know and what you are paying for. Firstly, the gas price is a network parameter, and the price does not change on its own as a reflection of demand at a given moment. In the future, it is planned to introduce a mechanism for controlling gas prices. Most likely, this will be realized with the establishment of a hard capped maximum gas price (the current price) and a possible lower price which would be applied if the demand decreases. Because on this blockchain it is critical for users to be able to calculate the exact maximum amount of tokens that they will have to spend on any action. (Due to the asynchronous model employed, you have to be able to know how much money to attach to a message so that you can send enough to cover all transaction fees in the sequence of messages). We pay for: Computing, the same as other blockchains.Loading memory cells, which is quite different from how things work on Ethereum. We will cover this in detail in the chapters on tvm and boc.The creation of outgoing messages, and we pay for incoming messages if these are external and we agree to pay for them.Storage. Every contract pays a rental fee for the storage of its own code and data in the network state. This fee is withdrawn each time a message is sent to you (for all the time that has elapsed since the last transaction). If the balance of your contract falls below 0, calls to the contract will cease to work until you replenish the balance. If the balance falls below -0.1 EVER (for workchain 0, a network parameter, can be changed) the contract will be frozen, with only the hash of data and code remaining while everything else is deleted. The unfreezing process is complicated, you need to replenish your contract and provide its data and code the moment it is frozen. In theory it is even possible that the hash gets deleted, if the contract is left frozen for a while. So you don’t want to store inessential information on the blockchain, even though writing on the chain is cheap, as we pay for storage on the chain separately. In the chapter called distributed programming we will look at how we should organize our smart contracts in accordance with the &quot;paid storage&quot; paradigm. The next part of this guide will cover what we need to know about TVM and the format of storing data on the blockchain. "},{"title":"LT Guarantees","type":0,"sectionRef":"#","url":"develop/smart-contract/learn/lt-guarantees","content":"","keywords":""},{"title":"Delivery order for two contracts​","type":1,"pageTitle":"LT Guarantees","url":"develop/smart-contract/learn/lt-guarantees#delivery-order-for-two-contracts","content":"When a contract receives incoming messages, it is guaranteed that it will receive them strictly in ascending order of the LT of those messages. That is, if we send two messages from the same transaction, the one that was sent first will be received first. If two messages are sent by different transactions, then the one that was sent first will be received first (the LT of the second transaction is greater than the first).  In this case, too, Int 1 will come first, but only if Ext 1 happens before Ext 2 (if you send two external messages at the same time or close in time, there is no guarantee regarding the order in which they will be added into the block).   "},{"title":"Complicated cases​","type":1,"pageTitle":"LT Guarantees","url":"develop/smart-contract/learn/lt-guarantees#complicated-cases","content":"note There is no consensus on whether or not you can count on this, so USE ONLY IF YOU UNDERSTAND WHAT YOU ARE DOING 100%, otherwise you should only use delivery order guarantees for two contracts. (This may change after new consensus) If we send two messages from contract A, and message 1 is sent before message 2, then message 1 will arrive earlier than any other message generated by message 2, as in the example below, Int 1 will always arrive before Int 3.  If you have more than 3 contracts, then the order of delivery is mostly undefined. For all other cases, you definitely shouldn’t count on this if you don’t consider yourself a super expert in LT and node operation. Below I will demonstrate several cases where the delivery order is not defined.  Here the order is not defined, G can receive a message from any of the chains first.  This is a more complicated example. If Ext 1 happens before Ext 2, but they occur close to each other in time, then 1 arrives before 3 and 4, but we don’t know in which order C will receive messages 3 and 4.   "},{"title":"Phases of transaction execution","type":0,"sectionRef":"#","url":"develop/smart-contract/learn/phases-of-transaction-execution","content":"Phases of transaction execution Storage phase — First, money is withdrawn for storing the contract data in the blockchain, and at this stage the contract can be frozen if it does not have enough money to pay for storage. Credit phase - the account balance is increased from the value sent in the message.Computation phase — execution of the transaction. If there is an error in this phase, then we go from here to phase 5 if we have the bounce: true flag. The subtle point here is that the creation of outgoing messages and computing are separated. If your transaction tries to create outgoing messages, then it simply adds the intentions to create outgoing messages into a special register. This does not check that you have enough money to attach value to all these messages. So, if you have 1 ever on your account and you are trying to create two messages, each of which wants to send 0.8 ever, then the computation phase will succeed, the tvm exit code will be 0 and the success: true. That is, the transaction will not fail at the moment when you do not have enough value to apply, it will only fail if you run out of money to pay for gas.Action phase — in this phase, the outgoing messages are created that were put in a special register in phase 3. And if you do not have enough money to pay for outgoing messages, the transaction will be rolled back and go to phase 5 (if the flag is on). In this situation, you will have the computation - success: true, action - success: false, abort: true. There is also a special flag when creating a message, which says that this message should be ignored if there is not enough money to create it.Bounce phase — if the bounce: true flag was set for the incoming message, then in this phase a back message is created (if there is enough money left to pay for the message), which will call the onBounce utility function. Any remaining value will be attached to the message. See more details in Transaction executor","keywords":""},{"title":"Protection against replay attacks for external messages","type":0,"sectionRef":"#","url":"develop/smart-contract/learn/replay-attacks-protection","content":"Protection against replay attacks for external messages External messages can be in any format, for example, an external message could be a plain text without a signature or any data signed with a private key. In the TON protocol itself, there is no built-in protection against validators including your message any number of times. How can this be implemented? Validators can store all external messages and not allow the same message to be inserted into processing twice at the protocol level. But this approach is contrary to the philosophy of TON, because it leads to an ever-increasing tail of data that must be stored by validators and, in our network, all data must pay for its storage in the state. So protection against replay attacks was shifted to smart contracts so that they can implement the protection that suits them. Let me remind you how external messages work. You send a message to a contract out of nowhere, the validator gives it 10k gas credits and tries to apply it. If the contract agrees to do tvm.accept() for 10k gas then it will pay for the message and the transaction will go through. If there is no tvm.accept() call or an exception occurs, then this message will not go to the block. TON-Solidity has built-in protection against replay attacks. It works at the SDK + ABI level. To work with a smart contract using sdk or tonos-cli, you need contract.abi.json, a description of the functions and their variables, so that the SDK can properly package the call. This abi has a header field where Solidity always writes at least :time when compiling. This is an instruction for the SDK to apply a time to each external message, which will be used to protect against replay attacks. Solidity, before processing an external message, performs a check, which can be understood as something similar to the following (pseudocode): note This is not the actual code, so approach this skeptically contract any { uint64 hidden_ts_replay_variable; func beforeAnyExternalMessageProcessing() { uint64 header_time = msg.header.time; require(uint64(now) + 3600 &gt; header_time, 52); require(hidden_ts_replay_variable &lt; header_time, 52); hidden_ts_replay_variable = header_time; } } As you can understand, this default check is very simple but will not work well if you want to send a bunch of parallel external messages to a contract. So you can always come up with a more comprehensive checking mechanism, for example something like this.","keywords":""},{"title":"Magic and overheads of Solidity compilers","type":0,"sectionRef":"#","url":"develop/smart-contract/learn/solidity-compiler-overheads","content":"Magic and overheads of Solidity compilers There are some nuances to the TON Solidity compiler. How does responsible work? Under the hood, one more variable has to be added, which points to the id of the function that should be called in the return message. You need to understand that when you receive a response to responsible, there is no magic check that will verify that you really called responsible. You yourself need to check everything here (that you really made this call and that the answer came from the correct contract). function owner() override external responsible returns (address) { return { value: 0, flag: 64, bounce: false }owner_; } // This will be compiled in something like this: function owner(uint32 asnwerID) override external returns (address) { msg.sender.call({ value: 0, flag: 64 bounce: false, functionToCall: asnwerID, values: owner_ }); } There are three utility variables solidity compiler add under the hood: _pubkey — this is just a static variable taken out separately, and it serves for the tvm.pubkey() and verification of the signature of the incoming external message;_constructorFlag — this is a constructor call flag. In general, due to the peculiarities of the blockchain, the internal work constructor in TON Solidity was implemented in a tricky way. When we deploy a contract, we can specify one function that we want to call after the deployment of the contract and its arguments. If we call the constructor, then, if its execution was successful, at the end the _constructorFlag will be set to true. All other functions check before their execution that the constructor has been called, if not, an error will occur. But since we can deploy a contract and not call the constructor, it is possible that the contract will get deployed, but its constructor will not be called. We must keep this in mind;_timestamp — this is the time of the last external call, used in the protection against replay attacks described above. There is also an interesting feature with state variables. At compilation time, Solidity will allocate all state variables to cells in the contract storage, like this: Storage for contracts in TVM is register c4, this is a BoC. There is a service register for temporary data c7 - but this is a tuple and it is always cleared at the end of a transaction. So, every time a transaction begins processing, Solidity unpacks variables from c4 to c7, so that it is easier to work with them in the code by register indexes, and at the end of the work it repacks them back to c4. You can draw your own conclusions, but it is undeniable that the more variables you have, the greater the overhead for unpacking/packing.","keywords":""},{"title":"Lifecycle","type":0,"sectionRef":"#","url":"develop/smart-contract/lifecycle","content":"Lifecycle","keywords":""},{"title":"Math","type":0,"sectionRef":"#","url":"develop/smart-contract/math","content":"Math","keywords":""},{"title":"Migration Guide","type":0,"sectionRef":"#","url":"develop/smart-contract/migration-guide","content":"Migration Guide","keywords":""},{"title":"Overview","type":0,"sectionRef":"#","url":"develop/smart-contract/overview","content":"Overview","keywords":""},{"title":"Verifying Smart Contract","type":0,"sectionRef":"#","url":"develop/smart-contract/verifying-smart-contract","content":"Verifying Smart Contract","keywords":""},{"title":"Issue a Fungible Token","type":0,"sectionRef":"#","url":"develop/smart-digital-assets/issue-ft","content":"","keywords":""},{"title":"Reference​","type":1,"pageTitle":"Issue a Fungible Token","url":"develop/smart-digital-assets/issue-ft#reference","content":"TIP-3 Core description "},{"title":"Mint a Non-Fungible Token","type":0,"sectionRef":"#","url":"develop/smart-digital-assets/mint-nft","content":"","keywords":""},{"title":"Reference​","type":1,"pageTitle":"Mint a Non-Fungible Token","url":"develop/smart-digital-assets/mint-nft#reference","content":"TIP-4 Core description "},{"title":"Getting started","type":0,"sectionRef":"#","url":"develop/tutorial/getting-started","content":"Getting started","keywords":""},{"title":"Tutorial 1","type":0,"sectionRef":"#","url":"develop/tutorial/tutorial-1","content":"Tutorial 1","keywords":""},{"title":"Tutorial 2","type":0,"sectionRef":"#","url":"develop/tutorial/tutorial-2","content":"Tutorial 2","keywords":""},{"title":"Multisignature Wallet","type":0,"sectionRef":"#","url":"develop/smart-contract/multisignature-wallet","content":"","keywords":""},{"title":"Glossary​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#glossary","content":"Multisignature wallet - crypto wallet on the blockchain, which supports multiple owners (custodians), who are authorized to manage the wallet. Wallet address - unique address of the wallet on the blockchain. It explicitly identifies the wallet and is required for any actions with the wallet to be performed. It does not, on its own, provide anyone access to wallet funds. Wallet custodian - authorized owner of the wallet. Owns the private key and corresponding seed phrase, which are required to make any changes to the wallet or wallet funds. Wallet may have more than one custodian. Custodian private key - the unique cryptographic key belonging to the wallet custodian, which authorizes access to the wallet. Should be kept secret. Custodian seed phrase - unique mnemonic phrase exactly corresponding to the custodian private key. Can be used to restore the private key, or to sign transactions in TONOS-CLI instead of it. Should be kept secret and securely backed up. Custodian public key - public key forming a cryptographic key pair with the custodian private key. It is not secret and may be freely shared with anyone. Validator - the entity performing validation of new blocks on the blockchain through a Proof-of-Stake system. Requires a multisignature wallet for staking. 2. Install TONOS-CLI "},{"title":"2.1. Install TONOS-CLI utility​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#21-install-tonos-cli-utility","content":""},{"title":"Install compiled executable​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#install-compiled-executable","content":"Create a folder. Download the .zip file from the latest release from here: https://github.com/tonlabs/tonos-cli/releases to this folder. Extract it. "},{"title":"Install through TONDEV​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#install-through-tondev","content":"You can use TONDEV to install the latest version of TONOS-CLI. tondev tonos-cli install  The installer requires NPM to be installed, so it can install packages globally without using sudo. In case of error, manually set environment variable PATH=$PATH:$HOME./tondev/solidity This command updates TONOS-CLI installed through TONDEV to the latest version: tondev tonos-cli update  This command specifies TONOS-CLI version to use and downloads it if needed: tondev tonos-cli set --version 0.8.0  "},{"title":"Build from source​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#build-from-source","content":"Refer to the TONOS-CLI readme for build from source procedure. "},{"title":"Tails OS secure environment​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#tails-os-secure-environment","content":"For maximum security while working with offline TONOS-CLI features (such as cryptographic commands or encrypted message generation), you can use the Tails OS. You can perform the following actions entirely offline: Generate seed phrases and custodian keysPepare deployment message offlinePrepare new transaction offlinePrepare transaction confirmation offline "},{"title":"A note on Windows syntax​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#a-note-on-windows-syntax","content":"When using Windows command line, the following syntax should be used for all TONOS-CLI commands: Never use the ./ symbols before tonos-cli: &gt; tonos-cli &lt;command_name&gt; &lt;options&gt;  For all commands with nested quotes, the outer single quotes should be changed to double quotes, and the inner double quotes should be shielded by a preceding \\. Example: &gt; tonos-cli deploy SafeMultisigWallet.tvc &quot;{\\&quot;owners\\&quot;:[\\&quot;0x723b2f0fa217cd10fe21326634e66106678f15d5a584babe4f576dffe9dcbb1b\\&quot;,\\&quot;0x127e3ca223ad429ddaa053a39fecd21131df173bb459a4438592493245b695a3\\&quot;,\\&quot;0xc2dd3682ffa9df97a968bef90b63da90fc92b22163f558b63cb7e52bfcd51bbb\\&quot;],\\&quot;reqConfirms\\&quot;:2}&quot; --abi SafeMultisigWallet.abi.json --sign deploy.keys.json  "},{"title":"2.2. Download contract files​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#22-download-contract-files","content":"Download compiled .abi.json and .tvc multisignature contract files from https://github.com/tonlabs/ton-labs-contracts/tree/master/solidity Choose a contract version: SafeMultisig - basic multisignature wallet, does not permit contract code modification. Is required if you use validator scripts. SafeMultisigWallet.abi.json direct link: https://raw.githubusercontent.com/tonlabs/ton-labs-contracts/master/solidity/safemultisig/SafeMultisigWallet.abi.json SafeMultisigWallet.tvc direct link: https://github.com/tonlabs/ton-labs-contracts/raw/master/solidity/safemultisig/SafeMultisigWallet.tvc SetcodeMultisig - more advanced multisignature wallet. SetcodeMultisigWallet.abi.json direct link: https://raw.githubusercontent.com/tonlabs/ton-labs-contracts/master/solidity/setcodemultisig/SetcodeMultisigWallet.abi.json SetcodeMultisigWallet.tvc direct link: https://github.com/tonlabs/ton-labs-contracts/raw/master/solidity/setcodemultisig/SetcodeMultisigWallet.tvc Place both files into the folder containing the tonos-cli executable. Note: Make sure you have downloaded the raw versions of the files. A common error when downloading from the github project page manually is to save the redirection page instead of the raw file.Note: TON Surf uses a specialized version of the SetcodeMultisig contract. It will not be possible to manage a standard Setcode wallet in TON Surf. "},{"title":"2.3. Configure TONOS-CLI environment​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#23-configure-tonos-cli-environment","content":"(Optional, Linux/Mac OS, if you didn't install through tondev) Put tonos-cli into system environment: export PATH=&quot;&lt;tonos_folder_path&gt;:$PATH&quot;  If you skip this step and didn't install through tondev, make sure you run the utility from the utility folder: ./tonos-cli &lt;command&gt; &lt;options&gt;  Use the following command to set the network: tonos-cli config --url &lt;https://network_url&gt;  Some of the frequently used networks: https://net.ton.dev - developer sandbox for testing. https://main.ton.dev - main Free TON network. https://rustnet.ton.dev - test network running on Rust nodes. You need to do it only once before using the utility. tonos-cli.conf.json configuration file will be created in the current folder. The URL of the current network will be specified there. All subsequent calls of the utility will use this file to select the network to connect to. Note: By default tonos-cli connects to net.ton.dev network.Note: Always run tonos-cli utility only from the folder where tonos-cli.conf.json is placed, unless you have configured a different path for the file. Refer to the TONOS-CLI document for additional information. 3. Use the following command to check the set network:  tonos-cli config --list  For additional configuration options, refer to the TONOS-CLI readme. 3. Create Wallet The following actions should be performed to create a wallet: Create wallet seed phraseGenerate deployment key pair file with wallet private/public keys based on the wallet seed phraseGenerate wallet address based on the wallet seed phraseSend some tokens to the wallet addressDeploy wallet (set custodians) All of these steps are detailed in this section. "},{"title":"3.1. Create seed phrases and public keys for all custodians​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#31-create-seed-phrases-and-public-keys-for-all-custodians","content":""},{"title":"3.1.1. Create wallet seed phrase​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#311-create-wallet-seed-phrase","content":"To generate your seed phrase enter the following command: tonos-cli genphrase  Terminal displays the generated seed phrase. Example: $ tonos-cli genphrase Config: /home/user/tonos-cli.conf.json Succeeded. Seed phrase: &quot;rule script joy unveil chaos replace fox recipe hedgehog heavy surge online&quot;  Note: Seed phrases should be created for every custodian of the multisignature wallet. The seed phrase ensures access to the multisignature wallet. If lost, the custodian will no longer be able to manage the wallet. The seed phrase is unique for every custodian and should be kept secret and securely backed up (word order matters). 3.1.2. Generate public key​ To generate your public key enter the following command with your previously generated seed phrase in quotes: tonos-cli genpubkey &quot;&lt;seed_phrase&gt;&quot;  Example: $ tonos-cli genpubkey &quot;rule script joy unveil chaos replace fox recipe hedgehog heavy surge online&quot; Config: /home/user/tonos-cli.conf.json Succeeded. Public key: 88c541e9a1c173069c89bcbcc21fa2a073158c1bd21ca56b3eb264bba12d9340 &lt;QR code with key&gt;  Copy the generated code from Terminal or scan the QR code containing the code with your phone and send it to whichever custodian is responsible for deploying the multisignature wallet. Note: The public key should also be generated for every custodian. The public key is not secret and can be freely transmitted to anyone. 3.2. Generate deployment key pair file​ Any custodian who has received the public keys of all other custodians can deploy the multisignature wallet to the blockchain. To create the key pair file from the seed phrase generated at step 3.1.1 use the following command: tonos-cli getkeypair &lt;deploy.keys.json&gt; &quot;&lt;seed_phrase&gt;&quot;  &lt;deploy.keys.json&gt; - the file the key pair will be written to. The utility generates the file that contains the key pair produced from seed phrase. $ tonos-cli getkeypair key.json &quot;rule script joy unveil chaos replace fox recipe hedgehog heavy surge online&quot; Config: /home/user/tonos-cli.conf.json Input arguments: key_file: key.json phrase: rule script joy unveil chaos replace fox recipe hedgehog heavy surge online Succeeded.  "},{"title":"3.3. Generate wallet address​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#33-generate-wallet-address","content":"Use deployment key pair file to generate your address: tonos-cli genaddr &lt;MultisigWallet.tvc&gt; &lt;MultisigWallet.abi.json&gt; --setkey &lt;deploy.keys.json&gt; --wc &lt;workchain_id&gt;  &lt;MultisigWallet.tvc&gt; - either SafeMultisigWallet.tvc or SetcodeMultisigWallet.tvc depending on the contract you have selected at step 2.2. &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2. &lt;deploy.keys.json&gt; - the file the key pair is read from. --wc &lt;workchain_id&gt; - (optional) ID of the workchain the wallet will be deployed to (-1 for masterchain, 0 for basechain). By default this value is set to 0. Note: Masterchain fees are significantly higher, but masterchain is required for direct staking validator wallets. Make sure to set workchain ID to -1 for any direct staking validator wallets you are deploying: --wc -1. Basechain, on the other hand, is best suited for user wallets and validator wallets that are staking through a DePool. The utility displays the new multisignature wallet address (Raw_address). Example: $ tonos-cli genaddr --genkey key.json --wc -1 SafeMultisigWallet.tvc SafeMultisigWallet.abi.json Config: /home/user/tonos-cli.conf.json Input arguments: tvc: SafeMultisigWallet.tvc wc: -1 keys: key.json init_data: None is_update_tvc: None Seed phrase: &quot;chimney nice diet engage hen sing vocal upgrade column address consider word&quot; Raw address: -1:a021414a79539001ed35d615a646dc8b89df29ccccf143c30df15c7fbcaff086 testnet: Non-bounceable address (for init): 0f-gIUFKeVOQAe011hWmRtyLid8pzMzxQ8MN8Vx_vK_whkeM Bounceable address (for later access): kf-gIUFKeVOQAe011hWmRtyLid8pzMzxQ8MN8Vx_vK_whhpJ mainnet: Non-bounceable address (for init): Uf-gIUFKeVOQAe011hWmRtyLid8pzMzxQ8MN8Vx_vK_whvwG Bounceable address (for later access): Ef-gIUFKeVOQAe011hWmRtyLid8pzMzxQ8MN8Vx_vK_whqHD Succeeded  Note: The wallet address is required for any interactions with the wallet. It should be shared with all wallet custodians. "},{"title":"3.4. Send tokens to the new address from another wallet​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#34-send-tokens-to-the-new-address-from-another-wallet","content":"Use the following command to create a new transaction from another existing wallet: tonos-cli call &lt;source_address&gt; submitTransaction '{&quot;dest&quot;:&quot;&lt;raw_address&gt;&quot;,&quot;value&quot;:&lt;nanotokens&gt;,&quot;bounce&quot;:false,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;}' --abi &lt;MultisigWallet.abi.json&gt; --sign &quot;&lt;source_seed_or_keyfile&gt;&quot;  &lt;source_address&gt; - address of the wallet the funds are sent from. &quot;dest&quot;:&lt;raw_address&gt; - new wallet address generated at step 3.3. Example: &quot;0:f22e02a1240dd4b5201f8740c38f2baf5afac3cedf8f97f3bd7cbaf23c7261e3&quot; &quot;value&quot;: - amount of tokens to transfer in nanotokens (Example: &quot;value&quot;:10000000000 sets up a transfer of 10 tokens). &quot;bounce&quot; - use false to transfer funds to a non-existing contract to create it. &quot;payload&quot; - use &quot;&quot; for simple transfer. Otherwise payload is used as a body of outbound internal message. &quot;allBalance&quot; - used to transfer all funds in the wallet. Use false for a simple transfer. Note: Due to a bug setting allBalance to true currently causes errors. Single-custodian multisig wallets may use sendTransaction method with flag 130 and value 0 instead: tonos-cli call &lt;multisig_address&gt; sendTransaction '{&quot;dest&quot;:&quot;raw_address&quot;,&quot;value&quot;:0,&quot;bounce&quot;:true,&quot;flags&quot;:130,&quot;payload&quot;:&quot;&quot;}' --abi &lt;MultisigWallet.abi.json&gt; --sign &lt;seed_or_keyfile&gt; &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2. &quot;&lt;source_seed_or_keyfile&gt;&quot; - seed phrase in quotes or path to keyfile of the source wallet. Example: $ tonos-cli call 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc submitTransaction '{&quot;dest&quot;:&quot;-1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;,&quot;value&quot;:234000000,&quot;bounce&quot;:false,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;}' --abi SetcodeMultisigWallet.abi.json --sign k1.keys.json Config: /home/user/tonos-cli.conf.json Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: submitTransaction params: {&quot;dest&quot;:&quot;-1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;,&quot;value&quot;:234000000,&quot;bounce&quot;:false,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;} abi: SetcodeMultisigWallet.abi.json keys: k1.keys.json lifetime: None output: None Connecting to net.ton.dev Generating external inbound message... MessageId: c6baac843fefe6b9e8dc3609487a63ef21207e4fdde9ec253b9a47f7f5a88d01 Expire at: Sat, 08 May 2021 14:52:23 +0300 Processing... Succeeded. Result: { &quot;transId&quot;: &quot;6959885776551137793&quot; }  If the sponsoring wallet has multiple custodians, the transaction may require confirmation from its other custodians. To confirm the transaction use the following command: tonos-cli call &lt;source_address&gt; confirmTransaction '{&quot;transactionId&quot;:&quot;&lt;id&gt;&quot;}' --abi &lt;MultisigWallet.abi.json&gt; --sign &quot;&lt;source_seed_or_keyfile&gt;&quot;  &lt;source_address&gt; - address of the wallet to funds are sent from. &quot;&lt;source_seed_or_keyfile&gt;&quot; - seed phrase in quotes or path to keyfile of the source wallet. transactionId – the ID of the transaction transferring tokens to the new wallet. &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2. Example: $ tonos-cli call 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc confirmTransaction '{&quot;transactionId&quot;:&quot;6981478983724354305&quot;}' --abi SetcodeMultisigWallet.abi.json --sign k2.keys.json Config: default Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: confirmTransaction params: {&quot;transactionId&quot;:&quot;6981478983724354305&quot;} abi: SetcodeMultisigWallet.abi.json keys: k2.keys.json lifetime: None output: None Connecting to https://net.ton.dev Generating external inbound message... MessageId: 322e1efffedf73c8009b84a103dd3fdc205796eb4d88a912fa13d931ce9e7c9c Expire at: Mon, 05 Jul 2021 19:28:08 +0300 Processing... Succeeded. Result: {}  Ensure that the new wallet has been created in the blockchain and has Uninit status: tonos-cli account &lt;multisig_address&gt;  &lt;multisig_address&gt; - new wallet address generated at step 3.3. "},{"title":"3.5. Deploy wallet (set custodians)​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#35-deploy-wallet-set-custodians","content":""},{"title":"3.5.1. Deploy the wallet to blockchain​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#351-deploy-the-wallet-to-blockchain","content":"Use the following command: tonos-cli deploy &lt;MultisigWallet.tvc&gt; '{&quot;owners&quot;:[&quot;0x...&quot;, ...],&quot;reqConfirms&quot;:N}' --abi &lt;MultisigWallet.abi.json&gt; --sign &lt;deploy_seed_or_keyfile&gt; --wc &lt;workchain_id&gt;  Configuration parameters: &lt;MultisigWallet.tvc&gt; - either SafeMultisigWallet.tvc or SetcodeMultisigWallet.tvc depending on the contract you have selected at step 2.2. &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2. owners - array of custodian public keys generated by all wallet custodians at step 3.1.2 as uint256 numbers. Make sure all public keys are enclosed in quotes and start with 0x.... Example: &quot;owners&quot;:[&quot;0x8868adbf012ebc349ced852fdcf5b9d55d1873a68250fae1be609286ddb962582&quot;, &quot;0xa0e16ccff0c7bf4f29422b33ec1c9187200e9bd949bb2dd4c7841f5009d50778a&quot;] reqConfirms - number of signatures needed to confirm a transaction ( 0 &lt; N ≤ custodian count). --wc &lt;workchain_id&gt; - (optional) ID of the workchain the wallet will be deployed to (-1 for masterchain, 0 for basechain). By default this value is set to 0. Note: Masterchain fees are significantly higher, but masterchain is required for validator wallets. Make sure to set workchain ID to -1 for any validator wallets you are deploying: --wc -1. Basechain, on the other hand, is best suited for user wallets.&lt;deploy_seed_or_keyfile&gt; - can either be the seed phrase used in step 3.2 to generate the deployment key pair file or the deploy.keys.json file itself. If seed phrase is used, enclose it in double quotes. Example: --sign &quot;flip uncover dish sense hazard smile gun mom vehicle chapter order enact&quot; or --sign deploy.keys.json Deploying a wallet without at least one custodian is not possible, since every transaction from a wallet has to be signed by one or more custodians (depending on wallet configuration) with their private key or equivalent seed phrase. It is a basic security requirement of the system. Example: $ tonos-cli deploy --sign key.json --wc -1 --abi SafeMultisigWallet.abi.json SafeMultisigWallet.tvc '{&quot;owners&quot;:[&quot;0x88c541e9a1c173069c89bcbcc21fa2a073158c1bd21ca56b3eb264bba12d9340&quot;],&quot;reqConfirms&quot;:1}' Config: /home/user/tonos-cli.conf.json Input arguments: tvc: SafeMultisigWallet.tvc params: {&quot;owners&quot;:[&quot;0x88c541e9a1c173069c89bcbcc21fa2a073158c1bd21ca56b3eb264bba12d9340&quot;],&quot;reqConfirms&quot;:1} abi: SafeMultisigWallet.abi.json keys: key.json wc: -1 Connecting to net.ton.dev Deploying... Transaction succeeded. Contract deployed at address: -1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6  Note: After a SafeMultisig wallet is deployed, for reasons of security you cannot add or remove custodians from it. If you want to change the custodian list, you have to create a new wallet, transfer all funds there, and set the new list of custodians. 3.5.2. Check that the wallet is active​ Check the new wallet status again. Now it should be Active. tonos-cli account &lt;multisig_address&gt;  "},{"title":"3.5.3. Request the list of custodian public keys from the blockchain​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#353-request-the-list-of-custodian-public-keys-from-the-blockchain","content":"Verify that they match the keys you have loaded during deploy. tonos-cli run &lt;multisig_address&gt; getCustodians {} --abi SafeMultisigWallet.abi.json  The wallet is deployed and the owners of the listed public keys have access to it. Example: $ tonos-cli run 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc getCustodians {} --abi SetcodeMultisigWallet.abi.json Config: default Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: getCustodians params: {} abi: SetcodeMultisigWallet.abi.json keys: None lifetime: None output: None Connecting to https://net.ton.dev Generating external inbound message... MessageId: 6c3daeeea601ef6c81a516079a3cec2210fea278a06cc7bb118b4529f154e5d7 Expire at: Mon, 05 Jul 2021 19:31:47 +0300 Running get-method... Succeeded. Result: { &quot;custodians&quot;: [ { &quot;index&quot;: &quot;1&quot;, &quot;pubkey&quot;: &quot;0x154bc7ed3088294e4e767e2e7183f43d62bcec820c58a30e2ec730f0bb8792a3&quot; }, { &quot;index&quot;: &quot;4&quot;, &quot;pubkey&quot;: &quot;0x18331765f53c6a50aa3a348fa4536e6f632798d81ff59281aae21d9b5f86a21c&quot; }, { &quot;index&quot;: &quot;3&quot;, &quot;pubkey&quot;: &quot;0x6ee6539d0d8a3800d7525922c25b64874e0645340f2b43a2cb277db458b42fa4&quot; }, { &quot;index&quot;: &quot;0&quot;, &quot;pubkey&quot;: &quot;0x849ee401fde65ad8cda6d937bdc81e2beba0f36ba2f87115f4a2d24a15568203&quot; }, { &quot;index&quot;: &quot;2&quot;, &quot;pubkey&quot;: &quot;0x9ef666feaacf1d65c78af3b1c099c5096aa2e26afc21346fd66b8e7d5d9d6224&quot; } ] }  4. Manage Wallet "},{"title":"4.1. Select blockchain network​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#41-select-blockchain-network","content":"There are two networks currently available: Some of the frequently used networks: https://net.ton.dev - developer sandbox for testing. https://main.ton.dev - main Free TON network. https://rustnet.ton.dev - test network running on Rust nodes. Use the following command to switch to any of these networks: tonos-cli config --url &lt;https://network_url&gt;  You need to do it only once before using the utility. A .json configuration file will be created in the current folder. The URL of the current network will be specified there. All subsequent calls of the utility will use this file to select the network to connect to. "},{"title":"4.2. Convert tokens to nanotokens​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#42-convert-tokens-to-nanotokens","content":"Amounts in most multisig wallet commands are indicated in nanotokens. To convert tokens to nanotokens use the following command: tonos-cli convert tokens &lt;amount&gt;  Example: $ tonos-cli convert tokens 125.8 Config: /home/user/tonos-cli.conf.json 125800000000  "},{"title":"4.3. Check wallet balance and status​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#43-check-wallet-balance-and-status","content":""},{"title":"4.3.1. Check wallet balance and status with TONOS-CLI​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#431-check-wallet-balance-and-status-with-tonos-cli","content":"You may use the following command to check the current status and balance of your wallet: tonos-cli account &lt;multisig_address&gt;  It displays the wallet status: Not found – if the wallet does not existUninit – wallet was created, but contract code wasn’t deployedActive – wallet exists and has the contract code and data It also displays the wallet balance, time of the most recent transaction, contract data block, data in boc format and code hash (which is unique for every contract type). Example: $ tonos-cli account 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc Config: default Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc Connecting to https://net.ton.dev Processing... Succeeded. acc_type: Active balance: 236565978364 nanoton last_paid: 1625502429 last_trans_lt: 0x9274fd9102 data(boc): b5ee9c7201020d010001b10003df849ee401fde65ad8cda6d937bdc81e2beba0f36ba2f87115f4a2d24a155682030000017a777eac3bc24f7200fef32d6c66d36c9bdee40f15f5d079b5d17c388afa5169250aab4101800000000000000000000000000000000000000000000000000000000000000082800000000182700c0a01020120050202016204030043bf3bd99bfaab3c75971e2bcec702671425aa8b89abf084d1bf59ae39f5767588900a0043bf127b9007f7996b63369b64def72078afae83cdae8be1c457d28b4928555a080c0202012007060044bfaee6539d0d8a3800d7525922c25b64874e0645340f2b43a2cb277db458b42fa40302016609080043bec198bb2fa9e3528551d1a47d229b737b193cc6c0ffac940d5710ecdafc3510e0240043beea5e3f6984414a7273b3f1738c1fa1eb15e7641062c5187176398785dc3c95180c01d7a030719912b7df6580b0719912b7df6580800000018201424f7200fef32d6c66d36c9bdee40f15f5d079b5d17c388afa5169250aab410180400255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f30000000000000000000000000df28e800003c0b0000000140 code_hash: e2b60b6b602c10ced7ea8ede4bdf96342c97570a3798066f3fb50a4b2b27a208  SafeMultisig code hash is 80d6c47c4a25543c9b397b71716f3fae1e2c5d247174c52e2c19bd896442b105 SetcodeMultisig code hash is e2b60b6b602c10ced7ea8ede4bdf96342c97570a3798066f3fb50a4b2b27a208 "},{"title":"4.3.2. Check wallet balance and status in the blockchain explorer​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#432-check-wallet-balance-and-status-in-the-blockchain-explorer","content":"The detailed status of the account can also be viewed in the ton.live blockchain explorer. Select the network the wallet is deployed to and enter the raw address of the wallet into the main search field. Account status, balance, message and transaction history for the account will be displayed. "},{"title":"4.4. List custodian public keys​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#44-list-custodian-public-keys","content":"The following command displays the list of public keys, the owners of which have rights to manage the wallet: tonos-cli run &lt;multisig_address&gt; getCustodians {} --abi &lt;MultisigWallet.abi.json&gt;  Example: $ tonos-cli run 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc getCustodians {} --abi SetcodeMultisigWallet.abi.json Config: default Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: getCustodians params: {} abi: SetcodeMultisigWallet.abi.json keys: None lifetime: None output: None Connecting to https://net.ton.dev Generating external inbound message... MessageId: 6c3daeeea601ef6c81a516079a3cec2210fea278a06cc7bb118b4529f154e5d7 Expire at: Mon, 05 Jul 2021 19:31:47 +0300 Running get-method... Succeeded. Result: { &quot;custodians&quot;: [ { &quot;index&quot;: &quot;1&quot;, &quot;pubkey&quot;: &quot;0x154bc7ed3088294e4e767e2e7183f43d62bcec820c58a30e2ec730f0bb8792a3&quot; }, { &quot;index&quot;: &quot;4&quot;, &quot;pubkey&quot;: &quot;0x18331765f53c6a50aa3a348fa4536e6f632798d81ff59281aae21d9b5f86a21c&quot; }, { &quot;index&quot;: &quot;3&quot;, &quot;pubkey&quot;: &quot;0x6ee6539d0d8a3800d7525922c25b64874e0645340f2b43a2cb277db458b42fa4&quot; }, { &quot;index&quot;: &quot;0&quot;, &quot;pubkey&quot;: &quot;0x849ee401fde65ad8cda6d937bdc81e2beba0f36ba2f87115f4a2d24a15568203&quot; }, { &quot;index&quot;: &quot;2&quot;, &quot;pubkey&quot;: &quot;0x9ef666feaacf1d65c78af3b1c099c5096aa2e26afc21346fd66b8e7d5d9d6224&quot; } ] }  "},{"title":"4.5. List transactions awaiting confirmation​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#45-list-transactions-awaiting-confirmation","content":"Use the following command to list the transactions currently awaiting custodian confirmation: tonos-cli run &lt;multisig_address&gt; getTransactions {} --abi &lt;MultisigWallet.abi.json&gt;  If there are some transactions requiring confirmation, they will be displayed. Example: $ tonos-cli run 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc getTransactions {} --abi SafeMultisigWallet.abi.json Config: /home/user/tonos-cli.conf.json Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: getTransactions params: {} abi: SafeMultisigWallet.abi.json keys: None lifetime: None output: None Connecting to net.ton.dev Generating external inbound message... MessageId: ff8b8a73b1a7803a735eb4f620cade78ed45fd1530992fd3bedb91f3c66eacc5 Expire at: Sat, 08 May 2021 15:16:59 +0300 Running get-method... Succeeded. Result: { &quot;transactions&quot;: [ { &quot;id&quot;: &quot;6959890394123980993&quot;, &quot;confirmationsMask&quot;: &quot;1&quot;, &quot;signsRequired&quot;: &quot;4&quot;, &quot;signsReceived&quot;: &quot;1&quot;, &quot;creator&quot;: &quot;0x849ee401fde65ad8cda6d937bdc81e2beba0f36ba2f87115f4a2d24a15568203&quot;, &quot;index&quot;: &quot;0&quot;, &quot;dest&quot;: &quot;-1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;, &quot;value&quot;: &quot;234000000&quot;, &quot;sendFlags&quot;: &quot;3&quot;, &quot;payload&quot;: &quot;te6ccgEBAQEAAgAAAA==&quot;, &quot;bounce&quot;: false } ] }  "},{"title":"4.6. Create transaction online​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#46-create-transaction-online","content":"Use the following command to create a new transaction: tonos-cli call &lt;multisig_address&gt; submitTransaction '{&quot;dest&quot;:&quot;raw_address&quot;,&quot;value&quot;:&lt;nanotokens&gt;,&quot;bounce&quot;:true,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;}' --abi &lt;MultisigWallet.abi.json&gt; --sign &lt;seed__or_keyfile&gt;  &quot;dest&quot; - raw address of a destination smart contract. Example: &quot;0:f22e02a1240dd4b5201f8740c38f2baf5afac3cedf8f97f3bd7cbaf23c7261e3&quot; &quot;value&quot;: - amount of tokens to transfer in nanotokens (Example: &quot;value&quot;:10000000000 sets up a transfer of 10 tokens). &quot;bounce&quot; - use false to transfer funds to a non-existing contract to create it. Use true to transfer funds to an Active contract. Note: at step [3.4]](#34-send-tokens-to-the-new-address-from-another-wallet) of the wallet deployment procedure use false.&quot;payload&quot; - use &quot;&quot; for simple transfer. Otherwise payload is used as a body of outbound internal message. &quot;allBalance&quot; - used to transfer all funds in the wallet. Use false for a simple transfer. Note: Due to a bug setting allBalance to true currently causes errors. Single-custodian multisig wallets may use sendTransaction method with flag 130 and value 0 instead: tonos-cli call &lt;multisig_address&gt; sendTransaction '{&quot;dest&quot;:&quot;raw_address&quot;,&quot;value&quot;:0,&quot;bounce&quot;:true,&quot;flags&quot;:130,&quot;payload&quot;:&quot;&quot;}' --abi &lt;MultisigWallet.abi.json&gt; --sign &lt;seed_or_keyfile&gt; &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2. &lt;seed_or_keyfile&gt; - can either be the custodian seed phrase or the corresponding custodian key pair file. If seed phrase is used, enclose it in double quotes. Example: --sign &quot;flip uncover dish sense hazard smile gun mom vehicle chapter order enact&quot; or --sign keyfile.json If the wallet has multiple custodians and more than one custodian signature is required to execute a transaction, the new transaction is queued in the wallet and waits for the necessary amount of confirmations. Otherwise it is executed immediately. Example: $ tonos-cli call 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc submitTransaction '{&quot;dest&quot;:&quot;-1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;,&quot;value&quot;:234000000,&quot;bounce&quot;:true,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;}' --abi SetcodeMultisigWallet.abi.json --sign k1.keys.json Config: /home/user/tonos-cli.conf.json Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: submitTransaction params: {&quot;dest&quot;:&quot;-1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;,&quot;value&quot;:234000000,&quot;bounce&quot;:true,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;} abi: SetcodeMultisigWallet.abi.json keys: k1.keys.json lifetime: None output: None Connecting to net.ton.dev Generating external inbound message... MessageId: c6baac843fefe6b9e8dc3609487a63ef21207e4fdde9ec253b9a47f7f5a88d01 Expire at: Sat, 08 May 2021 14:52:23 +0300 Processing... Succeeded. Result: { &quot;transId&quot;: &quot;6959885776551137793&quot; }  Note: For maximum security you may also create a transaction message on a machine without internet connection in offline mode. See section 4.8. "},{"title":"4.6.1. Alternative command to create transaction online​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#461-alternative-command-to-create-transaction-online","content":"TONOS-CLI supports alterbative syntax for this command, which does not use quotes and brackets to list parameters and may be more convenient: tonos-cli callex submitTransaction &lt;multisig_address&gt; &lt;MultisigWallet.abi.json&gt; &lt;seed_or_keyfile&gt; --dest &lt;raw_address&gt; --value &lt;tokens&gt;T --bounce &lt;true|false&gt; --allBalance &lt;true|false&gt; --payload &quot;&quot;  &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2. &lt;seed_or_keyfile&gt; - can either be the custodian seed phrase or the corresponding custodian key pair file. If seed phrase is used, enclose it in double quotes. Example: &quot;flip uncover dish sense hazard smile gun mom vehicle chapter order enact&quot; or keyfile.json &lt;raw_address&gt; - raw address of a destination smart contract. Example: 0:f22e02a1240dd4b5201f8740c38f2baf5afac3cedf8f97f3bd7cbaf23c7261e3 value - amount of tokens to transfer: in nanotokens, if specified without the T suffix, or in tokens, if specified with it (Example: --value 10500000000 and --value 10.5T are the same value of 10.5 tokens). bounce - use false to transfer funds to a non-existing contract to create it. Use true to transfer funds to an Active contract. Note: at step 3.4 of the wallet deployment procedure use false.payload - use &quot;&quot; for simple transfer. Otherwise payload is used as a body of outbound internal message. allBalance - used to transfer all funds in the wallet. Use false for a simple transfer. Note: Due to a bug setting allBalance to true currently causes errors. Single-custodian multisig wallets may use sendTransaction method with flag 130 and value 0 instead: tonos-cli callex sendTransaction &lt;multisig_address&gt; &lt;MultisigWallet.abi.json&gt; &lt;seed_or_keyfile&gt; --dest &lt;raw_address&gt; --value 0 --bounce &lt;true|false&gt; --flags 130 --payload &quot;&quot; Example: $ tonos-cli callex submitTransaction 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc SetcodeMultisigWallet.abi.json k1.keys.json --dest -1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6 --value 0.234T --bounce false --allBalance false --payload &quot;&quot; Config: /home/user/tonos-cli.conf.json Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: submitTransaction params: {&quot;dest&quot;:&quot;-1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;,&quot;value&quot;:&quot;0234000000&quot;,&quot;bounce&quot;:&quot;false&quot;,&quot;allBalance&quot;:&quot;false&quot;,&quot;payload&quot;:&quot;&quot;} abi: SetcodeMultisigWallet.abi.json keys: k1.keys.json Connecting to net.ton.dev Generating external inbound message... MessageId: a38f37bfbe3c7427c869b3ee97c3b2d7f4421ca1427ace4e7a92f1a61d7ef234 Expire at: Sat, 08 May 2021 15:10:15 +0300 Processing... Succeeded. Result: { &quot;transId&quot;: &quot;6959890394123980993&quot; }  "},{"title":"4.7. Create transaction confirmation online​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#47-create-transaction-confirmation-online","content":"Once one of the custodians creates a new transaction on the blockchain, it has to get the required number of confirmations from other custodians. To confirm a transaction, use the following command: tonos-cli call &lt;multisig_address&gt; confirmTransaction '{&quot;transactionId&quot;:&quot;&lt;id&gt;&quot;}' --abi &lt;MultisigWallet.abi.json&gt; --sign &lt;seed_or_keyfile&gt;  transactionId – the ID of the transaction can be acquired from the custodian who created it, or by requesting the list of transactions awaiting confirmation from the multisignature wallet. &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2. &lt;seed_or_keyfile&gt; - can either be the custodian seed phrase or the corresponding custodian key pair file. If seed phrase is used, enclose it in double quotes. Example: --sign &quot;flip uncover dish sense hazard smile gun mom vehicle chapter order enact&quot; or --sign keyfile.json Note: If the wallet has only one custodian, or if the number of confirmations required to perform a transaction was set to 1, this action won't be necessary. The transaction will be confirmed automatically. Example: $ tonos-cli call 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc confirmTransaction '{&quot;transactionId&quot;:&quot;6981478983724354305&quot;}' --abi SetcodeMultisigWallet.abi.json --sign k2.keys.json Config: default Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: confirmTransaction params: {&quot;transactionId&quot;:&quot;6981478983724354305&quot;} abi: SetcodeMultisigWallet.abi.json keys: k2.keys.json lifetime: None output: None Connecting to https://net.ton.dev Generating external inbound message... MessageId: 322e1efffedf73c8009b84a103dd3fdc205796eb4d88a912fa13d931ce9e7c9c Expire at: Mon, 05 Jul 2021 19:28:08 +0300 Processing... Succeeded. Result: {}  Note: For maximum security you may also create a transaction confirmation message on a machine without internet connection in offline mode. See section 4.9 4.7.1. Alternative command to confirm transaction online​ TONOS-CLI supports alterbative syntax for this command, which does not use quotes and brackets to list parameters and may be more convenient: tonos-cli callex confirmTransaction &lt;multisig_address&gt; &lt;MultisigWallet.abi.json&gt; &lt;seed_or_keyfile&gt; --transactionId &lt;id&gt;  &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2. &lt;seed_or_keyfile&gt; - can either be the custodian seed phrase or the corresponding custodian key pair file. If seed phrase is used, enclose it in double quotes. Example: &quot;flip uncover dish sense hazard smile gun mom vehicle chapter order enact&quot; or keyfile.json &lt;id&gt; - ID of the transaction that should be confirmed. Example: $ tonos-cli callex confirmTransaction 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc SetcodeMultisigWallet.abi.json k2.keys.json --transactionId 6982528395137505473 Config: default Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: confirmTransaction params: {&quot;transactionId&quot;:&quot;6982528395137505473&quot;} abi: SetcodeMultisigWallet.abi.json keys: k2.keys.json Connecting to https://net.ton.dev Generating external inbound message... MessageId: 00048660c32d95313eeee7e09d89679e0c68f9a7660794736ba399c4c5fab011 Expire at: Thu, 08 Jul 2021 15:26:26 +0300 Processing... Succeeded. Result: {}  "},{"title":"4.8. Create new transaction offline​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#48-create-new-transaction-offline","content":"An internet connection is not required to create a signed transaction message. Use the following command to do it: tonos-cli message &lt;multisig_address&gt; submitTransaction '{&quot;dest&quot;:&quot;raw_address&quot;,&quot;value&quot;:&lt;nanotokens&gt;,&quot;bounce&quot;:true,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;}' --abi &lt;MultisigWallet.abi.json&gt; --sign &lt;seed_or_keyfile&gt; --lifetime 3600  &quot;dest&quot; - raw address of a destination smart contract. Example: &quot;0:f22e02a1240dd4b5201f8740c38f2baf5afac3cedf8f97f3bd7cbaf23c7261e3&quot;. &quot;value&quot;: - amount of tokens to transfer in nanotokens (Example: &quot;value&quot;:10000000000 sets up a transfer of 10 tokens). &quot;bounce&quot; - use false to transfer funds to a non-existing contract to create it. Use true to transfer funds to an Active contract. &quot;payload&quot; - use &quot;&quot; for simple transfer. Otherwise payload is used as a body of outbound internal message. &quot;allBalance&quot; - used to transfer all funds in the wallet. Use false for a simple transfer. Note: Due to a bug setting allBalance to true currently causes errors. Single-custodian multisig wallets may use sendTransaction method with flag 130 and value 0 instead: tonos-cli message &lt;multisig_address&gt; sendTransaction '{&quot;dest&quot;:&quot;raw_address&quot;,&quot;value&quot;:0,&quot;bounce&quot;:true,&quot;flags&quot;:130,&quot;payload&quot;:&quot;&quot;}' --abi &lt;MultisigWallet.abi.json&gt; --sign &lt;seed_or_keyfile&gt; --lifetime 3600 &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2. &lt;seed_or_keyfile&gt; - can either be the custodian seed phrase or the corresponding custodian key pair file. If seed phrase is used, enclose it in double quotes. Example: --sign &quot;flip uncover dish sense hazard smile gun mom vehicle chapter order enact&quot; or --sign keyfile.json lifetime – message lifetime in seconds. Once this time elapses, the message will not be accepted by the contract. The TONOS-CLI utility displays encrypted message text and a QR code that contains the submitTransaction message. Example: $ tonos-cli message 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc submitTransaction '{&quot;dest&quot;:&quot;0:255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f3&quot;,&quot;value&quot;:567000000,&quot;bounce&quot;:true,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;}' --abi SetcodeMultisigWallet.abi.json --sign k1.keys.json --lifetime 3600 Config: default Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: submitTransaction params: {&quot;dest&quot;:&quot;0:255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f3&quot;,&quot;value&quot;:567000000,&quot;bounce&quot;:true,&quot;allBalance&quot;:false,&quot;payload&quot;:&quot;&quot;} abi: SetcodeMultisigWallet.abi.json keys: k1.keys.json lifetime: 3600 output: None Generating external inbound message... MessageId: 649e36ac7d656d1ce99f3e8b235074ff2483e115596a0233caacdf0c4ccf78a1 Expire at: Thu, 08 Jul 2021 16:32:45 +0300 Message: 7b226d7367223a7b226d6573736167655f6964223a2236343965333661633764363536643163653939663365386232333530373466663234383365313135353936613032333363616163646630633463636637386131222c226d657373616765223a227465366363674542424145413051414252596742534d553677767679593746624464704a365a5748706b4c7846304545726f4b4a36775165555369536633674d415148686d4733712f3553464e2f79317a703749337433586243796874586a51734b48763437654e657479504f6e46524b3939487a444c7974644754307a4e784a50314e3964544a4c444f6766496a2b556f57784c366571686d456e7551422f655a61324d326d32546539794234723636447a61364c34635258306f744a4b46566143417741414158714747793062594f622b66524d64677332414341574f41424b7448577a763146556e6d6b44437456666a36382b6a366f45436a495871734b4f4a77364230324c763567414141414141414141414141414141454f58643446414d4141413d3d222c22657870697265223a313632353735313136352c2261646472657373223a22303a61343632396436313764663933316438616438366564323466346361633364333231373838626130383235373431343466353832306632383934343933666263227d2c226d6574686f64223a227375626d69745472616e73616374696f6e227d &lt;Message QR code&gt;  Copy the message text or scan the QR code and broadcast the message online. "},{"title":"4.9. Create transaction confirmation offline​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#49-create-transaction-confirmation-offline","content":"Once one of the custodians creates a new transaction on the blockchain, it has to get the required number of confirmations from other custodians. To create a confirmation message offline use the following command: tonos-cli message &lt;multisig_address&gt; confirmTransaction '{&quot;transactionId&quot;:&quot;&lt;id&gt;&quot;}' --abi &lt;MultisigWallet.abi.json&gt; --sign &quot;&lt;seed_or_keyfile&gt;&quot; --lifetime 600  transactionId – the ID of the transaction can be acquired from the custodian who created it, or by requesting the list of transactions awaiting confirmation from the multisignature wallet. &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2. &lt;seed_or_keyfile&gt; - can either be the custodian seed phrase or the corresponding custodian key pair file. If seed phrase is used, enclose it in double quotes. Example: --sign &quot;flip uncover dish sense hazard smile gun mom vehicle chapter order enact&quot; or --sign keyfile.json lifetime – message lifetime in seconds. Once this time elapses, the message will not be accepted by the contract. The TONOS-CLI utility displays encrypted transaction text and a QR code that contains the confirmTransaction message. Example: $ tonos-cli message 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc confirmTransaction '{&quot;transactionId&quot;:&quot;6982528395137505473&quot;}' --abi SetcodeMultisigWallet.abi.json --sign k3.keys.json --lifetime 600 Config: default Input arguments: address: 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc method: confirmTransaction params: {&quot;transactionId&quot;:&quot;6982528395137505473&quot;} abi: SetcodeMultisigWallet.abi.json keys: k3.keys.json lifetime: 600 output: None Generating external inbound message... MessageId: 1751be3063638271c2590ede75d71bfaa48b0dc76180443f1158ffc3d178148d Expire at: Thu, 08 Jul 2021 15:59:47 +0300 Message: 7b226d7367223a7b226d6573736167655f6964223a2231373531626533303633363338323731633235393065646537356437316266616134386230646337363138303434336631313538666663336431373831343864222c226d657373616765223a227465366363674542416745416f51414252596742534d553677767679593746624464704a365a5748706b4c7846304545726f4b4a36775165555369536633674d41514478394d2b686c7a4a523034444370564d6c586e775954466344495532424a304d51304966654971476f36712b6646526f717545664c326b792f6c766873667133707a77704c4463504a48566b663472412b6a6f5870676565396d622b717338645a63654b383748416d63554a61714c69617677684e472f5761343539585a31694a414141415871474b734b6f594f62327778716e514f3167357579556b6a2f597759413d3d222c22657870697265223a313632353734393138372c2261646472657373223a22303a61343632396436313764663933316438616438366564323466346361633364333231373838626130383235373431343466353832306632383934343933666263227d2c226d6574686f64223a22636f6e6669726d5472616e73616374696f6e227d &lt;QR code&gt;  Copy the message text or scan the QR code and broadcast the message online. "},{"title":"4.10. Generate deploy message offline​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#410-generate-deploy-message-offline","content":"If needed, signed deploy message can be generated without immediately broadcasting it to the blockchain. Generated message can be broadcasted later. tonos-cli deploy_message [--raw] [--output &lt;path_to_file&gt;] [--sign &lt;deploy_seed_or_keyfile&gt;] [--wc &lt;int8&gt;] [--abi &lt;contract.abi.json&gt;] &lt;contract.tvc&gt; &lt;params&gt;  --raw - use to create raw message boc. --output &lt;path_to_file&gt; - specify path to file where the raw message should be written to, instead of printing it to terminal. &lt;deploy_seed_or_keyfile&gt; - can either be the seed phrase used to generate the deployment key pair file or the key pair file itself. If seed phrase is used, enclose it in double quotes. Example: --sign &quot;flip uncover dish sense hazard smile gun mom vehicle chapter order enact&quot; or --sign deploy.keys.json--wc &lt;int8&gt; ID of the workchain the wallet will be deployed to (-1 for masterchain, 0 for basechain). By default this value is set to 0. &lt;contract.abi.json&gt; - contract interface file. &lt;contract.tvc&gt; - compiled smart contract file. &lt;params&gt; - deploy command parameters, depend on the contract. Example (saving to a file contract deployment message to the masterchain): $ tonos-cli deploy_message --raw --output deploy.boc --sign key.json --wc -1 --abi SafeMultisigWallet.abi.json SafeMultisigWallet.tvc '{&quot;owners&quot;:[&quot;0x88c541e9a1c173069c89bcbcc21fa2a073158c1bd21ca56b3eb264bba12d9340&quot;],&quot;reqConfirms&quot;:1}' Config: /home/user/tonos-cli.conf.json Input arguments: tvc: SafeMultisigWallet.tvc params: {&quot;owners&quot;:[&quot;0x88c541e9a1c173069c89bcbcc21fa2a073158c1bd21ca56b3eb264bba12d9340&quot;],&quot;reqConfirms&quot;:1} abi: SafeMultisigWallet.abi.json keys: key.json wc: -1 MessageId: 51da1b8840bd12f9ef5152639bd1fe9062d77ed91829301043bb85b4a4d610ea Expire at: unknown Message saved to file deploy.boc Contract's address: -1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6 Succeeded.  "},{"title":"4.11. Broadcast previously generated message​","type":1,"pageTitle":"Multisignature Wallet","url":"develop/smart-contract/multisignature-wallet#411-broadcast-previously-generated-message","content":"Use the following command to broadcast any previously generated message (transaction message, confirmation message, deploy message): tonos-cli send --abi &lt;MultisigWallet.abi.json&gt; &quot;message&quot;  &lt;MultisigWallet.abi.json&gt; - either SafeMultisigWallet.abi.json or SetcodeMultisigWallet.abi.json depending on the contract you have selected at step 2.2.message – the content of the message generated by the TONOS-CLI utility during message creation. It should be enclosed in double quotes. Example: $ tonos-cli send --abi SafeMultisigWallet.abi.json &quot;7b226d7367223a7b226d6573736167655f6964223a2266363364666332623030373065626264386365643265333865373832386630343837326465643036303735376665373430376534393037646266663338626261222c226d657373616765223a227465366363674542424145413051414252596742534d553677767679593746624464704a365a5748706b4c7846304545726f4b4a36775165555369536633674d41514868757856507a324c5376534e663344454a2f374866653165562f5a78324d644e6b4b727770323865397a7538376a4d6e7275374c48685965367642523141756c48784b44446e4e62344f47686768386e6b6b7a48386775456e7551422f655a61324d326d32546539794234723636447a61364c34635258306f744a4b465661434177414141586c4d464e7077594a61616b524d64677332414341574f663459757151715976325233654e776d49655834517048686e37537a75624c76524838657931425a6a617a6a414141414141414141414141414141414a4d61735142414d4141413d3d222c22657870697265223a313632303438323730352c2261646472657373223a22303a61343632396436313764663933316438616438366564323466346361633364333231373838626130383235373431343466353832306632383934343933666263227d2c226d6574686f64223a227375626d69745472616e73616374696f6e227d&quot; Config: /home/user/tonos-cli.conf.json Input arguments: message: 7b226d7367223a7b226d6573736167655f6964223a2266363364666332623030373065626264386365643265333865373832386630343837326465643036303735376665373430376534393037646266663338626261222c226d657373616765223a227465366363674542424145413051414252596742534d553677767679593746624464704a365a5748706b4c7846304545726f4b4a36775165555369536633674d41514868757856507a324c5376534e663344454a2f374866653165562f5a78324d644e6b4b727770323865397a7538376a4d6e7275374c48685965367642523141756c48784b44446e4e62344f47686768386e6b6b7a48386775456e7551422f655a61324d326d32546539794234723636447a61364c34635258306f744a4b465661434177414141586c4d464e7077594a61616b524d64677332414341574f663459757151715976325233654e776d49655834517048686e37537a75624c76524838657931425a6a617a6a414141414141414141414141414141414a4d61735142414d4141413d3d222c22657870697265223a313632303438323730352c2261646472657373223a22303a61343632396436313764663933316438616438366564323466346361633364333231373838626130383235373431343466353832306632383934343933666263227d2c226d6574686f64223a227375626d69745472616e73616374696f6e227d abi: SafeMultisigWallet.abi.json Connecting to net.ton.dev MessageId: f63dfc2b0070ebbd8ced2e38e7828f04872ded060757fe7407e4907dbff38bba Expire at: Sat, 08 May 2021 17:05:05 +0300 Calling method submitTransaction with parameters: { &quot;dest&quot;: &quot;-1:0c5d5215317ec8eef1b84c43cbf08523c33f69677365de88fe3d96a0b31b59c6&quot;, &quot;value&quot;: &quot;1234000000&quot;, &quot;bounce&quot;: false, &quot;allBalance&quot;: false, &quot;payload&quot;: &quot;te6ccgEBAQEAAgAAAA==&quot; } Processing... Processing... Succeded. Result: { &quot;transId&quot;: &quot;6959904904053506881&quot; }  If transaction requires multiple confirmations, the terminal displays the transaction ID, which should be sent to other wallet custodians. 5. Error codes Errors related to the operation of multisig contracts typically are displayed like this: { &quot;code&quot;: 507, &quot;message&quot;: &quot;Message expired. Contract was not executed on chain. Possible reason: Contract execution was terminated with error: Contract did not accept message, exit code: 103. For more information about exit code check the contract source code or ask the contract developer&quot;, &quot;data&quot;: { &quot;message_id&quot;: &quot;029502efa1f4d5701713de772947de0c9447746abfb1c1191e403220698cf8cb&quot;, &quot;shard_block_id&quot;: &quot;baf38272f69eca4291e58958813d82cbc3e2107f0dc63ed261c2017232e3b714&quot;, &quot;core_version&quot;: &quot;1.14.1&quot;, &quot;waiting_expiration_time&quot;: &quot;Thu, 20 May 2021 18:23:37 +0300 (1621524217)&quot;, &quot;block_time&quot;: &quot;Thu, 20 May 2021 18:23:40 +0300 (1621524220)&quot;, &quot;account_address&quot;: &quot;0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc&quot;, &quot;local_error&quot;: { &quot;code&quot;: 414, &quot;message&quot;: &quot;Contract execution was terminated with error: Contract did not accept message, exit code: 103. For more information about exit code check the contract source code or ask the contract developer&quot;, &quot;data&quot;: { &quot;core_version&quot;: &quot;1.14.1&quot;, &quot;phase&quot;: &quot;computeVm&quot;, &quot;exit_code&quot;: 103, &quot;exit_arg&quot;: &quot;0&quot;, &quot;account_address&quot;: &quot;0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc&quot; } }, &quot;config_servers&quot;: [ &quot;net1.ton.dev&quot;, &quot;net5.ton.dev&quot; ], &quot;query_url&quot;: &quot;https://net5.ton.dev/graphql&quot; } } Error: All attempts have failed Error: 1  Multisig error codes, corresponding to the event that caused the error are specified in the exit_code parameter. The list of possible exit codes and what they mean is as follows:100 - message sender is not a custodian - sendTransaction, submitTransaction or confirmTransaction method was called by someone who is not a wallet custodian.102 - transaction does not exist - ID of the transaction that custodian attempted to confirm is not present in multisig.103 - operation is already confirmed by this custodian - custodian attempted to confirm transaction twice.107 - input value is too low - transaction amount is less than the minimum amount (1000000 nanotons).108 - wallet should have only one custodian - wallet custodian attempted to call sendTransaction in a wallet with more than one custodian.113 - Too many requests for one custodian - the maximum amount of queued submitTransaction and submitUpdate calls was reached (currently, this amount is set to 5). Custodian has to wait until the calls are executed, before queuing any more.117 - invalid number of custodians - the number of custodians specified during multisig deploy exceeds the maximum amount (currently, this amount is set to 32).121 - payload size is too big; submitTransaction payload exceeds the maximum limit.SetcodeMultisig-specific errors115 - update request does not exist - Setcode request with the specified ID is not present in the multisig.116 - update request already confirmed by this custodian - Setcode request with the specified ID is already confirmed by the current custodian.119 - stored code hash and calculated code hash are not equal - the code hash submitted in executeUpdate is not equal to the code previously submitted in submitUpdate .120 - update request is not confirmed; cannot perform executeUpdate as the setcode request was not confirmed by the required number of custodians yet.Currently unused error codes110 - too many custodians - not currently used. 122 - object is expired - not currently used. "},{"title":"DeBot Consortium","type":0,"sectionRef":"#","url":"learn/decentralization/debot-consortium","content":"","keywords":""},{"title":"DeBot-IS-consortium​","type":1,"pageTitle":"DeBot Consortium","url":"learn/decentralization/debot-consortium#debot-is-consortium","content":"DeBot Interface Specifications (IS) Consortium. IS a place where community defines interfaces every DeBot browser should support. DeBot-IS-consortium repository "},{"title":"Application Rules:​","type":1,"pageTitle":"DeBot Consortium","url":"learn/decentralization/debot-consortium#application-rules","content":"Each new interface must create a folder, which has a readme.md desciption of an interface, example of its implementaion in both Solidity and C++ placed in an &quot;examples&quot; sub folder. "},{"title":"Interface submission proccess:​","type":1,"pageTitle":"DeBot Consortium","url":"learn/decentralization/debot-consortium#interface-submission-proccess","content":"You should create a specifications proposal, discuss it.After the discussion is over and proposal is accepted you should submit examples in both Solidity and C++.Only proposals with examples will be published. "},{"title":"Supported browsers:​","type":1,"pageTitle":"DeBot Consortium","url":"learn/decentralization/debot-consortium#supported-browsers","content":"If you implemented a DeBot browser we will be happy to list it. Please let us know.Your browser should clearly state interfaces which it supports (by version number as stated in repository). "},{"title":"DePool Specifications","type":0,"sectionRef":"#","url":"learn/decentralization/depool-specifications","content":"","keywords":""},{"title":"Background​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#background","content":"It is quite evident that to achieve high-performance properties, a network needs powerful, reliable servers with fast connectivity. At the same time, to achieve sufficient decentralization, these servers have to belong to as many owners as possible. There seems to be a contradiction between these goals. In Proof-of-Work networks, performance is often sacrificed for decentralization. Yet, claims arise that the centralization of Bitcoin, Ethereum etc. mining power is not entirely prevented. Mining Pools centralization remains an issue, as these pools are controlled by particular entities distributing rewards. For example, almost 60% of Bitcoin mining power is concentrated in just 4 pools and around 80% of all mining power originates in China. Just 2 mining pools control 52% of Ethereum hashrate, more than 50% of which originates in China. In Proof-of-Stake, the correlation between network performance and concentration of power (money in this case) is even more apparent, as one does not need to buy, set up, and manage complicated mining farms. It can ultimately be claimed that POS is trading performance for decentralization (look no further than EOS centralization, Steemit network overtaking etc.). It seems that enabling small token holders to participate in network governance is a very important decentralization property. "},{"title":"Motivation​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#motivation","content":"Everscale blockchain needs all newly created blocks to be validated in order to run correctly. For this it relies on special designated nodes called &quot;Validators&quot;, and offers substantial reward for their work. However, becoming a validator requires a substantial cryptocurrency deposit. The required amount might far exceed an individual validator budget. On the other hand, blockchain users with no validating system might be interested in investing in validation duty. This is where the Decentralized Pool (DePool) smart contract comes in. There are two main use cases of DePool: User has no Validator capabilities but some free funds. User can support a third-party Validator and receive rewards.User has Validator capabilities and but doesn't have necessary amount of funds to participate in validator elections and subsequent rewards. "},{"title":"Basic terms​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#basic-terms","content":"DePool — a smart contract that allows other smart contracts to invest stakes into a common pool of funds and after some period of time to receive it back with interest.Elector — a system level smart contract, deployed to masterchain from zero state. Runs validator elections periodically.DePool Proxy (proxy) — a smart contract that delivers messages between DePool and Elector.Participant — a smart contract that invests funds into DePool.Validator — software running blockchain node. Each DePool works with one node only. This node must be a DePool participant.Validator wallet — a smart contract that is used by Validator to send election requests to DePool and receive the Validator reward. Validator wallet should be a Multisig contract with 3 custodians.DePool Helper — a smart contract that stores the address of the actual DePool and works with the Timer contract.Global Validators Set (GVS) — current set of validators chosen in the latest elections.Validation period — period of time for which GVS is elected.Investment round — period of time between Participant investing a stake in DePool and receiving it back (with or without interest).Timer — a smart contract that can call other smart contracts periodically. "},{"title":"Architecture​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#architecture","content":" DePool is designed to receive investment stakes from Participants, allocate the pool funds to a validator in order to participate in elections of the GVS and, after the end of the validation cycle, distribute stakes with certain rewards back to the Participants.DePool is deployed to basechain. But it cannot communicate with Elector directly, because Elector rejects messages from non-masterchain contracts. Thus there are DePool proxies that are deployed to masterchain and deliver messages from DePool to Elector and back. This is done, because DePool is a large and complex contract, and gas and storage fees are 10 times lower in basechain compared to masterchain. Keeping DePool on masterchain would be unreasonably expensive.DePool is open for Participants’ stakes at all times, however, there is a deadline for participation in the upcoming elections. The deadline depends on the timer of the Elector. After the deadline, the incoming stakes will be accumulated for participation in the next elections.DePool distinguishes stakes received before the deadline and after the deadline, therefore it stores information on Participant stakes in separate investment rounds (or rounds), one for every elections, to facilitate subsequent distribution of stakes and rewards. To separate Elector communication, DePool uses 2 proxies: one for even rounds, one for odd.In order to be time-aware, the DePool should be called from time to time. For this purpose the Timer contract is used. DePool Helper asks Timer to call it periodically and transmits every call from Timer to DePool. Interval between calls is chosen according to the elections interval.DePool must be linked to a validator wallet to participate in elections on behalf of the latter. This validator wallet address is specified during DePool deployment and cannot be changed afterwards. When elections start, DePool waits for signed election requests from linked wallet, then attaches round stake to request and transmits it to Elector.Validator can validate many DePools with 1 Validator wallet. Reputation of Validator wallet therefore is available and can be analyzed over time.To ensure that the validator will perform its functions correctly (be always online and not &quot;lie&quot; to other validators), the validator wallet must itself become a Participant and invest in every investment round at least m_validatorAssurance, which is initialized in DePool constructor. This can be achieved with any of the three available types of stakes.When Elector unfreezes validator stakes, DePool returns its stake back with round rewards. Part of the total reward is used to top up the DePool's own balance to a certain value. The rest is distributed as follows: m_validatorRewardFraction% goes to Validator wallet balance. m_participantRewardFraction% is distributed among all Participants in investment round (validator is also participant). m_associationRewardFraction% (can be equal to zero) goes to m_association address.DePool keeps a balance for each Participant and can automatically reinvest Participant's stake into the next investment round if appropriate flag is enabled.Participant can transfer part of its total stake to another Participant's stake inside DePool storage. This function allows for collateralization of the stake to provide liquidity to stake holders. "},{"title":"Special kinds of stakes​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#special-kinds-of-stakes","content":"Along with the basic ordinary stake, that functions according to the rules detailed above, there are 2 types of special stakes: vesting and lock stake. While the entire ordinary stake is invested into the current pooling round (and will thus be reinvested every second round), lock and vesting stakes are split into two equal parts upon reception, which are invested into the current pooling round, and the next round. This way they can be continuously reinvested into both odd and even rounds. "},{"title":"Vesting Stake​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#vesting-stake","content":"Any address can make a vesting stake and define a target participant address (beneficiary) who will own this stake. But not the whole stake is available to the beneficiary at once. Instead it is split into logical parts and the next part of stake becomes available to the participant only when next vesting period is ended. At completion step of every round DePool decides how many vesting parts should be unlocked and subtracted from vesting stake and become available to owner since last unlocking. These funds are added to beneficiary's ordinary stake. Example: address A makes a vesting stake of 120 tons for 1 year with vesting period of 1 month and defines address B as the stake beneficiary. It means that after 1 month 10 tons become available to address B and 110 tons are still locked in the pool. After 1 year vesting stake will be equal to 0 and last 10 tons will become available to owner. Vesting for validator beneficiaries is subject to additional rules: At the end of every withdrawal period, the part of the vesting stake to be released is divided proportionally into 2 parts — for rounds in this period when DePool successfully completed validation and received a reward (without slashing) and for rounds when DePool missed elections or was slashed. The portion of the stake corresponding to the successful rounds is sent to the validator, while the portion corresponding to the failed rounds is returned to the vesting stake owner. For example, if there were 100 rounds within the withdrawal period, and DePool successfully completed 80 of them, missed elections in 5 more and was slashed in the remaining 15, the validator will receive 80% of the unlocked part of the vesting stake, and the stake owner will get back 20% of it. "},{"title":"Lock Stake​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#lock-stake","content":"Any address can make a lock stake, in which it locks its funds in DePool for a defined period, but rewards from this stake will be payed to another target participant (beneficiary). At the end of a period the Lock Stake should be returned to the address which locked it. Example: address A makes a lock stake of 120 tons for 1 year with vesting period of 1 month and defines address B as the stake beneficiary. It means that after 1 month 10 tons become available to address A (as opposed to vesting, where these 10 tons would become available to address B, the beneficiary) and 110 tons are still locked in round. DePool will reinvest the gradually diminishing lock stake for a 1 year and pay rewards to B address. After 1 year DePool will return the remainder of the lock stake to address A. One Participant can be a beneficiary only of one lock and one vesting stake. Once current lock or vesting stake of the participant expires, it can be repeated. When a stake of either of these types is created, it is split equally into two last rounds, which means that the minimal value for such stake is 2 * minStake + fee. "},{"title":"Specification​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#specification","content":""},{"title":"Data Structures​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#data-structures","content":"DePool contract uses library and inheritance from several simple base contacts to separate functionality and facilitate development and debugging of the contract. The core data set stored by DePool is the following: DePoolLib.sol // Describes contract who deposit stakes in DePool pool struct Participant { // Count of rounds in which participant takes a part uint8 roundQty; // Sum of all rewards from completed rounds (for logging) uint64 reward; // count of parts of vesting stakes in the rounds uint8 vestingParts; // count of parts of lock stakes in the rounds uint8 lockParts; // Flag whether to reinvest ordinary stakes and rewards bool reinvest; // Target tons that will be transferred to participant after rounds are completed // After each round this value is decreased uint64 withdrawValue; } // Request for elections from validator wallet. struct Request { // Random query id. uint64 queryId; // Validator's public key that will be used as validator key if validator will win elections. uint256 validatorKey; // current election id. uint32 stakeAt; // Validator's stake factor. uint32 maxFactor; // Validator's address in adnl overlay network. uint256 adnlAddr; // Ed25519 signature of above values. bytes signature; }  DePoolRounds.sol // roundPre0 = m_rounds[m_roundQty - 1] — pre-pooling. Helper round for adding vesting and lock // stakes. When vesting/lock stake is added than stake is // split into two part. And first part invested into pooling // round and second part — pre-pooling. // // round0 = m_rounds[m_roundQty - 2] — pooling // round1 = m_rounds[m_roundQty - 3] — election or validation // round2 = m_rounds[m_roundQty - 4] — validation or investigation // Algo of round rotation: // delete round2 // round1 -&gt; round2 // round0 -&gt; round1 // roundPre0 -&gt; round0 // createNewRound -&gt; roundPre0 mapping(uint64 =&gt; Round) m_rounds; // count of created rounds uint64 m_roundQty = 0;  DePoolBase.sol // Dictionary of participants for rounds mapping (address =&gt; Participant) m_participants; // Address of the validator wallet address m_validatorWallet; // Array of proxies addresses. address[] m_proxies;  DePool.sol // Indicates that pool is closed. Closed pool doesn't accept stakes from other contracts. bool m_poolClosed; // Min stake accepted to the pool in nTon (for gas efficiency reasons): 10 tons is recommended. uint64 m_minStake; // Minimum validator stake in each round uint64 m_validatorAssurance; // % of participant rewards uint8 m_participantRewardFraction; // % of validator rewards uint8 m_validatorRewardFraction; // % of dePool association rewards uint8 m_associationRewardFraction; // Association address address m_association; // Minimum balance uint64 m_minimumBalance;  "},{"title":"DePool Initialization​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#depool-initialization","content":"When deployed, the DePool constructor is called with the following parameters: /// @dev DePool's constructor. /// @param minStake Min stake that participant may have in one round. /// @param validatorAssurance Min validator stake. /// @param proxyCode Code of proxy contract. /// @param validatorWallet Address of validator wallet. /// @param participantRewardFraction % of reward that distributed among participants. constructor( uint64 minStake, uint64 validatorAssurance, TvmCell proxyCode, address validatorWallet, uint8 participantRewardFraction, )  At initialization the variable m_balanceThreshold is set as current DePool account balance — 5 tokens. DePool will replenish its balance from validation rewards to this value every round it receives rewards. "},{"title":"Participant functions​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#participant-functions","content":"DePool stores some participant information in a dictionary (m_participants) where key — Participant's address and value — Participant structure. Functions used by participants perform checks and send receiveAnswer message back to the caller with an error code and a comment in case of failure. If all conditions are met, DePool sends a confirmation message (receiveAnswer with status 0) back to the caller. All functions can be called by internal messages only. addOrdinaryStake(uint64 stake) — allows to make an ordinary stake in the current pooling round. The source address of the message is taken as Participant's address. The Participant's total stake is increased by stake amount. Parameters: stake — value of participant's stake in nanotons. Function checks that: inbound message value is at least (stake + ADD_STAKE_FEE);stake is at least min stake;pool is not closed. Function returns change (part of unused ADD_STAKE_FEE). addVestingStake(uint64 stake, address beneficiary, uint32 withdrawalPeriod, uint32 totalPeriod) — allows to add a vesting stake for another participant (beneficiary). The source address of the message is saved as the vesting stake owner. Parameters: stake — value of participant's stake in nanotons (Note: this value is divided into 2 parts and is added to 2 rounds).beneficiary — address of target participant (beneficiary);withdrawalPeriod — the period in seconds after which the part of the vesting becomes available for beneficiary;totalPeriod — total period of vesting in seconds after which beneficiary becomes owner of the whole stake. Function checks that: DePool is not closed (m_poolClosed ≠ true);beneficiary is an addr_std. It's not zero address. It's not the message sender (not self vesting);inbound msg.value ≥ (m_minStake + ADD_STAKE_FEE);Message value is at least stake + STAKE_FEE;stake / 2 is at least min stake;withdrawalPeriod ≤ totalPeriod;totalPeriod &lt; 18 years;withdrawalPeriod ≠ 0;totalPeriod % withdrawalPeriod = 0;beneficiary doesn't have a vesting stake. addLockStake(uint64 stake, address beneficiary, uint32 withdrawalPeriod, uint32 totalPeriod) — allows to add a stake that will bring rewards to another participant (beneficiary). The source address of the message is saved as the lock stake owner. It has the same parameters and checks as addVestingStake, but it checks that participant doesn't have a lock stake instead of a vesting stake. withdrawFromPoolingRound(uint64 withdrawValue) — allows to remove Participant's stake from the current pooling round. Parameters: withdrawValue — desired amount of stake to be removed. Function checks that: inbound msg.sender address is address of an existing participant. If real ordinary stake is less than withdrawValue, then DePool returns the whole stake from pooling round. If the remaining stake in the pooling round is less than m_minStake, then the whole stake is transferred to Participant. If the remaining total stake of Participant is 0, then it is removed from the m_stakeholders dictionary. withdrawPart(uint64 withdrawValue) — Allows a participant to withdraw some value from DePool. This function withdraws withdrawValue nanotons when rounds are completed. If participant stake becomes less than minStake, then the whole stake is sent to participant. Parameters: withdrawValue — desired amount of stake to be removed. Function checks that: pool is not closed (m_poolClosed ≠ true);inbound msg.sender address is address of an existing participant. If the remaining stake in the round is less than m_minStake, then the whole stake will be transferred to Participant (after completing round). If the remaining total stake of Participant is 0, then it is removed from the m_stakeholders dictionary. 6. withdrawAll() — Set global flag for the participant that indicates to return participant's ordinary stake after completing rounds. Function checks that: pool is not closed (m_poolClosed ≠ true);inbound msg.sender address is address of an existing participant. After transferring all Participant's stake, the Participant will be removed from the m_stakeholders dictionary. cancelWithdrawal() — Cancel effect of calls of functions withdrawAll and withdrawPart. transferStake(address dest, uint64 amount) — allows to move amount of stake from msg.sender Participant to dest Participant inside DePool storage. Parameters: dest — stake beneficiary;amount — stake value transferred to dest in nanotons. Function checks that: pool is not closed (m_poolClosed ≠ true);destination is a non-zero addr_std;msg.sender ≠ dest;neither destination nor msg.sender is the validator wallet;inbound msg.sender address is address of an existing participant;desired amount can be transferred and transfer doesn't leave stake less than m_minStake in any round. In case of success DePool sends back a notification via onTransfer function calling to beneficiary. "},{"title":"Functions of interface DePoolInfoGetter:​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#functions-of-interface-depoolinfogetter","content":"function getLastRoundInfo() public If there is no completed round yet, call callback function receiveDePoolInfo with struct containing default values, else send call with struct containing info about last completed round. // Represent info about last completed round struct LastRoundInfo { uint32 supposedElectedAt; uint8 participantRewardFraction; uint8 validatorRewardFraction; uint32 participantQty; uint64 roundStake; address validatorWallet; uint256 validatorPubkey; uint64 validatorAssurance; }  "},{"title":"Participant callback functions:​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#participant-callback-functions","content":"These functions are called by DePool to send notifications to Participant. receiveAnswer(uint32 errcode, uint64 comment) — function, which is called as an answer from DePool to Participant. Arguments: errcode — error code. List of codes: uint8 constant STATUS_SUCCESS = 0; uint8 constant STATUS_STAKE_TOO_SMALL = 1; uint8 constant STATUS_DEPOOL_CLOSED = 3; uint8 constant STATUS_NO_PARTICIPANT = 6; uint8 constant STATUS_PARTICIPANT_HAVE_ALREADY_VESTING = 9; uint8 constant STATUS_WITHDRAWAL_PERIOD_GREATER_TOTAL_PERIOD = 10; uint8 constant STATUS_TOTAL_PERIOD_MORE_18YEARS = 11; uint8 constant STATUS_WITHDRAWAL_PERIOD_IS_ZERO = 12; uint8 constant STATUS_TOTAL_PERIOD_IS_NOT_DIVED_BY_WITHDRAWAL_PERIOD = 13; uint8 constant STATUS_PERIOD_PAYMENT_IS_ZERO = 14; uint8 constant STATUS_REMAINING_STAKE_LESS_THAN_MINIMAL = 16; uint8 constant STATUS_PARTICIPANT_HAVE_ALREADY_LOCK = 17; uint8 constant STATUS_TRANSFER_AMOUNT_IS_TOO_BIG = 18; uint8 constant STATUS_TRANSFER_SELF = 19; uint8 constant STATUS_TRANSFER_TO_OR_FROM_VALIDATOR = 20; uint8 constant STATUS_FEE_TOO_SMALL = 21; uint8 constant STATUS_INVALID_ADDRESS = 22; uint8 constant STATUS_INVALID_BENEFICIARY = 23; uint8 constant STATUS_NO_ELECTION_ROUND = 24; uint8 constant STATUS_INVALID_ELECTION_ID = 25;  comment — some value attached to error code. onTransfer(address source, uint128 amount) — function, which is called after successful transferStake to inform beneficiary. Arguments: source — address of Participant who made transfer;amount — funds that were transferred. onRoundComplete(uint64 roundId, uint64 reward, uint64 ordinaryStake, uint64 vestingStake, uint64 lockStake, bool reinvest, uint8 reason) — send a notification from DePool to Participant when round is completed: roundId — Id of completed round;reward — Participant's reward in completed round in nanotons;ordinaryStake — ordinary stake in completed round;vestingStake — vesting stake in completed round;lockStake — lock stake in completed round;reinvest — are ordinary stakes automatically reinvested (prolonged)?reason — reason why round is completed (See enum CompletionReason). "},{"title":"DePool owner functions:​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#depool-owner-functions","content":"These functions can be called only by the DePool owner, as they have to be signed with the deploy keypair. terminator() [external msg only] — a method to close DePool. All stakes from all rounds are returned in several phases: a. first of all, stakes from pooling round are returned immediately. b.m_poolClosed = true; c. All other rounds will return stakes after their &quot;completed&quot; step. Important: remaining parts of vesting/lock stakes will be sent to owners of those stakes (not to beneficiaries) setValidatorRewardFraction(uint8 fraction) [external msg only] Sets new validator's reward fraction and calculates new participants' reward fraction. New validator's reward fraction must be less than current one and be not zero. fraction — new validator's reward fraction. "},{"title":"Events​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#events","content":"DePoolClosed() — event emitted when pool is closed by terminator() function.RoundStakeIsAccepted(uint64 queryId, uint32 comment) — event is emitted on accepting stake by elector.RoundStakeIsRejected(uint64 queryId, uint32 comment) — event is emitted on rejecting stake by elector.ProxyHasRejectedTheStake(uint64 queryId) — event is emitted if stake is returned by proxy (IProxy.process_new_stake) because too low balance of proxy contract.ProxyHasRejectedRecoverRequest(uint64 roundId) — event is emitted if stake cannot be returned from elector (IProxy.recover_stake) because too low balance of proxy contract.RoundCompleted(TruncatedRound round) — event is emitted on completing round.StakeSigningRequested(uint32 electionId, address proxy) — Event emitted when round is switched from pooling to election. DePool is waiting for signed election request from validator wallet.TooLowDePoolBalance(uint replenishment) — event emitted when pure DePool's balance becomes too low. replenishment minimal value that must be sent to DePool via receiveFunds function.RewardFractionsChanged(uint8 validator, uint8 participants) — event emitted when contract owner changes reward fractions. validator — validator's reward fraction. participants — participants' reward fraction. "},{"title":"Get-methods​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#get-methods","content":"These get-methods are used for local run. getParticipantInfo(address addr) — returns participant's information about stakes in every rounds;getDePoolInfo() — returns DePool configuration parameters and constants;getParticipants() — return list of all participants;getRounds() — returns information about all rounds.getDePoolBalance() — returns DePool's own balance in nanotokens. The DePool does not store validator public keys or ADNL address, because, according to the official Everscale guide, the Validator generates a new keypair and ADNL for every elections. The contract stores only Validator wallet address. "},{"title":"State update function​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#state-update-function","content":"ticktock() — this function is the &quot;engine&quot; of DePool. This function rotates rounds: creates a new round if necessary and removes an old one. Switches steps of rounds and calls various internal functions if certain conditions are satisfied and so on. ticktock() — does not accept external inbound messages and can be called only from other contracts ticktock returns unspent message value (change) back to caller. "},{"title":"Multi-Round elections​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#multi-round-elections","content":" Every round goes through several steps: &quot;PrePooling&quot; step (RoundStep.PrePooling) — it's an imaginary round introduced to store half of vesting/lock stake from participants. See addVestingStake/addLockStake functions.&quot;Pooling&quot; step (RoundStep.Pooling) — round is ready to accept stakes from Participants. This round receives ordinary, vesting and lock stakes.&quot;waiting for election requests&quot; step (RoundStep.WaitingValidatorRequest) — round is switched to this step when validator elections begin. DePool is waiting for signed election request from validator wallet. See process_new_stake function of Elector to properly generate election request. Important: Validator wallet must also be a Participant and invest at least m_validatorAssurance stake in the round. If it doesn't, round is completed and stakes are reinvested in another round or are returned to participants. &quot;Waiting if stake is accepted by elector&quot; (RoundStep.WaitingIfStakeAccepted) — DePool has received the validator signed election request. DePool has sent the whole round stake to elector through one of its proxies. Now DePool is waiting for elector answer. Note: elector will call DePool's onStakeAccept function if election request is accepted successfully or onStakeReject in case of an error.&quot;waiting for validation start&quot; (RoundStep.WaitingValidationStart) — round stake was accepted by elector. Validator is a candidate. DePool now is waiting for the start of the validation to find out if validator won the elections.&quot;waiting for election result&quot; (RoundStep.WaitingIfValidatorWinElections) — DePool has tried to recover stake in validation period to find out if validator won elections. Waiting for elector answer. Note: If validator won the elections, elector returns no stake. If Validator lost the elections, elector returns the whole stake.&quot;waiting stake unfreeze&quot; (RoundStep.WaitingUnfreeze) — If CompletionReason != Undefined, the round is waiting round rotation to return/reinvest funds because elections were lost. Else validator won elections. DePool is waiting for ending of unfreeze period to recover funds from elector.&quot;waiting for a reward&quot; (RoundStep.WaitingReward) — Unfreeze period has been ended. Request to recover stake has been sent to elector. DePool is waiting for answer from elector.&quot;completing&quot; step (RoundStep.Completing) — DePool receives reward and replenishes its balance from it. Then it returns or reinvests participant's stakes. Also on this step DePool recounts vesting and lock stakes and modifies them if necessary.&quot;completed&quot; (RoundStep.Completed) — round switches to this step after processing all the Participants in the round. In next ticktock this round will be deleted. "},{"title":"Round completion​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#round-completion","content":"When a round switches to &quot;completing&quot; step (completeRound function), the DePool replenishes its balance from received rewards and then starts to cycle through all stakes in the round. If Participant's reinvestment flag is false, DePool sends it back to the Participant, otherwise — adds it to the pooling round. Also DePool sends notification message (onRoundComplete) to Participant. DePool goes through all vesting and lock stakes of the completing round and checks whether a withdrawal period has finished for the current stake. If it has, DePool modifies the stake via transferring part of it to Participants ordinary stake (in case of Vesting) and/or transferring part of the stake back to the owner (in case of Lock or in case of Vesting for validator which was slashed or lost elections over the course of the completed withdrawal period). Remark: if there are 15000 stakes in round, then the contract should split completion to 375 transactions sending 375 completePendingRound messages to itself. All these transactions can fit in 1-2 blocks and the whole operation will take about 5-20 seconds. "},{"title":"DePool decentralization​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#depool-decentralization","content":"No inherent way to replace the contract code (no SETCODE);No inherent way to transfer an arbitrary amount of currency from the DePool;Any contract can call the ticktock() function to update the state of the DePool;No one has special privileges, except for deployer of DePool who can only close DePool and start a procedure of returning all stakes back to Participants;Fees cannot be changed after the contract is deployed;Validator wallet must be a Participant as well to share risks with other Participants. "},{"title":"DePool contract fee​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#depool-contract-fee","content":"Caller of DePool's ticktock function must pay for consumed gas. Unused message value is returned back when ticktock is finished. At the beginning of completing step DePool first takes from the total reward an amount of tokens to replenish it's balance to m_balanceThreshold, and then additionally RET_OR_REINV_FEE * (N + 1), where N is the number of participants, to cover the costs of stake processing. "},{"title":"Links​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#links","content":"DePool contract is available on github. DePool deployment instructions can be found here. "},{"title":"DeBot Specifications","type":0,"sectionRef":"#","url":"learn/decentralization/debot-specifications","content":"","keywords":""},{"title":"Objective​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#objective","content":"Provide a secure and convenient environment to work with smart-contracts emulate calling smart-contract functions locally on the client;debug blockchain transactions;interact with smart-contracts deployed in the blockchain. "},{"title":"Basic terms​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#basic-terms","content":"DeBot — a smart contract facilitating conversation-like flow communication with a target smart contract;Target smart contract — a smart contract for which DeBot is created. DeBot is an interface to this smart contract;DeBot protocol — a set of rules describing the communication between browser and DeBot: how to call DeBot functions and how to interpret its answers;DeBot engine (DEngine) — a program component that executes DeBot and parses its answer using DeBot protocol;DeBot browser — a program, which creates instances of DEngine for executed DeBot and renders the user interface. "},{"title":"Architecture​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#architecture","content":" DeBot platform consists of the following elements: DeBot smart contract;DeBot browser;Target smart contract(s). One target smart contract can have several DeBot and vise versa. DeBot is deployed to the blockchain. DeBot browser runs on client. It downloads DeBot code and runs it inside the DEngine. "},{"title":"Proof of State​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#proof-of-state","content":"Transactions can be verified by running DeBot locally and comparing the result of execution to the account state in the blockchain. "},{"title":"DeBot Interfaces​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#debot-interfaces","content":""},{"title":"Motivation​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#motivation","content":"DeBot is a smart contract and smart contracts are isolated from each other and from the blockchain, their capabilities are limited by the commands of the virtual machine on which they are executed. But DeBot must have more possibilities. DeBot need to: receive input from users;query info about other smart contracts;query transactions and messages;receive data from external subsystems (like file system) and external devices (like NFC, camera and so on);call external function libraries that allow to do operations that are not supported by VM. For example, work with json, convert numbers to string and vice versa, encrypt/decrypt/sign data. To cover all these needs we should design different DeBot Interfaces (DInterfaces) which can be used in DeBot and which must be supported in DeBot Browsers. These interfaces should match the requirements: comprehensive — interfaces should describe all types of communication accessible on modern devices;universal — interfaces should be abstract from certain OS and hardware;atomic — every communication channel should be separately described in the interface for further flexible resource access management;convenient — even low-skilled developers should be able to use this interface in their DeBot. In this model DeBot Engine should act like a proxy between DeBot Browser and DeBot. But it can have builtin implementation of very basic DInterfaces (e.g. working with json). Also, we need to describe the manifest for DeBot. DeBot developer will describe all needed interfaces in this manifest and the DeBot Browser will check it before running DeBot. We need this manifest to keep users secure and private when using DeBot. "},{"title":"Description​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#description","content":"Every DeBot must declare which DInterfaces it will use. For this purpose it must have getRequiredInterfaces() function which returns array of required interfaces. Every interface must have an id which is an unsigned 256-bit integer and an address which is used in DeBot as a destination address of internal messages. Address must be a standard Everscale address consisting of DEBOT_WC (equal to 0xDB) as a workchain_id part and interface id as address part (see &quot;Telegram Open Network Blockchain&quot;specification, section 3.1.2 for details about TL-B scheme for address). For example, in solidity getRequiredInterfaces can be implemented like this: // Base contract for all DeBot abstract contract Debot { i32 constant DEBOT_WC = - 31; function getRequiredInterfaces() virtual returns (uint256[] interfaces); } contract DebotA is Debot { function getRequiredInterfaces() override returns (uint256[] interfaces) { return [ID_TERMINAL, ID_MENU, ...]; } }  "},{"title":"How to use DInterface in DeBot​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#how-to-use-dinterface-in-debot","content":"To use an interface DeBot should import source file with DInterface declaration and call its methods as any other smart contract methods in Everscale — by sending internal messages to interface address. Before running the DeBot, DeBot Browser should provide callbacks for DEngine to receive all requests to DInterfaces. Requests are packed into internal messages. When Browser receives a message from DEngine it should unpack the message, decode its body, call DInterface function, pack results to internal message and return it to DEngine using Dengine.send(msg). interface BrowserCallbacks { // Message from Debot to Browser with encoded DInterface call send(message: string): Promise&lt;void&gt; // Request from DEngine to approve some action (for example, send mesage to blockchain) approve(action: {}): boolean // Request from DeBot to call another DeBot invoke(debotAddress: string, message: string): Promise&lt;void&gt; }  "},{"title":"DeBot Start​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#debot-start","content":"Befor starting DeBot should also provide metadata, which includes its name, version, authorship information, description, language and ABI. This is accomplished through the getDebotInfo() mandatory function. Along with getRequiredInterfaces() this function is defined in the base contract Debot.sol. // Base contract for all DeBots abstract contract Debot { /// @notice ACTION structure struct Action { // String that describes action step, should be printed to user string desc; // Name of debot function that runs this action string name; // Action type uint8 actionType; // Action attributes. // Syntax: &quot;attr1,attr2,attr3=value,...&quot;. // Example: &quot;instant,fargs=fooFunc,sign=by-user,func=foo&quot; string attrs; // Context to transit to uint8 to; // Action internal data TvmCell misc; } struct Context { uint8 id; // Context ordinal string desc; // message to be printed to the user Action[] actions; // list of actions } string s_dabi; /* * Public debot interface */ /// @notice Returns list of interfaces used by DeBot. function getRequiredInterfaces() public view virtual returns (uint256[] interfaces); /// @notice Used for error handling for external messages if error code &gt;= 400 (TVM) and &lt; 500 (PROCESSING) function getErrorDescription(uint32 error) public pure virtual returns (string desc); /// @notice Invoked by DeBot Browser at debot startup. Returns array of debot contexts. function fetch() public virtual returns (Context[] contexts); /// @notice DeBot entry point. function start() public virtual; /// @notice Returns DeBot metadata. /// @return name String with name of debot, e.g. &quot;DePool&quot;. /// @return version Semver version of debot, that will be converted to string like &quot;x.y.z&quot;. /// @return publisher String with info about who has deployed debot to blokchain, e.g. &quot;TON Labs&quot;. /// @return caption (10-20 ch.) String with short description, e.g. &quot;Work with Smthg&quot;. /// @return author String with name of author of DeBot, e.g. &quot;Ivan Ivanov&quot;. /// @return support Free TON address of author for questions and donations. /// @return hello String with first messsage with DeBot description. /// @return language (ISO-639) String with debot interface language, e.g. &quot;en&quot;. /// @return dabi String with debot ABI. function getDebotInfo() public functionID(0xDEB) view virtual returns( string name, string version, string publisher, string caption, string author, address support, string hello, string language, string dabi, bytes icon ); /// @notice Allow to set debot ABI. Do it before using debot. function setABI(string dabi) public { require(tvm.pubkey() == msg.pubkey(), 100); tvm.accept(); s_dabi = dabi; } /// @notice Returns DeBot ABI. /// @dev Deprecated. Remove later. https://github.com/tonlabs/TON-SDK/blob/dc0631a726295c4e7190361c417214c301ec4e01/ton_client/src/debot/dengine.rs#L175 function getDebotOptions() public view returns ( uint8 options, string debotAbi, string targetAbi, address targetAddr ) { debotAbi = s_dabi; targetAbi = &quot;&quot;; targetAddr = address(0); options = 1; } } contract MyDeBot is Debot { function getErrorDescription(uint32 error) public pure override returns (string desc) { tvm.log(format(&quot;getErrorDescription: {}&quot;, error)); desc = format(&quot;some description about code {}&quot;, error); // TODO description error codes } function fetch() public override returns (Context[] contexts) { tvm.log(&quot;fetch&quot;); // TODO fetch Context } function start() public override { tvm.log(&quot;start&quot;); // TODO start } function getDebotInfo() public functionID(0xDEB) view override returns( string name, string version, string publisher, string caption, string author, address support, string hello, string language, string dabi, bytes icon ) { tvm.log(&quot;getDebotInfo&quot;); name = &quot;MyDeBot&quot;; version = &quot;1.0.0-alpha.0&quot;; publisher = &quot;Everscale&quot;; caption = &quot;My first DeBot&quot;; author = &quot;Everscale&quot;; support = address.makeAddrStd(0, 0x0); hello = &quot;Hello first user!&quot;; language = &quot;en&quot;; dabi = s_dabi; icon = &quot;&quot;; } function getRequiredInterfaces() public view override returns (uint256[] interfaces) { tvm.log(&quot;getRequiredInterfaces&quot;); // TODO add dependency interfaces } }  Run debug log: npx tonos-cli debot --debug fetch &lt;ADDRESS&gt; 19:43:58 [DEBUG] (1) ton_client::debot::dengine: running getRequiredInterfaces, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:43:58 [INFO] getRequiredInterfaces 19:43:58 [DEBUG] (1) ton_client::debot::dengine: running getDebotInfo, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:43:58 [INFO] getDebotInfo 19:43:58 [DEBUG] (1) ton_client::debot::dengine: run_debot_external getDebotOptions, args: {} 19:43:58 [DEBUG] (1) ton_client::debot::dengine: running getDebotOptions, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:43:58 [DEBUG] (1) ton_client::debot::dengine: run_debot_external fetch, args: {} 19:43:58 [DEBUG] (1) ton_client::debot::dengine: running fetch, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:43:58 [INFO] fetch DeBot Info: Name : MyDeBot Version: 1.0.0-alpha.0 Author : Everscale Publisher: Everscale Support: 0:0000000000000000000000000000000000000000000000000000000000000000 Description: My first DeBot Hello first user! Run the DeBot (y/n)? y 19:44:02 [DEBUG] (1) ton_client::debot::dengine: running getRequiredInterfaces, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:44:02 [INFO] getRequiredInterfaces 19:44:02 [DEBUG] (1) ton_client::debot::dengine: running getDebotInfo, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:44:02 [INFO] getDebotInfo 19:44:02 [DEBUG] (1) ton_client::debot::dengine: run_debot_external getDebotOptions, args: {} 19:44:02 [DEBUG] (1) ton_client::debot::dengine: running getDebotOptions, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:44:02 [DEBUG] (1) ton_client::debot::dengine: run_debot_external fetch, args: {} 19:44:02 [DEBUG] (1) ton_client::debot::dengine: running fetch, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:44:02 [INFO] fetch 19:44:02 [DEBUG] (1) ton_client::debot::dengine: switching to 0 19:44:02 [DEBUG] (1) tonos_cli::debot::callbacks: switched to ctx 0 19:44:02 [DEBUG] (1) ton_client::debot::dengine: run_action: start 19:44:02 [DEBUG] (1) ton_client::debot::dengine: run_debot_external start, args: {} 19:44:02 [DEBUG] (1) ton_client::debot::dengine: running start, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:44:02 [INFO] start 19:44:02 [DEBUG] (1) ton_client::debot::dengine: instant_switch = false, state_to = 0 19:44:02 [DEBUG] (1) tonos_cli::debot::callbacks: no more actions, exit loop  Before starting the DeBot, DeBot Browser creates new instance of DEngine with address of DeBot;DEngine downloads DeBot state, queries metadata and list of DInterfaces required by DeBot and returns the list to Browser;Browser must check that it supports all required DInterfaces. If one of interfaces is not supported, Browser must report error to the user (application) and not start the DeBot otherwise Browser must list requested interfaces to user (application);All required interfaces should be approved by user (application);After the list of interfaces is approved, the DeBot Browser starts DeBot using Dengine.start(callback). On every interface call Browser should check permission for DeBot and on success execute it according to isolation requirement if needed. Below you can see DeBot start sequence:  "},{"title":"DInterface specification​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#dinterface-specification","content":"Every DInterface must be discussed and accepted by DeBot Interface Specifications (DIS) Consortium before it can be used in DeBot. All accepted interfaces are published in DeBot Interface Specifications Consortium. Everybody can suggest new DInterface. Go to repo and follow the instructions. "},{"title":"DInterfaces support in DeBot Browser​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#dinterfaces-support-in-debot-browser","content":"DeBot Browser can support and implement any or all DInterfaces published in DIS repo depending on browser's capabilities. For example, console browser cannot support external devices like camera, NFC, microphone and so on. Some interfaces required for basic DeBot operation are built into the DEngine itself (SDK, Hex, JsonDeserialize). They are marked as such in their respective readme files in the DeBot Interface Specifications Consortium. "},{"title":"DEngine versioning​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#dengine-versioning","content":"DEngine as a SDK module should have a version of SDK itself. DIS statuses: Proposed, Accepted, Published. "},{"title":"Example of DInterface​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#example-of-dinterface","content":"Name\tIDRawInput\t8796536366ee21852db56dccb60bc564598b618c865fc50c8b1ab740bba128e3 "},{"title":"Description​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#description-1","content":"Allows to get string from user "},{"title":"Functions​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#functions","content":"Function input arguments: answerId: uint32 — function id of result callbackprompt: bytes — string printed to the user and describing what to enter returns: text: bytes — string entered by user "},{"title":"Declaration in Solidity​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#declaration-in-solidity","content":"interface IRawInput { function input(uint32 answerId, string prompt) external returns (string value); } Library RawInput { uint256 constant ID_RAWINPUT = 0x8796536366ee21852db56dccb60bc564598b618c865fc50c8b1ab740bba128e3 // Callback Function Prototype function inputResult(uint32 answerId, string prompt) public { address addr = address.makeAddrStd(DEBOT_WC, ID_RAWINPUT); IRawInput(addr).input(answerId, prompt); } }  "},{"title":"Declaration in C++​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#declaration-in-c","content":"namespace tvm { namespace schema { __interface IRawInput { [[internal, answer_id]] string input(string prompt); };  "},{"title":"Code Example​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#code-example","content":"Solidity​ pragma solidity &gt;=0.6.0; import &quot;Debot.sol&quot;; import &quot;RawInput.sol&quot;; contract ExampleDebot is Debot, RawInput { function start() public { RawInput.input(tvm.functionId(inputResult), &quot;enter your name:&quot;); RawInput.input(tvm.functionId(inputResult), &quot;enter your wallet address:&quot;); } function inputResult(string text) public override { require(text == &quot;Debot&quot;); } }  Note: C++ DeBot are currently in the state of early development, and not all features all completely defined for them yet. "},{"title":"DeBot Special Features​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#debot-special-features","content":"DeBot have 3 special features: calling — get-methods of target smart contracts;calling — external functions of target smart contracts onchain;invoking — other DeBot in a local environment. Ordinary Everscale smart contracts cannot use 1st and 2nd features because they cannot produce external inbound messages. But DeBot can, due to the fact that they are executed in DEngine, that allows DeBot to generate these kinds of messages, send them to blockchain and return results to DeBot. In terms of DeBot, all these features are implemented without DInterfaces but in a native way, like two smart contracts communicating with each other — by sending messages directly to target address. But with only one difference — to call a get-method or call a function onchain DeBot must generate external inbound message, while to invoke another DeBot, it should generate an internal message to the invoked DeBot address. DEngine distinguishes between get-methods and onchain calls by examining the sign header of the message. Signed messages (sign: true) are considered onchain calls, while unsigned messages (sign: false) are considered to be get-method calls. "},{"title":"Get-methods​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#get-methods","content":"Developer Example​ Solidity function showTasks(uint32 index) public view { index = index; optional(uint256) none; ITodo(m_address).getTasks{ abiVer: 2, extMsg: true, sign: false, pubkey: none, time: uint64(now), expire: 0, callbackId: tvm.functionId(showTasks_), onErrorId: tvm.functionId(onError) }(); }  Support in DEngine​ DEngine executes DeBot and checks if it produces external inbound messages. If yes, then DEngine analyzes each message by scanning signature and public key bits in message body to understand if message is for get-method call. If bits are zero DEngine downloads target contract and runs its get-method, then returns results to DeBot by calling its function set in the callbackId or onErrorId (in case of errors) headers of message body. "},{"title":"Onchain function call​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#onchain-function-call","content":"Developer example​ Solidity IMsig(m_msigAddress).sendTransaction{ abiVer: 2, extMsg: true, sign: true, pubkey: pubkey, time: uint64(now), expire: 0, callbackId: tvm.functionId(waitBeforeDeploy), onErrorId: tvm.functionId(onErrorRepeatCredit) }(m_address, INITIAL_BALANCE, false, 3, empty); }  Support in DEngine​ DEngine executes DeBot and checks if it produces external inbound messages. If there is one, DEngine analyzes if it is onchain call by scanning signature and public key bits in message body. If signature bit is 1 then DEngine does the following things. Downloads target smart contract, signs the message and emulates its transaction locally;Checks if transaction produces outbound internal messages with funds;Requests permission from DeBot Browser to send this message onchain. Request contains information about funds that will be spent if message will be executed onchain and message itself;If DeBot Browser allows to send message, DEngine sends message to blockchain. "},{"title":"Invoking DeBot​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#invoking-debot","content":"DeBot can call another DeBot by simply sending internal message to it. After DeBot execution DEngine filters all internal messages produced by DeBot with destination addresses with workchain 0. This filter allows to separate DInterface calls (which have 0xDB workchain id) from DeBot invokes. If there are invoke messages, DEngine sends them to Browser through BrowserCallbacks interface. Browser (or user) has to approve the invoke of a new DeBot, at which point Browser creates a new DEngine instance, downloads target DeBot and transfers the message to it. Browsers should generally support a common queue for messages from several DeBot. "},{"title":"Security notes​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#security-notes","content":"At start browser creates a DEngine instance, and receives DeBot metadata and list of required DInterfaces through DEngine, and checks them for compatibility and security. When DeBot is running, DEngine proxies all DInterface calls (except calls to builtin interfaces supported by engine itself like SDK calls) directly to Browser which must decide to execute or reject them. Get-method calls are always allowed. Executed by DEngine. External function calls must be approved by Browser. Executed by DEngine. Other DeBot calls are always allowed. But executed by Browser which can block invoke if needed. "},{"title":"End-to-end Decentralization","type":0,"sectionRef":"#","url":"learn/decentralization/end-to-end-decentralization","content":"","keywords":""},{"title":"Background​","type":1,"pageTitle":"End-to-end Decentralization","url":"learn/decentralization/end-to-end-decentralization#background","content":"Decentralization is an important property of public blockchain technology 1. Despite its claims of decentralization, blockchain keeps on fighting to achieve it through improvements and optimizations mainly related to consensus mechanisms and data exchange protocols. Proof-of-Work and Proof-of-Stake consensus protocols (and their derivatives) have issues related to centralization at both mining/staking and at the front-end levels. Considerable amounts of centralization exist in development ecosystems of some blockchains as well. Decentralization claims can only be made when the whole system is decentralized, and therefore, should be judged by its weakest (or rather most centralized) link. In the current invention we present an end-to-end Decentralization framework (E2ED). In today's blockchains that support smart contracts (or in other words the ability to perform and validate arbitrary computations), user interaction with results of such computations is performed using some front end library (such as Web3 in Ethereum blockchain). The Web3 library takes care of performing blockchain related tasks with blockchain data presented to a user. The IPFS is used to store data in a decentralized manner. Yet as shown below neither is enough to preserve full decentralization of end user interactions with a blockchain system to ensure censorship resistance and security. "},{"title":"Web3​","type":1,"pageTitle":"End-to-end Decentralization","url":"learn/decentralization/end-to-end-decentralization#web3","content":"Web3.0 js is a collection of libraries which allow you to interact with a local or remote Ethereum node, using a HTTP or IPC connection2. Web3.0 is a collection of JavaScript libraries that allow users to interact with a local or remote Ethereum node using an HTTP or IPC connection. In other words, it’s a kind of SDK which gives users the ability to work with blockchain in the browser. That’s why it actually has a Web in the name and not something else. Web3.0 is numbered 3.0 quite obviously because 2.0 and 1.0 versions of Web already exist, referring to the World Wide Web's evolution where the 2.0 version unlike the 1.0 version, for instance, allows for display of user-generated content, dynamically making websites more sophisticated. Web 3.0 on the other hand is seen as part of the World Wide Web’s evolution due to the fact that it can be considered as a first attempt to access decentralized (blockchain) applications on the web. The purpose of Web3 is to give the ability to create decentralized apps on the web connecting sites to the world of blockchain, in particular Ethereum blockchain. The main problem with this approach is that a user does not really interact with the blockchain when using Web3 based applications, because most of the time the user interacts with many elements of information outside of the blockchain, presented to them by the application user interface. This presents quite a significant problem as all such information and user interface elements are not decentralized, which means they are not immutable, not censorship resistant, and not fault tolerant. Moreover, blockchain related elements that are supposedly temper proofed lose their properties once they are part of this centralized model. "},{"title":"IPFS​","type":1,"pageTitle":"End-to-end Decentralization","url":"learn/decentralization/end-to-end-decentralization#ipfs","content":"Enters IPFS. The InterPlanetary File System (IPFS) is a protocol and peer-to-peer network for storing and sharing data in a distributed file system. IPFS uses content-addressing to uniquely identify each file in a global namespace connecting all computing devices3. An IPFS developer or user can store the content somewhere that’s always online and accessible and make sure that when the user comes online they know where to find the content. This way we theoretically could use IPFS to store all user interfaces somewhere, save a hash and an address of said content on the blockchain and therefore prove to the user that whatever is displayed in their browser is true and correct by way of verifying it using Web3 library. Yet even an IPFS and Web3 combination does not guarantee end-to-end decentralization as described below in more detail. "},{"title":"User interaction (DeBot)​","type":1,"pageTitle":"End-to-end Decentralization","url":"learn/decentralization/end-to-end-decentralization#user-interaction-debot","content":"A system is needed to create a comprehensive user experience without relying on trusted infrastructure. To achieve this, we introduced technology for writing the user interface inside the smart contract itself. Decentralized Bot (DeBot) is a technology enabling end-to-end Decentralization at a user interaction level. Using E2ED, any front-end application (be it in a web browser or a purposely built software) can draw an entire user experience without relying on a server. Comparing Web 2.0, Web 3.0 and E2ED based systems (which for the purpose of the diagram below we named Web3.11 as a reminiscent to the famous Windows 3.11), E2ED is not a contradiction to Web3.0 but rather a continuation that closes some centralization loopholes to achieve end-to-end decentralization. Web3.0 itself is not a monolithic system. It has many components such as an IPFS database for storage and others for address discovery and storage query on top. The Web3.0 approach is fragmented. A smart contract is executed in one place and the data it manipulates is stored in another. The data meets the business logic only on an end user device, therefore, the computation performed on such data can not be verified by a blockchain. For that reason we have verifiable business logic (smart contract) operating with the data it can not verify. The only limited verification available is the hash of data stored somewhere else. The interaction with said data is static. If a man-in-the-middle attack is performed on the user device level, the security of Web3 can be compromised. In practice today what happens in almost 100% of cases is shown in the middle column of the diagram below. A user interface is provided by a web server. An application is running on the server and displayed in the user browser (or on a mobile device). The user performs many usual operations with the website content on the server and only when needed to interact with the blockchain does the Web3.0.js get called, which then interacts with the blockchain calling it from the end user device and signed with the user private key. Even if Web3.0 is really advanced and stores the application data (say a website), in the IPFS database the Web3.0.js will be called to perform operations with a blockchain and again not the library nor the smart contract it interacts with, and will not be able to verify what has actually happened to the data that was stored and received from the IPFS on the user device.  In E2ED the smart contract contains the actual user interface in a form of DeBot. The DeBot system described herein is just one way of performing user interface functions by a smart contract. The whole graphical user interface could be drawn if needed. In DeBot the sequence of user actions is performed by calling DeBot smart contract functions using the local virtual machine of any particular blockchain. The result of those actions could at any time be transmitted to the remote smart contract together with the sequence of user performed actions and the whole interface interaction could be verified remotely by the blockchain, including the resulting transaction. In terms of addressing the user, it just needs to know the address of a smart contract DeBot, which is a blockchain address that in turn can be abstracted further using a blockchain based DNS service. "},{"title":"References​","type":1,"pageTitle":"End-to-end Decentralization","url":"learn/decentralization/end-to-end-decentralization#references","content":"The Meaning of Decentralization↩web3.js - Ethereum JavaScript API↩InterPlanetary File System↩ "},{"title":"Bridges","type":0,"sectionRef":"#","url":"learn/everscale-overview/bridges","content":"","keywords":""},{"title":"What is a cross-chain bridge?​","type":1,"pageTitle":"Bridges","url":"learn/everscale-overview/bridges#what-is-a-cross-chain-bridge","content":"Cross-chain bridges was made for transferring assets between chains. Their locks assets in the source chain and creates an equivalent number of wrapped assets in the destination blockchain. When you initiate an asset transfer from one blockchain to another using a bridge, assets are not actually moved or sent anywhere. Instead, the transfer functionality is used in a two-step process and handled by a smart contract. In simple terms - Let's say you want to move tokens from chain A to chain B. What the bridge does is it temporarily locks or freezes your asset in chain A. They then create an equivalent number of new tokens that will be unlocked for you in chain B. When you want to redeem the tokens, that is, when you want to move the original assets back from chain B to the original chain (chain A), the tokens created in chain B will be burned and the original assets will be unlocked. The concept of interchain communication and token transfer is done using a two-way binding system; where the value of a token in either blockchain is the same, as it remains tied to the value of the initial ones. "},{"title":"Everscale Bridges​","type":1,"pageTitle":"Bridges","url":"learn/everscale-overview/bridges#everscale-bridges","content":""},{"title":"Octus Bridge​","type":1,"pageTitle":"Bridges","url":"learn/everscale-overview/bridges#octus-bridge","content":"Octus Bridge is a platform built by the Broxus team that enables cross-chain asset transfers between Everscale and other networks such as Ethereum, BNB Chain, Fantom and Polygon. The platform also implements the Governance interface or DAO, which provides a level of decentralization unprecedented for bridges due to the ability to make decisions directly by network participants, as well as a staking interface. "},{"title":"Adaever​","type":1,"pageTitle":"Bridges","url":"learn/everscale-overview/bridges#adaever","content":"Cross-chain bridge between Cardano and Everscale built by the Broxus team. "},{"title":"Ecosystem","type":0,"sectionRef":"#","url":"learn/everscale-overview/ecosystem","content":"","keywords":""},{"title":"Wallets​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#wallets","content":"Go to the Wallets section to get acquainted with the Everscale network's wallets. "},{"title":"Exchanges​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#exchanges","content":""},{"title":"Gate.io (EVER/USDT)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#gateio-everusdt","content":""},{"title":"MEXC (EVER/USDT)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#mexc-everusdt","content":""},{"title":"Bitrue (EVER/USDT)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#bitrue-everusdt","content":""},{"title":"Digifinex (EVER/USDT)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#digifinex-everusdt","content":""},{"title":"HitBTC (EVER/USDT, EVER/BTC)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#hitbtc-everusdt-everbtc","content":""},{"title":"KUNA (EVER/USDT)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#kuna-everusdt","content":""},{"title":"Changelly PRO (EVER/BTC)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#changelly-pro-everbtc","content":""},{"title":"CEX.io (EVER/USDT, EVER/USD)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#cexio-everusdt-everusd","content":""},{"title":"FMFW.io (EVER/BTC)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#fmfwio-everbtc","content":""},{"title":"GameFi​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#gamefi","content":""},{"title":"Pokerton​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#pokerton","content":"Telegram Poker – Win EVER by participating in free daily tournaments. "},{"title":"EverBall.io​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#everballio","content":"The world's first game where you mine EVER by absorbing opponents. "},{"title":"Everscale Gaming​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#everscale-gaming","content":"Esports tournaments with prize pools in EVER. "},{"title":"EverCraft​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#evercraft","content":"A plugin to connect Everscale with Minecraft. "},{"title":"Galaxy Online​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#galaxy-online","content":"A great MMO with playable blockchain-based races. "},{"title":"Bridges​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#bridges","content":"Go to the Bridges to get acquainted with the Everscale network's bridges. "},{"title":"NFT​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#nft","content":""},{"title":"GrandBaraz​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#grandbaraz","content":"Everscale's first NFT marketplace. Buy, sell, and craft rare digital items. "},{"title":"ChessNFT​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#chessnft","content":"An NFT platform from the FIDE Chess Federation. "},{"title":"Third Place NFT​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#third-place-nft","content":"An NFT platform from the St. Petersburg creative space Third Place. "},{"title":"Most Expensive​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#most-expensive","content":"Real expensive NFT items! "},{"title":"ScalePunks.com​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#scalepunkscom","content":"A collection of 10,000 unique punks. "},{"title":"DeFi​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#defi","content":""},{"title":"FlatQube​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#flatqube","content":"DEX solution. Easy and fast exchange of tokens and participation in liquidity pools for farming income. "},{"title":"Surf Staking​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#surf-staking","content":"A staking service from the popular Ever Surf. "},{"title":"Surf Depooler​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#surf-depooler","content":"Top depooler rating, performance analysis and depooler selection for more income. "},{"title":"Surf Payments​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#surf-payments","content":"Payments framework built on low-fees Everscale blockchain. "},{"title":"EVER DAO​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#ever-dao","content":"Everscale decentralized project management platform. "},{"title":"EverStart​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#everstart","content":"DAO-controlled multi-chain launchpad to connect with curated projects "},{"title":"EverLand​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#everland","content":"A P2P secured lending platform with interest on funds. "},{"title":"EverKit Coin​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#everkit-coin","content":"Everscale Coin Information (EVER): stats, wallets, and resources to buy: Exchanges, DEX, and P2P. "},{"title":"KWPC​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#kwpc","content":"The Killer Whale Pod Cast is a launch pad for young blockchain projects developed on the Everscale network. "},{"title":"EVER Pools​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#ever-pools","content":"Depool analysis by Broxus – the developer of FlatQube and Octus Bridge. "},{"title":"Ever Live​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#ever-live","content":"Everscale Blockchain Explorer by EverX. "},{"title":"EVER Scan​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#ever-scan","content":"Everscale Blockchain Explorer by Broxus. "},{"title":"Wrapped EVER​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#wrapped-ever","content":"WEVER is Wrapped EVER. Similar to Wrapped Ether but for Everscale. "},{"title":"Wallets/Exchanges","type":0,"sectionRef":"#","url":"learn/everscale-overview/exchangewallets","content":"","keywords":""},{"title":"Non-custodial wallets​","type":1,"pageTitle":"Wallets/Exchanges","url":"learn/everscale-overview/exchangewallets#non-custodial-wallets","content":"Non-custodial - the user has full control over the keys and their funds. If the private key and the password to recover it are lost, the funds will be irretrievably lost. EVER Wallet (IOS, Android, Web) Ever Surf (IOS, Android, Windows, Linux, MacOS) Everspace (IOS, Android, Telegram) ScaleWallet (Web) Lumi (Android, Web) "},{"title":"Custodial wallets​","type":1,"pageTitle":"Wallets/Exchanges","url":"learn/everscale-overview/exchangewallets#custodial-wallets","content":"Custodial wallets are similar to bank instruments. The user does not have full control over their funds because an operator (custodian) has access to the private key. Pros: having lost passwords or keys, the user has the opportunity to gain access to the funds again. Combot (Web, Telegram) Koshelek (Android, IOS) Crypterium (IOS, Android) FreeWallet (IOS, Android, Web) Kilox (IOS, Android) "},{"title":"Exchange Wallets​","type":1,"pageTitle":"Wallets/Exchanges","url":"learn/everscale-overview/exchangewallets#exchange-wallets","content":"Crypterium (IOS, Android) Koshelek (Android, IOS) "},{"title":"Governance","type":0,"sectionRef":"#","url":"learn/governance","content":"Governance","keywords":""},{"title":"FAQ","type":0,"sectionRef":"#","url":"learn/faq","content":"","keywords":""},{"title":"What is Everscale?​","type":1,"pageTitle":"FAQ","url":"learn/faq#what-is-everscale","content":"Everscale is a peer-to-peer multi-blockchain system. Is a new and unique blockchain design that proposes a scalable decentralized world computer, paired with a distributed operating system — Ever OS. "},{"title":"Why Everscale?​","type":1,"pageTitle":"FAQ","url":"learn/faq#why-everscale","content":"It is important to understand that Everscale, unlike many other new networks, does not aim to create a second Ethereum. Even at the design stage, Everscale took into account the errors and shortcomings of the Ethereum architecture, thanks to which Everscale is now a truly unique blockchain. Consider its main advantages: Record speed, reliability, and thoughtful architecture.Smart contracts can perform operations on different nodes, which allows the blockchain to scale (sharding) and increases the speed of smart contract execution to an absolute record.Everscale is an asynchronous blockchain that is flexible in software development and rich in languages. You can write smart contracts in C ++, Solidity, Rust, and other high-level programming languages for your projects. Everscale has already implemented wallets, bridges, decentralized bots and exchanges, NFTs. It is also a promising and decentralized ecosystem, each participant of which can offer the community an idea for development, competition, or partnership. "},{"title":"Everscale blockchain explorer​","type":1,"pageTitle":"FAQ","url":"learn/faq#everscale-blockchain-explorer","content":"Blockchain explorer is a tool that allows you to track and view blocks, messages, transactions and other information contained in network. Currently available blockchain explorers for use: Evescan.io by BroxusEver.live by EverX "},{"title":"How does Everscale works?​","type":1,"pageTitle":"FAQ","url":"learn/faq#how-does-everscale-works","content":"To understand the basic principles and mechanisms of Everscale, we recommend that you familiarize yourself with the following sections of the documentation: Architecture section ( Blockchain basics, fee calculation, security, account, messages, EVER OS, etc.) Decentralization sectionSmart Contracts section ( Overview, FAQ, DeBots, Examples, etc.) Standards section "},{"title":"What is EVER?​","type":1,"pageTitle":"FAQ","url":"learn/faq#what-is-ever","content":"EVER - is the native coin of Everscale blockchain, unique blockchain design that proposes a scalable decentralized world computer, paired with a distributed operating system. EVER is token that captures value of all community sponsored projects, therefore optimized for a value capturing, it also used for network usage fee payments. It has a max supply of ~2 billion EVER coins. "},{"title":"Wrapped EVER​","type":1,"pageTitle":"FAQ","url":"learn/faq#wrapped-ever","content":"EVER is cryptocurrency that run on blockchain, but different blockchains have different functions, features, and protocols. Because of this difference, EVER is not able to interact with other blockchains. While this increases the security of a blockchain-based digital asset, it creates immense difficulties for the development of an interoperable exchange or system of cryptocurrencies where the data of one crypto gets transferred into another crypto. However, for decentralized finance to exist, the exchange of information from one to another cryptocurrency is crucial. This is where Wrapped EVER comes in. In simple words, WEVER represents a cryptocurrency based on a separate blockchain and is worth the same, but can be used on non-native blockchains and later, redeemed for the original cryptocurrency. Putting it in reference, Wrapped EVER (wEVER) is a digital token that has the same value as one EVER but is based on TIP-3 standard, which makes it usable on the Decentralised Finance ecosystem. WEVER also available on ETH and BNB (BSC) networks, which makes it usable on the Decentralized Finance ecosystem. Contracts of EVER (Wrapped EVER): TIP-3: 0:a49cd4e158a9a15555e624759e2e4e766d22600b7800d891e46f9291f044a93dEthereum: 0x29d578CEc46B50Fa5C88a99C6A4B70184C062953BNB Smart Chain: 0x0A7e7D210C45c4abBA183C1D0551B53AD1756ecA "},{"title":"Use-cases​","type":1,"pageTitle":"FAQ","url":"learn/faq#use-cases","content":"Cross-chain transaction fees.  Using the cross-chain bridge Octus Bridge, it is possible to transfer crypto-assets between Everscale, Ethereum, BNB Chain (Binance Smart Chain), Fantom Opera, Polygon, Avalanche, Milkomeda networks and pay commission in EVER. Validating  Validators stakes required to maintain the blockchain. To raise a validator node in the Everscale network, a Validator will need to purchase EVERs to provide a stake, as well as acquire a server that will withstand the projected loads due to block validation. Participation in DAO.  Using EVER DAO, a new decentralized governance mechanism that brings users into the fold on decisions that affect the entire Everscale ecosystem. Any user can stake their wEVER on the platform to submit proposals and vote on proposals submitted by others. Payment for services.  Many apps and bots use EVER, for example, you can pay Combot subscription, play PokerTON, etc. "},{"title":"How can i store and trade EVER?​","type":1,"pageTitle":"FAQ","url":"learn/faq#how-can-i-store-and-trade-ever","content":"For storing your TIP-3 tokens you need to use appropriate wallets - check out the wallets section. To buy EVER you can use exchange wallets, CEX (centralize exchanges) or DEX (decentralize exchanges). "},{"title":"What are the Everscale earning opportunities?​","type":1,"pageTitle":"FAQ","url":"learn/faq#what-are-the-everscale-earning-opportunities","content":""},{"title":"Earning EVERs​","type":1,"pageTitle":"FAQ","url":"learn/faq#earning-evers","content":"Staking​ In Everscale, here is DePool, which is a specialized smart contract that collects stakes from various participants to be pooled together and forwarded as one stake to the Elector on behalf of a validator node. The validator node owner supports the DePool providing a guaranteed minimal stake, and allowing smaller token holders to participate in and benefit from validation. The owner's benefit, in turn, is the increased stake for their node. Stake collection is continuous. Stakes can be made at any time, and will be distributed to whichever round is currently in the pooling stage. Every time an election begins on the blockchain, the accumulated pool is locked and staked in this election, and the pooling stage of the next round begins. Farming​ Yield-farming is an increasingly popular product in many various DeFi protocols, and Everscale is no different in this respect! Similar to staking, farming income is expressed as a percentage per year, and is added to your tokens as long as they are locked into a farming pool. These farming pool consist of LP tokens (Liquidity provider tokens) which are obtained through providing liquidity to the exchange pools in their respective pairs. Depending on which tokens are paired for farming, the amount of income can vary greatly. Generally speaking, pairs with better known coins and stable tokens offer a lower percentage yield than those pairs with less known tokens. The income indicator for the year is APR and is expressed as a percentage. Grants​ Everscale Grants is a new method of funding teams to develop Everscale blockchain that has come to replace contests. Grants aim to help promising IT startups launch and onramp into the Everscale ecosystem. In a word, the program was successful. Take a look for yourself at the results. A total of 17 projects were interviewed as part of the project. Of those 17, 8 of the best and brightest were selected to be part of the project. As of right now, the elite 8 are going through DD procedures and more technical interviews as partnership terms are being negotiated. You’ll be able to read the full details about each participant once all of the procedures have been completed and partnership terms have been agreed upon. While DeFi is our thing, the projects that are involved with the grants program come from all different sectors and stand to add some diversity to the Everscale ecosystem. In the first round, Everscale had projects from GameFi, the NFT space, DeFi, AML and the crypto news sphere apply. Everscale Grants campaign has grand pool of 15 000 000 EVERs. Validation​ "},{"title":"What about validation process?​","type":1,"pageTitle":"FAQ","url":"learn/faq#what-about-validation-process","content":"Everscale validator is a network node (server) that participates in the validation of generated new blocks of the blockchain. These nodes are selected as validators for a certain period (validation cycle), during which they participate in validation together. Validation is the signing of blocks by several nodes in order to reach a consensus (general agreement) on the correctness of the block. The very procedure of reaching consensus is necessary for the network to ensure the reliability of its functioning, that is, resistance to failures of individual nodes or deliberate attacks. In fact, validators provide the basis for the functioning of a decentralized network. For their work, they receive remuneration consisting of a processing fee (1,7 EVER for a new block in the masterchain, 1 EVER for a new block in the shardchain), as well as from the emission of new tokens distributed to validators. In the current network parameters, the emission is fixed at the level of ~0.5% per year. It is distributed each validation cycle to all validators in proportion to their stakes. Check out the Validation section for more information. "},{"title":"What can I do as a developer?​","type":1,"pageTitle":"FAQ","url":"learn/faq#what-can-i-do-as-a-developer","content":"Since Everscale is quite a young network, there are a lot of opportunities for developers here: hachatons and grants, Smart Contracts developing, DAO, etc. Check out the developer section to learn more. "},{"title":"How to contribute to Everscale?​","type":1,"pageTitle":"FAQ","url":"learn/faq#how-to-contribute-to-everscale","content":"Since Everscale was created on the principles of decentralization, the management and development of the network is completely decentralized with the help of a community where each participant can contribute, through DAOs, grants, making improvements to the network documentation, etc. Go to the Contributing section and see the main features of Everscale's self-improvement "},{"title":"How to integrate with Everscale?​","type":1,"pageTitle":"FAQ","url":"learn/faq#how-to-integrate-with-everscale","content":"Everscale is open to everything new, including integrations with other projects, teams and products. You can add EVER to your exchange, integrate your network into Octus Bridge, etc. For a detailed introduction to integration options and their implementation, see the Integration section. "},{"title":"What about Everscale ecosystem?​","type":1,"pageTitle":"FAQ","url":"learn/faq#what-about-everscale-ecosystem","content":"Check out the Ecosystem section. "},{"title":"History","type":0,"sectionRef":"#","url":"learn/history","content":"","keywords":""},{"title":"History behind TON blockchain​","type":1,"pageTitle":"History","url":"learn/history#history-behind-ton-blockchain","content":"The Telegram messenger project was created by brothers Nikolay and Pavel Durov in 2013. Nikolay Durov invented the MTProto encryption scheme, which formed the basis of the project. The main concept of Telegram messenger was privacy and secure communication of users. The messenger existed on Pavel Durov's personal funds until 2017. In 2017, Pavel Durov develops the concept of TON - Telegram Open Network. The Telegram Open Network project is inextricably linked with the Telegram Messenger, with plans to integrate the Gram cryptocurrency [1]. In December 2018 TON virtual machine delivired. In February 2018, Pavel Durov is raising $850 million in investments in the first round of ICO for the development of blockchain platform TON (price of the Gram token was $0.38). The ICO notification is officially registered by the US Securities and Exchange Commission (SEC). From the business plan of Pavel Durov, it follows that Telegram as a messenger is the first phase of a more global project, and was created mainly to form a huge customer base. As TON develops, the messenger itself will become just one of its applications, so in 2021 it is planned to rebrand Telegram Open Network into The Open Network, and the Telegram brand will remain with the messenger. The real goal of the project is the Telegram Open Network platform, which offers Gram cryptocurrency with fast transaction speeds, as well as various services from Proxy for bypassing censorship to bots and file storage that can be paid for with Gram cryptocurrency. In the second round of ICO, an additional $850 million are raised(price of the Gram is up to $1.33)[2]. At the same time, Pavel Durov rejected about half of the applications for investment until the third round of placement - investors wanted to invest more than $3.7 billion in the project. Pavel Durov's refusal to receive new investments is justified by the fact that his plan to raise money exceeded his expectations many times. The cost of establishing the Telegram Open Network is estimated at $400 million. At the same time, the total amount of raised investments amounted to $1.7 billion for both rounds. The whole amount was received from private investors who got Gram tokens in return for their investments. The list of investors includes quite famous personalities: Roman Arkadievich Abramovich (entrepreneur, included in the list of Forbes, invested $10 million through the fund Norma Investments Limited), David Mikhailovich Yakobashvili (founder of the company Wimm-Bill-Dann, invested $10 million), Sergey Alexandrovich Solonin (founder of the platform Qiwi, invested $ 17 million), Mikhail Safarbekovich Gutseriev (main shareholder of the group Safmar, the owner of the company M.Video and Eldorado, invested $15 million through Larnabel Ventures) [3]. TON blockchain platform was launched in autumn 2018. The developers then said that the network is 70% ready and most of the components have already been finalized. The launch of testnet should have taken place in January 2019, however, was postponed. Ferbuary 2019: TON Labs launches the first EVER blockchain with proof of authority (PoA). July 2019: TON Labs Launch of the alpha version of TON OS. On September 6, 2019, TON test portal for developers with official project specifications was opened - https://test.ton.org/, and on https://test.ton.org/testnet/ TON network explorer was available, displaying the first hundreds of working nodes of the network. The New York Times, commenting on these events, noted that the project produces test tokens ahead of schedule, which should satisfy investors. Observers, referring to experts in crypto, also note that Durov's strategy to keep the development of TON in relative secrecy has given rise to some skepticism in the cryptographic society about the competing Libra cryptocurrency project from Facebook, but in the end, it turned out to be correct, because Facebook, after making the development of Libra transparent, immediately incurred the anger of regulators. At the same time, crypto experts such as David Gerard note that despite the TON team's efforts to meet the KYC-AML principles, the project's central risk is similar to Libra - government regulators may be afraid of losing control of the financial system [4]. TON OS startup edition goes public. In October 2019, the U.S. Securities and Exchange Commission (SEC) demanded a ban on the issuance of Gram. The SEC, in its report, recognized Gram as security (not a commodity or utility token) and the Gram issue itself violated securities laws. On November 2019 TON Labs launches its own TON testnet. On January 7 and 8, 2020, the SEC interrogated Pavel Durov about TON ICO. The interrogation took place in Dubai, UAE. The American regulator was trying to find out why Durov launched the ICO, how much money he spent on Telegram and TON, and why Gram token is not a security. Durov replied that the money was needed to buy equipment and maintain the blockchain platform, and Gram was a utility token, not a security. On March 25, Telegram challenged the U.S. court ban on transferring Gram tokens to investors. The court of the Southern District of New York State in a preliminary decision agreed with the SEC's opinion that the project's cryptocurrency is a security. The U.S. authorities claim that investors purchased coins to sell on the secondary market to earn money. On May 12, 2020, Pavel Durov announced in his Telegram channel that he has closed the TON blockchain project. According to Pavel Durov, Telegram's participation in TON development is over. He urged users not to trust money or data to projects that use the name of the messenger or platform. No one from the company team participates in any of these projects, Durov said. He added that networks that use TON's developments may appear, but Telegram has nothing to do with them and is unlikely to ever support them. TON Labs participates in the community launch of the Free TON blockchain as the core developer On Thursday, May 7th, the Free TON Community (consisting of developers and potential TON users) launched the Free TON blockchain platform. Instead of Gram participants will get tokens called TON Crystal. To become a community member you need to sign Free TON Declaration of Decentralization. On August 2021 Everscale achieves world record high throughput. In 8 November, 2021, Free TON has announced an ecosystem rebrand to Everscale. The new brand identity comes as the network prepares to migrate from C++ to Rust programming language implementation, enabling unmatched scalability and throughput capable of bringing the world on-chain. December 2021: Free TON rebrands to Everscale Source: Everscale Wiki "},{"title":"Support","type":0,"sectionRef":"#","url":"learn/support","content":"Support","keywords":""},{"title":"Terminology","type":0,"sectionRef":"#","url":"learn/terminology","content":"Terminology","keywords":""},{"title":"Developers","type":0,"sectionRef":"#","url":"learn/tutorial/developers","content":"Developers","keywords":""},{"title":"Contributors","type":0,"sectionRef":"#","url":"learn/tutorial/contributors","content":"Contributors","keywords":""},{"title":"Multisig","type":0,"sectionRef":"#","url":"learn/tutorial/institutionals/multisig","content":"","keywords":""},{"title":"What is multisignature wallet?​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#what-is-multisignature-wallet","content":"As a simple analogy, we can imagine a secure deposit box that has two locks and two keys. One key is held by Alice and the other one is held by Bob. The only way they can open the box is by providing their both keys at the same time, so one cannot open the box without the consent of the other. Basically speaking, the funds stored on a multi-signature address can only be accessed by using 2 or more signatures. Therefore, the use of a multisig wallet enables users to create an additional layer of security to their funds. "},{"title":"Use cases for a multisignature wallet​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#use-cases-for-a-multisignature-wallet","content":""},{"title":"Increasing security​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#increasing-security","content":"By using a multisig wallet, users are able to prevent the problems caused by the loss or theft of a private key. So even if one of the keys is compromised, the funds are still safe. Imagine that Alice creates a 2-of-3 multisig address and then stores each private key into a different place or device (e.g. mobile phone, laptop, and tablet). Even if her mobile device is stolen, the thief won’t be able to access her funds using only 1 of the 3 keys. Similarly, phishing attacks and malware infections are less likely to succeed because the hacker would most likely have access to a single device and key. Malicious attacks aside, if Alice loses one of her private keys, she can still access her funds using the other 2 keys. "},{"title":"Two-factor authentication​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#two-factor-authentication","content":"By creating a multisig wallet that requires two keys, Alice is able to create a two-factor authentication mechanism to access her funds. For instance, she could have one private key stored in her laptop and the other one in her mobile device (or even on a piece of paper). This would ensure that only someone who has access to both keys is able to make a transaction. Keep in mind, however, that using multisig technology as two-factor authentication can be dangerous – especially if it is set as a 2-of-2 multisig address. If one of the keys are lost, you won’t be able to access your funds. "},{"title":"Escrow transactions​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#escrow-transactions","content":"Creating a 2-of-3 multisig wallet can allow for an escrow transaction between two parties (Alice and Bob) that includes a third party (Charlie) as a mutually trusted arbiter in case anything goes wrong. Charlie, the arbiter, would only need to step in if there was a dispute, at which point he could use his key to create a signature that would be provided to either Alice or Bob, according to Charlie’s judgment. "},{"title":"Decision making​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#decision-making","content":"A board of directors might use a multisig wallet to control access to a company’s funds. For example, by setting up a 4-of-6 wallet where each board member holds one key, no individual board member is able to misuse the funds. Therefore, only decisions that are agreed upon by the majority can be executed. "},{"title":"Everscale multisignature wallets​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#everscale-multisignature-wallets","content":"Let's move on to choosing a multi-signature wallet. "},{"title":"EVER Wallet​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#ever-wallet","content":"Everscale native wallet created by the Broxus team. Access on IOS, Android and as a Google Chrome browser extension. It has several types of multisignature wallets, including those with the ability to add new custodians. A distinctive feature of the wallet is the ability to connect it with Everscale's most popular DeFi products: FlatQube (DEX), Octus Bridge, Everstart (launchpad), etc. Download link "},{"title":"Ever Sufr​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#ever-sufr","content":"One of the most popular Everscale wallets. Available on IOS, Android, Windows and MacOS. Provides the ability to create a multisig wallet and add up to 32 custodians. Download link "},{"title":"Users","type":0,"sectionRef":"#","url":"learn/tutorial/users","content":"","keywords":""},{"title":"Buy and store tokens​","type":1,"pageTitle":"Users","url":"learn/tutorial/users#buy-and-store-tokens","content":"Everscale has several types of tokens, the most popular of which is the TIP-3 token format. The main network token is EVER. It is used to pay fees to validators, reward stakeholders and participants in contests run by the DAO management team, and performs a number of other important functions within the network. In order to store and manage tokens on the Everscale network, you will need a wallet that supports the TIP-3 token format. There are many different ways to buy EVER: Exchange walletsExchangesDEXS Check out the Wallets section for the most popular token storage solutions. "},{"title":"Popular cases of interaction with Everscale​","type":1,"pageTitle":"Users","url":"learn/tutorial/users#popular-cases-of-interaction-with-everscale","content":"Once you have an Everscale network wallet, you can start interacting with various products (Dapps) of the network. Everscale provides many earning opportunities for regular users. You can earn on farming, NFT, staking or trading on exchanges and DEX. In the Ecosystem section, you can get acquainted with the most popular representatives of Everscale dapps in various industries: DeFi, NFT, GameFi, etc. "},{"title":"Community​","type":1,"pageTitle":"Users","url":"learn/tutorial/users#community","content":"Everscale can be proud of its community - a community of friendly newbies and experienced users: network members help each other and discuss various aspects of the network in chats and on the Everscale forum. Go to the main Everscale chats and groups to see the strength of our unity: Everscale Community Everscale News EverKit Everscale DeFi Everscale Dev "},{"title":"Validators","type":0,"sectionRef":"#","url":"learn/tutorial/validators","content":"Validators","keywords":""},{"title":"TVM","type":0,"sectionRef":"#","url":"learn/tvm","content":"","keywords":""},{"title":"About TVM​","type":1,"pageTitle":"TVM","url":"learn/tvm#about-tvm","content":"The TVM , is the virtual machine used to execute smart-contract code in the masterchain and in the basic workchain. Other workchains may use other virtual machines alongside or instead of the TVM. Here we list some of its features. TVM represents all data as a collection of (TVM) cells. Each cell contains up to 128 data bytes and up to 4 references to other cells. As a consequence of the “everything is a bag of cells” philosophy, this enables TVM to work with all data related to the Everscale Blockchain, including blocks and blockchain global state if necessary. TVM can work with values of arbitrary algebraic data types, represented as trees or directed acyclic graphs of TVM cells. However, it is agnostic towards the existence of algebraic data types; it just works with cells. TVM has built-in support for hashmaps.TVM is a stack machine. Its stack keeps either 64-bit integers or cell references. 64-bit, 128-bit and 256-bit arithmetic is supported. All n-bit arithmetic operations come in three flavors: for unsigned integers, for signed integers and for integers modulo 2^n (no automatic overflow checks in the latter case). TVM has unsigned and signed integer conversion from n-bit to m-bit, for all 0 ≤ m, n ≤ 256, with overflow checks. All arithmetic operations perform overflow checks by default, greatly simplifying the development of smart contracts. TVM has “multiply-then-shift” and “shift-then-divide” arithmetic operations with intermediate values computed in a larger integer type; this simplifies implementing fixed-point arithmetic. TVM offers support for bit strings and byte strings. Support for 256-bit Elliptic Curve Cryptography (ECC) for some predefined curves, including Curve25519, is present. Support for Weil pairings on some elliptic curves, useful for fast implementation of zk-SNARKs, is also present. Support for popular hash functions, including sha256, is present. TVM can work with Merkle proofs.TVM offers support for “large” or “global” smart contracts. Such smart contracts must be aware of sharding. Usual (local) smart contracts can be sharding-agnostic. TVM supports closures. A “spineless tagless G-machine” can be easily implemented inside TVM.  Several high-level languages can be designed for TVM, in addition to the “TVM assembly”. All these languages will have static types and will support algebraic data types. We envision the following possibilities: A Java-like imperative language, with each smart contract resembling a separate class. A lazy functional language (think of Haskell). An eager functional language (think of ML).  "},{"title":"Peculiarities of TVM.​","type":1,"pageTitle":"TVM","url":"learn/tvm#peculiarities-of-tvm","content":"The TVM, used to run smart contracts in the masterchain and Workchain Zero, is considerably different from customary designs inspired by the EVM (Ethereum Virtual Machine): it works not just with 256-bit integers, but actually with (almost) arbitrary “records”, “structures”, or “sum-product types”, making it more suitable to execute code written in high-level (especially functional) languages. Essentially, TVM uses tagged data types, not unlike those used in implementations of Prolog or Erlang. \\ One might imagine first that the state of a TVM smart contract is not just a hashmap 2^256 → 2^256, or Hashmap(256, 2^256), but (as a first step) Hashmap(256, X), where X is a type with several constructors, enabling it to store, apart from 256-bit integers, other data structures, including other hashmaps Hashmap(256, X) in particular. This would mean that a cell of TVM (persistent or temporary) storage—or a variable or an element of an array in a TVM smart-contract code—may contain not only an integer, but a whole new hashmap. Of course, this would mean that a cell contains not just 256 bits, but also, say, an 8-bit tag, describing how these 256 bits should be interpreted. In fact, values do not need to be precisely 256-bit. The value format used by TVM consists of a sequence of raw bytes and references to other structures, mixed in arbitrary order, with some descriptor bytes inserted in suitable locations to be able to distinguish pointers from raw data (e.g., strings or integers); This raw value format may be used to implement arbitrary sum-product algebraic types. In this case, the value would contain a raw byte first, describing the “constructor” being used (from the perspective of a high-level language), and then other “fields” or “constructor arguments”, consisting of raw bytes and references to other structures depending on the constructor chosen. However, TVM does not know anything about the correspondence between constructors and their arguments; the mixture of bytes and references is explicitly described by certain descriptor bytes.* The Merkle tree hashing is extended to arbitrary such structures: to compute the hash of such a structure, all references are recursively replaced by hashes of objects referred to, and then the hash of the resulting byte string (descriptor bytes included) is computed. In this way, the Merkle tree hashing for hashmaps, described in 2.3.8, is just a special case of hashing for arbitrary (dependent) algebraic data types, applied to type Hashmap(n, X) with two constructors.** *These two descriptor bytes, present in any TVM cell, describe only the total number of references and the total number of raw bytes; references are kept together either before or after all raw bytes. **Actually, Leaf and Node are constructors of an auxiliary type, HashmapAux(n, X). Type Hashmap(n, X) has constructors Root and EmptyRoot, with Root containing a value of type HashmapAux(n, X). "},{"title":"TVM Cells​","type":1,"pageTitle":"TVM","url":"learn/tvm#tvm-cells","content":"Ultimately, the TVM keeps all data in a collection of (TVM) cells. Each cell contains two descriptor bytes first, indicating how many bytes of raw data are present in this cell (up to 128) and how many references to other cells are present (up to four). Then these raw data bytes and references follow. Each cell is referenced exactly once, so we might have included in each cell a reference to its “parent” (the only cell referencing this one). However, this reference need not be explicit. In this way, the persistent data storage cells of a Everscale smart contract are organized into a tree,* with a reference to the root of this tree kept in the smart-contract description. If necessary, a Merkle tree hash of this entire persistent storage is recursively computed, starting from the leaves and then simply replacing all references in a cell with the recursively computed hashes of the referenced cells, and subsequently computing the hash of the byte string thus obtained. *Logically; the “bag of cells” representation described in 2.5.5 identifies all duplicate cells, transforming this tree into a directed acyclic graph (dag) when serialized. "},{"title":"Additionally​","type":1,"pageTitle":"TVM","url":"learn/tvm#additionally","content":"You can learn more about TVM and how it works from several sources: Legacy TON WhitepaperTVM WhitepaperTVM Extended Instructions "},{"title":"Welcome","type":0,"sectionRef":"#","url":"learn/welcome","content":"","keywords":""},{"title":"About Everscale​","type":1,"pageTitle":"Welcome","url":"learn/welcome#about-everscale","content":"Everscale is a unique blockchain design that proposes a scalable decentralized world computer, paired with a distributed operating system — Ever OS. Ever OS is capable of processing millions of transactions per second, with Turing-complete smart contracts and decentralized user interfaces. Everscale presents some new and unique properties, such as dynamic multithreading, soft majority consensus and distributed programming, which enable it to be scalable, fast and secure at the same time. It is governed by a decentralized community founded upon meritocratic principles via Soft Majority Voting protocol. Everscale has powerful developer tools, such as compilers for Solidity and C++, API, SDK that includes client libraries for 13 programming languages and all popular platforms, local node for DApp testing, CLI tools and a range of decentralized browsers and wallets empowering many applications in DeFi, NFT, tokenization and governance domains. If you would like to learn more about Everscale, please visit the Everscale Overview page. Comparison with other networks "},{"title":"Everscale for you​","type":1,"pageTitle":"Welcome","url":"learn/welcome#everscale-for-you","content":"Everscale is able to interest several types of users with their own interests by providing them with different features. In this documentation we have created sections and tutorials for each type of user, so you can find key information for getting to know and immerse yourself in any part of Everscale: Users (Tutorial) - Everscale as an opportunity for storage and earnings (DeFi, NFT, etc.). Developers (Tutorial, Section) - Development on Everscale and technical details. Validators (Tutorial, Section) - Validating and staking. Contributors (Tutorial, Section) - Earning on partnership and benefiting the network. Intergators (Tutorial, Section) - Integration of Everscale technologies, listing of tokens, etc. "},{"title":"Key organizations​","type":1,"pageTitle":"Welcome","url":"learn/welcome#key-organizations","content":"Many organizations have formed around Everscale to grow the network: recruiting new teams, DAOs, grants, etc. Let's take a look at some of them: Everscale DeFi Alliance - Everscale DeFi Alliance creates the necessary infrastructure to attract and maintain strong teams and projects, attract liquidity from another projects to Everscale and establish a partnerships with major companies with large amounts of liquidity and/or a large number of transactions. Everscale Grants - Everscale Grants is a campaign that aims to attract promising IT projects that can contribute to the Everscale ecosystem's growth. EVER DAO - EVER DAO is a platform where EVER token holders can make on-chain governance decisions for the whole Everscale Network. Ever Foundation (the website is under construction) - The Ever Foundation shall become the primary entry point for all kinds of projects that want to develop and create their products and businesses on top of the Everscale. The Foundation provides grant support to projects that bring the greatest benefit to the network, and is also actively promoting them. "},{"title":"Free Software License (TIP-1.1)","type":0,"sectionRef":"#","url":"standard/TIP-1.1","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Free Software License (TIP-1.1)","url":"standard/TIP-1.1#introduction","content":"Many members of our community have asked questions about Free TON code philosophy. Why we call it Free Software? What is a relationship between Free TON and Free Software? What is the difference between Free Software and Open Source? I have decided to combine this with an idea I have regarding gas payment redistribution in TON. You will see below why it is related. The concept of Free Software predates open source. Richard Stallman has started the free-software movement in 1983 with a launch of GNU Project while open-source movement has been derived from Free Software only in 1998. To clarify, the Free Software is not in conflict with Open Source. As explained below it follows all the same principles and the differences seems more ideological. Yet TON project did not have any problem with open-source nature of it software. It is all open sourced. The problem was exactly about the Freedom of people to use it. That is why Free TON is heavily influenced by Free Software movement. Declaration of Decentralisation is, in many ways, inspired by Stallman’s «The GNU Manifesto»1. In «Why Open Source misses the point of Free Software» Stallman writes among other things: «The terms «free software» and «open source» stand for almost the same range of programs. However, they say different things about those programs, based on different values. The free software movement campaigns for freedom for the users of computing; it is a movement for freedom and justice. By contrast, the open source idea values mainly practical advantage and does not campaign for principles. This is why we do not agree with open source, and do not use that term»2. It seems Free TON is in agreement with this line of thought. While all our software is open source it is the Freedom to run the software what has launched this network. Now let’s talk about Copyright and Licensing as they relate to the Free Software in general and Blockchain in particular. Before we start I need to say that blockchain may potentially provide a solution to some of the free software inherited business model problems. We all remember that free in the free software stands for freedom and not for zero price. The ability to get paid for a software should not be based on restrictions imposed by its license. But what it should be based upon then? There are several business models for free software non of which really works. What works is a business model that is not exactly related to the software itself and therefore can not be attributed to it. Such as charging for support or for portions of the software which are closed source. It all seems quite unnatural. It also prevents one of the major points of free software — an open collaboration of the community around software projects. Donald Fischer article title «Open source creators: Red Hat got $34 billion and you got $0. Here’s why»3 is self explanatory. IBM has bought a commercial company that was built on top of many developers’ contribution to its code. Those developers never got any part out of the value they have created. "},{"title":"Aligning the incentives​","type":1,"pageTitle":"Free Software License (TIP-1.1)","url":"standard/TIP-1.1#aligning-the-incentives","content":"Many free and open source software projects struggle to introduce a sustainable business model. This is one of the reasons why most of the open source software contributors work for large corporations. When a venture capital provides funding to a software project it expects multiple return on its capital. With commercial software it is quite straight forward — a company is charging money for its software use and if successful passes profits to its stakeholders. With free software its quite difficult. That is why there are very few (or should we say: not enough) commercially successful open source software companies. Blockchain introduces a unique opportunity for Free Software developers to align their commercial interests with those of users for the benefit of the whole ecosystem. As an Internet of Value protocol, Blockchain has built-in network incentive mechanism — network fees (or gas). To remind: Miners in Proof-Of-Work collect miner rewards and network fees to compensate them for resources spent to secure the network and process transactions. Both security computations and transaction processing are separate resources, thus requiring separate fees. In Proof-Of-Stake Validators commit funds and processing power to secure the network and process transactions (in a form of smart contract execution in TON). For this they also get separate rewards: block rewards in a form of token emission and transaction reward in a form of a fee. Please note, rewards are separated in both cases. We propose to extend the reward model to transaction facilitators. It would be logical to pay part of the fees to the smart contract developer who is initiating the transaction which pays the fee. This will attract both Developers and Users which will increase network usage and total transaction fees for all network participants. "},{"title":"On-chain licensing fees​","type":1,"pageTitle":"Free Software License (TIP-1.1)","url":"standard/TIP-1.1#on-chain-licensing-fees","content":"Somewhat naive mechanism but with the same underlying idea is proposed by Near blockchain. «The developerReward are allocated by per block per account, as they can be efficiently done every time the transaction or receipts is being processed by the contract»4. The problem with this approach lays in the fact that network fees not only pays for resources but also provide an important anti spam mechanism. One can use the developer kick-back to simply lower an attack costs. To mitigate that risk we propose a use of a special Payout Contract. This contract is going to pay the collected Copyleft fees to developers only after certain threshold in both amount of fees and time frame are surpassed. In this respect the Developer motivation is again aligned with the Network security model — it is not practical to break the network where one receives a long term rent. "},{"title":"Some technical details​","type":1,"pageTitle":"Free Software License (TIP-1.1)","url":"standard/TIP-1.1#some-technical-details","content":"Technically we introduce a TVM Opcode FB0A. Contract may include that code together with a License information and address of its developer. Collator will include a reward related to gas fees from these transactions into the block for the address indicated in the TVM instruction in the amount corresponding to the indicated License. The percentage of gas fees depends on the license type such as that the most free software compatible license provides more gas. FB0A - COPYLEFT (n x y - ), looks up for the license rule for ‘n’ in ConfigParam (for example 42) and creates output action to send part of the tokens it collected from gas fees to Payout contract indicated in ConfigParam for address x:y, where x - is 32 bit signed integer for workchain and y is 256 bit unsigned integer for contract address in this workchain. It will not throw any exceptions if n or the address are incorrect. Generally allowed licenses are those supported by Free Software Foundation as described here: https://www.gnu.org/licenses/license-list.html#SoftwareLicenses 2 License types payout GPL-Compatible Free Software Licenses 2 → 30% fees GPL-Incompatible Free Software Licenses → 20% fees To implement we add network config parameter: license fees threshold value Collator check threshold each time the instruction is executed. After threshold is reached collator sends value to Developer Account defined in contract instruction FB0A TVM creates special out action with Developer Account (last call of FB0A matters) If account is been deleted, the executor sends value to Developer Account or to ValueFlow if it is not enough (this case must be checked in Validator) Executor analyzes special out action and counts value then sends message to developer account (payment for transaction gets from value) We add fields to json objects and QServer for SDK Collator and Validator must check fees from ValueFlow with Developer correction "},{"title":"Copyright discussion​","type":1,"pageTitle":"Free Software License (TIP-1.1)","url":"standard/TIP-1.1#copyright-discussion","content":"«What is the proper way to decide copyright policy? If copyright is a bargain made on behalf of the public, it should serve the public interest above all. The government’s duty when selling the public’s freedom is to sell only what it must, and sell it as dearly as possible. At the very least, we should pare back the extent of copyright as much as possible while maintaining a comparable level of publication»5. One important dimension of copyright is its durationAnother dimension of copyright policy is the extent of fair use: some ways of reproducing all or part of a published work that are legally permitted even though it is copyrighted. (c) Richard Stallman Both duration and fair use of copyright is balanced in this proposal by virtue of compensating copyright holder by Payout Contract creating an ongoing reward from the network while at the same time not preventing a forking possibility by other developers who then need to improve the software in a way that will bring new users and create new intensive for the new contributor. So both improvements as well as long term rent (subscription) is provided for developers. The Copyleft spirit is fully supported here as the Fee is collected for developers who facilitates the fees creation in the first place. The freedom to fork is fully executed as well as anyone can fork the code of a smart contract. In the end it is the community of users who chooses which contract to use and the decision is usually based upon the reputation of the code represented by the hash of the code where is no single byte has been changed. Therefore the system is merit-based. Both long term developer’s incentives for original developers and forking is provided. To recap the proposed system is compatible with all four essential freedoms: The freedom to run the program as you wish, for any purpose (freedom 0).The freedom to study how the program works, and change it so it does your computing as you wish (freedom 1). Access to the source code is a precondition for this.The freedom to redistribute copies so you can help others (freedom 2).The freedom to distribute copies of your modified versions to others (freedom 3). By doing this you can give the whole community a chance to benefit from your changes. Access to the source code is a precondition for this. "},{"title":"References​","type":1,"pageTitle":"Free Software License (TIP-1.1)","url":"standard/TIP-1.1#references","content":"The GNU Manifesto↩Why Open Source Misses the Point of Free Software↩Open source creators: Red Hat got $34 billion and you got $0. Here's why↩Economics in a Sharded Blockchain — Section 06 — Developer Business Models↩Misinterpreting Copyright — A Series of Errors↩ "},{"title":"DeCert — Decentralized Certificates","type":0,"sectionRef":"#","url":"standard/TIP-2","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#abstract","content":"There is a clear need for unified decentralized and distributed certificate system in Free TON. As described in more details below, such system would be used in providing many services which requires a certified provable key-value store. For example a Decentralized Name Service (DeNS), a Prove of Ownership / Prove of Purchase certificate and many others. Current solutions (for example a TON DNS, proposed here) are either a large smart contracts which maintains a full list of records, or a tree-like solutions which shards the list based on some parameters. Neither of these solutions are satisfactory due to a lack of scalability, high costs of maintenance, long search time, single point of failure and so on. Here I present a completely distributed system, which does not require centralized record, nor a tree of domains or records with almost zero latency. The design relies heavily onе the principles of TIP-3 Token architecture with some notable modifications. "},{"title":"Issuance​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#issuance","content":"Root is a smart contract contains a Code of Certificate smart contract without data. The Root has methods for Certificate Issuance, Certificate Code Retrieval, Root PubKey retrieval and Version history. Each Certificate can become a Root, therefore a Root smart contract and its Certificate smart contract are the same. The Code contains an address of its Root. When a User wishes to register it is calling a Certificate Issuance method in Root, sending a Certificate Data (for example an alphanumeric string of a certificate body). Root is taking its Public Key and a Code of Certificate smart contract, inserts a Certificate Data sent by a User, calculates the address of Certificate and checks if the address already has a Certificate or any other Code deployed by sending a bounced true message calling getData method. If a contract exists it means that a Certificate with the same Certificate Data already exists. The contract then can return a registration information to the Root which will return it to a User. If a contract does not exist the message will bounce to the Root smart contract which will mean the Certificate can be registered. If Certificate does not exist the Root will Issue the Certificate by deploying the Certificate Contract with its Data. On deploy the Certificate will check that it has been deployed from the root address by comparing the address of a Root inside with the deployer address. If there is no match the deploy will fail. Of course additional business logic steps could be included between the last two steps, such as monetization or other mechanics as shown below in one of the examples. "},{"title":"Resolving​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#resolving","content":"To resolve the Name any User can now call Get method Resolve of a Root locally to obtain an Address. Root will use Certificate Code, Root PubKey, insert a name User wishes to resolve into Certificate Code and calculate the address. To resolve a Root smart contract one can take any Certificate Core and resolve for the Root name. A user application can cash the Certificate Code smart contract and Root PubKey once, after which resolving any name is achieved locally with a simple address calculation, with no need for network connection at all. The Certificate itself contains variable types of addresses of a target smart contracts to which the Certificate owner wishes the name to point. A user should choose which type of address they wish to use. "},{"title":"Reverse resolving​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#reverse-resolving","content":"In order to make a reverse resolving a smart contract need to state its certificate address. The user will check if certificate indeed has contract address. "},{"title":"Search​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#search","content":"Of course search is one of the most important features of any name system. Knowing a Certificate Code hash enables to retrieve all smart contracts having the same hash by simply querying the blockchain state. Decoding contract data will produce a full list of names under specific Root. It would be quite easy to produce a table with all the certificate records. "},{"title":"Example: Decentralized Name Service (DeNS)​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#example-decentralized-name-service-dens","content":"Let’s consider a DeNS Root is a smart contract which contains a Code of the Name Identity Certificate (NIC) smart contract. The Root has methods for Identity Registering, NIC Code Retrieval, Root PubKey retrieval, Version history. When a User wishes to register an Identity it is calling a «RegName» method in DeNS Root with the signed message of UTF-8 string (Name) together with a Registration Bid (a hash of a Bid Value in TONs with some salt) with value attached 1 TON. DeNS Root is taking its Public Key and a NIC Code inserts a Name, calculates the NIC address and checks if the address already has a NIC Code deployed by sending a bounced true message calling method «getName». Return to User a Whois Information. If it bounces or a registration period in Whois is less than 28 days DeNS Root will send the name into an Auction Smart Contract together with a Registration Bid Hash and a number of years before expiration. First bidder determines the duration of the auctioned name. Other users will be able to Bid for the same name but only for same duration with their Bids following exactly the same process. Auction duration is minimum 7 days per year of name duration but no more than 28 days. At the end of the Auction all participants will submit to the Auction contract a message signed from the address of the original bid together with their original bid price and salt. The winner of the auction will be determined by the highest bid per day and will pay the second higher price for the Name Certificate. Once DeNS Root knows the Auction result it will wait until registration period ends if the name certificate has existed before or immediately deploy the NIC smart contract into the address calculated as a NIC Contract Code with a Name inserted into initial data and PubKey of the Owner passed in its constructor. To resolve the Name any User can now call Get method «Resolve» of DeNS Root locally to obtain an Address. DeNS Root will use Code of NIC smart contract, a DeNS Root PubKey, insert any name they are wishing to resolve into NIC Code and calculate the address. Since most of the time a user application will just cash the Code of NIC smart contract and DeNS PubKey, resolving any name is achieved locally with a simple address calculation, with no need for network connection at all. "},{"title":"Example of NIC smart contract methods​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#example-of-nic-smart-contract-methods","content":"Whois — sends all certificate data: a name, date of registration, owner PubKey GetWhois is a whois getter GetAddress by Type, for example — ADNL, Wallet, RegName GetResolve ChangeAddress ChangeOwnership "},{"title":"Free TON Name Identity Certificate convention​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#free-ton-name-identity-certificate-convention","content":"Format: any alfa-numeric string except for a dot (.) and slash (/) which are prohibited. Only top level names are provided by DeNS Root, but any NIC smart contract can point into a next level of hierarchy which is divided by / top-name/sub-name/ The dot (.) is specifically prohibited as to not create confusions with a current internet domain system. "},{"title":"Example: Ownership Certificate​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#example-ownership-certificate","content":"The Certificate is issued by Root for ownership of an item. Let’s call it certificate of Ownership or COW for short. COW will include a serial number of an item a User want to prove owning. Since the PubKey of an owner of certificate is presented it is easy to prove an ownership of an Item by finding the certificate with corresponding serial number calculating the address of this certificate with this number, POW Code and Root PubKey without a need to maintain any centralized ledger of said items. The transfer of ownership of an Item is easily supported as well by calling a ChangeOwnership Method in the POW signed by the owner private key. "},{"title":"Reference​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#reference","content":"Contest Proposal: Decentralized Name Service (DeNS)ReDeNS — Reverse DeCert (TIP-2.1) "},{"title":"ReDeNS — Reverse DeCert (TIP-2.1)","type":0,"sectionRef":"#","url":"standard/TIP-2.1","content":"ReDeNS — Reverse DeCert (TIP-2.1) In TIP-2 it is stated that in order to resolve a Certificate Address from the Contract Address, that contract must have its Certificate Address explicitly stated. There is a need sometimes to resolve some certificate address from the address of a contract. Here we present an architecture and implementation of Reverse DeCert and one of its usecases: ReDeNS Reverse Decentralized Names or ReDeNS for short is a certificate that enables reverse resolving of some contracts addresses from another contract. It uses a contract Placeholder for each type of contract functionality that we want to be able to put into external (or satellite) contract of a main contract. ReDeNs enables any client to calculate the address of a satellite contract using a ReDeNs code as a certificate for each type of satellite contract it desires to resolve. In order to resolve a ReDeNS address the user may calculate an address taking a hash of a main contract and a hash of ReDeNS certificate as initial data and an owner address or PubKey in constructor parameters. After the deploy of initial ReDeNS certificate code developer will use SetCode to change the ReDeNS certificate code to desired type of satellite smart contract (with ABI, Getter or DeBot functionality, respectively and so on) For example we have identified 3 types of satellite contracts which will be default ReDeNS Certificates of any main contract in Solidity and C++ Compilers and TON OS SDK: ABI, GETTERS and DEBOT. To protect contracts without ReDeNS certificate deployed from squatters we propose to use header with bitmask: one bit for each type of ReDeNS certificates: abi-DeCert, getters-DeCert, debot-DeCert and so on. So far, we decided to have 16-bit bitmask. 3 of them already occupied. { Abi, getters, debot }. The ReDeNS certificate code is as following: How to create DeBot derived from your smart contract","keywords":""},{"title":"Fungible Token","type":0,"sectionRef":"#","url":"standard/TIP-3","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Fungible Token","url":"standard/TIP-3#abstract","content":"The following standard describes the basic idea about distributed fungible token architecture. "},{"title":"Motivation​","type":1,"pageTitle":"Fungible Token","url":"standard/TIP-3#motivation","content":"The suggested standard differs considerably from Ethereum ERC20 and other smart contract token standards with single registry due to its distributed nature related to Everscale blockchain particularities. Given that Everscale has a storage fee, using an existing ERC20 standard design would cause excessive maintenance costs. Also, ERC20 is somewhat incompatible with the sharding architecture. Therefore, a Distributed Token standard is preferable. The ERC20 sharding implementation (with an idea to simply shard its registry) has drawbacks mainly related to complicated and expansive management. TIP-3 is fully distributed and implies separate storage of each user’s balance. "},{"title":"Architecture​","type":1,"pageTitle":"Fungible Token","url":"standard/TIP-3#architecture","content":"General information about token is stored in the token root contract. Each token holder has its own instance of token wallet contract. Token transfers SHOULD be implemented in P2P fashion, between sender and receiver token wallets. "},{"title":"Token root​","type":1,"pageTitle":"Fungible Token","url":"standard/TIP-3#token-root","content":"Token root contract stores the general information about the token, e.g. name, symbol, decimals, token wallet code and so on. "},{"title":"Token wallet​","type":1,"pageTitle":"Fungible Token","url":"standard/TIP-3#token-wallet","content":"Each token holder has its own instance of token wallet contract. Transfer happens in a decentralized fashion - sender token wallet SHOULD send the specific message to the receiver token wallet. Since token wallets have the same code, it's easy for receiver token wallet to check the correctness of sender token wallet. "},{"title":"References​","type":1,"pageTitle":"Fungible Token","url":"standard/TIP-3#references","content":"EIP-20: Token StandardForum FreeTON - TIP3Reference implementation by Broxus "},{"title":"Non-Fungible Token","type":0,"sectionRef":"#","url":"standard/TIP-4","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Non-Fungible Token","url":"standard/TIP-4#abstract","content":"TDB "},{"title":"Motivation​","type":1,"pageTitle":"Non-Fungible Token","url":"standard/TIP-4#motivation","content":"TDB "},{"title":"Non-Fungible Token (TIP-4.1)","type":0,"sectionRef":"#","url":"standard/TIP-4.1","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#abstract","content":"TDB "},{"title":"Motivation​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#motivation","content":"TDB "},{"title":"Fungible Token Interface (TIP-3.1)","type":0,"sectionRef":"#","url":"standard/TIP-3.1","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Fungible Token Interface (TIP-3.1)","url":"standard/TIP-3.1#abstract","content":"The following standard allows for the implementation of a standard API for tokens within smart contracts. General information about token is stored in the token root contract. Each token holder has its own instance of token wallet contract. Token transfers SHOULD be implemented in P2P fashion, between sender and receiver token wallets. "},{"title":"Motivation​","type":1,"pageTitle":"Fungible Token Interface (TIP-3.1)","url":"standard/TIP-3.1#motivation","content":"A standard interface allows any tokens on Everscale to be re-used by other applications: from wallets to decentralized exchanges. "},{"title":"Specification​","type":1,"pageTitle":"Fungible Token Interface (TIP-3.1)","url":"standard/TIP-3.1#specification","content":"The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. "},{"title":"Notes​","type":1,"pageTitle":"Fungible Token Interface (TIP-3.1)","url":"standard/TIP-3.1#notes","content":"We choose Standard Interface Detection to expose the interfaces that a TIP3 smart contract supports.This standard does not define the external methods to initiate transfer, mint or burn tokens. Though it defines the methods, which MUST be called on a recipient token wallet or token root during these operations.The rules for a token wallet ownership MUST be defined in a child standards.A -1 offset is added to some function IDs derivations, so the preimage of the hash cannot be known, further reducing the chances of a possible collisions. "},{"title":"Token root​","type":1,"pageTitle":"Fungible Token Interface (TIP-3.1)","url":"standard/TIP-3.1#token-root","content":"Name​ Returns the name of the token - e.g. &quot;MyToken&quot;. function name() public view responsible returns (string);  Symbol​ Returns the symbol of the token. E.g. “HIX”. function symbol() public view responsible returns (string);  Decimals​ Returns the number of decimals the token uses - e.g. 8, means to divide the token amount by 100000000 to get its user representation. function decimals() public view responsible returns (uint8);  Total supply​ Returns the total token supply. function totalSupply() public view responsible returns (uint128);  Token wallet code​ Returns the token wallet code. function walletCode() public view responsible returns (TvmCell);  Accept tokens burn​ Does not have a standard signature, but has a standard function ID 0x192B51B1 obtained as tvm.functionId('acceptBurn(uint128)') - 1. The uint128 _value parameter MUST be first. The function name and the rest of the parameters are not fixed by this standard and can be reinvented for each substandard. Decreases token total supply by _value. The contract MUST check that the sender is a correct token wallet. Before sending this message, caller token wallet MUST decrease its own balance by _value. If the mint can't be accepted (e.g. invalid sender), this message MUST be bounced. Any function from the following snippet is a valid example: interface TIP3AcceptBurn { function acceptBurn(uint128 _value) functionID(0x192B51B1) public; function acceptBurn2(uint128 _value, uint256 _publicKey, address _owner) functionID(0x192B51B1) public; function acceptBurn3(uint128 _value, TvmCell _meta) functionID(0x192B51B1) public; }  Standard interface detection​ interface TIP3TokenRoot { function acceptBurn(uint128 _value) functionID(0x192B51B1) public view responsible; function name() public view responsible returns (string); function symbol() public view responsible returns (string); function decimals() public view responsible returns (uint8); function totalSupply() public view responsible returns (uint128); function walletCode() public view responsible returns (TvmCell); }  The token root interface ID is 0x4371D8ED. "},{"title":"Token wallet​","type":1,"pageTitle":"Fungible Token Interface (TIP-3.1)","url":"standard/TIP-3.1#token-wallet","content":"Root​ Returns the token root address. function root() public view responsible returns (address);  Balance​ Returns the token wallet balance. function balance() public view responsible returns (uint128);  Wallet code​ Returns the token wallet code. function walletCode() public view responsible returns (TvmCell);  Accept tokens transfer​ Does not have a standard signature, but has a standard function ID 0x67A0B95F obtained as tvm.functionId('acceptTransfer(uint128)') - 1. The uint128 _value parameter MUST be first. The function name and the rest of the parameters are not fixed by this standard and can be reinvented for each substandard. Increases token wallet balance by _value. The contract MUST check that the sender is a correct token wallet. Before sending this message, caller token wallet MUST decrease its own balance by _value. If the transfer can't be accepted (e.g. invalid sender), this message MUST be bounced. Any function from the following snippet is a valid example: interface TIP3AcceptTransfer { function acceptTransfer(uint128 _value) functionID(0x67A0B95F) external; function acceptTransfer2(uint128 _value, uint256 _publicKey, address _owner) functionID(0x67A0B95F) external; function acceptTransfer3(uint128 _value, TvmCell _meta) functionID(0x67A0B95F) external; }  Accept tokens mint​ Does not have a standard signature, but has a standard function ID 0x4384F298 obtained as tvm.functionId('acceptMint(uint128)') - 1. The uint128 _value parameter MUST be first. The function name and the rest of the parameters are not fixed by this standard and can be reinvented for each substandard. Increases token wallet balance by _value. The contract MUST check that the sender is a correct token root. Before sending this message, token root MUST increase the total supply by _value. If the mint can't be accepted (e.g. invalid sender), this message MUST be bounced. Any function from the following snippet is a valid example: interface TIP3AcceptMint { function acceptMint(uint128 _value) functionID(0x4384F298) external; function acceptMint2(uint128 _value, uint256 _publicKey, address _owner) functionID(0x4384F298) external; function acceptMint3(uint128 _value, TvmCell _meta) functionID(0x4384F298) external; }  On-bounce behaviour​ The acceptTransfer or acceptBurn methods can be bounced, e.g. receiver token wallet has a different code or burning disabled. The token wallet behaviour in these cases should be implemented according to the following rules. Handle acceptTransfer bounce​ Increases token wallet balance according to the value, specified in the bounce body. Handle acceptBurn bounce​ Increases token wallet balance according to the value, specified in the bounce body. Standard interface detection​ interface TIP3TokenWallet { function acceptTransfer(uint128 _value) functionID(0x67A0B95F) external; function acceptMint(uint128 _value) functionID(0x4384F298) external; function root() public view responsible returns (address); function balance() public view responsible returns (uint128); function walletCode() public view responsible returns (TvmCell); }  The token wallet interface ID is 0x4F479FA3. "},{"title":"URI scheme","type":0,"sectionRef":"#","url":"standard/TIP-5","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"URI scheme","url":"standard/TIP-5#abstract","content":"TDB "},{"title":"Motivation​","type":1,"pageTitle":"URI scheme","url":"standard/TIP-5#motivation","content":"TDB "},{"title":"Fungible token payment link (TIP-5.1)","type":0,"sectionRef":"#","url":"standard/TIP-5.1","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Fungible token payment link (TIP-5.1)","url":"standard/TIP-5.1#abstract","content":"TDB "},{"title":"Motivation​","type":1,"pageTitle":"Fungible token payment link (TIP-5.1)","url":"standard/TIP-5.1#motivation","content":"TDB "},{"title":"Non-fungible token payment link (TIP-5.2)","type":0,"sectionRef":"#","url":"standard/TIP-5.2","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Non-fungible token payment link (TIP-5.2)","url":"standard/TIP-5.2#abstract","content":"TDB "},{"title":"Motivation​","type":1,"pageTitle":"Non-fungible token payment link (TIP-5.2)","url":"standard/TIP-5.2#motivation","content":"TDB "},{"title":"Standard Interface Detection","type":0,"sectionRef":"#","url":"standard/TIP-6","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Standard Interface Detection","url":"standard/TIP-6#abstract","content":"Smart contracts in Everscale can implement a wide variety of functionality - wallets, tokens, exchanges and so on. We need a standard way to determine the type of smart contract without relying on knowledge of its internal structure. "},{"title":"Standard Interface Detection Interface (TIP-6.1)","type":0,"sectionRef":"#","url":"standard/TIP-6.1","content":"","keywords":""},{"title":"Simple summary​","type":1,"pageTitle":"Standard Interface Detection Interface (TIP-6.1)","url":"standard/TIP-6.1#simple-summary","content":"Creates a standard method to publish and detect what interfaces a smart contract implements. "},{"title":"Abstract​","type":1,"pageTitle":"Standard Interface Detection Interface (TIP-6.1)","url":"standard/TIP-6.1#abstract","content":"Herein, we standardize the following: How interfaces are identifiedHow a contract will publish the interfaces it implements "},{"title":"Motivation​","type":1,"pageTitle":"Standard Interface Detection Interface (TIP-6.1)","url":"standard/TIP-6.1#motivation","content":"For some “standard interfaces” like the token interface, it is sometimes useful to query whether a contract supports the interface and if yes, which version of the interface, in order to adapt the way in which the contract is to be interacted with. This proposal standardizes the concept of interfaces and standardizes the identification (naming) of interfaces. "},{"title":"Specification​","type":1,"pageTitle":"Standard Interface Detection Interface (TIP-6.1)","url":"standard/TIP-6.1#specification","content":""},{"title":"How interfaces are identified​","type":1,"pageTitle":"Standard Interface Detection Interface (TIP-6.1)","url":"standard/TIP-6.1#how-interfaces-are-identified","content":"For this standard, an interface is a set of function selectors as defined by the Solidity ABI. This a subset of Solidity’s concept of interfaces and the interface keyword definition which also defines return types, mutability and events. We define the interface identifier as the XOR of all function selectors in the interface. This code example shows how to calculate an interface identifier: Solidity​ interface Solidity101 { function hello() external pure; function world(int) external pure; } contract Selector { function calculateSelector() public view returns (bytes4) { Solidity101 i; return bytes4(tvm.functionId(i.hello) ^ tvm.functionId(i.world)); } }  How a Contract will Publish the Interfaces it Implements​ A contract that is compliant with TIP6.1 shall implement the following interface: Solidity​ interface TIP6 { /// @notice Query if a contract implements an interface /// @param interfaceID The interface identifier, as specified in TIP6.1 /// @dev Interface identification is specified in TIP6.1. /// @return `true` if the contract implements `interfaceID` and /// `interfaceID` is not 0xffffffff, `false` otherwise function supportsInterface(bytes4 interfaceID) external view responsible returns (bool); }  The interface identifier for this interface is 0x3204EC29. You can calculate this by running tvm.functionId('supportsInterface(bytes4)'); or using the Selector contract above. Therefore, the implementing contract will have a supportsInterface function that returns: true when interfaceID is 0x3204EC29 (TIP6.1 interface)false when interfaceID is 0xfffffffftrue for any other interfaceID this contract implementsfalse for any other interfaceID "},{"title":"References​","type":1,"pageTitle":"Standard Interface Detection Interface (TIP-6.1)","url":"standard/TIP-6.1#references","content":"EIP-165: Standard Interface Detection "},{"title":"What is TIP? (TIP-0)","type":0,"sectionRef":"#","url":"standard/workflow","content":"What is TIP? (TIP-0) TIP — Trustless Improvement Proposal (TIPs) describe standards for the Everscale blockchain. They may include anything that the community considers in need of improvement or standardization. That can be specifications for core protocol, description of interfaces, smart contract standards and so on. I propose a more relaxed structure more closely resembling Bitcoin BIPs but with quite different proccess (see below). Each TIP should have the following parts (which are heavily copy-pasted from BIP requirements): Preamble — Headers containing metadata about the TIP;Abstract — A short (~200 word) description of the technical issue being addressed;Copyright — The TIP must be explicitly licensed under acceptable copyright terms;Specification — The technical specification should describe the syntax and semantics of any new feature;The specification should be detailed enough to allow competing, interoperable implementations;Motivation — The motivation is critical for TIPs that want to change the Everscale protocol. It should clearly explain why the existing protocol is inadequate to address the problem that the TIP solves;Rationale — The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work. The rationale should provide evidence of consensus within the community and discuss important objections or concerns raised during discussion;Backwards compatibility — All TIPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The TIP must explain how the author proposes to deal with these incompatibilities; Each TIP should pass the following process of acceptance: Proposal → Discussion → Community Voting → Reference Implementations Contest → Final TIP with Reference Implementations Reference implementation — The reference implementation must be completed before any TIP is given status Final, but it need not be completed before the TIP is accepted. It is better to finish the specification and rationale first and reach consensus on it before writing code. The final implementation must include test code and documentation appropriate for the Everscale protocol.","keywords":""},{"title":"Delegate","type":0,"sectionRef":"#","url":"validate/delegate","content":"Delegate","keywords":""},{"title":"Contributing","type":0,"sectionRef":"#","url":"validate/contributing","content":"Contributing","keywords":""},{"title":"Economics","type":0,"sectionRef":"#","url":"validate/economics","content":"Economics","keywords":""},{"title":"FAQ","type":0,"sectionRef":"#","url":"validate/depools/faq","content":"","keywords":""},{"title":"General​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#general","content":""},{"title":"What is DePool?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#what-is-depool","content":"DePool is a smart contract that allows other smart contracts to invest stakes into a common pool, which it then uses in validator elections on behalf of the validator owning the DePool, and upon successful validation pays rewards to all participants proportionally to their contribution. "},{"title":"Are there multiple versions of DePools?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#are-there-multiple-versions-of-depools","content":"Currently only one version of the DePool is used: the current master version. "},{"title":"Are there multiple types of nodes?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#are-there-multiple-types-of-nodes","content":"At this time available node types include the original C++ EVER node and the EverX Rust node (currently being tested on rustnet). DePool works with both versions. "},{"title":"Is DePool some special kind of wallet? How can I be sure no one’s going to misuse my funds?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#is-depool-some-special-kind-of-wallet-how-can-i-be-sure-no-ones-going-to-misuse-my-funds","content":"DePool is not a wallet with a single balance. It remembers which wallets invested which stakes. A stake cannot be withdrawn from DePool to any wallet that isn’t the owner of the stake. The DePool owner has no access to any stakes other than their own. All the owner can do is close the DePool, in which case all stakes and rewards are returned to their owners. There are however some risks involved: if DePool's validator node wins elections, but doesn't function correctly, it may be punished by the elector, and part or all of its stake may be lost. For this reason, the DePool owner is obliged to invest a certain amount of tokens each validation round, all or some of which they stand to lose, and will be the first among the participants to lose, should their node perform poorly or misbehave in any way. This way participants can be sure, that the person upon whose actions their funds and rewards depend is highly motivated to perform their duties properly and ensure everyone receives their rewards. The contract code in open sourced and formally verified. See specifications and contract code for details. "},{"title":"What is validator assurance?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#what-is-validator-assurance","content":"It is the minimum amount of tokens the DePool owner is obliged to invest each validation round. Without it, DePool will not participate in elections. DePool owner's funds will be the first lost, in case of any validator node malfunction or misbehavior. Only if they are not enough to cover the losses of the total stake, will the funds of other pool participants be affected. So the higher the validator assurance, the more the validator owner is motivated to ensure proper operation of their node and the safer the stakes of all other participants are. This parameter of the DePool cannot be changed after the DePool is deployed, not even by its owner. "},{"title":"What is DePool fee?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#what-is-depool-fee","content":"It is the fraction of the total DePool reward, that goes directly to the validator's wallet each time rewards are received. Validator needs it to cover current operational expenses of the node and the DePool. The rest of the rewards are distributed among all DePool participants, proportionally to their stakes. So the lower the DePool fee, the more profitable the DePool is for participants. "},{"title":"Why even use DePool? What are the advantages?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#why-even-use-depool-what-are-the-advantages","content":"Becoming a validator requires a substantial cryptocurrency deposit. The required amount might far exceed an individual validator budget. On the other hand, blockchain users with no validating system might be interested in investing in validation duty. This is where the DePool contract comes in. There are two main use cases of DePool: User has no Validator capabilities but some free funds. User can support a third-party Validator and receive rewards.User has Validator capabilities and but doesn't have necessary amount of funds to participate in validator elections and subsequent rewards. Thus the usage of DePool allows to greatly expand the number of individuals involved in validation process and decentralize the network to a much higher degree. "},{"title":"How does DePool work?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#how-does-depool-work","content":"The DePool system has several components. The validator node, which is the same, as a regular node. It forms election requests and performs validation.The validator wallet - the wallet belonging to the validator. Normally it holds the funds to be used in stakes and sends them with election requests to the elector directly. In a DePool system however the staking funds are kept in the DePool: the validator wallet has to invest its funds into the DePool and sends its the election requests through the DePool as well.The DePool itself collects stakes from the validator and any other participants, who wish to invest in validation, receives election requests from validator wallet, attaches the collected funds, and through its proxies passes it to the elector. Whenever elector returns the stake, DePool processes it and distributes rewards among its participants.The DePool needs to be called regularly, to perform its functions. There are several methods to do it, both manually and automatically. "},{"title":"How configurable is a DePool? What settings can I define?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#how-configurable-is-a-depool-what-settings-can-i-define","content":"DePool has a number of parameters that its owner can set during deploy. Note, that these parameters cannot be changed after deploy. You’d have to close the current DePool and set up a new one, if you need to change them. The parameters are: minStake - minimum stake that DePool accepts from participants. It's recommended to set it not less than 10 everss.validatorAssurance - minimal stake for validator. If validator has stake less than validatorAssurance, DePool won't be taking part in elections.validatorWalletAddress – validator wallet address.participantRewardFraction - percentage of the total DePool reward that goes to Participants. Proxy contract code is also provided to the DePool at deploy, but has no bearing on its performance. It simply lets DePool deploy its own proxies, thus simplifying the setup. "},{"title":"How do I choose DePool deploy configuration?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#how-do-i-choose-depool-deploy-configuration","content":"The DePool configuration will influence the appeal of your DePool to potential participants and its success in competition to the other DePools out there: minStake – minimum stake that DePool accepts from participants. If set to high, some small token holders won’t be able to invest, whereas a very low minimal stake will permit participants to make small pointless stakes, where DePool fees will eat up a significant part of their reward and/or investment. 10 tokens is the recommended minimum for this parameter.validatorAssurance determines how much you take it upon yourself to invest in the DePool every election and lose in case of any validator node malfunction or misbehavior. If set too small, potential participants might decide you aren't risking enough and avoid your DePool in favor of others. Should be chosen depending on the current competition in the network.participantRewardFraction determines what percentage of the total reward all participants will receive. DePool is a complex contract that takes up a lot of computational resources to run. Depending on the setup, other contracts involved in DePool operations, such as the validator wallet, also regularly spend significant amounts on their operation. Thus DePool is programmed to reserve a part of the total rewards it receives for it’s own balance, and send a part the rewards (100% - ParticipantRewardFraction) directly to the validator wallet. Only then does it distribute ParticipantRewardFraction % of the rewards between all participants. So, if this parameter is set too small, other DePools might draw potential participants away. If it is set too big, your validator wallet might not receive enough rewards to support validation and staking. It should be chosen to balance these two concerns. "},{"title":"What are the risks of using DePool?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#what-are-the-risks-of-using-depool","content":"Validator using a DePool bears the same risks as a validator participating in elections through their own wallet and with only their own funds directly – in case of malfunction or misbehavior of their node during validation, part of the total stake or all of it may be lost. As in DePool there are usually other participants, who have no control over the node, the DePool is programmed to preserve as much of their funds as possible – the losses are deducted from the validator’s investment first, and only then from other participants. There are also some operational risks associated with the DePool specifically. If any of the contracts involved in its operation run out of funds, DePool might get up stuck and miss elections. Learn how to prevent that here. "},{"title":"Setting up​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#setting-up","content":""},{"title":"How do I set up a validator node with a DePool?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#how-do-i-set-up-a-validator-node-with-a-depool","content":"You have to follow this procedure exactly. To briefly sum up, you have to do the following: Set up a node;Set up a validator wallet. For security, we advise to have not less than three custodians in this wallet;Insert one custodian keypair for the validator wallet and its address into the node files;Deploy DePool and do not forget to set up a state update method for it;Make the necessary stakes in the DePool – ensure at least validatorAssurance is staked every round. All types of stakes count towards this value;Set up validator script;If required, confirm any transactions that the validator script or the state update method you set up generates. If all is set up correctly, DePool should participate in the next validator elections. If it doesn’t, here is some troubleshooting advice. "},{"title":"What do the validator contest winners need to do differently?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#what-do-the-validator-contest-winners-need-to-do-differently","content":"The main requirement specific to validator contest winners is their validator wallet. The vesting stake they will receive on the main net will be assigned to this specific wallet, and won’t count towards validatorAssurance, if this wallet isn’t used as validator wallet. So if you are a winner of the DePool contest: make sure to insert the address of this wallet and any one of the custodian key pairs you set up for this wallet during deploy into your node files.specify it's address as validator wallet during DePool deployment. Another important detail is the validatorAssurance parameter at DePool deployment. As the rewards for winning the contest are fixed, to make sure your DePool participates in every election, regardless of any additional stakes you make, you should set validator assurance no higher than contest reward/2. Here’s why. "},{"title":"What are the possible state update methods for the DePool?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#what-are-the-possible-state-update-methods-for-the-depool","content":"Currently there are two: Using a multisig contract to call the DePool ticktock function directly. This requires monitoring and regular replenishing of the multisig contract balance and can be automated with any task scheduler. Note, that if the multisig contract requires multiple signatures to execute transactions (for example, if it’s a contest winner’s wallet with three custodians), every such transaction has to be confirmed by the required number of custodians.Setting up a DePool helper contract and calling it with external messages. This also requires monitoring and regular replenishing of the helper contract balance and can also be automated with any task scheduler. "},{"title":"Why are two proxies necessary?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#why-are-two-proxies-necessary","content":"DePool maintains multiple rounds at once to ensure participants can make their stakes at all times. Two proxies are required to establish separate communication with the elector for odd and even rounds. This setup prevents stakes from consequent rounds getting mixed up in the event of any DePool lag, for example, if the DePool runs out of funds and sends some of its messages to the elector later than usual. Without two separate proxies for odd and even rounds, elector may combine two consequent stakes into one, and it would not be possible to accurately calculate how the rewards should be distributed between participants of the two rounds, which might have changed their stakes in-between them. "},{"title":"Stake and rounds​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#stake-and-rounds","content":""},{"title":"How do DePool rounds work?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#how-do-depool-rounds-work","content":"To make sure participants can invest their funds in the DePool at any time regardless of the current stage of the election cycle, DePool runs its operations in multiple rounds at once, and one of these rounds is always in the pooling stage (is ready to receive stakes). Whenever a new election on the network begins, the current round in the pooling stage is switched to the next stage – election - and can no longer receive stakes. Everything, that DePool accumulated during pooling is attached to validator's election request and staked in the elections. The next round then enters pooling stage, gathering stakes for the next election. In practice this comes down to alternating odd and even rounds. When a round completes its last stage and is removed from the DePool, the round after the next locks its accumulated stake (including any stakes released from the just completed round, that were reinvested) and enters elections.  So to make sure DePool participates in every election, you have to ensure sufficient stakes are invested (and set to be reinvested) in even and odd rounds both. "},{"title":"What do the parameters displayed by getRounds method mean?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#what-do-the-parameters-displayed-by-getrounds-method-mean","content":"You can find a list of getRounds parameters and their meanings here. "},{"title":"What types of stakes are there?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#what-types-of-stakes-are-there","content":"There are three types of stakes supported: Ordinary stakes​ This is the most basic type of stake. Any account (for example, any wallet) can make an ordinary stake. Its full value is invested in the DePool round that is currently in the pooling stage, and set to be continuously reinvested into every second round. The account that made the ordinary stake owns its entirety. Such a stake can increased: the value of any additional ordinary stakes from this account is simply added to the account’s ordinary stake in the current pooling round. Any rewards a participant receives in the DePool are also added to their ordinary stake. If a participant initially has no ordinary stake (e.g. is a beneficiary of a single vesting stake from which it receives rewards), and ordinary stake is created for it when the first reward is received. An ordinary stake, or a part of it can be withdrawn only to the account that owns it. An ordinary stake can also be transferred, in part or in full, to another participant of the same DePool (if this other the participant does not currently have an ordinary stake, it will be created). Vesting Stakes​ Any account can make a vesting stake and define a target participant address (beneficiary) who will own this stake. But not the whole stake is available to the beneficiary at once. Instead it is split into logical parts and the next part of stake becomes available to the participant only when next vesting period is ended. At completion step of every round DePool decides how many vesting parts should be unlocked and subtracted from vesting stake and become available to owner since last unlocking. These funds are added to beneficiary's ordinary stake. Example: address A makes a vesting stake of 120 evers for 1 year with vesting period of 1 month and defines address B as the stake beneficiary. It means that after 1 month 10 evers become available to address B and 110 evers are still locked in the pool. After 1 year vesting stake will be equal to 0 and last 10 evers will become available to owner. One Participant can be a beneficiary only of one vesting stake. When a vesting stake is created, it is split equally into two last rounds, to make sure it can be uniformly reinvested into odd and even rounds both. To receive a vesting stake, participant has to first specify the donor, that is expected to make it. Lock Stakes​ Any account can make a lock stake, in which it locks its funds in DePool for a defined period, but rewards from this stake will be payed to another target participant (beneficiary). At the end of a period the Lock Stake should be returned to the account which locked it. Example: address A makes a lock stake of 120 evers for 1 year with vesting period of 1 month and defines address B as the stake beneficiary. It means that after 1 month 10 evers become available to address A (as opposed to vesting, where these 10 evers would become available to address B, the beneficiary) and 110 evers are still locked in round. DePool will reinvest the gradually diminishing lock stake for a 1 year and pay rewards to B address. After 1 year DePool will return the remainder of the lock stake to address A. One Participant can be a beneficiary only of one lock stake. When a lock stake is created, it is split equally into two last rounds, to make sure it can be uniformly reinvested into odd and even rounds both. To receive a lock stake, participant has to first specify the donor, that is expected to make it. "},{"title":"What’s this about lock and vesting stakes split into two parts?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#whats-this-about-lock-and-vesting-stakes-split-into-two-parts","content":"The total funds of lock and vesting stakes do get split into two equal parts, and each half is invested into the current pooling round and, once it's locked, into the next pooling round. This is done, because the same stake can only be reinvested every second DePool round. The funds simply don't get unlocked in time to be reinvested into the very next one. On the other hand, one participant can be a beneficiary of only one lock and one vesting stake. So by splitting them into two parts, DePool makes it so a single lock or vesting stake is continuously reinvested into every single DePool round, and, provided it exceeds validatorAssurance *2, enough to participate in every validator election. "},{"title":"How is the validator’s stake different?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#how-is-the-validators-stake-different","content":"Validator's stake in their own DePool has certain requirements and limitations it must conform to. Most importantly, it has to always (both in odd and even rounds) exceed the validatorAssurance parameter. Otherwise DePool won't participate in elections. These are the funds validator invests in their DePool to guarantee their conscientious performance to any other participants of the pool. These funds will be the first lost, in case the node misbehaves and is punished by the elector. All three types of stakes count towards reaching this limit. Additionally, the ordinary stake of the validator wallet cannot be transferred to another participant of the DePool, nor can any other participant's ordinary stake be transferred to the validator. This rule prevents attempts to circumvent the above requirement. "},{"title":"Do lock and vesting stakes count toward validatorAssurance?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#do-lock-and-vesting-stakes-count-toward-validatorassurance","content":"Yes, if the validator wallet is the beneficiary of a lock and/or vesting stake, they count towards the validatorAssurance requirement. A single lock or vesting stake is enough to ensure your DePool participates in every election, if it is equal to or greater than validatorAssurance*2. "},{"title":"How do I make stakes?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#how-do-i-make-stakes","content":"Currently, this can be done through TONOS-CLI. It should be configured to be used with DePool. A participant needs to know the DePool address and have a suitable contract holding the funds they want to invest (e.g. a multisig wallet). Ordinary, vesting and lock stakes all have their own commands, that should be used to make a stake in the DePool, as they all have different sets of parameters, that need to be specified, when the stake is sent to the DePool. All participants' stakes have to exceed the minimum stake set for the DePool (minStake DePool parameter). Validator's stake in every round has to additionally exceed validatorAssurance. "},{"title":"I made a stake but DePool returned my funds. What's wrong?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#i-made-a-stake-but-depool-returned-my-funds-whats-wrong","content":"There can be several reasons this happened: The stake was too small. Check DePool Info to find out the minimum stake for this DePool.DePool is closed. Check DePool events to find out if it is.You are trying to make a lock or vesting stake on behalf of a wallet that did not set a donor for lock or vesting. Check Participant Info for the beneficiary.You are trying to make a lock or vesting stake on behalf of a wallet that already has this type of stake. Check Participant Info for the beneficiary.There are errors in lock or vesting period settings (withdrawalPeriod &gt; totalPeriod, totalPeriod &gt; 18 years or totalPeriod &lt;=0 seconds, or totalPeriod is not exactly divisible by withdrawalPeriod).You are using an old TONOS-CLI version (&lt;1.25). "},{"title":"Can I make a lock or vesting stake for myself?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#can-i-make-a-lock-or-vesting-stake-for-myself","content":"Starting with version 3 of the DePool, yes. "},{"title":"How are stakes reinvested and withdrawn?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#how-are-stakes-reinvested-and-withdrawn","content":"Whenever an ordinary stake is made, it is set to be continuously reinvested. The participant who made the stake may disable reinvestment at any time, and the entirety of their ordinary stake will be withdrawn to their wallet as soon as the funds are unlocked from the rounds they are invested in. A part of the ordinary stake can also be withdrawn. The remainder of the stake will keep being reinvested in this case. Lock and vesting stakes are reinvested for the full duration of their existence, which is set during their investment. "},{"title":"What are the DePool fees for staking operations?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#what-are-the-depool-fees-for-staking-operations","content":"The sender of any stake management transaction (including withdrawal and transfer) is required to cover DePool fees for this operation. These fees are normally under 0.5 tokens, so by default this value is additionally attached to any transaction to the DePool, and the change is returned to the sender. If for any reason a value of 0.5 tokens proves to be insufficient (and DePool starts running out of gas trying to execute a transaction), it can be increased in TONOS-CLI config. Additionally, when DePool receives the stake and rewards back from elector and processes the funds of participants, 0.05 evers are deducted from every participant's share of the pool, to cover the costs of executing this action. "},{"title":"How do I view my stakes in the DePool?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#how-do-i-view-my-stakes-in-the-depool","content":"It can be done with the getParticipantInfo get-method. Here's how. "},{"title":"Ensuring Regular Operations​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#ensuring-regular-operations","content":""},{"title":"How do I make sure my DePool always participates in elections?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#how-do-i-make-sure-my-depool-always-participates-in-elections","content":"Make sure that: your validator wallet has at least validatorAssurance staked in both odd and even rounds. Your own ordinary stakes, as well as Lock and vesting stakes, where you are the beneficiary, count towards validatorAssuranceyou set up the state update method to run regularlyyou have sufficient funds on the balances of all contracts (DePool, validator wallet, proxies, helper, if you use it, multisig, that updates the DePool state, if you use it)your validator script generates the election request correctly. You can find some troubleshooting advice here. "},{"title":"How do I make sure my DePool wins elections?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#how-do-i-make-sure-my-depool-wins-elections","content":"No guarantees here, just as with any elections. Configure your DePool to be competitive and appealing to participants and develop your reputation. "},{"title":"How often do I have to call the DePool state update function?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#how-often-do-i-have-to-call-the-depool-state-update-function","content":"The period for state updates should be chosen based on the duration of the validation cycle on the blockchain. At the very minimum DePool's state update function should be called three times during the validation cycle: Once after the elections begin, so DePool gets ready to receive and forward validator's election request.Once after the validation begins, to find out if it won elections or not.Once after unfreeze, to process stakes and rewards and rotate the rounds. In the current network configuration, 1 and 3 coincide, so DePool's state update function can be called twice during the validation cycle - once during elections and once during validation. "},{"title":"How do DePool and its supporting contracts receive funds for their operations?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#how-do-depool-and-its-supporting-contracts-receive-funds-for-their-operations","content":"Each of the contracts involved has its own balance from which funds are spent on any operations it performs. These balances have to be replenished regularly. For DePool this is automated. Whenever DePool receives validation rewards, it tops up its balance depending on number of participants. If it fails to do so, and the balance dips below 10 tokens, it emits an event notifying of the problem. Proxy contracts also receive the necessary funds automatically, but if for any reason their balance becomes to low to perform the necessary operations, the DePool will also emit an event notifying about it. You can replenish their balance, then call the DePool’s state update function by any available means, and resume normal operations. Helper contract, if you use it, doesn’t have built-in balance replenishing mechanisms. It has to be monitored and replenished separately. Same goes for the multisig contract you use for DePool state update, unless it’s your validator wallet. The validator wallet gets a fraction of the total DePool validation rewards each time they are received. The specific percentage is set during DePool deployment. These funds are transferred to the validator wallet directly and usually cover all its expenses related to running a DePool sufficiently well. "},{"title":"My DePool is constantly running out of funds. What do I do?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#my-depool-is-constantly-running-out-of-funds-what-do-i-do","content":"You can set up a script which will listen for the low balance DePool event and top it back up to 100 tokens, whenever the event occurs. "},{"title":"How do I monitor what’s happening to my DePool?​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#how-do-i-monitor-whats-happening-to-my-depool","content":"There is a number of methods available, such as DePool events, get methods and the ever.live explorer. Read more here. "},{"title":"Rewards Distribution​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#rewards-distribution","content":"Every time DePool receives rewards for validation, DePool replenishes it's pure balance to be more than balanceThreshold and the rest is distributed according to the following rules: validatorRewardFraction% of the reward, regardless of the validator’s share in the pool, goes directly to the validator wallet. This is the reward for maintaining the node and is intended to be used on operational expenses.participantRewardFraction% of the reward is distributed among all participants (including the validator) proportionally to their share of the staking pool. By default these rewards are added to the ordinary stakes of all participants and reinvested with it. To withdraw this stake or any part of it to the participant wallet, use one of the withdrawal functions.The remaining associationRewardFraction% of the reward is transferred to the DePool Association. This is not yet implemented. "},{"title":"Troubleshooting​","type":1,"pageTitle":"FAQ","url":"validate/depools/faq#troubleshooting","content":"You can find some troubleshooting advice here. "},{"title":"Validator FAQ","type":0,"sectionRef":"#","url":"validate/faq","content":"","keywords":""},{"title":"Getting started​","type":1,"pageTitle":"Validator FAQ","url":"validate/faq#getting-started","content":""},{"title":"How can I become a Everscale validator?​","type":1,"pageTitle":"Validator FAQ","url":"validate/faq#how-can-i-become-a-everscale-validator","content":"To set up a validator node you should follow the instructions in Run validator section. "},{"title":"Can I test out the node?​","type":1,"pageTitle":"Validator FAQ","url":"validate/faq#can-i-test-out-the-node","content":"You may setup a node on the net.ton.dev test network. The procedure is similar. "},{"title":"Requirements​","type":1,"pageTitle":"Validator FAQ","url":"validate/faq#requirements","content":""},{"title":"What kind of hardware do I need to run a node?​","type":1,"pageTitle":"Validator FAQ","url":"validate/faq#what-kind-of-hardware-do-i-need-to-run-a-node","content":"Configuration\tCPU (cores)\tRAM (GiBs)\tStorage (GiBs)\tNetwork (Bbits/s)Minimal\t8\t16\t1000\t1 Recommended\t16\t32\t1000\t1 SSD disks are recommended for /var/ton-work/db storage "},{"title":"Does the validator node require a public IP?​","type":1,"pageTitle":"Validator FAQ","url":"validate/faq#does-the-validator-node-require-a-public-ip","content":"Yes, the validator requires a public IP, otherwise other nodes will not be able to communicate with it. "},{"title":"What ports are needed for a node to work?​","type":1,"pageTitle":"Validator FAQ","url":"validate/faq#what-ports-are-needed-for-a-node-to-work","content":"The UDP port set here (ADNL_PORT parameter) for the node itself.HTTPS port 443 for the TONOS-CLI utility. "},{"title":"What volumes of outgoing traffic do you need for the validator at the moment? How about in the future?​","type":1,"pageTitle":"Validator FAQ","url":"validate/faq#what-volumes-of-outgoing-traffic-do-you-need-for-the-validator-at-the-moment-how-about-in-the-future","content":"In general, the traffic requirements are high (up to tens of TB per month), so it’s best to find a server without traffic limitations. Currently the network has 16 shards by default, and a block is issued every 2-4 seconds in each shard, even if there are no transactions and it is empty – such is the Ever architecture. On the other hand, as the number of transactions increases, traffic will not grow too fast. Furthermore, as the number of validators grows, they will be divided into groups, each to validate their own shards. This means that the number of constantly communicating neighboring validator nodes will be approximately the same. "},{"title":"Node Setup​","type":1,"pageTitle":"Validator FAQ","url":"validate/faq#node-setup","content":""},{"title":"What network does the node work with by default?​","type":1,"pageTitle":"Validator FAQ","url":"validate/faq#what-network-does-the-node-work-with-by-default","content":"The node is compatible with all Everscale networks, but connects to just one at a time. It is specified in the configs during node setup. "},{"title":"Why are there different initial DiffTime values? Why do some start at 40k and others at 190k?​","type":1,"pageTitle":"Validator FAQ","url":"validate/faq#why-are-there-different-initial-difftime-values-why-do-some-start-at-40k-and-others-at-190k","content":"Nodes begin synchronization from the latest key block, which is generally issued whenever validator elections end or the validator set is changed. Thus initial DiffTime depends on when in the election cycle the node began synchronization. Synchronization speed is also very dependent on the hardware and the network throughput. "},{"title":"How can I make sure synchronization is proceeding as it should?​","type":1,"pageTitle":"Validator FAQ","url":"validate/faq#how-can-i-make-sure-synchronization-is-proceeding-as-it-should","content":"It’s normal for synchronization to take multiple hours. However, if you have noticed that DiffTime has not been decreasing for an hour, or even started increasing, then something is wrong. Make sure you have followed the instructions exactly and that you are using an SSD, check your network status, review the logs. If no obvious reason for the lag presents itself, contact support to get help. "},{"title":"How can I correctly stop the node?​","type":1,"pageTitle":"Validator FAQ","url":"validate/faq#how-can-i-correctly-stop-the-node","content":"pkill -f validator-engine  "},{"title":"Monitoring","type":0,"sectionRef":"#","url":"validate/monitoring","content":"Monitoring","keywords":""},{"title":"Run testnet node","type":0,"sectionRef":"#","url":"validate/run-validator/run-testnet-node","content":"","keywords":""},{"title":"1. System Requirements​","type":1,"pageTitle":"Run testnet node","url":"validate/run-validator/run-testnet-node#1-system-requirements","content":""},{"title":"2. Prerequisites​","type":1,"pageTitle":"Run testnet node","url":"validate/run-validator/run-testnet-node#2-prerequisites","content":""},{"title":"2.1 Set the Environment​","type":1,"pageTitle":"Run testnet node","url":"validate/run-validator/run-testnet-node#21-set-the-environment","content":"Adjust (if needed) net.ton.dev/scripts/env.sh: Set export DEPOOL_ENABLE=yes in env.sh for a depool validator (an elector request is sent to a depool from a validator multisignature wallet). Set export DEPOOL_ENABLE=no in env.sh for a direct staking validator (an elector request is sent from a multisignature wallet directly to the elector). cd net.ton.dev/scripts/ . ./env.sh  Note: Make sure to run the script as . ./env.sh, not ./env.sh 2.2 Install Dependencies​ install_deps.sh script supports Ubuntu OS only. ./install_deps.sh  Install and configure Docker according to the official documentation. Note: Make sure to add your user to the docker group, or run subsequent command as superuser: sudo usermod -a -G docker $USER  "},{"title":"3. Deploy RUST Validator Node​","type":1,"pageTitle":"Run testnet node","url":"validate/run-validator/run-testnet-node#3-deploy-rust-validator-node","content":"Do this step when the network is launched. Deploy the node: ./deploy.sh 2&gt;&amp;1 | tee ./deploy.log  Note: the log generated by this command will be located in the net.ton.dev/scripts/ folder and can be useful for troubleshooting. Wait until the node is synced. Depending on network throughput this step may take significant time (up to several hours). "},{"title":"4. Check Node synchronization​","type":1,"pageTitle":"Run testnet node","url":"validate/run-validator/run-testnet-node#4-check-node-synchronization","content":"Use the following command to check if the node is synced: docker exec -it rnode /ton-node/tools/console -C /ton-node/configs/console.json --cmd getstats  Script output example: tonlabs console 0.1.254 COMMIT_ID: BUILD_DATE: 2021-12-24 10:53:20 +0300 COMMIT_DATE: GIT_BRANCH: { &quot;sync_status&quot;: &quot;synchronization finished&quot;, &quot;masterchainblocktime&quot;: 1640343840, &quot;masterchainblocknumber&quot;: 13393489, &quot;timediff&quot;: 4, &quot;in_current_vset_p34&quot;: true, &quot;in_next_vset_p36&quot;: false, &quot;last_applied_masterchain_block_id&quot;: {&quot;shard&quot;:&quot;-1:8000000000000000&quot;,&quot;seq_no&quot;:13393489,&quot;rh&quot;:&quot;e74d505222bbe64617bbd42939cf01334b035990ae4b4e285e67ecbb1b537dd3&quot;,&quot;fh&quot;:&quot;fc0be7c22310389400a7bdbd000b3737b317ce44d92e9a5ed72086c4fa404afa&quot;}, &quot;processed_workchain&quot;: 0, &quot;validation_stats&quot;: { &quot;-1:8000000000000000&quot;: &quot;1 sec ago&quot;, &quot;0:e800000000000000&quot;: &quot;1 sec ago&quot; }, &quot;collation_stats&quot;: { &quot;-1:8000000000000000&quot;: &quot;never&quot;, &quot;0:e800000000000000&quot;: &quot;6 sec ago&quot; }, &quot;tps_10&quot;: 2, &quot;tps_300&quot;: 1 }  If the timediff parameter is less than 10 seconds, synchronization with masterchain is complete.&quot;sync_status&quot;: &quot;synchronization finished&quot; means synchronization with workchains is complete Note: The sync process may not start for up to one hour after node deployment, during which this command may result in error messages. If errors persist for more than an hour after deployment, review deployment log for errors and check the network status. "},{"title":"5. Configure validator multisignature wallet​","type":1,"pageTitle":"Run testnet node","url":"validate/run-validator/run-testnet-node#5-configure-validator-multisignature-wallet","content":"There is a small difference between direct staking and DePool validators on this step: For direct staking validator it is necessary to create and deploy a validator SafeMultisig wallet in -1 chain.For a DePool validator it is necessary to create and deploy a validator SafeMultisig wallet in 0 chain. You can use TONOS-CLI for this purpose. It should be configured to connect to the net.ton.dev network. Refer to this document for the detailed wallet creation procedure, or follow the links in the short guide below: All wallet custodians should create seed phrases and public keys for themselves. At least three custodians are recommended for validator wallet, one of which will be used by the validator node. All seed phrases should be kept secret by their owners and securely backed up.The wallet deployer (who may or may not be one of the custodians) should gather the public keys from all custodians.The wallet deployer should obtain SafeMultisig contract code from the repository.The wallet deployer should generate deployment keys.The wallet deployer should generate validator wallet address: in -1 chain for direct staking validator or in 0 chain for a DePool validator.Any user should send at least 1 token to the generated wallet address to create it in the blockchain.The wallet deployer should deploy the wallet contact to the blockchain and set all gathered public keys as its custodians. At this step the number of custodian signatures required to make transactions from the wallet is also set (&gt;=2 recommended for validator wallets). Deploy to -1 chain for direct staking validator or to 0 chain for a DePool validator.In case of direct staking, the funds for staking should be transferred to the newly created validator wallet. Once the wallet is deployed, place 2 files on the validator node: /ton-node/configs/${VALIDATOR_NAME}.addr should contain validator multisignature wallet address in form X:XXX...XXX (the folder on the host is net.ton.dev/docker-compose/ton-node/configs) /ton-node/configs/keys/msig.keys.json should contain validator multisignature custodian's keypair (the folder on the host is net.ton.dev/docker-compose/ton-node/configs/keys/) The node will use the wallet address and the keys provided to it to generate election requests each validation cycle. Note: If the validator wallet requires more than 1 custodian signature to make transactions, make sure each transaction sent by the validator node is confirmed by the required amount of custodians. "},{"title":"6. Configure DePool​","type":1,"pageTitle":"Run testnet node","url":"validate/run-validator/run-testnet-node#6-configure-depool","content":"For a DePool validator it is necessary to deploy a DePool contract to workchain 0. You can use TONOS-CLI for this purpose. It should be configured to connect to the net.ton.dev network. Refer to this document for the detailed DePool creation procedure, or follow the links in the short guide below: Obtain contract code from the repository.Generate deployment keys.Calculate contract addresses.Send tokens to the calculated addresses.Deploy contracts. Make sure to specify your validator wallet in the DePool contract at this step.Configure DePool state update method. Once DePool is successfully deployed and configured to be regularly called to update its state, you can make stakes in it. Note that validator stakes must always exceed validator assurance, otherwise DePool will not participate in elections. Also note, that DePool and supporting contracts balance should be monitored and kept positive at all times. Once the validator wallet and the DePool are deployed, place 3 files on the validator node: /ton-node/configs/${VALIDATOR_NAME}.addr should contain validator multisignature wallet address in form 0:XXX...XXX (the folder on the host is net.ton.dev/docker-compose/ton-node/configs)/ton-node/configs/keys/msig.keys.json should contain validator multisignature custodian's keypair (the folder on the host is net.ton.dev/docker-compose/ton-node/configs/keys/)/ton-node/configs/depool.addr should contain DePool address in form 0:XXX...XXX (the folder on the host is net.ton.dev/docker-compose/ton-node/configs) The script generating validator election requests (directly through multisig wallet, or through DePool, depending on the setting selected on step 2.1) will run regularly, once the necessary addresses and keys are provided. "},{"title":"7. Upgrade RUST Validator Node​","type":1,"pageTitle":"Run testnet node","url":"validate/run-validator/run-testnet-node#7-upgrade-rust-validator-node","content":"Note: You may need to renew your copy of net.ton.dev scripts but do not remove any working files from the previous deployment (for example, configs folder). Adjust (specify new commit ID) net.ton.dev/scripts/env.sh: export TON_NODE_GITHUB_REPO=&quot;https://github.com/tonlabs/ton-labs-node.git&quot; export TON_NODE_GITHUB_COMMIT_ID=&quot;master&quot; export TON_NODE_TOOLS_GITHUB_REPO=&quot;https://github.com/tonlabs/ton-labs-node-tools.git&quot; export TON_NODE_TOOLS_GITHUB_COMMIT_ID=&quot;master&quot; export TONOS_CLI_GITHUB_REPO=&quot;https://github.com/tonlabs/tonos-cli.git&quot; export TONOS_CLI_GITHUB_COMMIT_ID=&quot;master&quot;  Upgrade the node: ./upgrade.sh 2&gt;&amp;1 | tee ./upgrade.log  Note: the log generated by this command will be located in the net.ton.dev/scripts/ folder and can be useful for troubleshooting. Wait until the node is synced. Stopping, restarting the RUST Node Note: call docker-compose commands from the net.ton.dev/docker-compose/ton-node folder. To stop the node use the following command: docker-compose stop  To restart a stopped node use the following command: docker-compose restart  Logging "},{"title":"During deployment​","type":1,"pageTitle":"Run testnet node","url":"validate/run-validator/run-testnet-node#during-deployment","content":"It is highly recommended to record the full log during node deployment: ./deploy.sh 2&gt;&amp;1 | tee ./deploy.log  The log is saved to the net.ton.dev/scripts/ folder next to the deployment script and can be useful for troubleshooting. "},{"title":"During operation​","type":1,"pageTitle":"Run testnet node","url":"validate/run-validator/run-testnet-node#during-operation","content":"When operational, the node keeps a number of logs in the net.ton.dev/docker-compose/ton-node/logs folder. Logs are generated with log4rs framework. For detailed documentation on it refer to https://docs.rs/log4rs/1.0.0/log4rs/. Logging configuration is determined by the net.ton.dev/docker-compose/ton-node/configs/log_cfg.yml file. By default is contains the recommended configuration for the Rust node. refresh_rate: 30 seconds appenders: stdout: kind: console encoder: pattern: &quot;{d(%s.%f)} {l} [{h({t})}] {I}: {m}{n}&quot; stdout_ref: kind: console encoder: pattern: &quot;{f}:{L} {l} [{h({t})}] {I}: {m}{n}&quot; logfile: kind: file path: &quot;/ton-node/logs/output.log&quot; encoder: pattern: &quot;{d(%s.%f)} {l} [{h({t})}] {I}: {m}{n}&quot; rolling_logfile: kind: rolling_file encoder: pattern: &quot;{d(%Y-%m-%d %H:%M:%S.%f)} {l} [{h({t})}] {I}: {m}{n}&quot; path: /ton-node/logs/output.log policy: kind: compound trigger: kind: size limit: 50 gb roller: kind: fixed_window pattern: '/ton-node/logs/output_{}.log' base: 1 count: 1 tvm_logfile: kind: file path: &quot;target/log/tvm.log&quot; encoder: pattern: &quot;{m}{n}&quot; root: level: info appenders: - rolling_logfile loggers: # node messages ton_node: level: trace boot: level: trace sync: level: trace # adnl messages adnl: level: info overlay: level: info rldp: level: info dht: level: info # block messages ton_block: level: debug # block messages executor: level: debug # tvm messages tvm: level: info librdkafka: level: info validator: level: debug catchain: level: debug validator_session: level: debug  The currently configured targets are the following: ton_node: node-related messages, except initial boot and sync, block exchange with other nodes boot: initial boot messages, creation of trusted key block chain, loading blockchain state sync: node synchronization - loading a certain number of most recent blocks adnl: messages of the ADNL protocol overlay: messages of the overlay protocol rldp: messages of the RLDP protocol dht: messages of the DHT protocol ton_block: messages of the block structures library, logs are turned on in debug executor: messages of the smart contract execution library, logs are turned on in debug tvm: ton virtual machine messages, logs are turned on in debug librdkafka: kafka client library messages validator: top level consensus protocol messages catchain: low level consensus protocol messages validator_session: mid level consensus protocol messages Migrating from C++ node To migrate your validator from legacy C++ node to Rust node, complete the following steps: Set up a new host for the Rust node, according to steps 1-3 of this document.Wait for node to sync. Check sync according to step 4 of this document.Stop the C++ node sending election requests (by default - disable scheduling of the validator script). Do not shut down the C++ validator itself, let it finish the current round.Configure validator wallet and corresponding keys, optionally - DePool (copy them from C++ node files to Rust Node files). By default: Copy validator wallet address from ~/ton-keys/$(hostname -s).addr file on the C++ node to /ton-node/configs/${VALIDATOR_NAME}.addr on the Rust Node.Copy validator wallet keys from /ton-keys/msig.keys.json on the C++ node to /ton-node/configs/keys/msig.keys.json on the Rust Node.If you have a DePool set up, copy DePool address from ~/ton-keys/depool.addr on the C++ node to /ton-node/configs/depool.addr on the Rust Node. Once this is done, the Rust node validator script will start automatically with the next round. DO NOT shut down the C++ host. Wait for the C++ node to complete the current round until the validator set is changed.Check logs/validator.log on the Rust node, and make sure the first election request was successfully sent. There should be no errors in the log.Only once the validator set changes, the C++ node is no longer a validator and the Rust node starts validating (validation_stats and collation_stats in the console output should not be empty), shut down the C++ node. Troubleshooting Here are some solutions to frequently encountered problems. "},{"title":"1. Couldn’t connect to Docker daemon at http+docker://localhost​","type":1,"pageTitle":"Run testnet node","url":"validate/run-validator/run-testnet-node#1-couldnt-connect-to-docker-daemon-at-httpdockerlocalhost","content":"This error occurs in two cases. Either the docker daemon isn't running, or current user doesn't have rights to access docker. You can fix the rights issue either by running relevant commands as the superuser or adding the user to the docker group: sudo usermod -a -G docker $USER  Make sure to restart the system or log out and back in, for the new group settings to take effect. "},{"title":"2. thread 'main' panicked error when checking node synchronization​","type":1,"pageTitle":"Run testnet node","url":"validate/run-validator/run-testnet-node#2-thread-main-panicked-error-when-checking-node-synchronization","content":"The following error may occur for a short time immediately after node deployment when attempting to check synchronization: thread 'main' panicked at 'Can't create client: Os { code: 111, kind: ConnectionRefused, message: &quot;Connection refused&quot; }', bin/console.rs:454:59  Currently this is expected behavior, unless it persists for more than a few minutes. If it does persist, check network status at https://net.ton.live/, and, if the network is up and running, review deployment logs for errors. "},{"title":"3. Error executing command when checking node synchronization​","type":1,"pageTitle":"Run testnet node","url":"validate/run-validator/run-testnet-node#3-error-executing-command-when-checking-node-synchronization","content":"The following error may occur for up to an hour after node deployment when attempting to check synchronization: Error executing command: Error receiving answer: early eof bin/console.rs:296  Currently this is expected behavior, unless it persists for more than one hour. If it does persist, check network status at https://net.ton.live/, and, if the network is up and running, review deployment logs for errors. "},{"title":"4. Cannot stop/restart/remove node container​","type":1,"pageTitle":"Run testnet node","url":"validate/run-validator/run-testnet-node#4-cannot-stoprestartremove-node-container","content":"Make sure you are running all docker-compose commands from the net.ton.dev/docker-compose/ton-node folder. "},{"title":"5. DePool state not updating​","type":1,"pageTitle":"Run testnet node","url":"validate/run-validator/run-testnet-node#5-depool-state-not-updating","content":"It's recommended to send at least two ticktocks while the elections are open. For rust node you can use the provided ticktock script, which sends 5 ticktocks after the elections open. "},{"title":"Run Mainnet Node","type":0,"sectionRef":"#","url":"validate/run-validator/run-mainnet-node","content":"","keywords":""},{"title":"1. System Requirements​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#1-system-requirements","content":""},{"title":"2. Prerequisites​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#2-prerequisites","content":""},{"title":"2.1 Set the Environment​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#21-set-the-environment","content":"Adjust (if needed) main.ton.dev/scripts/env.sh: Set export DEPOOL_ENABLE=yes in env.sh for a depool validator (an elector request is sent to a depool from a validator multisignature wallet). Set export DEPOOL_ENABLE=no in env.sh for a direct staking validator (an elector request is sent from a multisignature wallet directly to the elector). cd main.ton.dev/scripts/ . ./env.sh  Note: Make sure to run the script as . ./env.sh, not ./env.sh 2.2 Install Dependencies​ install_deps.sh script supports Ubuntu OS only. ./install_deps.sh  Install and configure Docker according to the official documentation. Note: Make sure to add your user to the docker group, or run subsequent command as superuser: sudo usermod -a -G docker $USER  "},{"title":"3. Deploy RUST Validator Node​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#3-deploy-rust-validator-node","content":"Do this step when the network is launched. Deploy the node: ./deploy.sh 2&gt;&amp;1 | tee ./deploy.log  Note: the log generated by this command will be located in the main.ton.dev/scripts/ folder and can be useful for troubleshooting. Wait until the node is synced. Depending on network throughput this step may take significant time (up to several hours). "},{"title":"4. Check Node synchronization​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#4-check-node-synchronization","content":"Use the following command to check if the node is synced: docker exec -it rnode /ton-node/tools/console -C /ton-node/configs/console.json --cmd getstats  Script output example: tonlabs console 0.1.254 COMMIT_ID: BUILD_DATE: 2021-12-24 10:53:20 +0300 COMMIT_DATE: GIT_BRANCH: { &quot;sync_status&quot;: &quot;synchronization finished&quot;, &quot;masterchainblocktime&quot;: 1640343840, &quot;masterchainblocknumber&quot;: 13393489, &quot;timediff&quot;: 4, &quot;in_current_vset_p34&quot;: true, &quot;in_next_vset_p36&quot;: false, &quot;last_applied_masterchain_block_id&quot;: {&quot;shard&quot;:&quot;-1:8000000000000000&quot;,&quot;seq_no&quot;:13393489,&quot;rh&quot;:&quot;e74d505222bbe64617bbd42939cf01334b035990ae4b4e285e67ecbb1b537dd3&quot;,&quot;fh&quot;:&quot;fc0be7c22310389400a7bdbd000b3737b317ce44d92e9a5ed72086c4fa404afa&quot;}, &quot;processed_workchain&quot;: 0, &quot;validation_stats&quot;: { &quot;-1:8000000000000000&quot;: &quot;1 sec ago&quot;, &quot;0:e800000000000000&quot;: &quot;1 sec ago&quot; }, &quot;collation_stats&quot;: { &quot;-1:8000000000000000&quot;: &quot;never&quot;, &quot;0:e800000000000000&quot;: &quot;6 sec ago&quot; }, &quot;tps_10&quot;: 2, &quot;tps_300&quot;: 1 }  If the timediff parameter is less than 10 seconds, synchronization with masterchain is complete.&quot;sync_status&quot;: &quot;synchronization finished&quot; means synchronization with workchains is complete Note: The sync process may not start for up to one hour after node deployment, during which this command may result in error messages. If errors persist for more than an hour after deployment, review deployment log for errors and check the network status. "},{"title":"5. Configure validator multisignature wallet​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#5-configure-validator-multisignature-wallet","content":"There is a small difference between direct staking and DePool validators on this step: For direct staking validator it is necessary to create and deploy a validator SafeMultisig wallet in -1 chain.For a DePool validator it is necessary to create and deploy a validator SafeMultisig wallet in 0 chain. You can use TONOS-CLI for this purpose. It should be configured to connect to the main.ton.dev network. Refer to this document for the detailed wallet creation procedure, or follow the links in the short guide below: All wallet custodians should create seed phrases and public keys for themselves. At least three custodians are recommended for validator wallet, one of which will be used by the validator node. All seed phrases should be kept secret by their owners and securely backed up.The wallet deployer (who may or may not be one of the custodians) should gather the public keys from all custodians.The wallet deployer should obtain SafeMultisig contract code from the repository.The wallet deployer should generate deployment keys.The wallet deployer should generate validator wallet address: in -1 chain for direct staking validator or in 0 chain for a DePool validator.Any user should send at least 1 token to the generated wallet address to create it in the blockchain.The wallet deployer should deploy the wallet contact to the blockchain and set all gathered public keys as its custodians. At this step the number of custodian signatures required to make transactions from the wallet is also set (&gt;=2 recommended for validator wallets). Deploy to -1 chain for direct staking validator or to 0 chain for a DePool validator.In case of direct staking, the funds for staking should be transferred to the newly created validator wallet. Once the wallet is deployed, place 2 files on the validator node: /ton-node/configs/${VALIDATOR_NAME}.addr should contain validator multisignature wallet address in form X:XXX...XXX (the folder on the host is main.ton.dev/docker-compose/ton-node/configs) /ton-node/configs/keys/msig.keys.json should contain validator multisignature custodian's keypair (the folder on the host is main.ton.dev/docker-compose/ton-node/configs/keys/) The node will use the wallet address and the keys provided to it to generate election requests each validation cycle. Note: If the validator wallet requires more than 1 custodian signature to make transactions, make sure each transaction sent by the validator node is confirmed by the required amount of custodians. "},{"title":"6. Configure DePool​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#6-configure-depool","content":"For a DePool validator it is necessary to deploy a DePool contract to workchain 0. You can use TONOS-CLI for this purpose. It should be configured to connect to the main.ton.dev network. Refer to this document for the detailed DePool creation procedure, or follow the links in the short guide below: Obtain contract code from the repository.Generate deployment keys.Calculate contract addresses.Send tokens to the calculated addresses.Deploy contracts. Make sure to specify your validator wallet in the DePool contract at this step.Configure DePool state update method. Once DePool is successfully deployed and configured to be regularly called to update its state, you can make stakes in it. Note that validator stakes must always exceed validator assurance, otherwise DePool will not participate in elections. Also note, that DePool and supporting contracts balance should be monitored and kept positive at all times. Once the validator wallet and the DePool are deployed, place 3 files on the validator node: /ton-node/configs/${VALIDATOR_NAME}.addr should contain validator multisignature wallet address in form 0:XXX...XXX (the folder on the host is main.ton.dev/docker-compose/ton-node/configs)/ton-node/configs/keys/msig.keys.json should contain validator multisignature custodian's keypair (the folder on the host is main.ton.dev/docker-compose/ton-node/configs/keys/)/ton-node/configs/depool.addr should contain DePool address in form 0:XXX...XXX (the folder on the host is main.ton.dev/docker-compose/ton-node/configs) The script generating validator election requests (directly through multisig wallet, or through DePool, depending on the setting selected on step 2.1) will run regularly, once the necessary addresses and keys are provided. "},{"title":"7. Upgrade RUST Validator Node​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#7-upgrade-rust-validator-node","content":"Note: You may need to renew your copy of main.ton.dev scripts but do not remove any working files from the previous deployment (for example, configs folder). Adjust (specify new commit ID) main.ton.dev/scripts/env.sh: export TON_NODE_GITHUB_REPO=&quot;https://github.com/tonlabs/ton-labs-node.git&quot; export TON_NODE_GITHUB_COMMIT_ID=&quot;master&quot; export TON_NODE_TOOLS_GITHUB_REPO=&quot;https://github.com/tonlabs/ton-labs-node-tools.git&quot; export TON_NODE_TOOLS_GITHUB_COMMIT_ID=&quot;master&quot; export TONOS_CLI_GITHUB_REPO=&quot;https://github.com/tonlabs/tonos-cli.git&quot; export TONOS_CLI_GITHUB_COMMIT_ID=&quot;master&quot;  Upgrade the node: ./upgrade.sh 2&gt;&amp;1 | tee ./upgrade.log  Note: the log generated by this command will be located in the main.ton.dev/scripts/ folder and can be useful for troubleshooting. Wait until the node is synced. Stopping, restarting the RUST Node Note: call docker-compose commands from the main.ton.dev/docker-compose/ton-node folder. To stop the node use the following command: docker-compose stop  To restart a stopped node use the following command: docker-compose restart  Logging "},{"title":"During deployment​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#during-deployment","content":"It is highly recommended to record the full log during node deployment: ./deploy.sh 2&gt;&amp;1 | tee ./deploy.log  The log is saved to the main.ton.dev/scripts/ folder next to the deployment script and can be useful for troubleshooting. "},{"title":"During operation​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#during-operation","content":"When operational, the node keeps a number of logs in the main.ton.dev/docker-compose/ton-node/logs folder. Logs are generated with log4rs framework. For detailed documentation on it refer to https://docs.rs/log4rs/1.0.0/log4rs/. Logging configuration is determined by the main.ton.dev/docker-compose/ton-node/configs/log_cfg.yml file. By default is contains the recommended configuration for the Rust node. refresh_rate: 30 seconds appenders: stdout: kind: console encoder: pattern: &quot;{d(%s.%f)} {l} [{h({t})}] {I}: {m}{n}&quot; stdout_ref: kind: console encoder: pattern: &quot;{f}:{L} {l} [{h({t})}] {I}: {m}{n}&quot; logfile: kind: file path: &quot;/ton-node/logs/output.log&quot; encoder: pattern: &quot;{d(%s.%f)} {l} [{h({t})}] {I}: {m}{n}&quot; rolling_logfile: kind: rolling_file encoder: pattern: &quot;{d(%Y-%m-%d %H:%M:%S.%f)} {l} [{h({t})}] {I}: {m}{n}&quot; path: /ton-node/logs/output.log policy: kind: compound trigger: kind: size limit: 50 gb roller: kind: fixed_window pattern: '/ton-node/logs/output_{}.log' base: 1 count: 1 tvm_logfile: kind: file path: &quot;target/log/tvm.log&quot; encoder: pattern: &quot;{m}{n}&quot; root: level: info appenders: - rolling_logfile loggers: # node messages ton_node: level: trace boot: level: trace sync: level: trace # adnl messages adnl: level: info overlay: level: info rldp: level: info dht: level: info # block messages ton_block: level: debug # block messages executor: level: debug # tvm messages tvm: level: info librdkafka: level: info validator: level: debug catchain: level: debug validator_session: level: debug  The currently configured targets are the following: ton_node: node-related messages, except initial boot and sync, block exchange with other nodes boot: initial boot messages, creation of trusted key block chain, loading blockchain state sync: node synchronization - loading a certain number of most recent blocks adnl: messages of the ADNL protocol overlay: messages of the overlay protocol rldp: messages of the RLDP protocol dht: messages of the DHT protocol ton_block: messages of the block structures library, logs are turned on in debug executor: messages of the smart contract execution library, logs are turned on in debug tvm: ton virtual machine messages, logs are turned on in debug librdkafka: kafka client library messages validator: top level consensus protocol messages catchain: low level consensus protocol messages validator_session: mid level consensus protocol messages Migrating from C++ node To migrate your validator from legacy C++ node to Rust node, complete the following steps: Set up a new host for the Rust node, according to steps 1-3 of this document.Wait for node to sync. Check sync according to step 4 of this document.Stop the C++ node sending election requests (by default - disable scheduling of the validator script). Do not shut down the C++ validator itself, let it finish the current round.Configure validator wallet and corresponding keys, optionally - DePool (copy them from C++ node files to Rust Node files). By default: Copy validator wallet address from ~/ton-keys/$(hostname -s).addr file on the C++ node to /ton-node/configs/${VALIDATOR_NAME}.addr on the Rust Node.Copy validator wallet keys from /ton-keys/msig.keys.json on the C++ node to /ton-node/configs/keys/msig.keys.json on the Rust Node.If you have a DePool set up, copy DePool address from ~/ton-keys/depool.addr on the C++ node to /ton-node/configs/depool.addr on the Rust Node. Once this is done, the Rust node validator script will start automatically with the next round. DO NOT shut down the C++ host. Wait for the C++ node to complete the current round until the validator set is changed.Check logs/validator.log on the Rust node, and make sure the first election request was successfully sent. There should be no errors in the log.Only once the validator set changes, the C++ node is no longer a validator and the Rust node starts validating (validation_stats and collation_stats in the console output should not be empty), shut down the C++ node. Troubleshooting Here are some solutions to frequently encountered problems. "},{"title":"1. Couldn’t connect to Docker daemon at http+docker://localhost​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#1-couldnt-connect-to-docker-daemon-at-httpdockerlocalhost","content":"This error occurs in two cases. Either the docker daemon isn't running, or current user doesn't have rights to access docker. You can fix the rights issue either by running relevant commands as the superuser or adding the user to the docker group: sudo usermod -a -G docker $USER  Make sure to restart the system or log out and back in, for the new group settings to take effect. "},{"title":"2. thread 'main' panicked error when checking node synchronization​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#2-thread-main-panicked-error-when-checking-node-synchronization","content":"The following error may occur for a short time immediately after node deployment when attempting to check synchronization: thread 'main' panicked at 'Can't create client: Os { code: 111, kind: ConnectionRefused, message: &quot;Connection refused&quot; }', bin/console.rs:454:59  Currently this is expected behavior, unless it persists for more than a few minutes. If it does persist, check network status at https://ever.live, and, if the network is up and running, review deployment logs for errors. "},{"title":"3. Error executing command when checking node synchronization​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#3-error-executing-command-when-checking-node-synchronization","content":"The following error may occur for up to an hour after node deployment when attempting to check synchronization: Error executing command: Error receiving answer: early eof bin/console.rs:296  Currently this is expected behavior, unless it persists for more than one hour. If it does persist, check network status at https://ton.live/, and, if the network is up and running, review deployment logs for errors. "},{"title":"4. Cannot stop/restart/remove node container​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#4-cannot-stoprestartremove-node-container","content":"Make sure you are running all docker-compose commands from the main.ton.dev/docker-compose/ton-node folder. "},{"title":"5. DePool state not updating​","type":1,"pageTitle":"Run Mainnet Node","url":"validate/run-validator/run-mainnet-node#5-depool-state-not-updating","content":"It's recommended to send at least two ticktocks while the elections are open. For rust node you can use the provided ticktock script, which sends 5 ticktocks after the elections open. "},{"title":"System requirements","type":0,"sectionRef":"#","url":"validate/run-validator/system-requirements","content":"","keywords":""},{"title":"EverX Testnet Node​","type":1,"pageTitle":"System requirements","url":"validate/run-validator/system-requirements#everx-testnet-node","content":"Configuration\tCPU (threads)\tRAM (GiB)\tStorage (GiB)\tNetwork (Gbit/s)Minimum\t48\t128\t1000\t1 "},{"title":"EverX Mainnet Node​","type":1,"pageTitle":"System requirements","url":"validate/run-validator/system-requirements#everx-mainnet-node","content":"Configuration\tCPU (threads)\tRAM (GiB)\tStorage (GiB)\tNetwork (Gbit/s)Minimum\t48\t128\t1000\t1 "},{"title":"Update Validator","type":0,"sectionRef":"#","url":"validate/run-validator/update-validator","content":"Update Validator","keywords":""},{"title":"Validator elections","type":0,"sectionRef":"#","url":"validate/run-validator/validator-elections","content":"Validator elections","keywords":""},{"title":"Staking","type":0,"sectionRef":"#","url":"validate/staking","content":"","keywords":""},{"title":"Glossary​","type":1,"pageTitle":"Staking","url":"validate/staking#glossary","content":"Validator - the entity performing validation of new blocks on the blockchain through a Proof-of-Stake system. Requires a multisignature wallet for staking. Deployer - person who generates the public key for multisignature wallet, collects custodian public keys and deploys the wallet. DevOps - IT Engineer who sets up validator node and scripts, generates Validator Custodian key Custodians - Multisignature wallet owners who submit and confirm transactions from multisignature wallet. Deployer may be one of the custodians. Deployer seed phrase - the seed phrase, generated by Deployer, used to deploy the wallet. Validator Custodian Key - public key generated by DevOps during Node setup. "},{"title":"Prerequisites​","type":1,"pageTitle":"Staking","url":"validate/staking#prerequisites","content":"Synced validator node with initialized wallet - all responsible persons have completed all steps up to and including step 4.4 of Run Validator page.TONOS-CLI installed and configured with the correct network for all wallet custodians, including the Deployer - refer to Multisignature Wallet page.Elections have started - election_id parameter of the elector contract != 0~/ton-keys/msig.keys.json - file with validator custodian keypair.~/ton-keys/$(hostname -s).addr - file wallet address. "},{"title":"1. Validator script submits staking transaction​","type":1,"pageTitle":"Staking","url":"validate/staking#1-validator-script-submits-staking-transaction","content":"Synced validator node should be continuously running validator script (see step 5 of Run Validator page): ./validator_msig.sh &lt;STAKE&gt; &gt;&gt; ./validator.log 2&gt;&amp;1  Once election begins, validator script attempts to create a staking transaction, pledging &lt;STAKE&gt; amount of tokens to the elections contract. Note: to continuously participate in elections validator should have at least 2x &lt;STAKE&gt; on its balance. When the transaction is successfully created, script extracts transactionId and prints it in terminal. Note: if the multisignature wallet has only one custodian the transaction is confirmed automatically and steps 2 and 3 of this guide can be skipped. Go to step 4. "},{"title":"2. Custodians identify Transaction ID​","type":1,"pageTitle":"Staking","url":"validate/staking#2-custodians-identify-transaction-id","content":"Note: Custodians should know the address of their multisignature wallet. A number of custodian signatures are required for a transaction to be executed. Custodians can request the list of transactions awaiting confirmation with the following command: ./tonos-cli run &lt;multisig_address&gt; getTransactions {} --abi SafeMultisigWallet.abi.json  multisig_address – address of the validator wallet. If there are some transactions requiring confirmation, they will be displayed:  Identify the transaction ID of the transaction where the &quot;dest&quot; parameter equals 1:333333....3333333. This is the transaction to the elector contract. Alternatively DevOps may send transactionId to other custodians directly. "},{"title":"3. Wallet custodians confirm staking transaction​","type":1,"pageTitle":"Staking","url":"validate/staking#3-wallet-custodians-confirm-staking-transaction","content":"The required number of validator wallet custodians confirm the transaction through TONOS-CLI with their seed phrases. To create a confirmation message use the following command: ./tonos-cli call &lt;multisig_address&gt; confirmTransaction '{&quot;transactionId&quot;:&quot;&lt;id&gt;&quot;}' --abi SafeMultisigWallet.abi.json --sign &quot;&lt;seed_phrase&gt;&quot;  multisig_address – address of the validator wallet. transactionId – the ID of the transaction identified on the previous step. seed_phrase – custodian seed phrase. "},{"title":"4. Custodians check that the staking transaction was executed​","type":1,"pageTitle":"Staking","url":"validate/staking#4-custodians-check-that-the-staking-transaction-was-executed","content":"To confirm the transaction has been executed, use the getTransactions command again: ./tonos-cli run &lt;multisig_address&gt; getTransactions {} --abi SafeMultisigWallet.abi.json  The staking transaction will no longer be displayed in the list of transactions awaiting confirmation. You can also visit the ever.live explorer and find the message from your address to the 1:333333....3333333 address in the message list. "},{"title":"5. After the elections cycle completes, script checks the size of validator stake to be returned​","type":1,"pageTitle":"Staking","url":"validate/staking#5-after-the-elections-cycle-completes-script-checks-the-size-of-validator-stake-to-be-returned","content":"If election_id == 0 (that means no validator elections at the moment): script requests size of validator stake that can be returned from elector. Returned value will not be 0 if validator won previous elections and was a validator;if this value != 0, script submits new transaction from wallet to Elector contract with 1 token and recover-stake payload, extracts transactionId and prints it in terminal and then exits.  "},{"title":"6. Wallet custodians confirm the recover transaction​","type":1,"pageTitle":"Staking","url":"validate/staking#6-wallet-custodians-confirm-the-recover-transaction","content":"If the number of custodian confirmations required to execute a transaction is &gt; 1, repeat step 2 and 3 for this guide for the recover transaction. Otherwise the transaction will be confirmed automatically and the stake will be returned from elector. Note: It is recommended to run validator_msig.sh periodically, for example with cron utility. validator_misg.sh will automatically make a stake and request it (stake + reward) back when it is available. Only custodian confirmations will have to be done manually in this case. "},{"title":"FAQ","type":0,"sectionRef":"#","url":"validate/troubleshooting/faq","content":"FAQ","keywords":""},{"title":"Node upgrades","type":0,"sectionRef":"#","url":"validate/troubleshooting/node-upgrades","content":"Node upgrades","keywords":""},{"title":"Mainnet EverX Node Troubleshooting","type":0,"sectionRef":"#","url":"validate/troubleshooting/mainnet-node-troubleshooting","content":"","keywords":""},{"title":"1. Couldn’t connect to Docker daemon at http+docker://localhost​","type":1,"pageTitle":"Mainnet EverX Node Troubleshooting","url":"validate/troubleshooting/mainnet-node-troubleshooting#1-couldnt-connect-to-docker-daemon-at-httpdockerlocalhost","content":"This error occurs in two cases. Either the docker daemon isn't running, or current user doesn't have rights to access docker. You can fix the rights issue either by running relevant commands as the superuser or adding the user to the docker group: sudo usermod -a -G docker $USER  Make sure to restart the system or log out and back in, for the new group settings to take effect. "},{"title":"2. thread 'main' panicked error when checking node synchronization​","type":1,"pageTitle":"Mainnet EverX Node Troubleshooting","url":"validate/troubleshooting/mainnet-node-troubleshooting#2-thread-main-panicked-error-when-checking-node-synchronization","content":"The following error may occur for a short time immediately after node deployment when attempting to check synchronization: thread 'main' panicked at 'Can't create client: Os { code: 111, kind: ConnectionRefused, message: &quot;Connection refused&quot; }', bin/console.rs:454:59  Currently this is expected behavior, unless it persists for more than a few minutes. If it does persist, check network status at https://ton.live/, and, if the network is up and running, review deployment logs for errors. "},{"title":"3. Error executing command when checking node synchronization​","type":1,"pageTitle":"Mainnet EverX Node Troubleshooting","url":"validate/troubleshooting/mainnet-node-troubleshooting#3-error-executing-command-when-checking-node-synchronization","content":"The following error may occur for up to an hour after node deployment when attempting to check synchronization: Error executing command: Error receiving answer: early eof bin/console.rs:296  Currently this is expected behavior, unless it persists for more than one hour. If it does persist, check network status at https://ton.live/, and, if the network is up and running, review deployment logs for errors. "},{"title":"4. Cannot stop/restart/remove node container​","type":1,"pageTitle":"Mainnet EverX Node Troubleshooting","url":"validate/troubleshooting/mainnet-node-troubleshooting#4-cannot-stoprestartremove-node-container","content":"Make sure you are running all docker-compose commands from the main.ton.dev/docker-compose/ton-node folder. "},{"title":"5. DePool state not updating​","type":1,"pageTitle":"Mainnet EverX Node Troubleshooting","url":"validate/troubleshooting/mainnet-node-troubleshooting#5-depool-state-not-updating","content":"It's recommended to send at least two ticktocks while the elections are open. For rust node you can use the provided ticktock script, which sends 5 ticktocks after the elections open. "},{"title":"Testnet EverX Node Troubleshooting","type":0,"sectionRef":"#","url":"validate/troubleshooting/testnet-node-troubleshooting","content":"","keywords":""},{"title":"1. Couldn’t connect to Docker daemon at http+docker://localhost​","type":1,"pageTitle":"Testnet EverX Node Troubleshooting","url":"validate/troubleshooting/testnet-node-troubleshooting#1-couldnt-connect-to-docker-daemon-at-httpdockerlocalhost","content":"This error occurs in two cases. Either the docker daemon isn't running, or current user doesn't have rights to access docker. You can fix the rights issue either by running relevant commands as the superuser or adding the user to the docker group: sudo usermod -a -G docker $USER  Make sure to restart the system or log out and back in, for the new group settings to take effect. "},{"title":"2. thread 'main' panicked error when checking node synchronization​","type":1,"pageTitle":"Testnet EverX Node Troubleshooting","url":"validate/troubleshooting/testnet-node-troubleshooting#2-thread-main-panicked-error-when-checking-node-synchronization","content":"The following error may occur for a short time immediately after node deployment when attempting to check synchronization: thread 'main' panicked at 'Can't create client: Os { code: 111, kind: ConnectionRefused, message: &quot;Connection refused&quot; }', bin/console.rs:454:59  Currently this is expected behavior, unless it persists for more than a few minutes. If it does persist, check network status at https://net.ton.live/, and, if the network is up and running, review deployment logs for errors. "},{"title":"3. Error executing command when checking node synchronization​","type":1,"pageTitle":"Testnet EverX Node Troubleshooting","url":"validate/troubleshooting/testnet-node-troubleshooting#3-error-executing-command-when-checking-node-synchronization","content":"The following error may occur for up to an hour after node deployment when attempting to check synchronization: Error executing command: Error receiving answer: early eof bin/console.rs:296  Currently this is expected behavior, unless it persists for more than one hour. If it does persist, check network status at https://net.ton.live/, and, if the network is up and running, review deployment logs for errors. "},{"title":"4. Cannot stop/restart/remove node container​","type":1,"pageTitle":"Testnet EverX Node Troubleshooting","url":"validate/troubleshooting/testnet-node-troubleshooting#4-cannot-stoprestartremove-node-container","content":"Make sure you are running all docker-compose commands from the net.ton.dev/docker-compose/ton-node folder. "},{"title":"5. DePool state not updating​","type":1,"pageTitle":"Testnet EverX Node Troubleshooting","url":"validate/troubleshooting/testnet-node-troubleshooting#5-depool-state-not-updating","content":"It's recommended to send at least two ticktocks while the elections are open. Here are some solutions to frequently encountered problems. "},{"title":"Getting started","type":0,"sectionRef":"#","url":"validate/tutorial/getting-started","content":"Getting started","keywords":""},{"title":"How to stake","type":0,"sectionRef":"#","url":"validate/tutorial/how-to-stake","content":"How to stake","keywords":""},{"title":"How to vote","type":0,"sectionRef":"#","url":"validate/tutorial/how-to-vote","content":"How to vote","keywords":""}]